/**
 *  "Kofian" oscillator motion by Krystof Pesek 2011
 *  Modifing values can result completely different drawing "style" 
 */


//////////////// LUCKY NUMBER //////////////////////////
long SEED = 19;
//////////// THERE IS NO CHOICE ! ////////////////////////

// PRINT
int INK = 200;
boolean serie = true;
int SERIE = 999;

int SIRKA = 1600;
int VYSKA = 900;


int plottNum = 644;
// number of random patterns
int patNum = 333;
//number of oscillators
int rotNum = 360/2-9;

// minimum oscillation speed (the more low == slower), and the relative spread of speeds (lower == more organized structure)
float minRep = 0.9;
float spread = 0.0000338743;
// size of display averages
int prumSize = 5;
// scale speed of movement per cycle
float scal = 5.0;
// alpha of drawer

float alph = 4;
// scale of graph
float sc = 30.0;

boolean showGRPHS = true;
boolean showCONNECT = false;
// animation fade
int fade = 100;

// animation caputure
boolean record = false;
int frameCnt = 0;
int frameSkip = 1;

// debuging showing some more informations on screen
boolean debug = false;
boolean showGraph = false;

// X (time) coordinate of graph
float graphX = 0;

// AL of random patterns
ArrayList patterns = new ArrayList();
// AL of oscillators
ArrayList <CPU> cpu = new ArrayList();
// array for average values of all the rotators
ArrayList <Plotter> plotters = new ArrayList();


// square root of size of rotators matrixes (not generic do not change)
int size = 5;
// positions of plotter
int YY,XX;

// default settings for movement increments
int xs[] = {-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2};
int ys[] = {-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2};

// offscreen plotter paper
PGraphics img;
PFont font;

float UNIQUE = (float)(SEED/7.7+1.0);

// cycle finished ?
boolean reach = false;
///////////////////////////////


// GLOBAL BEGINNING
float GLOBAL_STEP = minRep;


void setup(){
	size(SIRKA,VYSKA,P2D);
	
	font = createFont("Calluna",24,true);

	// init function
	reset();

	rectMode(CENTER);
	noFill();
	noSmooth();
	stroke(0);

	// autogenerated font
	textFont(createFont("Verdana",10,false));

	// turn off in case of opengl render !!
	textMode(SCREEN);
	textAlign(CENTER);



	if(serie){
		SEED = 1;
	}

	noiseSeed(SEED);
}
//////////////////////////////
void eraseImg(){
	img.beginDraw();
	img.background(255);
	//smoothing off ?
	//img.smooth();
	img.endDraw();


}

int frmCnt = 0;

void printImg(){

	img.beginDraw();

	img.textFont(font);
	img.textMode(SCREEN);
	img.textAlign(RIGHT);
	img.fill(#FEEFAA);
	img.text(nf((int)SEED,3)+"/"+nf(SERIE,3),width-30,height-60);
	
	img.endDraw();

	frmCnt++;
	img.save("/desk/kof_11/raw"+nf(frmCnt,4)+"_ze_"+nf(SERIE,4)+".png");
}

void keyReleased(){
	if(key=='s'){
	printImg();
	
	}
}

//////////////////////////////
void reset(){

	//////// patterns /////////
	patterns = new ArrayList();

	for(int i = 0;i<patNum;i++)
		patterns.add(new Pattern(true));


	//////// cpu oscills /////////
	cpu = new ArrayList();

	// place oscillators
	XX = width-40;
	YY = height-40;
	for(int i = 0;i<rotNum;i++){
		cpu.add(new CPU(XX,YY,i));
		XX-=40;
		if(XX<=0){
			XX=width-40;
			YY-=40;
		}

	}

	//////// plotters /////////
	plotters = new ArrayList();

	for(int i = 0 ;i<plottNum;i++){
		plotters.add(new Plotter(i));
	}

	/////////////////

	// create drawable canvas
	img = createGraphics(width,height,P2D);

	// background
	eraseImg();

	// for extra debug graphs
	graphX = 0;

	noiseSeed(SEED);
	UNIQUE = (float)(SEED/7.7+1.0);
	GLOBAL_STEP = minRep;
}
//////////////////////////////
void mousePressed(){
	if(mouseButton==LEFT){
		reset();
	}

}

//////////////////////////////
void draw(){
	background(img);

	// reach never happen if animation is off
	if(reach){
		if(record)
			img.save("/desk/parralerAnimator/img"+nf(frameCnt,4)+".png");
		frameCnt++;
		//patterns.add(new Pattern());

		reach = false;

		for(int i = 0;i<plotters.size();i++){
			Plotter p = (Plotter)plotters.get(i);
			p.plotX = width/2;
			p.plotY = height/2;
		}
		//plotX = width/2;
		//plotY = height/2;
		img.beginDraw();
		img.noStroke();
		img.fill(255,fade);
		img.rect(0,0,width,height);
		img.endDraw();
	}




	stroke(0);
	// update oscillator vals
	for(int i = 0;i<cpu.size();i++){
		CPU tmp = (CPU)cpu.get(i);
		tmp.compute();

	}


	// reset plotters matrix values
	for(int i = 0;i<plotters.size();i++){
		Plotter p = (Plotter)plotters.get(i);
		for(int ii = 0 ;ii<p.graph.length;ii++)
			p.graph[ii] = 0;
	}

	// add averages of matrixes
	for(int i = 0;i<plotters.size();i++){

		Plotter p = (Plotter)plotters.get(i);

		for(int ii = 0 ;ii<cpu.size();ii++){
			if(p.vliv[ii]){
				CPU tmp = (CPU)cpu.get(ii);
				p.addVals(tmp);

			}
		}
	}

	// graphing debug
	graphX += 1/sc;
	graphX = graphX%width;

	// draw plotters on canvas
	img.beginDraw();
	for(int i = 0 ;i<plottNum;i++){
		Plotter p = (Plotter)plotters.get(i);
		p.draw();
	}
	img.endDraw();


	// ? :)
	int X = 0;
	int Y = 0;


	if(serie && frameCount > INK ){
		printImg();


		if(SEED>=SERIE)
		 exit();
		

		SEED+=0.000001;
		reset();
		frameCount = 1;
	}


}
//////////////////////////////
//////////////////////////////
class CPU{
	// own pattern and reference
	Pattern pat;
	// x,y just for positioning on screen
	int x,y;

	// own timer
	float time;

	// speed of oscillation
	float tstep = 0.01;

	// radius (drawing only)
	float r = 20;

	// current pattern referal
	int current = 0;

	// last time
	float ltime;

	// id of oscillator
	int id;

	CPU neigh;

	boolean modified = false;
	boolean modifying = true;
	boolean is_first = false;

	//////////////////////////////
	CPU(int _x,int _y,int _id){


		x=_x;
		y=_y;
		id = _id;
		time = -HALF_PI;

		if(id == 0)
			is_first = true;

		GLOBAL_STEP -= spread;		

		// random speed according global settings
		tstep += GLOBAL_STEP; //random(minRep,minRep+spread)/10000.0;


		pat = new Pattern(true);

		if(!is_first)
			neigh = (CPU)cpu.get(id-1);
	}
	//////////// get current patern value (i) in integer //////////////////
	int getStateVal(int i){
		int this_one = pat.state[i]?1:0;
		// XOR
		int answ = this_one;// ^ the_other;
		return answ;
	}
	//////////////////////////////


	// bitwise *black* magic
	void interconnect(){
		// get the reference pattern
		//	Pattern current_pattern = (Pattern)patterns.get(current);

		//if fastest rotator copy it to current pattern 		

		if( !is_first ){
			// update curretn pattern
			Pattern avail = (Pattern)patterns.get(current);
			Pattern navail = (Pattern)patterns.get(neigh.current);

			for(int i = 0;i<pat.state.length;i++){
				pat.state[i] = (avail.state[i] ^ neigh.pat.state[i]);

			}

		}


	}

	void compute(){
		interconnect();

		/*
		// black magic
		CPU left_cpu = this;               


		// monday, minsky, shining
		if(id > 0 && id < cpu.size()-1){
		left_cpu = (CPU)cpu.get(id+1);
		}else{
		modified = true;
		}


		// shall we modify current matrix ?
		modifying = !modified;


		if(modifying){
		avail = (Pattern)patterns.get(current); 
		modified = true;

		for(int i = 0;i<avail.state.length;i++){
		pat.state[i] ^= left_cpu.avail.state[i];//pat.state[i];
		}
		}



		 */		


		// advance time
		time+=tstep;

		// compute oscillation viz coords
		float cx = cos(time)*r;
		float cy = sin(time)*r;

		// special fancy viz vals
		noFill();
		stroke(0,map(abs(time+HALF_PI-TWO_PI),0,TWO_PI,0,127));
		ellipse(x,y,r*2,r*2);

		// draw matrix
		pushStyle();



		rectMode(CORNER);
		int sqr = (int)sqrt(pat.state.length);
		for(int ii = 0;ii<sqr;ii++){
			for(int i = 0;i<sqr;i++){

				// monday, minsky, shining
				//if(modifying){
				//	pat.state[ii*sqr+i] = left_cpu.pat.state[ii*sqr+i] ^ pat.state[ii*sqr+i];
				//	modified = true;
				//}


				if(pat.state[ii*sqr+i]){
					fill(0);
				}else{
					fill(255);
				}

				stroke(0);
				rect(ii*sqr+x-pat.state.length/2,i*sqr+y-pat.state.length/2,sqr,sqr);



			}
		}
		popStyle();
		stroke(0);

		// draw oscill rect
		rect(x+cx,y+cy,3,3);
		fill(0);

		//draw speed number
		text(floor(tstep*1000),x,y-11);

		// special debug info
		if(debug){
			fill(0);
			text(time,(int)x+cx,(int)y+cy);
		}

		// save position and reset time + position (sync)
		if((time+HALF_PI)>TWO_PI&&(ltime+HALF_PI)<(TWO_PI)){
			float savePos = time-TWO_PI;
			time = savePos;
			getNewPattern();
		}

		// last time = now;
		ltime = time;


	}
	///////////// get new pattern from globally stored ones /////////////////
	void getNewPattern(){

		current+=1;
		modified = false;


		if(current>=patterns.size()){
			current = 0;
			if(id==0 && record)
				reach=true;
		}

		if(is_first){

			Pattern p = (Pattern)patterns.get(current);

			pat = new Pattern(true);
			for(int i = 0;i<pat.state.length;i++){
				pat.state[i] = p.state[i];
			}	
		}
		//(Pattern)patterns.get(current);

	}

}
///////////// simple class for holding matrix values /////////////////

class Pattern{
	boolean [] state;
	boolean rand;


	Pattern(boolean _rand){
		rand = _rand;
		state  = new boolean[(int)sq(size)];

		UNIQUE+=noise(UNIQUE)/4.17;
		UNIQUE+=1.331;

		regen();
	}

	////////////// random generator ////////////////
	void regen(){
		for(int i = 0;i<state.length;i++){
			if(rand){
				UNIQUE += 2.3;
				if( noise(i/50.0+UNIQUE--) >= 0.5){
					state[i] = true;
				}else{
					state[i] = false;
				}
			}else{
				if( i % 2 == 0){
					state[i] = true;
				}else{
					state[i] = false;
				}

			}
		}

	}

}



///////////// class for drawing approx matrixes onto canvas /////////////////

class Plotter{
	// coords
	float plotX, plotY, lplotX, lplotY;
	// id value
	int id;

	// selection of affecting oscillators !
	boolean vliv[];

	// number of affecting oscillators
	int kolik = 0;

	// own averages of values
	int graph[];

	// alpha ? value
	float al = 0;

	Plotter(int _id){
		id = _id;

		// square "size" graph length
		graph = new int[(int)sq(size)];

		// affecting ? array
		vliv = new boolean[rotNum];

		// probability of being affected is approx. 1/3 ?
		// lower number results more varying drawing
		// higher more organized 
		for(int i  = 0;i<vliv.length;i++){
			if(noise(-i+UNIQUE*id)<=0.33){
				vliv[i] = true;
				kolik++;
			}else{
				vliv[i] = false;
			}
		}

		// set x,y's on "center"
		lplotX = plotX = width/2;
		lplotY = plotY = height/2;

	}


	void draw(){
		// last = now

		lplotX = plotX;
		lplotY = plotY;

		// update positions according global scale
		for(int i = 0;i<graph.length;i++){
			plotX += xs[i]*map(graph[i],0,kolik,0,scal);
			plotY += ys[i]*map(graph[i],0,kolik,0,scal);
			plotY += (height/2.0-plotY)*0.0033;
		}

		img.stroke(0,alph);
		// some weird line on begining
		if(frameCount>3)
			img.line(plotX,plotY,lplotX,lplotY);

		//img.line(plotX-(atan2(lplotY-plotY,lplotX-plotX))*2,plotY,plotX+(atan2(lplotY-plotY,lplotX-plotX))*2,plotY);
		//img.strokeWeight(dist(plotX,plotY,lplotX,lplotY));
		//img.strokeWeight(map(atan2(lplotY-plotY,lplotX-plotX),-PI,PI,1,5));

		//graph debugging
		if(showGraph){
			img.stroke(0,20);
			img.line(graphX,map(abs(width/2-plotX),0,width/2,height/2+100,height/2-100),graphX,map(abs(width/2-lplotX),0,width/2,height/2+100,height/2-100));
			img.line(graphX,map(abs(height/2-plotY),0,height/2,height/2+100,height/2-100),graphX,map(abs(height/2-lplotY),0,height/2,height/2+100,height/2-100));
		}



		// border values
		plotBorder(40);


		// paint cross
		stroke(0,30);
		line(plotX-5,plotY,plotX+5,plotY);
		line(plotX,plotY-5,plotX,plotY+5);

		// some more debugging (useless)
		if(showCONNECT){
			stroke(0,3);
			for(int i = 0;i<cpu.size();i++){
				if(vliv[i]){
					CPU tmp = (CPU)cpu.get(i);
					line(tmp.x,tmp.y,plotX,plotY);

				}
			}
		}


		// show avg matrixes
		if(showGRPHS){
			int X = 0,Y=0;

			for(int i = 0;i<graph.length;i++){
				stroke(map(graph[i],0,kolik,255,0));
				point((int)(plotX+X),(int)(plotY+Y));//,prumSize,prumSize);


				X+=1;//prumSize;

				if(X>=size){
					X = 0;
					Y+=1;//prumSize;
				}

			}
		}

	}

	// constrian drawing
	void plotBorder(int kolik){
		if(plotX<kolik-20)plotX=width-kolik+20;
		if(plotX>width-kolik+20)plotX=kolik-20;

		if(plotY>YY-kolik+20)plotY=kolik-20;
		if(plotY<kolik-20)plotY=YY-kolik+20;

		// draw border
		pushStyle();
		rectMode(CORNERS);
		noFill();

		stroke(0,40);
		rect(kolik-20,kolik-20,width-kolik+20,YY-kolik+20);
		popStyle();

	}

	// funtion to modify current matrix averages
	void addVals(CPU tmp){


		for(int ii = 0;ii<(int)sq(size);ii++){
			graph[ii]+=tmp.getStateVal(ii);
			//al+=(PI-tmp.time);
		}

	}

}

// et voila!
