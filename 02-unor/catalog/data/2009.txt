import processing.serial.*;
import cc.arduino.*;

Arduino arduino;
int ledPin = 13;

void setup()
{
  //println(Arduino.list());
  arduino = new Arduino(this, Arduino.list()[0]); // v2
  //arduino = new Arduino(this, Arduino.list()[0], 57600); // v1
  arduino.pinMode(ledPin, Arduino.OUTPUT);
}

void draw()
{
  arduino.digitalWrite(ledPin, Arduino.HIGH);
  delay(1000);
  arduino.digitalWrite(ledPin, Arduino.LOW);
  delay(1000);
}

import ddf.minim.signals.*;
import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.effects.*;

import rita.wordnet.*;

RiWordnet wordnet;
PFont font1, font2;
String word;
String[] flak = new String[25];
color[] c = new color[25];
int radek =  0;
Basnik kecal;
boolean say = false;
int lastRadek = 0;

void setup() 
{
  size(300, 400);    
  font1 = loadFont("00Acrobatix-8.vlw");
  font2 = loadFont("Verdana-Bold-48.vlw");  
  wordnet = new RiWordnet(this);
  kecal =  new Basnik("kevin16");
   
}

void draw() 
{  
  background(30);

  // get synonyms every 100 frames 
  if (frameCount%60 == 1)  
  {   

    String sec = "";    
    String first = "";
    String adj = wordnet.getRandomWord("a");
    String adj2 = wordnet.getRandomWord("a");
    String pre = "";

    if((adj.charAt(0)=='a')||(adj.charAt(0)=='e')||(adj.charAt(0)=='i')||(adj.charAt(0)=='o')||(adj.charAt(0)=='u')||(adj.charAt(0)=='y')){
      pre = "an"; 
    }
    else{
      pre = "a"; 
    }

    first = wordnet.getRandomWord("v");
    sec = wordnet.getRandomWord("v");



    flak[radek] = "to ";
    flak[radek] += first; 
    flak[radek] += ", and ";
    flak[radek] += sec;
    flak[radek] += ", ";
    flak[radek] += pre;
    flak[radek] += " ";
    flak[radek] += adj;
    flak[radek] += " ";
     flak[radek] += adj2;
    flak[radek] += " ";
    flak[radek] += wordnet.getRandomWord("n");
    flak[radek] += ".";
    c[radek] = color(random(80,255));

    say = true;
    lastRadek=radek;
    radek++;

    if(radek==flak.length-1){
      radek=0;
      
    }

  }
   textFont(font2);
  fill(255,55);
  text("poem::gen",5,48);

    textFont(font1);
  int yPos=60;   // draw the synonyms

  for (int i = 0; i < flak.length; i++){
    if(flak[i]==null){
    }
    else{
      fill(c[i]);
      text(flak[i], 10, yPos += 13);
    }  
  }
  
  if(say){
    rekni(); 
  }
}

void rekni(){
  println(flak[lastRadek]);
  kecal.mluv(flak[constrain(lastRadek-1,0,flak.length)]);  
  say = false;
}
import com.sun.speech.freetts.Voice;
import com.sun.speech.freetts.VoiceManager;
import com.sun.speech.freetts.audio.JavaClipAudioPlayer;

public class Basnik {

  String voiceName = "kevin16";
  VoiceManager voiceManager;
  Voice voice; 
  // Age age;


  Basnik(String name){
    voiceName = name;     
    this.setup(); 

  }

  void listAllVoices() {
    System.out.println();
    System.out.println("All voices available:");        
    VoiceManager voiceManager = VoiceManager.getInstance();
    Voice[] voices = voiceManager.getVoices();
    for (int i = 0; i < voices.length; i++) {
      System.out.println("    " + voices[i].getName()
        + " (" + voices[i].getDomain() + " domain)");
    }
  }

  void setup() {

    listAllVoices();


    System.out.println();
    System.out.println("Using voice: " + voiceName);


    voiceManager = VoiceManager.getInstance();
    //voice = voiceManager.getVoice(voiceName);
    voice = voiceManager.getVoice(voiceName);      

    //voice.setPitch(8.25f);
    voice.setPitchShift(0.75);
   // voice.setPitchRange(10.1); //mutace
    voice.setStyle("casual");  //"business", "casual", "robotic", "breathy"

    if (voice == null) {
      System.err.println(
      "Cannot find a voice named "
        + voiceName + ".  Please specify a different voice.");
      System.exit(1);
    }      

    voice.allocate();
  }

  void mluv(String _a){     


    if(_a==null){
      _a= "nothing"; 
    }
    voice.speak(_a);

  }

  void exit(){

    voice.deallocate();  
  }
}
import ddf.minim.signals.*;
import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.effects.*;

import rita.wordnet.*;

RiWordnet wordnet;
PFont font1, font2;
String word;
String[] flak = new String[25];
color[] c = new color[25];
int radek =  0;
Basnik kecal;
boolean say = false;
int lastRadek = 0;

void setup() 
{
  size(300, 400);    
  font1 = loadFont("00Acrobatix-8.vlw");
  font2 = loadFont("Verdana-Bold-48.vlw");  
  wordnet = new RiWordnet(this);
  kecal =  new Basnik("kevin16");
   
}

void draw() 
{  
  background(30);

  // get synonyms every 100 frames 
  if (frameCount%60 == 1)  
  {   

    String sec = "";    
    String first = "";
    String adj = wordnet.getRandomWord("a");
    String adj2 = wordnet.getRandomWord("a");
    String pre = "";

    if((adj.charAt(0)=='a')||(adj.charAt(0)=='e')||(adj.charAt(0)=='i')||(adj.charAt(0)=='o')||(adj.charAt(0)=='u')||(adj.charAt(0)=='y')){
      pre = "an"; 
    }
    else{
      pre = "a"; 
    }

    first = wordnet.getRandomWord("v");
    sec = wordnet.getRandomWord("v");



    flak[radek] = "to ";
    flak[radek] += first; 
    flak[radek] += ", and ";
    flak[radek] += sec;
    flak[radek] += ", ";
    flak[radek] += pre;
    flak[radek] += " ";
    flak[radek] += adj;
    flak[radek] += " ";
     flak[radek] += adj2;
    flak[radek] += " ";
    flak[radek] += wordnet.getRandomWord("n");
    flak[radek] += ".";
    c[radek] = color(random(80,255));

    say = true;
    lastRadek=radek;
    radek++;

    if(radek==flak.length-1){
      radek=0;
      
    }

  }
   textFont(font2);
  fill(255,55);
  text("poem::gen",5,48);

    textFont(font1);
  int yPos=60;   // draw the synonyms

  for (int i = 0; i < flak.length; i++){
    if(flak[i]==null){
    }
    else{
      fill(c[i]);
      text(flak[i], 10, yPos += 13);
    }  
  }
  
  if(say){
    rekni(); 
  }
}

void rekni(){
  println(flak[lastRadek]);
  kecal.mluv(flak[constrain(lastRadek-1,0,flak.length)]);  
  say = false;
}
import com.sun.speech.freetts.Voice;
import com.sun.speech.freetts.VoiceManager;
import com.sun.speech.freetts.audio.JavaClipAudioPlayer;

public class Basnik {

  String voiceName = "kevin16";
  VoiceManager voiceManager;
  Voice voice; 
  // Age age;


  Basnik(String name){
    voiceName = name;     
    this.setup(); 

  }

  void listAllVoices() {
    System.out.println();
    System.out.println("All voices available:");        
    VoiceManager voiceManager = VoiceManager.getInstance();
    Voice[] voices = voiceManager.getVoices();
    for (int i = 0; i < voices.length; i++) {
      System.out.println("    " + voices[i].getName()
        + " (" + voices[i].getDomain() + " domain)");
    }
  }

  void setup() {

    listAllVoices();


    System.out.println();
    System.out.println("Using voice: " + voiceName);


    voiceManager = VoiceManager.getInstance();
    //voice = voiceManager.getVoice(voiceName);
    voice = voiceManager.getVoice(voiceName);      

    //voice.setPitch(8.25f);
    voice.setPitchShift(0.75);
   // voice.setPitchRange(10.1); //mutace
    voice.setStyle("casual");  //"business", "casual", "robotic", "breathy"

    if (voice == null) {
      System.err.println(
      "Cannot find a voice named "
        + voiceName + ".  Please specify a different voice.");
      System.exit(1);
    }      

    voice.allocate();
  }

  void mluv(String _a){     


    if(_a==null){
      _a= "nothing"; 
    }
    voice.speak(_a);

  }

  void exit(){

    voice.deallocate();  
  }
}
import ddf.minim.signals.*;
import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.effects.*;

import rita.wordnet.*;

RiWordnet wordnet;
PFont font1, font2;
String word;
String[] flak = new String[25];
color[] c = new color[25];
int radek =  0;
Basnik kecal;
boolean say = false;
int lastRadek = 0;

void setup() 
{
  size(300, 400);    
  font1 = loadFont("00Acrobatix-8.vlw");
  font2 = loadFont("Verdana-Bold-48.vlw");  
  wordnet = new RiWordnet(this);
  kecal =  new Basnik("kevin16");
   
}

void draw() 
{  
  background(30);

  // get synonyms every 100 frames 
  if (frameCount%60 == 1)  
  {   

    String sec = "";    
    String first = "";
    String adj = wordnet.getRandomWord("a");
    String adj2 = wordnet.getRandomWord("a");
    String pre = "";

    if((adj.charAt(0)=='a')||(adj.charAt(0)=='e')||(adj.charAt(0)=='i')||(adj.charAt(0)=='o')||(adj.charAt(0)=='u')||(adj.charAt(0)=='y')){
      pre = "an"; 
    }
    else{
      pre = "a"; 
    }

    first = wordnet.getRandomWord("v");
    sec = wordnet.getRandomWord("v");



    flak[radek] = "to ";
    flak[radek] += first; 
    flak[radek] += ", and ";
    flak[radek] += sec;
    flak[radek] += ", ";
    flak[radek] += pre;
    flak[radek] += " ";
    flak[radek] += adj;
    flak[radek] += " ";
     flak[radek] += adj2;
    flak[radek] += " ";
    flak[radek] += wordnet.getRandomWord("n");
    flak[radek] += ".";
    c[radek] = color(random(80,255));

    say = true;
    lastRadek=radek;
    radek++;

    if(radek==flak.length-1){
      radek=0;
      
    }

  }
   textFont(font2);
  fill(255,55);
  text("poem::gen",5,48);

    textFont(font1);
  int yPos=60;   // draw the synonyms

  for (int i = 0; i < flak.length; i++){
    if(flak[i]==null){
    }
    else{
      fill(c[i]);
      text(flak[i], 10, yPos += 13);
    }  
  }
  
  if(say){
    rekni(); 
  }
}

void rekni(){
  println(flak[lastRadek]);
  kecal.mluv(flak[constrain(lastRadek-1,0,flak.length)]);  
  say = false;
}
import com.sun.speech.freetts.Voice;
import com.sun.speech.freetts.VoiceManager;
import com.sun.speech.freetts.audio.JavaClipAudioPlayer;

public class Basnik {

  String voiceName = "kevin16";
  VoiceManager voiceManager;
  Voice voice; 
  // Age age;


  Basnik(String name){
    voiceName = name;     
    this.setup(); 

  }

  void listAllVoices() {
    System.out.println();
    System.out.println("All voices available:");        
    VoiceManager voiceManager = VoiceManager.getInstance();
    Voice[] voices = voiceManager.getVoices();
    for (int i = 0; i < voices.length; i++) {
      System.out.println("    " + voices[i].getName()
        + " (" + voices[i].getDomain() + " domain)");
    }
  }

  void setup() {

    listAllVoices();


    System.out.println();
    System.out.println("Using voice: " + voiceName);


    voiceManager = VoiceManager.getInstance();
    //voice = voiceManager.getVoice(voiceName);
    voice = voiceManager.getVoice(voiceName);      

    //voice.setPitch(8.25f);
    voice.setPitchShift(0.75);
   // voice.setPitchRange(10.1); //mutace
    voice.setStyle("casual");  //"business", "casual", "robotic", "breathy"

    if (voice == null) {
      System.err.println(
      "Cannot find a voice named "
        + voiceName + ".  Please specify a different voice.");
      System.exit(1);
    }      

    voice.allocate();
  }

  void mluv(String _a){     


    if(_a==null){
      _a= "nothing"; 
    }
    voice.speak(_a);

  }

  void exit(){

    voice.deallocate();  
  }
}
import ddf.minim.signals.*;
import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.effects.*;

import rita.wordnet.*;

RiWordnet wordnet;
PFont font1, font2;
String word;
String[] flak = new String[25];
color[] c = new color[25];
int radek =  0;
Basnik kecal;
boolean say = false;
int lastRadek = 0;

void setup() 
{
  size(300, 400);    
  font1 = loadFont("00Acrobatix-8.vlw");
  font2 = loadFont("Verdana-Bold-48.vlw");  
  wordnet = new RiWordnet(this);
  kecal =  new Basnik("kevin16");
   
}

void draw() 
{  
  background(30);

  // get synonyms every 100 frames 
  if (frameCount%60 == 1)  
  {   

    String sec = "";    
    String first = "";
    String adj = wordnet.getRandomWord("a");
    String adj2 = wordnet.getRandomWord("a");
    String pre = "";

    if((adj.charAt(0)=='a')||(adj.charAt(0)=='e')||(adj.charAt(0)=='i')||(adj.charAt(0)=='o')||(adj.charAt(0)=='u')||(adj.charAt(0)=='y')){
      pre = "an"; 
    }
    else{
      pre = "a"; 
    }

    first = wordnet.getRandomWord("v");
    sec = wordnet.getRandomWord("v");



    flak[radek] = "to ";
    flak[radek] += first; 
    flak[radek] += ", and ";
    flak[radek] += sec;
    flak[radek] += ", ";
    flak[radek] += pre;
    flak[radek] += " ";
    flak[radek] += adj;
    flak[radek] += " ";
     flak[radek] += adj2;
    flak[radek] += " ";
    flak[radek] += wordnet.getRandomWord("n");
    flak[radek] += ".";
    c[radek] = color(random(80,255));

    say = true;
    lastRadek=radek;
    radek++;

    if(radek==flak.length-1){
      radek=0;
      
    }

  }
   textFont(font2);
  fill(255,55);
  text("poem::gen",5,48);

    textFont(font1);
  int yPos=60;   // draw the synonyms

  for (int i = 0; i < flak.length; i++){
    if(flak[i]==null){
    }
    else{
      fill(c[i]);
      text(flak[i], 10, yPos += 13);
    }  
  }
  
  if(say){
    rekni(); 
  }
}

void rekni(){
  println(flak[lastRadek]);
  kecal.mluv(flak[constrain(lastRadek-1,0,flak.length)]);  
  say = false;
}
import com.sun.speech.freetts.Voice;
import com.sun.speech.freetts.VoiceManager;
import com.sun.speech.freetts.audio.JavaClipAudioPlayer;

public class Basnik {

  String voiceName = "kevin16";
  VoiceManager voiceManager;
  Voice voice; 
  // Age age;


  Basnik(String name){
    voiceName = name;     
    this.setup(); 

  }

  void listAllVoices() {
    System.out.println();
    System.out.println("All voices available:");        
    VoiceManager voiceManager = VoiceManager.getInstance();
    Voice[] voices = voiceManager.getVoices();
    for (int i = 0; i < voices.length; i++) {
      System.out.println("    " + voices[i].getName()
        + " (" + voices[i].getDomain() + " domain)");
    }
  }

  void setup() {

    listAllVoices();


    System.out.println();
    System.out.println("Using voice: " + voiceName);


    voiceManager = VoiceManager.getInstance();
    //voice = voiceManager.getVoice(voiceName);
    voice = voiceManager.getVoice(voiceName);      

    //voice.setPitch(8.25f);
    voice.setPitchShift(0.75);
   // voice.setPitchRange(10.1); //mutace
    voice.setStyle("casual");  //"business", "casual", "robotic", "breathy"

    if (voice == null) {
      System.err.println(
      "Cannot find a voice named "
        + voiceName + ".  Please specify a different voice.");
      System.exit(1);
    }      

    voice.allocate();
  }

  void mluv(String _a){     


    if(_a==null){
      _a= "nothing"; 
    }
    voice.speak(_a);

  }

  void exit(){

    voice.deallocate();  
  }
}
import ddf.minim.signals.*;
import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.effects.*;

import rita.wordnet.*;

RiWordnet wordnet;
PFont font1, font2;
String word;
String[] flak = new String[25];
color[] c = new color[25];
int radek =  0;
Basnik kecal;
boolean say = false;
int lastRadek = 0;

void setup() 
{
  size(300, 400);    
  font1 = loadFont("00Acrobatix-8.vlw");
  font2 = loadFont("Verdana-Bold-48.vlw");  
  wordnet = new RiWordnet(this);
  kecal =  new Basnik("kevin16");
   
}

void draw() 
{  
  background(30);

  // get synonyms every 100 frames 
  if (frameCount%60 == 1)  
  {   

    String sec = "";    
    String first = "";
    String adj = wordnet.getRandomWord("a");
    String adj2 = wordnet.getRandomWord("a");
    String pre = "";

    if((adj.charAt(0)=='a')||(adj.charAt(0)=='e')||(adj.charAt(0)=='i')||(adj.charAt(0)=='o')||(adj.charAt(0)=='u')||(adj.charAt(0)=='y')){
      pre = "an"; 
    }
    else{
      pre = "a"; 
    }

    first = wordnet.getRandomWord("v");
    sec = wordnet.getRandomWord("v");



    flak[radek] = "to ";
    flak[radek] += first; 
    flak[radek] += ", and ";
    flak[radek] += sec;
    flak[radek] += ", ";
    flak[radek] += pre;
    flak[radek] += " ";
    flak[radek] += adj;
    flak[radek] += " ";
     flak[radek] += adj2;
    flak[radek] += " ";
    flak[radek] += wordnet.getRandomWord("n");
    flak[radek] += ".";
    c[radek] = color(random(80,255));

    say = true;
    lastRadek=radek;
    radek++;

    if(radek==flak.length-1){
      radek=0;
      
    }

  }
   textFont(font2);
  fill(255,55);
  text("poem::gen",5,48);

    textFont(font1);
  int yPos=60;   // draw the synonyms

  for (int i = 0; i < flak.length; i++){
    if(flak[i]==null){
    }
    else{
      fill(c[i]);
      text(flak[i], 10, yPos += 13);
    }  
  }
  
  if(say){
    rekni(); 
  }
}

void rekni(){
  println(flak[lastRadek]);
  kecal.mluv(flak[constrain(lastRadek-1,0,flak.length)]);  
  say = false;
}
import com.sun.speech.freetts.Voice;
import com.sun.speech.freetts.VoiceManager;
import com.sun.speech.freetts.audio.JavaClipAudioPlayer;

public class Basnik {

  String voiceName = "kevin16";
  VoiceManager voiceManager;
  Voice voice; 
  // Age age;


  Basnik(String name){
    voiceName = name;     
    this.setup(); 

  }

  void listAllVoices() {
    System.out.println();
    System.out.println("All voices available:");        
    VoiceManager voiceManager = VoiceManager.getInstance();
    Voice[] voices = voiceManager.getVoices();
    for (int i = 0; i < voices.length; i++) {
      System.out.println("    " + voices[i].getName()
        + " (" + voices[i].getDomain() + " domain)");
    }
  }

  void setup() {

    listAllVoices();


    System.out.println();
    System.out.println("Using voice: " + voiceName);


    voiceManager = VoiceManager.getInstance();
    //voice = voiceManager.getVoice(voiceName);
    voice = voiceManager.getVoice(voiceName);      

    //voice.setPitch(8.25f);
    voice.setPitchShift(0.75);
   // voice.setPitchRange(10.1); //mutace
    voice.setStyle("casual");  //"business", "casual", "robotic", "breathy"

    if (voice == null) {
      System.err.println(
      "Cannot find a voice named "
        + voiceName + ".  Please specify a different voice.");
      System.exit(1);
    }      

    voice.allocate();
  }

  void mluv(String _a){     


    if(_a==null){
      _a= "nothing"; 
    }
    voice.speak(_a);

  }

  void exit(){

    voice.deallocate();  
  }
}
import rita.wordnet.*;

RiWordnet wordnet;
PFont font1, font2;
String word;
String[] flak = new String[25];
color[] c = new color[25];
int radek =  0;
Basnik kecal;
boolean say = false;
int lastRadek = 0;

void setup() 
{
  size(300, 400,P3D);    
  font1 = loadFont("00Acrobatix-8.vlw");
  font2 = loadFont("Verdana-Bold-48.vlw");  
  wordnet = new RiWordnet(this,"/sketchBook/libraries/ritanet/library");
  kecal =  new Basnik("kevin16");  
  textMode(SCREEN);
}

void draw() 
{  
  background(30);
  // get synonyms every 100 frames 
  if (frameCount%30 == 1)  
  {   
    String sec = "";    
    String first = "";    
    String pre = "";
    String adv = "";
    String adj = "";
    
    //String[] temp = new String[10];
    first = wordnet.getRandomWord("v", true, 5);
    //temp = wordnet.getRandomWord(pos, stemsOnly, maxChars);
    sec = wordnet.getRandomWord("v", true, 8);    
    adv = wordnet.getRandomWord("r", true, 5);
    adj = wordnet.getRandomWord("a", true,12);
    
     if((adj.charAt(0)=='a')||(adj.charAt(0)=='e')||(adj.charAt(0)=='i')||
     (adj.charAt(0)=='o')||(adj.charAt(0)=='u')||(adj.charAt(0)=='y')){
      pre = "an"; 
    }
    else{
      pre = "a"; 
    }
    flak[radek] = "to ";
    flak[radek] += first; 
    flak[radek] += ", and ";
    flak[radek] += sec;
    flak[radek] += ", ";
    flak[radek] += pre;
    flak[radek] += " ";
    flak[radek] += adv;
    flak[radek] += " ";
    flak[radek] += adj;
    flak[radek] += " ";
    flak[radek] += wordnet.getRandomWord("n", true, 5);
    flak[radek] += ".";
    c[radek] = color(random(80,255));

    say = true;
    lastRadek=radek;
    radek++;

    if(radek==flak.length-1){
      radek=0;      
    }
  }
  
   textFont(font2);
  fill(255,55);
  text("poem::gen",5,48);

    textFont(font1);
  int yPos=60;   // draw the synonyms

  for (int i = 0; i < flak.length; i++){
    if(flak[i]==null){
    }
    else{
      fill(c[i]);
      text(flak[i], 10, yPos += 13);
    }  
  }
  
  if(say){
    rekni(); 
  }
}

void rekni(){
  println(flak[lastRadek]);
  kecal.mluv(flak[constrain(lastRadek-1,0,flak.length)]);  
  say = false;
}
import com.sun.speech.freetts.Voice;
import com.sun.speech.freetts.VoiceManager;
import com.sun.speech.freetts.audio.JavaClipAudioPlayer;

public class Basnik {
  String voiceName = "kevin16";
  VoiceManager voiceManager;
  Voice voice; 
  // Age age;
  
  Basnik(String name){
    voiceName = name;     
    this.setup(); 
  }
  
  void listAllVoices() {
    System.out.println();
    System.out.println("All voices available:");        
    VoiceManager voiceManager = VoiceManager.getInstance();
    Voice[] voices = voiceManager.getVoices();
    for (int i = 0; i < voices.length; i++) {
      System.out.println("    " + voices[i].getName()
        + " (" + voices[i].getDomain() + " domain)");
    }
  }

  void setup() {
    listAllVoices();
    System.out.println();
    System.out.println("Using voice: " + voiceName);

    voiceManager = VoiceManager.getInstance();
    //voice = voiceManager.getVoice(voiceName);
    voice = voiceManager.getVoice(voiceName);      

    voice.setPitch(1.75);
    voice.setPitchShift(0.75);
   // voice.setPitchRange(10.1); //mutace
    voice.setStyle("casual");  //"business", "casual", "robotic", "breathy"

    if (voice == null) {
      System.err.println(
      "Cannot find a voice named "
        + voiceName + ".  Please specify a different voice.");
      System.exit(1);
    }      
    voice.allocate();
  }

  void mluv(String _a){     

    if(_a==null){
      _a= "nothing"; 
    }
    voice.speak(_a);

  }

  void exit(){
    voice.deallocate();  
  }
}
import processing.pdf.*;

Node n[] = new Node[361];

PFont a,b;
	
void setup(){
	size(380,270,P3D);
	rectMode(CENTER);

	
	a = createFont("Veranda",4);
	b = createFont("Veranda",20);
	
	for(int i =0;i<n.length;i++){
		n[i] = new Node(i);
	}
	background(0);
}

void draw(){
	//background(255);

	for(int i =0;i<n.length;i++){
		n[i].run();
	}
	
	storeNodes(frameCount);
}

void keyPressed(){
	if(key==' '){
		storeNodes(0);
		println("output sored!");
	}



}


void storeNodes(int nu){
	PGraphics p = createGraphics(width,height,P3D);
	loadPixels();
	for(int i =0 ;i<pixels.length;i++){
		p.pixels[i] = pixels[i];
	}

	boolean last = false;
	int lastROw = 0;

	int cnt = 0;
	PGraphics pdf = createGraphics(500, 800, PDF, "out/output"+nf(nu,6)+".pdf");
	pdf.beginDraw();
	pdf.background(0);
	
	
	pdf.textFont(b);
	pdf.textAlign(LEFT);
	pdf.fill(255,200);
	pdf.text("lenoid project",20,30);
	pdf.text("screen no."+frameCount,20,50);
	
	pdf.textFont(a);
	pdf.textAlign(CENTER);
	
	for(int y= 80;y<pdf.height-25;y+=25){
		for(int x= 25;x<pdf.width-10;x+=25){
			if(cnt<n.length){
				pdf.fill(255);
				pdf.text(cnt,x-5,y);

				n[cnt].pdfDraw(pdf,x+5,y);
				cnt++;


			}
		}
	}
	pdf.imageMode(CENTER);
	pdf.image(p,pdf.width/2,pdf.height-height/2-10,width/2,height/2);


	
	pdf.dispose();
	pdf.endDraw();
	if(frameCount>199){
		exit();
	}

}






class Node{
	color c;
	boolean ons[][] = new boolean[3][3];
	float x,y;
	int id;
	float speed = 0.2;
	float br = 20.0;
	float stillx,stilly;
	int freeze = 0;

	Node(int _id){
		id=_id;

		x= random(br,width-br);
		y= random(br,height-br);

		c= color(random(150,255),random(150,255),random(55));

		for(int i = 0;i<ons.length;i++){
			for(int r = 0;r<ons[i].length;r++){
				if(random(501)<250){
					ons[i][r] = true;
				}else{
					ons[i][r] = false;
				}
			}
		}

	}

	void run(){
		noStroke();
		for(int i = 0;i<ons.length;i++){
			for(int r = 0;r<ons[i].length;r++){
				if(ons[i][r]){
					fill(0,15);
					x+=(i-1)*speed;
					y+=(r-1)*speed;
				}else{
					fill(255,15);
				}
				rect(((int)x+(i-1)*3),((int)y+(r-1)*3),3,3);
			}
		}

		bordr(3);
		checkFreeze(20);
		collision();
	}


	void pdfDraw(PGraphics p,float _x,float _y){
		p.noStroke();
		for(int i = 0;i<ons.length;i++){
			for(int r = 0;r<ons[i].length;r++){
				if(ons[i][r]){
					p.fill(255);

					p.rect((_x+(i-1)*3),(_y+(r-1)*3),3,3);
				}
			}
		}

	}

	void collision(){
		for(int i = 0;i<n.length;i++){
			if(i!=id){
				if(abs(x-n[i].x)<4.5&&abs(y-n[i].y)<4.5){
					mutate(1);
				}
			}
		}

	}

	void checkFreeze(int lim){
		if(stillx==x){
			freeze++;
		}else if(stilly==y){
			freeze++;
		}else{
			freeze = 0;
		}

		stillx =x;
		stilly = y;

		if(freeze>lim){
			mutate(1);
		}


	}

	void bordr(int qark){

		if(x>width-br){
			x=width-br-1;
			mutate(qark);
		}

		if(x<br){
			x=br+1;
			mutate(qark);
		}


		if(y>height-br){
			y=width-br-1;
			mutate(qark);
		}

		if(y<br){
			y=br+1;
			mutate(qark);
		}

		x= constrain(x,br,width-br);
		y= constrain(y,br,height-br);


	}

	void mutate(int mutace){
		int cn = 0;

		int pre[] = new int[mutace];

		for(int i=0;i<pre.length;i++){
			pre[i] = (int)random(sq(ons.length));
		}

		for(int i=0;i<pre.length;i++){
			ons[pre[i]/3][pre[i]%3] = !ons[pre[i]/3][pre[i]%3];
		}
	}
}



void setup(){
// The amount of memory allocated so far (usually the -Xms setting)
long allocated = Runtime.getRuntime().totalMemory();

// Free memory out of the amount allocated (value above minus used)
long free = Runtime.getRuntime().freeMemory();

// The maximum amount of memory that can eventually be consumed
// by this application. This is the value set by the Preferences
// dialog box to increase the memory settings for an application.
long maximum = Runtime.getRuntime().maxMemory();

println("alloc : "+allocated);
println("free : "+free);
println("maximum : "+maximum);
}
//import processing.opengl.*;

// .OBJ Loader
// by SAITO <http://users.design.ucla.edu/~tatsuyas>
// Placing a virtual structure represented as mathematically
// three-dimensional object.
// SModel.load() reads structure data of the object stored
// as numerical data.
// SModel.draw() gives a visual form to the structure data.
// processing standard drawing functions can be used to manipulate
// the visual form to create deep visual experiences.
// Created 20 April 2005

import saito.objloader.*;

OBJModel model;
float rotX;
float rotY;

void setup()
{
  size(600, 600, P3D);
  frameRate(30);
  model = new OBJModel(this);
  model.debugMode();
  model.load("test.obj");
 smooth();
}
void draw()
{
  background(255); 
  lights();
  //stroke(0,1);
  pushMatrix();
  translate(width/2, height/2, 0);
  rotateX(rotY);
  rotateY(rotX);
  scale(50.0);
  model.draw();
  popMatrix();
  
  rotX+= 0.001;
}

boolean bTexture = true;
boolean bStroke = true;
void keyPressed(){
  if(key == 't'){
    if(!bTexture){
      model.enableTexture();
      bTexture = true;
    } else {
      model.disableTexture();
      bTexture = false;
    }
  }
  if(key == 's'){
    if(!bStroke){
      stroke(10, 10, 10, 100);
      bStroke = true;
    } else {
      noStroke();
      bStroke = false;
    }
  }
  else if(key=='1')
  model.drawMode(POINTS);
  else if(key=='2')
  model.drawMode(TRIANGLES);
  else if(key=='4')
  model.drawMode(POLYGON);
}

void mouseDragged()
{
  rotX += (mouseX - pmouseX) * 0.01;
  rotY -= (mouseY - pmouseY) * 0.01;
}

class MatrixGen{
	boolean [][] matr = new boolean[0][0];
	String[] s = new String[0];
	boolean a = false;
	String in;
	boolean working = false;

	MatrixGen(String _in){
		rebuild(_in);
	}

	void rebuild(String _in){
		working = true;
		in = ""+_in.toUpperCase();
		loadF();
		construct();
		matrix = matr;
		working = false;
	}

	void loadF(){
		int pis = 65;
		String[] temp = new String[0];
		s = new String[0];                         
		for(int i =0;i<in.length();i++){
			//print(in.charAt(i));
			
			File a = new File(sketchPath+"/font/"+(in.charAt(i))+".txt");
			if(a.exists()){
				//println();
			temp = loadStrings(a.getPath());
			}
			pis++;

			for(int q = 0;q<temp.length;q++){
				s = (String[])expand(s,s.length+1);
				s[s.length-1] = temp[q];
			}
		}

		println("matrix change: "+in);

	}

	void construct(){
		matr = new boolean[0][0];
		for(int i = 0;i<s.length;i++){
			matr = (boolean[][])expand(matr,matr.length+1);
			matr[matr.length-1] = new boolean[5];

			for(int q = 0;q<s[i].length();q++){
				if((s[i].charAt(q))=='1'){
					matr[matr.length-1][q] = true;
					//print(1);
				}else{
					matr[matr.length-1][q] = false;
					//print(0);
				}
			}
			//println("");

		}

	}
}
import processing.serial.*;

Serial port;
int[] pins = {8,12,10,11,7};
boolean[] ons;
boolean matrix[][] = new boolean[20][5];

MatrixGen mg;

String tt="";

int cntr = 0;
int chaa = 65;

void setup(){
	size(200,200,P3D);
	frameRate(60);

	textFont(createFont("Veranda",9));
	textMode(SCREEN);
	

	pins = reverse(pins);

	mg = new MatrixGen(" ");
	
	ons = new boolean[pins.length];
	println(Serial.list()[0]);
	port = new Serial(this, Serial.list()[0], 115200);

	for(int i =0;i<pins.length;i++){
		offLed(i);
	}

}

void draw(){
	background(0);

	fill(255);
	noStroke();


	if(!mg.working){
		try{
			for(int i = 0;i<matrix[0].length;i++){
				if(mg.working){
					return;
				}else{

					if(matrix[cntr][i]){
						onLed(i);
					}else{
						offLed(i);
					}

				}
			}
		}catch(ArrayIndexOutOfBoundsException e){
			println("hmm routine error ...");
		}
	}

	/**
		stroke(255,120);
		for(int x = 0;x<matrix.length;x++){
			line(x*40,0,x*40,height);
			for(int y = 0;y<matrix[x].length;y++){
				line(0,y*40,width,y*40);


				if(matrix[x][y]){
					rect(x*40,y*40,40,40);
				}
			}
		}
		*/

	cntr++;
	if(cntr>=matrix.length){
		cntr = 0;
	}

	fill(255);
	text(tt,10,10,width-20,height-20);
	if(frameCount%10==0)
		text("_");
}


void keyPressed(){
	//println((int)key);
	if(((int)key)>=33&&((int)key<=122)){
		tt += key;

	}else if(keyCode == BACKSPACE){
		if(tt.length()>=1){
			tt = tt.substring(0,tt.length()-1);
		}

	}else if(key == ' '){
		tt += " ";

	}else if(keyCode==DELETE){
		tt= "";

	}else if(keyCode == ENTER){
		mg.rebuild(tt);
	}else if(keyCode == TAB){
		String q[] = loadStrings("input.txt");
		tt = "";
		for(int i = 0;i<q.length;i++){
			tt+=q[i]+" ";
		}
		println("loaded");
		
	}
	
}

void storeChar(){
	String s[] = new String[5];
	for(int i =0;i<5;i++){
		s[i] = "";
		for(int q =0;q<s.length;q++){
			if(matrix[i][q]){
				s[i]+=1;
			}else{
				s[i]+=0;
			}
		}
	}
	saveStrings(((char)chaa)+".txt",s);
	chaa++;

}

void changeMatrix(int _x,int _y){
	matrix[_x][_y]=!matrix[_x][_y];

}

void changeState(int which){
	which = constrain(which,0,pins.length);
	if(ons[which]){
		offLed(which);
	}else{
		onLed(which);
	}
}


void onLed(int which) {
	int sel = pins[which];
	ons[which] = true;
	port.write("w d ");                                     
	port.write(sel+" 1");
	port.write(13);
}


void offLed(int which) {
	int sel = pins[which];
	ons[which] = false;
	port.write("w d ");
	port.write(sel+" 0");
	port.write(13);
}




import rita.*;

RiText[] rts;
RiGrammar grammar;

void setup()
{
  size(650, 200);
  rts = new RiText[3];
  RiText.setDefaultAlignment(CENTER);
  //PFont a = createFont("Veranda",9);
  //RiText.setDefaultFont(a);
  rts[0] = new RiText(this, "click to", width/2, 85);
  rts[1] = new RiText(this, "generate", width/2, 110);
  rts[2] = new RiText(this, "a haiku",  width/2, 135);
  grammar = new RiGrammar(this, "haiku.g");
}

void draw()
{
  background(100);
}

void mouseClicked()                                                                                
{    
  String result = grammar.expand();
  String[] lines = result.split("%");
  for (int i = 0; i < rts.length; i++) {
    rts[i].fadeToText(lines[i].trim(), 1.0f);
  }
}


import rita.*;

// Kafka + Wittgenstein

int MAX_LINE_LENGTH = 60;

RiText rts[];
RiMarkov markov;

void setup()
{    
  size(380, 500);

  // a little info msg
  new RiText(this, "click to (re)generate!", 135, height/2);
  
  RiText.setDefaultAlignment(LEFT);

  // create a new markov model w' n=3
  markov = new RiMarkov(this, 3);  
  
  //markov.setPrintIgnoredText(true);

  // load 2 files into the model
  markov.loadFile("wtf.txt"); 
  markov.loadFile("kafka.txt");    
}

void draw()
{
  background(80);
}

// generate on mouse click
void mouseClicked() 
{   
  RiText.deleteAll(); // clean-up old data

  String[] lines = markov.generateSentences(10);

  // lay out the return text starting at x=20 y=50)
  rts = RiText.createLines(this, lines, 20, 50, MAX_LINE_LENGTH);
}


PShape a;

void setup(){
	size(300,300);
	a = loadShape("drawing.svg");
	smooth();
}

void draw(){
	//background(255);
	fill(0,120);
	rect(0,0,width,height);
	
	tint(#FFCC00,120);	
	
	for(int x = 10;x < width-10;x+=20){
	for(int y = 10;y< height-10;y+=20){
	shape(a,x+random(-2,2),y+random(-2,2),15,15);
}

}

}

void keyPressed(){
	if(key==' '){
		saveFrame("shot####.png");
	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

  Recorder(String _dir,String _name){
    dir = _dir;
    name=_name;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="6000000";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" msmpeg4v2 "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }



}

int num = 450;
MyObj[] o = new MyObj[num];
PImage shade,glow;
Recorder r;


boolean smoothing = true;
boolean recording = true;
boolean blurring = true;

void setup() {

	size(600,300,P3D);
	background(0);


	if(smoothing)
		smooth();


	if(recording)
		r = new Recorder("out","sorting2.avi");

	shade = loadImage("shade.png");
	glow = loadImage("glow.png");
	imageMode(CENTER);
	rectMode(CENTER);

	PFont a = new PFont();

	//println(a.list());
	textFont(createFont(a.list()[86],9));
	textMode(SCREEN);
	textAlign(CENTER);

	//create an array of MyObjs
	for(int i=0;i<o.length;i++) {
		o[i] = new MyObj(i);
	}
	// sort the array. since MyObj implements
	// the comparable interface, the MyObj list
	// will be sorted based on the outcome of
	// function toCompare
	Arrays.sort(o);



	// print the sorted list based on value x of
	// each object

}


void draw(){
	//background(40);

	fill(20,180);
	rect(width/2,height/2,width,height);

	Arrays.sort(o);


	for(int i  = 0;i<o.length;i++){
		o[i].draw();
	}
	
	if(blurring){
	filter(BLUR,1.8);
	for(int i  = 0;i<o.length;i++){
		o[i].draw();
	}
	}


	if(recording)
		r.add();
}

void keyPressed(){
	if(key=='q'){
		if(recording)
			r.finish();
		exit();

	}

}

class MyObj implements Comparable {
	float x,y,tx,ty;
	int id;
	color c;
	int cycle;
	int sir = 20;
	int redT = 0;
	float theta = 0;

	MyObj(int theId) {
		id = theId;
		cycle = (int)random(1500)+40;
		c = color(lerpColor(0xff2e482c,0xff000000,random(1000)/1000.0));
		tx = x = (random(width));
		ty = y = (random(height));
	}


	void draw(){
		stroke(0);
		image(shade,x+5,y+5);
		fill(c,200);
		rect(x,y,sir,sir);
		fill(0,60);
		text(id,x+2,y+4);
		fill(#a6552b);
		text(id,x,y+3);

		line(x+3,y+10,x+3,height);
		stroke(255,15);
		line(x+2,y+10,x+2,height);
		noStroke();
		//fill(#8c0d0d,redT);
		//rect(x+sir/2.0-2,y-sir/2.0+1.5,3,3);
		if(frameCount%cycle==0){
			redT=255;
			tx=random(width);
			ty=random(height);
		}

		tint(255,redT);
		image(glow,x+2,y+2,60,60);
		noTint();

		drawNode();

		x+=(tx-x)/30.0;
		y+=(ty-y)/30.0;

		if(redT>1)
			redT-=3;
		//collide();
	}

	void collide(){
		//boolean answ = false;
		//	int w = 0;
		int coll[] = new int[0];

		for(int i =0;i<o.length;i++){
			if(abs(x-o[i].x)<sir/2.0&&abs(y-o[i].y)<sir/2.0){
				x+=(tx-o[i].x)/20.0;
				y+=(ty-o[i].y)/20.0;
			}



			coll = (int[])expand(coll,coll.length+1);
			coll[coll.length-1]=i;

		}


	}

	void drawNode(){
		theta += 0.1*(atan2(ty-y,tx-x)-theta);
		pushStyle();
		stroke(0,100);
		noFill();
		//for(float i = 0;i<=1;i+=0.1){
		pushMatrix();
		translate(x,y);
		rotate(theta);
		//	if(i==1)

		stroke(lerpColor(#000000,#ffffff,norm(redT,0,255)),100);
		triangle(50,0,40,3,40,-3);
		rect(0,0,sir*2+sir,sir*2+sir);
		//line(0,0,50,0);
		popMatrix();
		//}
		popStyle();

	}

	//if we want to sort based on the X value of MyObj-es:
	int compareTo(Object o)
	{
		MyObj other=(MyObj)o;
		if(other.y>y)
			return -1;
		if(other.y==y)
			return 0;
		else
			return 1;
	}

}

// "the supreme code" by krystof pesek
// every single line of the text you are now reading;
// has been genereted by the text itself
// source language: processing - 5.1.2009

String code[];

void setup (){
	// load this code line by line
	code = loadStrings("supremeCode.pde");

	// prepare the frame
	size(320,code.length*9+20,P3D);

	// create the output
	beginRecord(PDF, "theWhatYouAreNowLookingAt.pdf");

	// create the font
	textFont(createFont("Veranda",9));
}

void draw(){
	// blank white background
	background(color(#FFFFFF));

	// loop through an every line of the source
	for(int i =0;i<code.length;i++){

		// gray out the comments line like this one
		if(code[i].indexOf("/")>-1&&code[i].indexOf("indexOf")==-1){
			fill(color(#666666));
		}else{
			fill(color(#000000));
		}

		// apply simple text formatting
		int format = code[i].lastIndexOf("\t");
		if(format>-1){
			for(int q = 0;q < format;q++)
				code[i]="   "+code[i];
		}

		// and print each line of itself
		text(code[i],15,i*9+10);
	}

	// save it
	endRecord();

	// and die
	exit();

	// "there is no need to understand anymore,
	// when you find out that you are the understanding itself"
}



 	

import processing.candy.*;
import processing.xml.*;

SVG m;

void setup(){
  size(400,400);
  // The file "moo.svg" must be in the data folder
  // of the current sketch to load successfully
  m = new SVG(this, "test.svg");
} 

void draw(){
  m.draw();
  m.draw(200, 200);
}

import traer.physics.*;
//import java.util.Vector;

Vector tendrils;
ParticleSystem physics;
Particle mouse;
int greyer;
boolean drawing;
boolean nothingDrawn;

void setup()
{
	size( 400, 400 , P3D);
	//smooth();
	stroke( 0 );
	background( 255 );
	frameRate( 30 );
	cursor( CROSS );

	physics = new ParticleSystem( 0.0f, 0.05f );

	mouse = physics.makeParticle();
	mouse.makeFixed();

	tendrils = new Vector();
	drawing = false;
	greyer = 255;
}

void draw()
{
	mouse.moveTo( mouseX, mouseY, 0 );

	if ( !drawing )
	{
		physics.advanceTime( 1.0f );
		if ( greyer < 255 )
			greyer *= 1.11111;
		if ( greyer > 255 )
			greyer = 255;
	}
	else
	{
		if ( greyer >= 64 )
			greyer *= 0.9;
	}

	//background( 255 );
	fill(255,5);
	rect(0,0,width,height);
	
	drawOldGrey();
}

void drawOldGrey()
{
	stroke( 255 - greyer , 15);
	for ( int i = 0; i < tendrils.size()-1; ++i )
	{
		T3ndril t = (T3ndril)tendrils.get( i );
		drawElastic( t );
	}

	stroke( 0,55 );
	if ( tendrils.size()-1 >= 0 )
		drawElastic( (T3ndril)tendrils.lastElement() );
}

void drawElastic( T3ndril t )
{
	float lastStretch = 1;
	for ( int i = 0; i < t.particles.size()-1; ++i )
	{
		Vector3D firstPoint = ((Particle)t.particles.get( i )).position();
		Vector3D firstAnchor =  i < 1 ? firstPoint : ((Particle)t.particles.get( i-1 )).position();
		Vector3D secondPoint = i+1 < t.particles.size() ? ((Particle)t.particles.get( i+1 )).position() : firstPoint;
		Vector3D secondAnchor = i+2 < t.particles.size() ? ((Particle)t.particles.get( i+2 )).position() : secondPoint;

		//float springStretch = 2.5f/((Spring)t.springs.get( i )).stretch();
		Spring s = (Spring)t.springs.get( i );
		float springStretch = 2.5*s.restLength()/s.currentLength();

		strokeWeight( (float)((springStretch + lastStretch)/2.0f) );	// smooth out the changes in stroke width with filter
		lastStretch = springStretch;

		curve( firstAnchor.x(), firstAnchor.y(),
		       firstPoint.x(), firstPoint.y(),
		       secondPoint.x(), secondPoint.y(),
		       secondAnchor.x(), secondAnchor.y() );
	}
}

void mousePressed()
{
	drawing = true;
	tendrils.add( new T3ndril( physics, new Vector3D( mouseX, mouseY, 0 ), 								   mouse ) );
}

void mouseDragged()
{
	((T3ndril)tendrils.lastElement()).addPoint( new Vector3D( mouseX, mouseY, 0 ) );
}

void mouseReleased()
{
	drawing = false;
}

void keyPressed(){
	if ( key == ' ' ){
		tendrils.clear();
		physics.clear();
	}
}

class T3ndril
{
	public Vector particles;
	public Vector springs;
	ParticleSystem physics;

	public T3ndril( ParticleSystem p, Vector3D firstPoint, Particle followPoint ){
		particles = new Vector();
		springs = new Vector();

		physics = p;

		Particle firstParticle = p.makeParticle( 1.0f, firstPoint.x(), firstPoint.y(), firstPoint.z() );
		particles.add( firstParticle );
		physics.makeSpring( followPoint, firstParticle, 0.1f, 0.1f, 5 );
	}

	public void addPoint( Vector3D p ){
		Particle thisParticle = physics.makeParticle( 1.0f, p.x(), p.y(), p.z() );
		springs.add( physics.makeSpring( ((Particle)particles.lastElement()),
		                                 thisParticle,
		                                 1.0f,
		                                 1.0f,
		                                 ((Particle)particles.lastElement()).position().distanceTo( thisParticle.position() ) ) );
		particles.add( thisParticle );
	}
}

String a  ="";

void setup(){
	size(200,200);
	textFont(loadFont("Monospaced.plain-9.vlw"));
	fill(255);

	for(int i =0;i<36;i++){
		a+="1";
	}
}
                                                                              
void draw(){
	background(0);

	for(int y = 10;y<height-8;y+=9){
		for(int x = 0;x<36;x++){
			if(random(255)>200){
				fill(120);
				text("1",x*5+10,y);
			}else{
				fill(20);
				text("0",x*5+10,y);
			}
		}
	}
}


Valve valve[];
int num = 30;

void setup(){
	size(300,200,P3D);
	background(0);
	
	PFont a = new PFont();
	a = createFont(a.list()[85],15);
	textFont(a);
	textMode(SCREEN);
	
	//println(a.list());

	valve = new Valve[num];

	for(int i =0;i<num;i++){
		valve[i] = new Valve(i);
	}

}

void draw(){
	background(0);
		
	for(int i =0;i<valve.length;i++){
		valve[i].run();
	}

}

class Valve{
	int id;
	float x,y;
	int local;
	
	Valve(int _id){
		id=_id;
		this.setup();
	}

	void setup(){
		x = random(width);
		y = random(height);
	}
	
	void move(){
		x++;
		x=x%width;
	}
	
	void run(){
		move();
		
		pushStyle();
		
		stroke(255);
		noFill();
		rectMode(CENTER);
		rect(x,y,3,3);
		text(id,x,y);
		popStyle();
	}
}

Vector xes = new Vector(), yes = new Vector();

void setup(){
	size(200,200);
	background(255);
	
	for(int i =0;i<20;i++){
		xes.add(i*10.0);
		yes.add(i*10.0);
	}
	
	stroke(0);
	for(int i =0;i<xes.size();i++){
		float x = (Float)xes.get(i);
		line(x,0,x,height);
		float y = (Float)yes.get(i);
		line(0,y,width,y);
	}
	
}
PVector p[];
float rota = 0;

void setup(){
	
	size(300,300,P3D);
	p = new PVector[3];
	
	for(int i =0;i<p.length;i++){
		p[i] = new PVector(random(width),random(height),random(width));	
	}
	noFill();
	stroke(0);
	
}

void draw(){
	background(255);
	
	pushMatrix();
	translate(0,0,-width*2);
	
	pushMatrix();
	
	translate(width/2.0,height/2.0,width/2.0);
	
	pushMatrix();
	
	rotateY(rota);
	rota += 0.01;
	
	pushMatrix();
	
	translate(-width/2.0,-height/2.0,-width/2.0);
		stroke(0);
	for(int i = 0;i<p.length;i++){
		line(p[i].x,p[i].y,p[i].z,0,0,0);
	}
	stroke(255,0,0);
	PVector temp = (p[1]);
	temp.sub(p[0]);
	line(temp.x,temp.y,temp.z,0,0,0);
	
	popMatrix();
		
	popMatrix();
	
	
	popMatrix();
		
	
	popMatrix();
	
	
}
PVector p1, p2, p3;


boolean bFirst = true;

void setup()
{
	size(400, 400,P3D);
	noFill();
	p1 = new PVector(random(width), random(height),random(width));
	p2 = new PVector(random(width), random(height),random(width));
}

void draw(){
	background(255);

	// Draw main vector
	stroke(0);
	// strokeWeight(3);

	pushMatrix();
	translate(0,0,-width);
	
	pushMatrix();
	translate(width/2,height/2,width/2);

	pushMatrix();
	rotateY(frameCount/50.0);

	pushMatrix();
	box(width);
	popMatrix();

	pushMatrix();

	translate(-width/2,-height/2,-width/2);
	line(p1.x, p1.y,p1.z, p2.x, p2.y,p2.z);
	p3 = new PVector(lerp(p1.x,p2.x,0.5),lerp(p1.y,p2.y,0.5),
	lerp(p1.z,p2.z,0.5));
	
	pushMatrix();
	translate(p3.x,p3.y,p3.z);
	box(10);
	popMatrix();
		
	// Compute perpendicular vector: (y, -x)
	PVector perp = new PVector(p2.y-p1.y,p1.x-p2.x,p3.z-p1.z);
	// Length 1
	perp.normalize();
	// Length to n pixels
	perp.mult(100);  // Put 10 for 10 pixels
	// Move to p1
	//perp.add();
	// Draw it
	stroke(#AA2244);
	//strokeWeight(1);
	line(p3.x, p3.y,p3.z, perp.x, perp.y,perp.z);
	
	popMatrix();
	popMatrix();
	popMatrix();
	popMatrix();
}

void mousePressed(){
	p1 = new PVector(random(width), random(height),random(width));
	p2 = new PVector(random(width), random(height),random(width));
}
class Recorder{
  String dir,name;
  int cntr = 0;

  Recorder(String _dir,String _name){
    dir = _dir;
    name=_name;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="6000000";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" msmpeg4v2 "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }



}
//import processing.opengl.*;

/**
* Voronoi structure by Krystof Pesek (aka kof)
*	speed optimization in las release
*
*/

///////////////////////////////////////////////// >
int num = 100;
int precision = 4;
///////////////////////////////////////////////// >
boolean record = true;
boolean smoothing = true;
///////////////////////////////////////////////// >
Recorder r;
Site [] s;
///////////////////////////////////////////////// >

void setup(){
	size(800,500,P3D);
	background(0);

	//textFont(createFont("Veranda",9));
	//textMode(SCREEN);
	rectMode(CENTER);


	//frame.setAlwaysOnTop(true);

	if(record)
		r = new Recorder("out","voronoiIO5.avi");

	s = new Site[num];

	if(smoothing)
		smooth();

	float X = 0;
	float Y = 0;
	for(int i =0;i<s.length;i++){
		s[i] = new Site(i);
	}
}

///////////////////////////////////////////////// >

void draw(){
	//background(0);
	fade(50);

	for(int i =0;i<s.length;i++){
		s[i].live();
	}

	if(record)
		r.add();
}

///////////////////////////////////////////////// >

void fade(int kolik){
	fill(0,kolik);
	noStroke();
	rect(width/2,height/2,width,height);
}

///////////////////////////////////////////////// >

void keyPressed(){
	if(key=='q'){
		if(record)
			r.finish();
		exit();
	}else if(key == 's'){
		save("shot"+nf(frameCount,6)+".png");
		println("shot saved");
	}
}


///////////////////////////////////////////////// >

class Site{
	int id;
	float x,y,tx,ty;
	float speed = 3.0;

	float[][] kol = new float[0][4];
	//float [][] bis = new float[s.length][2];;
	boolean valid[];
	Vector vX = new Vector();
	Vector vY = new Vector();
	Vector poradi = new Vector();

	float dens = 0;

	color c;

	float br = 20.0;

	///////////////////////////////////////////////// >

	Site(int _id){
		id=_id;
		tx=x=random(br,width-br);
		ty=y= random(br,height-br);
		c = color(random(255));
		valid = new boolean[s.length];

	}

	///////////////////////////////////////////////// >

	Site(int _id,float _x,float _y){
		id=_id;
		tx=x=_x;
		ty=y= _y;
		c = color(random(255));
		valid = new boolean[s.length];

	}

	///////////////////////////////////////////////// >

	void compute(){
		kol = new float[0][4];

		for(int i =0;i<s.length;i++){
			if(i!=id){
				float bisX=lerp(x,s[i].x,0.5);
				float bisY=lerp(y,s[i].y,0.5);
				if(kol.length>0){
					if(visible2(bisX,bisY)<precision){
						kol = (float[][])expand(kol,kol.length+1);
						kol[kol.length-1] = kolmice(x,y,s[i].x,s[i].y);
					}
				}else{
					kol = (float[][])expand(kol,kol.length+1);
					kol[kol.length-1] = kolmice(x,y,s[i].x,s[i].y);

				}
			}
		}

		kol = (float[][])expand(kol,kol.length+1);
		kol[kol.length-1] = kolmice2(x,y,x,br);
		kol = (float[][])expand(kol,kol.length+1);
		kol[kol.length-1] = kolmice2(x,y,width-br,y);
		kol = (float[][])expand(kol,kol.length+1);

		kol[kol.length-1] = kolmice2(x,y,x,height-br);
		kol = (float[][])expand(kol,kol.length+1);

		kol[kol.length-1] = kolmice2(x,y,br,y);


		PVector tmp;
		vX.clear();
		vY.clear();
		//println((Float)vX.get(0));
		for(int i = 0;i<kol.length;i++){
			//if(valid[i]){
			for(int e = 0;e<kol.length;e++){
				if(e!=i){
					tmp = lineIntersection(kol[i][0],kol[i][1],kol[i][2],kol[i][3],
					                       kol[e][0],kol[e][1],kol[e][2],kol[e][3]);
					if(tmp!=null){
						if(visible(tmp.x,tmp.y)){
							if(!exist(tmp.x,tmp.y)){
								vX.add(tmp.x);
								vY.add(tmp.y);
							}
						}
					}
				}
			}
		}

		sortV();

	}

	///////////////////////////////////////////////// >

	void live(){
		compute();

		///////////////////////////////////////////////// >

		/**
		dens = 0;

		for(int i =0;i<poradi.size();i++){
			dens+=dist((float)(Float)vX.get((Integer)poradi.get(i)),
			           (float)(Float)vY.get((Integer)poradi.get(i)),x,y);
	}

		dens /= poradi.size();
		dens = map(dens,3,(width)/20.0,1,0);
		dens=constrain(dens,0,1);
		*/


		///////////////////////////////////////////////// >

		for(int i = 0;i<poradi.size();i++){
			int sel = (i+1)%(poradi.size());
			float X2a = (float)(Float)vX.get((Integer)poradi.get(i));
			float Y2a = (float)(Float)vY.get((Integer)poradi.get(i));
			float X2b = (float)(Float)vX.get((Integer)poradi.get(sel));
			float Y2b = (float)(Float)vY.get((Integer)poradi.get(sel));

			float [] center = getCenter(x,y,X2a,Y2a,X2b,Y2b);

			tx+=(center[0]-tx)/(poradi.size()+0.0);
			ty+=(center[1]-ty)/(poradi.size()+0.0);

		}
		
		
		///////////////////////////////////////////////// >



		fill(c,120);
		noStroke();

		c = lerpColor(color(#FFFFFF),color(#FFCC00),
		              constrain(map(dist(tx,ty,x,y),0,5,0,1),0,1));


/**
		///////////////////////////////////////////////// >

		beginShape(POLYGON);
		for(int i = 0;i<poradi.size();i++){
			float X2 = (float)(Float)vX.get((Integer)poradi.get(i));
			float Y2 = (float)(Float)vY.get((Integer)poradi.get(i));

			vertex(lerp(X2,x,0.05),lerp(Y2,y,0.05));
		}
		endShape(CLOSE);

		fill(0);
		noStroke();


		*///////////////////////////////////////////////// >
		
	//	 curveTightness(4.1);
		 fill(c,200);
		 float rat = 0.1;
		 
		beginShape();
		vertex(lerp((float)(Float)vX.get((Integer)poradi.get(0)),x,rat),lerp((float)(Float)vY.get((Integer)poradi.get(0)),y,rat));
		
		for (int i=1; i<poradi.size()+1; i++){
			
			float x2 = lerp((float)(Float)vX.get((Integer)poradi.get(i%poradi.size())),x,rat);
			float y2 = lerp((float)(Float)vY.get((Integer)poradi.get(i%poradi.size())),y,rat);
			
			float x1 = lerp((float)(Float)vX.get((Integer)poradi.get(i-1)),x,rat);
			float y1 = lerp((float)(Float)vY.get((Integer)poradi.get(i-1)),y,rat);
			
			float mx = lerp(x1,x2,0.5);
			float my = lerp(y1,y2,0.5);
			
			float cx1 = mx+(mx-tx)*map(dist(x1,y1,x2,y2),0,100,0.0001,0.6);
			float cy1 = my+(my-ty)*map(dist(x1,y1,x2,y2),0,100,0.0001,0.6);
			
			bezierVertex(cx1, cy1, cx1, cy1, x2, y2);			
		}
		
		endShape(CLOSE);

		
		
		fill(0);
		rat = 0.35;
		 
		beginShape();
		vertex(lerp((float)(Float)vX.get((Integer)poradi.get(0)),x,rat),lerp((float)(Float)vY.get((Integer)poradi.get(0)),y,rat));
		
		for (int i=1; i<poradi.size()+1; i++){
			
			float x2 = lerp((float)(Float)vX.get((Integer)poradi.get(i%poradi.size())),x,rat);
			float y2 = lerp((float)(Float)vY.get((Integer)poradi.get(i%poradi.size())),y,rat);
			
			float x1 = lerp((float)(Float)vX.get((Integer)poradi.get(i-1)),x,rat);
			float y1 = lerp((float)(Float)vY.get((Integer)poradi.get(i-1)),y,rat);
			
			float mx = lerp(x1,x2,0.5);
			float my = lerp(y1,y2,0.5);
			
			float cx1 = mx+(mx-tx)*map(dist(x1,y1,x2,y2),0,100,0.0001,0.6);
			float cy1 = my+(my-ty)*map(dist(x1,y1,x2,y2),0,100,0.0001,0.6);
			
			bezierVertex(cx1, cy1, cx1, cy1, x2, y2);			
		}
		
		endShape(CLOSE);
/**
		beginShape(POLYGON);
		for(int i = 0;i<poradi.size();i++){
			float X2 = (float)(Float)vX.get((Integer)poradi.get(i));
			float Y2 = (float)(Float)vY.get((Integer)poradi.get(i));

			vertex(lerp(X2,x,0.2),lerp(Y2,y,0.2));
		}

		endShape(CLOSE);
*/

		///////////////////////////////////////////////// >
		noStroke();
		fill(c,100);
		rect(x,y,3,3);
		fill(255,60);
		rect(tx,ty,2,2);

		///////////////////////////////////////////////// >
		tx=constrain(tx,br,width-br);
		ty=constrain(ty,br,height-br);

		x+=(tx-x)/speed;
		y+=(ty-y)/speed;
	}

	///////////////////////////////////////////////// >

	boolean exist(float _x,float _y){
		boolean answr = false;
		float d;
		for(int i =0;i<vX.size();i++){
			d = (abs((Float)vX.get(i)-_x)+abs((Float)vY.get(i)-_y)) * 1000.0;
			if(d<1){
				answr = true;
			}
		}
		return answr;
	}

	///////////////////////////////////////////////// >

	boolean visible(float xx,float yy){
		boolean answr = true;
		PVector a;

		for(int i =0;i<kol.length;i++){
			a = segIntersection(x,y,lerp(x,xx,0.998),lerp(y,yy,0.998),kol[i][0],kol[i][1],kol[i][2],kol[i][3]);
			if(a!=null){
				answr = false;
			}
		}
		return answr;
	}

	///////////////////////////////////////////////// >

	int visible2(float xx,float yy){
		int answr = 0;
		PVector a;

		for(int i =0;i<kol.length;i++){
			a = segIntersection(x,y,lerp(x,xx,0.998),lerp(y,yy,0.998),kol[i][0],kol[i][1],kol[i][2],kol[i][3]);
			if(a!=null){
				answr++;
			}
		}
		return answr;
	}

	///////////////////////////////////////////////// >

	void sortV(){
		int delka = vX.size();

		poradi.clear();
		Vector thetas =  new Vector();

		for(int i = 0;i<delka;i++){
			thetas.add(angle(i));
		}

		int selector = 0;
		float tmpaa = 1000.0;

		boolean[] sel = new boolean[thetas.size()];
		for(int i = 0;i<thetas.size();i++){

			selector = 0;
			tmpaa = 1000.0;

			for(int q = 0;q<thetas.size();q++){
				if((Float)thetas.get(q)<(tmpaa)&&!sel[q]){
					tmpaa = (Float)thetas.get(q);
					selector = q;
				}
			}
			sel[selector] = true;

			if(poradi.size()>0){
				if(((Float)thetas.get(selector)-(Float)thetas.get((Integer)poradi.get(poradi.size()-1)))>0.25)
					poradi.add(selector);
			}else{
				poradi.add(selector);
			}
		}
	}

	///////////////////////////////////////////////// >

	float[] kolmice(float x1,float y1,float x2,float y2){
		float A1 = x1-x2;
		float A2 = y1-y2;
		float midX = lerp(x1,x2,0.5);
		float midY = lerp(y1,y2,0.5);
		float resX = midX+A2*100.5;
		float resY = midY-A1*100.5;
		float resX2 = midX-A2*100.5;
		float resY2 = midY+A1*100.5;

		float[] res = {resX,resY,resX2,resY2};
		return res;
	}


	///////////////////////////////////////////////// >

	float[] kolmice2(float x1,float y1,float x2,float y2){
		float A1 = x1-x2;
		float A2 = y1-y2;
		float midX = x2;
		float midY = y2;
		float resX = midX+A2*100.5;
		float resY = midY-A1*100.5;
		float resX2 = midX-A2*100.5;
		float resY2 = midY+A1*100.5;

		float[] res = {resX,resY,resX2,resY2};
		return res;
	}

	///////////////////////////////////////////////// >

	PVector segIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
		float bx = x2 - x1;
		float by = y2 - y1;
		float dx = x4 - x3;
		float dy = y4 - y3;

		float b_dot_d_perp = bx * dy - by * dx;

		if(b_dot_d_perp == 0) return null;

		float cx = x3 - x1;
		float cy = y3 - y1;

		float t = (cx * dy - cy * dx) / b_dot_d_perp;
		if(t < 0 || t > 1) return null;

		float u = (cx * by - cy * bx) / b_dot_d_perp;
		if(u < 0 || u > 1) return null;

		return new PVector(x1+t*bx, y1+t*by);
	}

	///////////////////////////////////////////////// >

	PVector lineIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
		float bx = x2 - x1;
		float by = y2 - y1;
		float dx = x4 - x3;
		float dy = y4 - y3;

		float b_dot_d_perp = bx*dy - by*dx;

		if(b_dot_d_perp == 0) return null;

		float cx = x3-x1;
		float cy = y3-y1;

		float t = (cx*dy - cy*dx) / b_dot_d_perp;

		return new PVector(x1+t*bx, y1+t*by);
	}

	///////////////////////////////////////////////// >

	float angle(int b){
		float angle;

		float x1 = (Float)vX.get(b);
		float y1 = (Float)vY.get(b);

		float X = (x1-x);
		float Y = (y1-y);

		PVector vec = new PVector(X,Y);
		vec.normalize();

		if(vec.x==0){
			angle = 0;
		}else{
			angle = atan(vec.y / vec.x);
		}

		float qadr = 0;
		if((vec.x >= 0)&&(vec.y > 0)) qadr = 0;
		if((vec.x <= 0)&&(vec.y > 0)) qadr = 180;
		if((vec.x <= 0)&&(vec.y < 0)) qadr = 180;
		if((vec.x >= 0)&&(vec.y < 0)) qadr = 360;

		angle = degrees(angle)+qadr;

		return angle;
	}

	///////////////////////////////////////////////// >

	float getArea(float x1,float y1,float x2,float y2,float x3,float y3){
		float v1x, v1y, v2x, v2y;

		v1x = x2 - x1;	// compute side vectors
		v1y = y2 - y1; 	// compute side vectors

		v2x = x3 - x1; 	// compute side vectors
		v2y = y3 - y1; 	// compute side vectors

		// return cross product of side vectors / 2

		return 0.5 * (v1x * v2y - v1y * v2x);
	}

	///////////////////////////////////////////////// >

	float[] getCenter(float _x1,float _y1,float _x2,float _y2,float _x3,float _y3){

		float[] cntr = new float[2];
		cntr[0] = 0;
		cntr[1] = 0;

		float x1, y1, x2, y2, x3, y3, x4, y4;

		x1 = _x1;	// get endpoints of first median
		y1 = _y1;	// get endpoints of first median
		x2 = (_x2 + _x3) / 2.0;	// get endpoints of first median
		y2 = (_y2 + _y3) / 2.0;	// get endpoints of first median

		x3 = _x2;	// get endpoints of second median (only need two)
		y3 = _y2;	// get endpoints of second median
		x4 = (_x3 + _x1) / 2.0;	// get endpoints of second median
		y4 = (_y3 + _y1) / 2.0;	// get endpoints of second median

		// see if either median is vertical (slope == infinity)

		if (x1 == x2)	// if so...
		{
			x1 = _x3;	// use third median (can't be two vertical medians)
			y1 = _y3; // use third median
			x2 = (_x1 + _x2) / 2.0; // use third median
			y2 = (_y1 + _y2) / 2.0; // use third median
		}
		else if (x3 == x4)
		{
			x3 = _x3;
			y3 = _y3;
			x4 = (_x1 + _x2) / 2.0;
			y4 = (_y1 + _y2) / 2.0;
		}

		float a1, a2, b1, b2;

		a1 = (y2 - y1) / (x2 - x1);	// compute slope of first median
		b1 = y1 - a1 * x1;	// compute intercept of first median

		a2 = (y4 - y3) / (x4 - x3);	// compute slope of second median
		b2 = y3 - a2 * x3;	// compute intercept of second median

		// solve a1 * x + b1 = a2 * x + b2

		cntr[0] = (b2 - b1) / (a1 - a2);	// solve for x coordinate of intersection
		cntr[1] = a1 * cntr[0] + b1;	// solve for y coordinate of intersection

		return cntr;	// return center as a point

	}

	///////////////////////////////////////////////// >

}

//import com.processinghacks.triangulate.*;


int num = 8;
Site t[];


void setup(){
	size(400,400,P3D);
	frameRate(20);


	reseed();
	rectMode(CORNER);
	textFont(createFont("Veranda",9));
	textMode(SCREEN);
	//smooth();


}

void reseed(){
	t = new Site[num];
	for(int i =0;i<num;i++){
		t[i] = new Site(i);
	}
}

void mousePressed(){
	if(mouseButton==LEFT){
		reseed();
	}

}

void draw(){
	fill(#ffffff);
	rect(0,0,width,height);


	for(int i =0;i<t.length;i++){
		//vertex(t[i].x,t[i].y);
		t[i].live();
	}


}





class Site{
	int ns = num;

	int id;
	float x,y;
	float k[][];
	float r[][];
	float rohyX[] = new float[0];
	float rohyY[] = new float[0];
	int neighs[];
	float verX[] = new float[0];
	float verY[] = new float[0];
	boolean valid[];

	boolean vizKolmice = true;
	boolean vizSite = true;
	boolean vizStred = true;

	PVector stred,L,T,R,D,VIS;

	boolean first = true;
	
	Site(int _id){
		id = _id;
		x= random(width);
		y= random(height);
		neighs = new int[ns];
		k = new float[ns][4];
		r = new float[ns][2];
		
	}

	void compute(){
		
		if(id==2&&first){
			first=false;
			println(closest(id,ns));
			
		}
		
		//neighs=(closest(id,ns));
		for(int i = 0;i<ns;i++){
			if(i!=id){
			r[i][0] = lerp(x,t[i].x,0.5);
			r[i][1] = lerp(y,t[i].y,0.5);
			k[i] = kolmice(x,y,t[i].x,t[i].y);
			}
		}

		valid=new boolean[ns];
		rohyX=new float[0];
		rohyY=new float[0];

		verX = new float[0];
		verY = new float[0];

		
		for(int i =0;i<ns;i++){
		valid[i] = true;

			for(int e = 0;e<ns;e++){
				//if(i!=e){
					VIS = segIntersection(r[e][0],r[e][1],x,y,k[i][0],k[i][1],k[i][2],k[i][3]);
					if(VIS!=null){
						valid[i] = false;
					}
				//}
			}
		}
		
		
		
		for(int i =0;i<ns;i++){
			int a = i;
			
			
			//directly visible?
			if(valid[i]){
		
				for(int w = 0;w<ns;w++){	
					if(valid[w]){
					stred=lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],k[w][0],k[w][1],k[w][2],k[w][3]);
					if(stred!=null){
						addV(stred.x,stred.y);
					}
					}
				}

			}
		}

			/*

			for(int w = 0;w<ns;w++){


				             // if(valid[w]){



					              L = lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],0,0,0,height);
					              T = lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],0,0,width,0);                                                           
					              R = lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],width,0,width,height);
					              D = lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],0,height,width,height);

					              stred=lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],
					                                     k[w][0],k[w][1],k[w][2],k[w][3]);
					              //if(stred!=null&&dist(r[i][0],r[i][1],x,y)>dist(stred.x,stred.y,r[i][0],r[i][1])){
						      
					              addP(stred);
					              
					              addP(L);
					              addP(T);
					              addP(R);
					              addP(D);


				              //}
			              }

			             }
			            }*/


			//constructVertex(8);

		}

		boolean visible(float xaa,float yaa){
			boolean answr = true;
			for(int e = 0;e<ns;e++){
				//if(e!=id){
				VIS = segIntersection(xaa,yaa,x,y,k[e][0],k[e][1],k[e][2],k[e][3]);
				if(VIS!=null){
					answr = false;
				}
				//}

			}
			return answr;

		}

	/*	void constructVertex(int q){
			addV(r[neighs[0]][0],r[neighs[0]][1]);

			//int which = closestRC(0)[0];

			int result[] = closObj(neighs[0],1);
			for(int i =0;i<q;i++){

				if(result[1]==1){
					addV(r[result[0]][0],r[result[0]][1]);
					result = closObj(result[0],1);
				}else{
					addV(rohyX[result[0]],rohyY[result[0]]);
					result = closObj(result[0],2);
				}
			}
		}
*/

		void addV(float xx,float yy){
			verX = (float[])expand(verX,verX.length+1);
			verY = (float[])expand(verY,verY.length+1);
			verX[verX.length-1] = xx;
			verY[verY.length-1] = yy;


		}

		void addP(PVector q){
			if(q!=null&&visible(q.x,q.y)){
				rohyX = (float[])expand(rohyX,rohyX.length+1);
				rohyY = (float[])expand(rohyY,rohyY.length+1);
				rohyX[rohyX.length-1] = q.x;
				rohyY[rohyY.length-1] = q.y;
			}
		}

		void live(){
			compute();
			stroke(#553300,60);

			fill(0);
			rect(x,y,2,2);
			text(id,x,y);

			if(id==2){


				fill(#ffcc00);
				for(int i = 0;i<ns;i++){
					rect(r[i][0],r[i][1],3,3);
				}

				//println(verX.length);
				//beginShape(POLYGON);
				for(int i = 0;i<verX.length;i++){
					ellipse(verX[i],verY[i],15,15);
				}
				//endShape(CLOSE);

				for(int i = 0;i<k.length;i++){
					//int a = constrain(i-1,0,k.length);

					if(valid[i]){
						stroke(0);	
					}else{
						stroke(0,60);
					}
					line(r[i][0],r[i][1],x,y);
					line(k[i][0],k[i][1],k[i][2],k[i][3]);
					
				}

				for(int i = 0;i<rohyY.length;i++){
					boolean valid = false;

					for(int q = 0;q<num;q++){

						if(q!=id){
							if(dist(rohyX[i],rohyY[i],x,y) < dist(rohyX[i],rohyY[i],r[q][0],r[q][1])){
								valid = true;
							}
						}
					}

					//if(valid){
					fill(255,0,0);
					rect(rohyX[i],rohyY[i],3,3);
					//}
				}
				x=mouseX;
				y=mouseY;
			}
		}

		int[] closest(int q,int _kolik){
			int[] answr = new int[_kolik];
			float[] temp = new float[num];
			//float[] temp2 = new float[num];

			for(int i =0 ;i<num;i++){
				if(i==q){
					temp[i] = width*height;
				}else{
					temp[i] = dist(t[q].x,t[q].y,t[i].x,t[i].y);
				}
			}

			//temp2=temp;

			for(int i =0;i<_kolik;i++){
				for(int w =0;w<num;w++){
					if(temp[w]==min(temp)){
						answr[i] = w;
						temp[w] = max(temp);
						break;
					}
				}
			}

			return answr;
		}


		float[] kolmice(float x1,float y1,float x2,float y2){
			float A1 = x1-x2;
			float A2 = y1-y2;
			float midX = lerp(x1,x2,0.5);
			float midY = lerp(y1,y2,0.5);
			float resX = midX+A2*10.5;
			float resY = midY-A1*10.5;
			float resX2 = midX-A2*10.5;
			float resY2 = midY+A1*10.5;

			float[] res = {resX,resY,resX2,resY2};
			return res;
		}


		// Line Segment Intersection
		PVector segIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
			float bx = x2 - x1;
			float by = y2 - y1;
			float dx = x4 - x3;
			float dy = y4 - y3;

			float b_dot_d_perp = bx * dy - by * dx;

			if(b_dot_d_perp == 0) return null;

			float cx = x3 - x1;
			float cy = y3 - y1;

			float t = (cx * dy - cy * dx) / b_dot_d_perp;
			if(t < 0 || t > 1) return null;

			float u = (cx * by - cy * bx) / b_dot_d_perp;
			if(u < 0 || u > 1) return null;

			return new PVector(x1+t*bx, y1+t*by);
		}

		PVector lineIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
			float bx = x2 - x1;
			float by = y2 - y1;
			float dx = x4 - x3;
			float dy = y4 - y3;

			float b_dot_d_perp = bx*dy - by*dx;

			if(b_dot_d_perp == 0) return null;

			float cx = x3-x1;
			float cy = y3-y1;

			float t = (cx*dy - cy*dx) / b_dot_d_perp;

			return new PVector(x1+t*bx, y1+t*by);
		}

	}

//import com.processinghacks.triangulate.*;


int num = 8;
Site t[];


void setup(){
	size(400,400,P3D);
	frameRate(20);


	reseed();
	rectMode(CORNER);
	textFont(createFont("Veranda",9));
	textMode(SCREEN);
	//smooth();


}

void reseed(){
	t = new Site[num];
	for(int i =0;i<num;i++){
		t[i] = new Site(i);
	}
}

void mousePressed(){
	if(mouseButton==LEFT){
		reseed();
	}

}

void draw(){
	fill(#ffffff);
	rect(0,0,width,height);


	for(int i =0;i<t.length;i++){
		//vertex(t[i].x,t[i].y);
		t[i].live();
	}


}





class Site{
	int ns = num;

	int id;
	float x,y;
	float k[][];
	float r[][];
	float rohyX[] = new float[0];
	float rohyY[] = new float[0];
	int neighs[];
	float verX[] = new float[0];
	float verY[] = new float[0];
	boolean valid[];

	boolean vizKolmice = true;
	boolean vizSite = true;
	boolean vizStred = true;

	PVector stred,L,T,R,D,VIS;

	Site(int _id){
		id = _id;
		x= random(width);
		y= random(height);
		neighs = new int[ns];
		k = new float[ns][4];
		r = new float[ns][2];
	}

	void compute(){
		neighs=(closest(id,ns));
		for(int i = 0;i<ns;i++){
			r[i][0] = lerp(x,t[neighs[i]].x,0.5);
			r[i][1] = lerp(y,t[neighs[i]].y,0.5);
			k[i] = kolmice(x,y,t[neighs[i]].x,t[neighs[i]].y);
		}

		valid=new boolean[ns];
		rohyX=new float[0];
		rohyY=new float[0];

		verX = new float[0];
		verY = new float[0];

		for(int i =0;i<ns;i++){
			int a = i;
			//int b = (i+1)%(ns);


			//directly visible?
			valid[i] = true;

			for(int e = 0;e<ns;e++){
				if(i!=e){
					VIS = segIntersection(r[i][0],r[i][1],x,y,k[e][0],k[e][1],k[e][2],k[e][3]);
					if(VIS!=null){
						valid[i] = false;
					}
				}
			}

			if(valid[i]){

				for(int w = 0;w<ns;w++){


					             // if(valid[w]){



						              L = lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],0,0,0,height);
						              T = lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],0,0,width,0);                                                           
						              R = lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],width,0,width,height);
						              D = lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],0,height,width,height);

						              stred=lineIntersection(k[a][0],k[a][1],k[a][2],k[a][3],
						                                     k[w][0],k[w][1],k[w][2],k[w][3]);
						              //if(stred!=null&&dist(r[i][0],r[i][1],x,y)>dist(stred.x,stred.y,r[i][0],r[i][1])){
							      
						              addP(stred);
						              
						              addP(L);
						              addP(T);
						              addP(R);
						              addP(D);


					              //}
				              }

			              }
		              }


		              //constructVertex(8);

	              }

	              boolean visibility(float xaa,float yaa){
		              boolean answr = true;
		              for(int e = 0;e<ns;e++){
				      //if(e!=id){
			              VIS = segIntersection(xaa,yaa,x,y,k[e][0],k[e][1],k[e][2],k[e][3]);
			              if(VIS!=null){
				              answr = false;
			              }

		              }
		              return answr;

	              }

	              void constructVertex(int q){
		              addV(r[neighs[0]][0],r[neighs[0]][1]);

		              //int which = closestRC(0)[0];

		              int result[] = closObj(neighs[0],1);
		              for(int i =0;i<q;i++){

			              if(result[1]==1){
				              addV(r[result[0]][0],r[result[0]][1]);
				              result = closObj(result[0],1);
			              }else{
				              addV(rohyX[result[0]],rohyY[result[0]]);
				              result = closObj(result[0],2);
			              }
		              }
	              }


	              void addV(float xx,float yy){
		              verX = (float[])expand(verX,verX.length+1);
		              verY = (float[])expand(verY,verY.length+1);
		              verX[verX.length-1] = xx;
		              verY[verY.length-1] = yy;


	              }

	              void addP(PVector q){
		              if(q!=null&&visibility(q.x,q.y)){
			              rohyX = (float[])expand(rohyX,rohyX.length+1);
			              rohyY = (float[])expand(rohyY,rohyY.length+1);
			              rohyX[rohyX.length-1] = q.x;
			              rohyY[rohyY.length-1] = q.y;
		              }
	              }

	              void live(){
		              compute();
		              stroke(#553300,60);

		              fill(0);
		              rect(x,y,2,2);
		              text(id,x,y);

		              if(id==2){


			              fill(#ffcc00);
			              for(int i = 0;i<ns;i++){
				              rect(r[i][0],r[i][1],3,3);
			              }

			              //println(verX.length);
			              //beginShape(POLYGON);
			              for(int i = 0;i<verX.length;i++){
				              ellipse(verX[i],verY[i],15,15);
			              }
			              //endShape(CLOSE);

			              for(int i = 0;i<k.length;i++){
				              //int a = constrain(i-1,0,k.length);

				              line(r[i][0],r[i][1],x,y);
				              if(valid[i]){
					              line(k[i][0],k[i][1],k[i][2],k[i][3]);


				              }
				              //line(rohyX[i],rohyY[i],rohyX[constrain(i-1,0,rohyX.length)],rohyY[constrain(i-1,0,rohyX.length)]);
				              //rect(rohyX[i],rohyY[i],2,2);
			              }

			              for(int i = 0;i<rohyY.length;i++){
				              boolean valid = false;

				              for(int q = 0;q<num;q++){

					              if(q!=id){
						              if(dist(rohyX[i],rohyY[i],x,y) < dist(rohyX[i],rohyY[i],r[q][0],r[q][1])){
							              valid = true;
						              }
					              }
				              }

				              //if(valid){
				              fill(255,0,0);
				              rect(rohyX[i],rohyY[i],3,3);
				              //}
			              }

			              /*
			              beginShape(POLYGON);

			              int W[] = closestC();
			              for(int i = 0;i<rohyY.length;i++){
			              	//vertex(rohyX[W[i]],rohyY[W[i]]);
			              	//rect(rohyX[i],rohyY[i],3,3);
		              }
			              endShape(CLOSE);*/
			              x=mouseX;
			              y=mouseY;
		              }
	              }




	              int[] closest(int q,int _kolik){
		              int[] answr = new int[_kolik];
		              float[] temp = new float[num];
		              //float[] temp2 = new float[num];

		              for(int i =0 ;i<num;i++){
			              if(i==q){
				              temp[i] = width*height;
			              }else{
				              temp[i] = dist(t[q].x,t[q].y,t[i].x,t[i].y);
			              }
		              }

		              //temp2=temp;

		              for(int i =0;i<_kolik;i++){
			              for(int w =0;w<num;w++){
				              if(temp[w]==min(temp)){
					              answr[i] = w;
					              temp[w] = max(temp);
					              break;
				              }
			              }
		              }

		              return answr;
	              }

	              int[] closObj(int q,int mode){
		              int answr[] = {-1,-1};

		              float[] temp = new float[rohyX.length+num];
		              //float[] temp2 = new float[num];

		              //vstup je stredobod
		              if(mode==1){
			              for(int i =0 ;i<temp.length;i++){
				              if(i<rohyX.length){
					              temp[i] = dist(r[q][0],r[q][1],rohyX[i],rohyY[i]);
				              }else{
					              temp[i] = dist(r[q][0],r[q][1],r[i-rohyY.length][0],r[i-rohyY.length][1]);
				              }
			              }
			              //vstup je prusecik
		              }else if(mode==2){
			              for(int i =0 ;i<temp.length;i++){
				              if(i<rohyX.length){
					              temp[i] = dist(rohyX[q],rohyY[q],rohyX[i],rohyY[i]);
				              }else{
					              temp[i] = dist(rohyX[q],rohyY[q],r[i-rohyY.length][0],r[i-rohyY.length][1]);
				              }
			              }
		              }

		              //temp2=temp;


		              for(int w =0;w<temp.length;w++){
			              if(temp[w]==min(temp)){
				              answr[0] = w;
				              temp[w] = max(temp);
				              break;
			              }
		              }

		              if(answr[0]<rohyX.length){
			              //vystup je prusecik
			              answr[1] = 2;
		              }else{
			              //vystup je stedobod
			              answr[1] = 1;
			              answr[0] -=rohyX.length;
		              }

		              return answr;
	              }


	              float[] kolmice(float x1,float y1,float x2,float y2){
		              float A1 = x1-x2;
		              float A2 = y1-y2;
		              float midX = lerp(x1,x2,0.5);
		              float midY = lerp(y1,y2,0.5);
		              float resX = midX+A2*10.5;
		              float resY = midY-A1*10.5;
		              float resX2 = midX-A2*10.5;
		              float resY2 = midY+A1*10.5;

		              float[] res = {resX,resY,resX2,resY2};
		              return res;
	              }


	              // Line Segment Intersection
	              PVector segIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
		              float bx = x2 - x1;
		              float by = y2 - y1;
		              float dx = x4 - x3;
		              float dy = y4 - y3;

		              float b_dot_d_perp = bx * dy - by * dx;

		              if(b_dot_d_perp == 0) return null;

		              float cx = x3 - x1;
		              float cy = y3 - y1;

		              float t = (cx * dy - cy * dx) / b_dot_d_perp;
		              if(t < 0 || t > 1) return null;

		              float u = (cx * by - cy * bx) / b_dot_d_perp;
		              if(u < 0 || u > 1) return null;

		              return new PVector(x1+t*bx, y1+t*by);
	              }

	              PVector lineIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
		              float bx = x2 - x1;
		              float by = y2 - y1;
		              float dx = x4 - x3;
		              float dy = y4 - y3;

		              float b_dot_d_perp = bx*dy - by*dx;

		              if(b_dot_d_perp == 0) return null;

		              float cx = x3-x1;
		              float cy = y3-y1;

		              float t = (cx*dy - cy*dx) / b_dot_d_perp;

		              return new PVector(x1+t*bx, y1+t*by);
	              }

              }


int num = 20;
Site [] s;


void setup(){
	size(800,400,P3D);
	background(0);

	textFont(createFont("Veranda",9));
	textMode(SCREEN);
	rectMode(CENTER);
	//smooth();

	s = new Site[num];

	for(int i =0;i<s.length;i++){
		s[i] = new Site(i);
	}
}

void draw(){
	background(0);

	
	for(int i =0;i<s.length;i++){
		s[i].live();

	}
}




class Site{
	int id;
	float x,y;
	float[][] kol = new float[s.length+4][4];
	float [][] bis = new float[s.length][2];;
	boolean valid[];
	Vector vX = new Vector();
	Vector vY = new Vector();
	Vector poradi = new Vector();

	color c = color(random(120,200));

	float br = 10.0;

	Site(int _id){
		id=_id;
		x=random(width);
		y= random(height);

		valid = new boolean[s.length];
	}

	void compute(){

		for(int i =0;i<s.length;i++){
			if(i!=id){
				bis[i][0]=lerp(x,s[i].x,0.5);
				bis[i][1]=lerp(y,s[i].y,0.5);
				kol[i] = kolmice(x,y,s[i].x,s[i].y);

			}
		}

		kol[s.length] = kolmice2(x,y,x,br);
		kol[s.length+1] = kolmice2(x,y,width-br,y);
		kol[s.length+2] = kolmice2(x,y,x,height-br);
		kol[s.length+3] = kolmice2(x,y,br,y);


		PVector tmp;
		vX.clear();
		vY.clear();
		for(int i = 0;i<kol.length;i++){
			for(int e = 0;e<kol.length;e++){
				if(e!=i){
					tmp = lineIntersection(kol[i][0],kol[i][1],kol[i][2],kol[i][3],
					                       kol[e][0],kol[e][1],kol[e][2],kol[e][3]);
					if(tmp!=null){
						if(visible(tmp.x,tmp.y)){
							vX.add(tmp.x);
							vY.add(tmp.y);
						}
					}
				}
			}
		}
		sortV();
		
		x+=random(-1,1);
		y+=random(-1,1);
		x=constrain(x,br,width-br);
		y=constrain(y,br,height-br);
	}

	void live(){
		compute();

		fill(c);
		stroke(0);
		beginShape(POLYGON);
		for(int i =0;i<poradi.size();i++){
			float X = (float)(Float)vX.get((Integer)poradi.get(i));
			float Y = (float)(Float)vY.get((Integer)poradi.get(i));
			vertex(lerp(X,x,0.2),lerp(Y,y,0.2));
		}
		endShape(CLOSE);

		noStroke();
		fill(0);
		rect(x,y,3,3);
		text(id,x+5,y+5);


	}

	boolean exist(float _x,float _y){
		boolean answr = false;
		float d;
		for(int i =0;i<vX.size();i++){
			d = (abs((Float)vX.get(i)-_x)+abs((Float)vY.get(i)-_y)) * 1000.0;
			if(d<5){

				answr = true;
			}

		}

		return answr;

	}

	boolean visible(float xx,float yy){
		boolean answr = true;
		PVector a;

		for(int i =0;i<kol.length;i++){

			a = segIntersection(x,y,lerp(x,xx,0.999),lerp(y,yy,0.999),kol[i][0],kol[i][1],kol[i][2],kol[i][3]);
			if(a!=null){
				answr = false;
			}
		}

		return answr;
	}

	void sortV(){
		int delka = vX.size();

		poradi.clear();
		Vector thetas =  new Vector();

		for(int i = 0;i<delka;i++){
			thetas.add(angle(i));
		}

		int selector = 0;
		float tmpaa = 1000.0;

		boolean[] sel = new boolean[thetas.size()];
		for(int i = 0;i<thetas.size();i++){

			selector = 0;
			tmpaa = 1000.0;

			for(int q = 0;q<thetas.size();q++){
				if((Float)thetas.get(q)<(tmpaa)&&!sel[q]){
					tmpaa = (Float)thetas.get(q);
					selector = q;
				}
			}

			sel[selector] = true;

			if(poradi.size()>0){
				if(((Float)thetas.get(selector)-(Float)thetas.get((Integer)poradi.get(poradi.size()-1)))>0.5)
					poradi.add(selector);
			}else{
				poradi.add(selector);
			}

		}
	}


	float[] kolmice(float x1,float y1,float x2,float y2){
		float A1 = x1-x2;
		float A2 = y1-y2;
		float midX = lerp(x1,x2,0.5);
		float midY = lerp(y1,y2,0.5);
		float resX = midX+A2*100.5;
		float resY = midY-A1*100.5;
		float resX2 = midX-A2*100.5;
		float resY2 = midY+A1*100.5;

		float[] res = {resX,resY,resX2,resY2};
		return res;
	}


	float[] kolmice2(float x1,float y1,float x2,float y2){
		float A1 = x1-x2;
		float A2 = y1-y2;
		float midX = x2;
		float midY = y2;
		float resX = midX+A2*100.5;
		float resY = midY-A1*100.5;
		float resX2 = midX-A2*100.5;
		float resY2 = midY+A1*100.5;

		float[] res = {resX,resY,resX2,resY2};
		return res;
	}

	PVector segIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
		float bx = x2 - x1;
		float by = y2 - y1;
		float dx = x4 - x3;
		float dy = y4 - y3;

		float b_dot_d_perp = bx * dy - by * dx;

		if(b_dot_d_perp == 0) return null;

		float cx = x3 - x1;
		float cy = y3 - y1;

		float t = (cx * dy - cy * dx) / b_dot_d_perp;
		if(t < 0 || t > 1) return null;

		float u = (cx * by - cy * bx) / b_dot_d_perp;
		if(u < 0 || u > 1) return null;

		return new PVector(x1+t*bx, y1+t*by);
	}

	PVector lineIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
		float bx = x2 - x1;
		float by = y2 - y1;
		float dx = x4 - x3;
		float dy = y4 - y3;

		float b_dot_d_perp = bx*dy - by*dx;

		if(b_dot_d_perp == 0) return null;

		float cx = x3-x1;
		float cy = y3-y1;

		float t = (cx*dy - cy*dx) / b_dot_d_perp;

		return new PVector(x1+t*bx, y1+t*by);
	}

	float angle(int b){
		float angle;

		float x1 = (Float)vX.get(b);
		float y1 = (Float)vY.get(b);

		float X = (x1-x);
		float Y = (y1-y);

		PVector vec = new PVector(X,Y);
		vec.normalize();

		if(vec.x==0){
			angle = 0;
		}else{
			angle = atan(vec.y / vec.x);
		}

		float qadr = 0;
		if((vec.x >= 0)&&(vec.y > 0)) qadr = 0;
		if((vec.x <= 0)&&(vec.y > 0)) qadr = 180;
		if((vec.x <= 0)&&(vec.y < 0)) qadr = 180;
		if((vec.x >= 0)&&(vec.y < 0)) qadr = 360;


		angle = degrees(angle)+qadr;

		return angle;

	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

  Recorder(String _dir,String _name){
    dir = _dir;
    name=_name;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="6000000";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" msmpeg4v2 "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }



}
/**
* Voronoi structure by Krystof Pesek (aka kof)
*	speed optimization in las release
*
*/

///////////////////////////////////////////////// >
int num = 10;
int precision = 4;
///////////////////////////////////////////////// >
boolean record = false;
boolean smoothing = false;
///////////////////////////////////////////////// >
Recorder r;
Site [] s;
///////////////////////////////////////////////// >

void setup(){
	size(800,500,P3D);
	background(0);

	//textFont(createFont("Veranda",9));
	//textMode(SCREEN);
	rectMode(CENTER);


	//frame.setAlwaysOnTop(true);
	
	if(record)
	r = new Recorder("out","voronoiIO5.avi");
	
	s = new Site[num];
	
	if(smoothing)
	smooth();

	float X = 0;
	float Y = 0;
	for(int i =0;i<s.length;i++){
		s[i] = new Site(i);
	}
}

///////////////////////////////////////////////// >

void draw(){
	//background(0);
	fade(50);

	for(int i =0;i<s.length;i++){
		s[i].live();
	}
	
	if(record)
	r.add();
}

///////////////////////////////////////////////// >

void fade(int kolik){
	fill(0,kolik);
	noStroke();
	rect(width/2,height/2,width,height);
}

///////////////////////////////////////////////// >

void keyPressed(){
	if(key=='q'){
		if(record)
		r.finish();
		exit();
	}else if(key == 's'){
		save("shot"+nf(frameCount,6)+".png");
		println("shot saved");
	}
}


///////////////////////////////////////////////// >

class Site{
	int id;
	float x,y,tx,ty;
	float speed = 3.0;

	float[][] kol = new float[0][4];
	//float [][] bis = new float[s.length][2];;
	boolean valid[];
	Vector vX = new Vector();
	Vector vY = new Vector();
	Vector poradi = new Vector();

	float dens = 0;

	color c;

	float br = 20.0;

	///////////////////////////////////////////////// >

	Site(int _id){
		id=_id;
		tx=x=random(br,width-br);
		ty=y= random(br,height-br);
		c = color(random(255));
		valid = new boolean[s.length];

	}

	///////////////////////////////////////////////// >

	Site(int _id,float _x,float _y){
		id=_id;
		tx=x=_x;
		ty=y= _y;
		c = color(random(255));
		valid = new boolean[s.length];

	}

	///////////////////////////////////////////////// >

	void compute(){
		kol = new float[0][4];

		for(int i =0;i<s.length;i++){
			if(i!=id){
				float bisX=lerp(x,s[i].x,0.5);
				float bisY=lerp(y,s[i].y,0.5);
				if(kol.length>0){
					if(visible2(bisX,bisY)<precision){
						kol = (float[][])expand(kol,kol.length+1);
						kol[kol.length-1] = kolmice(x,y,s[i].x,s[i].y);
					}
				}else{
					kol = (float[][])expand(kol,kol.length+1);
					kol[kol.length-1] = kolmice(x,y,s[i].x,s[i].y);

				}
			}
		}

		kol = (float[][])expand(kol,kol.length+1);
		kol[kol.length-1] = kolmice2(x,y,x,br);
		kol = (float[][])expand(kol,kol.length+1);
		kol[kol.length-1] = kolmice2(x,y,width-br,y);
		kol = (float[][])expand(kol,kol.length+1);

		kol[kol.length-1] = kolmice2(x,y,x,height-br);
		kol = (float[][])expand(kol,kol.length+1);

		kol[kol.length-1] = kolmice2(x,y,br,y);


		PVector tmp;
		vX.clear();
		vY.clear();
		//println((Float)vX.get(0));
		for(int i = 0;i<kol.length;i++){
			//if(valid[i]){
			for(int e = 0;e<kol.length;e++){
				if(e!=i){
					tmp = lineIntersection(kol[i][0],kol[i][1],kol[i][2],kol[i][3],
					                       kol[e][0],kol[e][1],kol[e][2],kol[e][3]);
					if(tmp!=null){
						if(visible(tmp.x,tmp.y)){
							if(!exist(tmp.x,tmp.y)){
								vX.add(tmp.x);
								vY.add(tmp.y);
							}
						}
					}
				}
			}
		}

		sortV();

	}

	///////////////////////////////////////////////// >

	void live(){
		compute();

		///////////////////////////////////////////////// >

		/**
		dens = 0;

		for(int i =0;i<poradi.size();i++){
			dens+=dist((float)(Float)vX.get((Integer)poradi.get(i)),
			           (float)(Float)vY.get((Integer)poradi.get(i)),x,y);
	}

		dens /= poradi.size();
		dens = map(dens,3,(width)/20.0,1,0);
		dens=constrain(dens,0,1);
		*/


		///////////////////////////////////////////////// >

		for(int i = 0;i<poradi.size();i++){
			int sel = (i+1)%(poradi.size());
			float X2a = (float)(Float)vX.get((Integer)poradi.get(i));
			float Y2a = (float)(Float)vY.get((Integer)poradi.get(i));
			float X2b = (float)(Float)vX.get((Integer)poradi.get(sel));
			float Y2b = (float)(Float)vY.get((Integer)poradi.get(sel));

			float [] center = getCenter(x,y,X2a,Y2a,X2b,Y2b);

			tx+=(center[0]-tx)/(poradi.size()+0.0);
			ty+=(center[1]-ty)/(poradi.size()+0.0);

		}

		///////////////////////////////////////////////// >



		fill(c,120);
		noStroke();

		c = lerpColor(color(#FFFFFF),color(#FFCC00),
		              constrain(map(dist(tx,ty,x,y),0,5,0,1),0,1));



		///////////////////////////////////////////////// >

		beginShape(POLYGON);
		for(int i = 0;i<poradi.size();i++){
			float X2 = (float)(Float)vX.get((Integer)poradi.get(i));
			float Y2 = (float)(Float)vY.get((Integer)poradi.get(i));

			vertex(lerp(X2,x,0.05),lerp(Y2,y,0.05));
		}
		endShape(CLOSE);

		fill(0);
		noStroke();


		///////////////////////////////////////////////// >
		beginShape(POLYGON);
		for(int i = 0;i<poradi.size();i++){
			float X2 = (float)(Float)vX.get((Integer)poradi.get(i));
			float Y2 = (float)(Float)vY.get((Integer)poradi.get(i));

			vertex(lerp(X2,x,0.2),lerp(Y2,y,0.2));
		}

		endShape(CLOSE);


		///////////////////////////////////////////////// >
		noStroke();
		fill(c,100);
		rect(x,y,3,3);
		fill(255,60);
		rect(tx,ty,2,2);

		///////////////////////////////////////////////// >
		tx=constrain(tx,br,width-br);
		ty=constrain(ty,br,height-br);

		x+=(tx-x)/speed;
		y+=(ty-y)/speed;
	}

	///////////////////////////////////////////////// >

	boolean exist(float _x,float _y){
		boolean answr = false;
		float d;
		for(int i =0;i<vX.size();i++){
			d = (abs((Float)vX.get(i)-_x)+abs((Float)vY.get(i)-_y)) * 1000.0;
			if(d<1){
				answr = true;
			}
		}
		return answr;
	}

	///////////////////////////////////////////////// >

	boolean visible(float xx,float yy){
		boolean answr = true;
		PVector a;

		for(int i =0;i<kol.length;i++){
			a = segIntersection(x,y,lerp(x,xx,0.998),lerp(y,yy,0.998),kol[i][0],kol[i][1],kol[i][2],kol[i][3]);
			if(a!=null){
				answr = false;
			}
		}
		return answr;
	}

	///////////////////////////////////////////////// >

	int visible2(float xx,float yy){
		int answr = 0;
		PVector a;

		for(int i =0;i<kol.length;i++){
			a = segIntersection(x,y,lerp(x,xx,0.998),lerp(y,yy,0.998),kol[i][0],kol[i][1],kol[i][2],kol[i][3]);
			if(a!=null){
				answr++;
			}
		}
		return answr;
	}

	///////////////////////////////////////////////// >

	void sortV(){
		int delka = vX.size();

		poradi.clear();
		Vector thetas =  new Vector();

		for(int i = 0;i<delka;i++){
			thetas.add(angle(i));
		}

		int selector = 0;
		float tmpaa = 1000.0;

		boolean[] sel = new boolean[thetas.size()];
		for(int i = 0;i<thetas.size();i++){

			selector = 0;
			tmpaa = 1000.0;

			for(int q = 0;q<thetas.size();q++){
				if((Float)thetas.get(q)<(tmpaa)&&!sel[q]){
					tmpaa = (Float)thetas.get(q);
					selector = q;
				}
			}
			sel[selector] = true;

			if(poradi.size()>0){
				if(((Float)thetas.get(selector)-(Float)thetas.get((Integer)poradi.get(poradi.size()-1)))>0.25)
					poradi.add(selector);
			}else{
				poradi.add(selector);
			}
		}
	}

	///////////////////////////////////////////////// >

	float[] kolmice(float x1,float y1,float x2,float y2){
		float A1 = x1-x2;
		float A2 = y1-y2;
		float midX = lerp(x1,x2,0.5);
		float midY = lerp(y1,y2,0.5);
		float resX = midX+A2*100.5;
		float resY = midY-A1*100.5;
		float resX2 = midX-A2*100.5;
		float resY2 = midY+A1*100.5;

		float[] res = {resX,resY,resX2,resY2};
		return res;
	}


	///////////////////////////////////////////////// >

	float[] kolmice2(float x1,float y1,float x2,float y2){
		float A1 = x1-x2;
		float A2 = y1-y2;
		float midX = x2;
		float midY = y2;
		float resX = midX+A2*100.5;
		float resY = midY-A1*100.5;
		float resX2 = midX-A2*100.5;
		float resY2 = midY+A1*100.5;

		float[] res = {resX,resY,resX2,resY2};
		return res;
	}

	///////////////////////////////////////////////// >

	PVector segIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
		float bx = x2 - x1;
		float by = y2 - y1;
		float dx = x4 - x3;
		float dy = y4 - y3;

		float b_dot_d_perp = bx * dy - by * dx;

		if(b_dot_d_perp == 0) return null;

		float cx = x3 - x1;
		float cy = y3 - y1;

		float t = (cx * dy - cy * dx) / b_dot_d_perp;
		if(t < 0 || t > 1) return null;

		float u = (cx * by - cy * bx) / b_dot_d_perp;
		if(u < 0 || u > 1) return null;

		return new PVector(x1+t*bx, y1+t*by);
	}

	///////////////////////////////////////////////// >

	PVector lineIntersection(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4){
		float bx = x2 - x1;
		float by = y2 - y1;
		float dx = x4 - x3;
		float dy = y4 - y3;

		float b_dot_d_perp = bx*dy - by*dx;

		if(b_dot_d_perp == 0) return null;

		float cx = x3-x1;
		float cy = y3-y1;

		float t = (cx*dy - cy*dx) / b_dot_d_perp;

		return new PVector(x1+t*bx, y1+t*by);
	}

	///////////////////////////////////////////////// >

	float angle(int b){
		float angle;

		float x1 = (Float)vX.get(b);
		float y1 = (Float)vY.get(b);

		float X = (x1-x);
		float Y = (y1-y);

		PVector vec = new PVector(X,Y);
		vec.normalize();

		if(vec.x==0){
			angle = 0;
		}else{
			angle = atan(vec.y / vec.x);
		}

		float qadr = 0;
		if((vec.x >= 0)&&(vec.y > 0)) qadr = 0;
		if((vec.x <= 0)&&(vec.y > 0)) qadr = 180;
		if((vec.x <= 0)&&(vec.y < 0)) qadr = 180;
		if((vec.x >= 0)&&(vec.y < 0)) qadr = 360;

		angle = degrees(angle)+qadr;

		return angle;
	}

	///////////////////////////////////////////////// >

	float getArea(float x1,float y1,float x2,float y2,float x3,float y3){
		float v1x, v1y, v2x, v2y;

		v1x = x2 - x1;	// compute side vectors
		v1y = y2 - y1; 	// compute side vectors

		v2x = x3 - x1; 	// compute side vectors
		v2y = y3 - y1; 	// compute side vectors

		// return cross product of side vectors / 2

		return 0.5 * (v1x * v2y - v1y * v2x);
	}

	///////////////////////////////////////////////// >

	float[] getCenter(float _x1,float _y1,float _x2,float _y2,float _x3,float _y3){

		float[] cntr = new float[2];
		cntr[0] = 0;
		cntr[1] = 0;

		float x1, y1, x2, y2, x3, y3, x4, y4;

		x1 = _x1;	// get endpoints of first median
		y1 = _y1;	// get endpoints of first median
		x2 = (_x2 + _x3) / 2.0;	// get endpoints of first median
		y2 = (_y2 + _y3) / 2.0;	// get endpoints of first median

		x3 = _x2;	// get endpoints of second median (only need two)
		y3 = _y2;	// get endpoints of second median
		x4 = (_x3 + _x1) / 2.0;	// get endpoints of second median
		y4 = (_y3 + _y1) / 2.0;	// get endpoints of second median

		// see if either median is vertical (slope == infinity)

		if (x1 == x2)	// if so...
		{
			x1 = _x3;	// use third median (can't be two vertical medians)
			y1 = _y3; // use third median
			x2 = (_x1 + _x2) / 2.0; // use third median
			y2 = (_y1 + _y2) / 2.0; // use third median
		}
		else if (x3 == x4)
		{
			x3 = _x3;
			y3 = _y3;
			x4 = (_x1 + _x2) / 2.0;
			y4 = (_y1 + _y2) / 2.0;
		}

		float a1, a2, b1, b2;

		a1 = (y2 - y1) / (x2 - x1);	// compute slope of first median
		b1 = y1 - a1 * x1;	// compute intercept of first median

		a2 = (y4 - y3) / (x4 - x3);	// compute slope of second median
		b2 = y3 - a2 * x3;	// compute intercept of second median

		// solve a1 * x + b1 = a2 * x + b2

		cntr[0] = (b2 - b1) / (a1 - a2);	// solve for x coordinate of intersection
		cntr[1] = a1 * cntr[0] + b1;	// solve for y coordinate of intersection

		return cntr;	// return center as a point

	}

	///////////////////////////////////////////////// >

}
import megamu.mesh.*;

int num = 5000;

float thick = 0.2;
float sp = 1.31;


boolean mesh=false;
boolean voron=true;

Voronoi voronoi;
Site[] s;
float[][] points = new float[num][3];
float[][] myEdges;


MPolygon[] regions;

void setup(){
	size(1200,800,P3D);
	frameRate(5);
	//	smooth();
	/*
	xx= new float[num];
	yy= new float[num];
		
	tx= new float[num];
	ty= new float[num];
	lx= new float[num];
	ly= new float[num];

	cnt = new int[num];
	*/

	reset();
}

void draw(){
	background(0);

	//refresh();
	//update = false;

	if(voron){
		//beginShape();

		for(int i=0; i<myEdges.length; i++){
			// an array of points
			//noStroke();
			stroke(255);
			//fill(s[i].c);
			line(myEdges[i][0],myEdges[i][1],myEdges[i][2],myEdges[i][3]);
			//vertex(myEdges[i][2],myEdges[i][3]);



		}

		//endShape();
	}




	if(mesh){
		if(!voron){
			stroke(255,155);
		}else{
			stroke(0,155);
		}

		for(int i=0; i<myEdges.length; i++)
		{
			float startX = myEdges[i][0];
			float startY = myEdges[i][1];
			float endX = myEdges[i][2];
			float endY = myEdges[i][3];
			line( startX, startY, endX, endY );
		}
	}

	for(int i =0;i<num;i++){
		s[i].live();
	}

}

void reset(){
	s = new Site[num];
	//smooth();

	float X = 0;
	float Y = 0;
	for(int i =0;i<num;i++){
		s[i] = new Site(i);

		X+=random(20,30);
		if(X>width){
			X=0;
			Y+=20;
		}


		points[i][0] = s[i].x;
		points[i][1] = s[i].y;
		points[i][2] = s[i].z;
		/*
		lx[i]=tx[i]=xx[i] = s[i].x;
		ly[i]=ty[i]=yy[i] = s[i].y;
		cnt[i] = 0;
		*/
	}

	voronoi = new Voronoi( points );
	myEdges = voronoi.getEdges();
}

void refresh(){

	try{
		if(voron){
			voronoi = new Voronoi( points );
			//regions = voronoi.getRegions();
			myEdges = voronoi.getEdges();
		}

		if(mesh){
			Delaunay myDelaunay = new Delaunay( points );
			myEdges = myDelaunay.getEdges();
		}
	}catch( ArrayIndexOutOfBoundsException e){
		println("pruser!!! "+e);
		reset();
	}

}

void keyPressed(){
	if(key==' '){
		loop();
	}

}

class Site{
	float x,y,z;
	float tx,ty,tz;
	int id = 0;
	int cyc = 4;
	color c;

	float brdr = 50.0;


	float speed = 120.0;
	float trsh = 20.0;

	Site(int _id){
		id=_id;
		tx = x = random(brdr,width-brdr);
		ty = y = random(brdr,height-brdr);
		tz = z = random(brdr,height-brdr);

		c = color(random(120,255));
		//	speed = random(50,125);
	}

	Site(int _id,float _x,float _y,float _z){
		c = color(random(120,255));
		id=_id;
		tx = x = _x;
		ty = y = _y;
		tz = z = _z;
	}

	void live(){

		//move();
		//bordr(brdr);

		points[id][0] = x;
		points[id][1] = y;
		points[id][2] = z;

		draw();
	}

	void move(){
		for(int i =0;i<s.length;i++){
			if(i!=id){
				float d = dist(s[i].x,s[i].y,x,y);
				d = constrain(d,1.001,width);

				//c = lerpColor(#FFFFFF,#FFCC00,map(d,trsh*2,0,0,1));
				tx+=(s[i].x-tx)/(d*4.0);
				ty+=(s[i].y-ty)/(d*4.0);

				if(d<trsh){
					tx-=(s[i].x-tx)/(d);
					ty-=(s[i].y-ty)/(d);
				}

			}

		}

		//	tx = constrain(tx,x-10,x+10);
		//		ty = constrain(ty,y-10,y+10);

		x+=(tx-x)/speed;
		y+=(ty-y)/speed;

	}

	void bordr(float k){
		x = constrain(x,k,width-k);
		y = constrain(y,k,height-k);

	}

	void draw(){
		fill(0,150);
		noStroke();
		rect(x-1.5,y-1.5,2,2);
	}


}

/*
	myVoronoi = new Voronoi( points );
	
	float[][] myEdges = myVoronoi.getEdges();

for(int i=0; i<myEdges.length; i++)
{
	float startX = myEdges[i][0];
	float startY = myEdges[i][1];
	float endX = myEdges[i][2];
	float endY = myEdges[i][3];
	line( startX, startY, endX, endY );
}

	myRegions = myVoronoi.getRegions();

	for(int i=0; i<myRegions.length; i++){
		// an array of points
		float[][] regionCoordinates = myRegions[i].getCoords();

		fill(255,0,0,50);
		myRegions[i].draw(this); // draw this shape
	}
*/


import supercollider.*;

int num = 10;
Zenit z[];

void setup (){
	size(300, 300,P3D);
	frameRate(24);
	
	textFont(createFont("Veranda",9));
	textMode(SCREEN);
	
	z= new Zenit[num];

	for(int i =0 ;i<num;i++){
		z[i] = new Zenit();
	}
}

void draw (){
	background(0);
	for(int i =0 ;i<num;i++){
		z[i].live();

	}
}

void stop (){
	for(int i =0 ;i<num;i++){
		z[i].kill();
	}
}

class Zenit{
	float tx,ty,x,y,sx,sy;
	Synth synth;

	Zenit(){
		sx=x=tx=random(width);
		sy=y=ty=random(height);
		synth = new Synth("defs");
		synth.set("freq", 80);
		synth.create();
	}

	void live(){
		tx = tx+random(-10,10);
		ty = ty+random(-10,10);
		
		sx+=(tx-sx) * 0.1;
		sy+=(ty-sy) * 0.1;
		
		for(int i = 0;i<z.length;i++){
			if(dist(x,y,z[i].x,z[i].y)<10){
			tx-=(z[i].x-x)*.02;
			ty-=(z[i].y-y)*.02;
			}
		}
		
		bordr(10);
		
		x+=(tx-x)*0.01;
		y+=(ty-y)*0.01;
		float speed = abs(sx-x)+abs(sy-y);
		speed/=2.0;

		pushStyle();
		fill(255,80);
		noStroke();
		rect(x,y,3,3);
		text(speed,x,y);
		stroke(255,80);
		line(sx,sy,x,y);
		popStyle();

		synth.set("freq",speed);
	}
	
	void bordr(int q){
		if(tx<q)tx=q;
		if(tx>width-q)tx=width-q;
		
		if(ty<q)ty=q;
		if(ty>height-q)ty=height-q;
		
	}

	void kill(){
		synth.free();
	}
}
Site[] s = new Site[2];
float rot = 0;

void setup(){
	size(300,300,P3D);
	background(255);

	for(int i =0;i<s.length;i++){
		s[i] = new Site(i);
	}
	noFill();
	stroke(0);
}

void draw(){
	size(300,300,P3D);
	background(255);


	pushMatrix();
	translate(0,0,-width*1.2);
	pushMatrix();
	translate(width/2.0,height/2.0,width/2.0);

	pushMatrix();
	rotateY(rot);
	rot+=0.01;
	box(width);

	translate(-width/2.0,-height/2.0,-width/2.0);

	pushMatrix();


	for(int i =0;i<s.length;i++){
		s[i].draw();
	}

	popMatrix();

	popMatrix();

	popMatrix();

	popMatrix();
}

void mousePressed(){
	reset();
}

void reset(){
	for(int i =0;i<s.length;i++){
		s[i] = new Site(i);
	}

}


class Site{
	float x,y,z;
	int id;
	float siz = 10;

	Site(int _id){
		id=_id;
		x=random(0,width);
		y=random(0,height);
		z=random(0,height);
	}


	void compute(){


	}
	void draw(){
		//siz = mouseX;
		compute();
		pushStyle();
		noFill();
		stroke(0);
		pushMatrix();
		translate(x,y,z);
		box(3);
		popMatrix();

		for(int i = 0;i<s.length;i++){
			if(i!=id){
				line(s[i].x,s[i].y,s[i].z,x,y,z);

				fill(0,100);
				beginShape(QUAD);
				vertex(D(s[i])[0],D(s[i])[1],D(s[i])[2]);
				vertex(C(s[i])[0],C(s[i])[1],C(s[i])[2]);
				vertex(A(s[i])[0],A(s[i])[1],A(s[i])[2]);
				vertex(B(s[i])[0],B(s[i])[1],B(s[i])[2]);

				//vertex(A(s[i])[0],A(s[i])[1],A(s[i])[2]);
				endShape(CLOSE);
				noFill();


				pushMatrix();
				translate(midpoint(s[i])[0],midpoint(s[i])[1],midpoint(s[i])[2]);
				box(4);
				popMatrix();
			}

		}
		popStyle();

	}

	float[] midpoint(Site _s){
		Site temp = _s;

		float midX = lerp(x,temp.x,0.5);
		float midY = lerp(y,temp.y,0.5);
		float midZ = lerp(z,temp.z,0.5);

		float[] answr = {midX,midY,midZ};
		return answr;
	}

	float[] A(Site _s){

		float x2 = _s.x;
		float y2 = _s.y;
		float z2 = _s.z;

		float x3 = midpoint(_s)[0];
		float y3 = midpoint(_s)[1];
		float z3 = midpoint(_s)[2];

		float rX = x3+siz;
		float rY = y3+siz;
		float rZ = z3+(x3+y3-x2-y2)/(z2-z3);

		float result[] = {rX,rY,rZ};

		return result;

	}

	float[] B(Site _s){

		float x2 = _s.x;
		float y2 = _s.y;
		float z2 = _s.z;

		float x3 = midpoint(_s)[0];
		float y3 = midpoint(_s)[1];
		float z3 = midpoint(_s)[2];

		float rX = x3+siz;
		float rY = y3-siz;
		float rZ = z3+(x3+y2-x2-y3)/(z2-z3);

		float result[] = {rX,rY,rZ};

		return result;

	}

	float[] C(Site _s){
		float x2 = _s.x;
		float y2 = _s.y;
		float z2 = _s.z;

		float x3 = midpoint(_s)[0];
		float y3 = midpoint(_s)[1];
		float z3 = midpoint(_s)[2];

		float rX = x3-siz;
		float rY = y3+siz;
		float rZ = z3+(x2+y3-x3-y2)/(z2-z3);

		float result[] = {rX,rY,rZ};

		return result;

	}

	float[] D(Site _s){
		float x2 = _s.x;
		float y2 = _s.y;
		float z2 = _s.z;

		float x3 = midpoint(_s)[0];
		float y3 = midpoint(_s)[1];
		float z3 = midpoint(_s)[2];

		float rX = x3-siz;
		float rY = y3-siz;
		float rZ = z3+(x2+y2-x3-y3)/(z2-z3);

		float result[] = {rX,rY,rZ};

		return result;

	}

}
//import processing.opengl.*;

int num = 300;
float x[],y[], speed[], offset[];

void setup(){
	size(1280,720,P3D);
	background(255);

	x = new float[num];
	y = new float[num];
	speed = new float[num];
	offset = new float[num];

	for(int i =0;i<num;i++){
		offset[i] = 1.0;
		speed[i] = random(40.0,60.0);
		}

	noFill();
	stroke(0,1.5);//stroke(0,90);

	smooth();
}

void draw(){

	compute();

	//background(255);

	for(int i =0;i<num;i++){
		line(x[i],y[i],x[i]+sin(y[i]/100.0)*10.0,y[i]+cos(x[i]/100.0)*10.0);
		line(x[i],y[i],x[i]+5,y[i]);
	}
}

void compute(){
	
	for(int i =0;i<num;i++){
		x[i] = (cos(frameCount/(speed[i]+i))*width*180.0/(i+offset[i]))+width/2.0;
		y[i] = (sin(frameCount/(speed[i]+i))*width*180.0/(i+offset[i]))+width/2.0;
		offset[i]+=offset[i]/2000.0;
	}


}
import blobDetection.*;

BlobDetection theBlobDetection;
PImage img;

// ==================================================
// setup()
// ==================================================
void setup()
{
	img = loadImage("partitionblack2.jpg");
	theBlobDetection = new BlobDetection(img.width, img.height);
	theBlobDetection.setPosDiscrimination(false);
	theBlobDetection.setThreshold(0.38f);
	theBlobDetection.computeBlobs(img.pixels);

	// Size of applet
	size(img.width, img.height);
}

// ==================================================
// draw()
// ==================================================
void draw()
{
	image(img,0,0,width,height);
	drawBlobsAndEdges(false,true);
}

// ==================================================
// drawBlobsAndEdges()
// ==================================================
void drawBlobsAndEdges(boolean drawBlobs, boolean drawEdges)
{
	noFill();
	Blob b;
	EdgeVertex eA,eB;
	for (int n=0 ; n<theBlobDetection.getBlobNb() ; n++)
	{
		b=theBlobDetection.getBlob(n);
		if (b!=null)
		{
			// Edges
			if (drawEdges)
			{
				strokeWeight(3);
				stroke(0,255,0);
				for (int m=0;m<b.getEdgeNb();m++)
				{
					eA = b.getEdgeVertexA(m);
					eB = b.getEdgeVertexB(m);
					if (eA !=null && eB !=null)
						line(
							eA.x*width, eA.y*height, 
							eB.x*width, eB.y*height
							);
				}
			}

			// Blobs
			if (drawBlobs)
			{
				strokeWeight(1);
				stroke(255,0,0);
				rect(
					b.xMin*width,b.yMin*height,
					b.w*width,b.h*height
					);
			}

		}

      }
}
int res = 1;
int penSize = 30;
int lwidth;
int lheight;
int pnum = 30000;
vsquare[][] v;
vbuffer[][] vbuf;
particle[] p = new particle[pnum];
int pcount = 0;
int mouseXvel = 0;
int mouseYvel = 0;

void setup() 
{
  size(200, 200,P3D);
  noStroke();
  frameRate(30);
  lwidth = width/res;
  lheight = height/res;
  v = new vsquare[lwidth+1][lheight+1];
  vbuf = new vbuffer[lwidth+1][lheight+1];
  for (int i = 0; i < pnum; i++) {
    p[i] = new particle(random(res,width-res),random(res,height-res));
  }
  for (int i = 0; i <= lwidth; i++) {
    for (int u = 0; u <= lheight; u++) {
      v[i][u] = new vsquare(i*res,u*res);
      vbuf[i][u] = new vbuffer(i*res,u*res);
    }
  }
}

void draw() 
{
  background(0);
  
  int axvel = mouseX-pmouseX;
  int ayvel = mouseY-pmouseY;

  mouseXvel = (axvel != mouseXvel) ? axvel : 0;
  mouseYvel = (ayvel != mouseYvel) ? ayvel : 0;

  for (int i = 0; i < lwidth; i++) {
    for (int u = 0; u < lheight; u++) {
      vbuf[i][u].updatebuf(i,u);
      v[i][u].col = 32;
    }
  }
  for (int i = 0; i < pnum-1; i++) {
    p[i].updatepos();
  }
  for (int i = 0; i < lwidth; i++) {
    for (int u = 0; u < lheight; u++) {
      v[i][u].addbuffer(i, u);
      v[i][u].updatevels(mouseXvel, mouseYvel);
      v[i][u].display(i, u);
    }
  }
}

class particle {
  float x;
  float y;
  float xvel;
  float yvel;
  int pos;
  particle(float xIn, float yIn) {
    x = xIn;
    y = yIn;
  }

  void updatepos() {
    float col1;
    if (x > 0 && x < width && y > 0 && y < height) {
      int vi = (int)(x/res);
      int vu = (int)(y/res);
      vsquare o = v[vi][vu];    
      
      float ax = (x%res)/res;
      float ay = (y%res)/res;
      
      xvel += (1-ax)*v[vi][vu].xvel*0.05;
      yvel += (1-ay)*v[vi][vu].yvel*0.05;
      
      xvel += ax*v[vi+1][vu].xvel*0.05;
      yvel += ax*v[vi+1][vu].yvel*0.05;
      
      xvel += ay*v[vi][vu+1].xvel*0.05;
      yvel += ay*v[vi][vu+1].yvel*0.05;

      o.col += 4;
      
      x += xvel;
      y += yvel;
    }
    else {
      x = random(0,width);
      y = random(0,height);
      xvel = 0;
      yvel = 0;
    }

    xvel *= 0.5;
    yvel *= 0.5;
  }
}

class vbuffer {
  int x;
  int y;
  float xvel;
  float yvel;
  float pressurex = 0;
  float pressurey = 0;
  float pressure = 0;

  vbuffer(int xIn,int yIn) {
    x = xIn;
    y = yIn;
    pressurex = 0;
    pressurey = 0;
    }

  void updatebuf(int i, int u) {
    if (i>0 && i<lwidth && u>0 && u<lheight) {
      pressurex = (v[i-1][u-1].xvel*0.5 + v[i-1][u].xvel + v[i-1][u+1].xvel*0.5 - v[i+1][u-1].xvel*0.5 - v[i+1][u].xvel - v[i+1][u+1].xvel*0.5);
      pressurey = (v[i-1][u-1].yvel*0.5 + v[i][u-1].yvel + v[i+1][u-1].yvel*0.5 - v[i-1][u+1].yvel*0.5 - v[i][u+1].yvel - v[i+1][u+1].yvel*0.5);
      pressure = (pressurex + pressurey)*0.25;
      }
    }
  }

class vsquare {
  int x;
  int y;
  float xvel;
  float yvel;
  float col;

  vsquare(int xIn,int yIn) {
    x = xIn;
    y = yIn;
    }

  void addbuffer(int i, int u) {
    if (i>0 && i<lwidth && u>0 && u<lheight) {
      xvel += (vbuf[i-1][u-1].pressure*0.5
              +vbuf[i-1][u].pressure
              +vbuf[i-1][u+1].pressure*0.5
              -vbuf[i+1][u-1].pressure*0.5
              -vbuf[i+1][u].pressure
              -vbuf[i+1][u+1].pressure*0.5
              )*0.25;
      yvel += (vbuf[i-1][u-1].pressure*0.5
              +vbuf[i][u-1].pressure
              +vbuf[i+1][u-1].pressure*0.5
              -vbuf[i-1][u+1].pressure*0.5
              -vbuf[i][u+1].pressure
              -vbuf[i+1][u+1].pressure*0.5
              )*0.25;
      }
    }

  void updatevels(int mvelX, int mvelY) {
    if (mousePressed) {
      float adj = x - mouseX;
      float opp = y - mouseY;
      float dist = sqrt(opp*opp + adj*adj);
      if (dist < penSize) {
        if (dist < 4) dist = penSize;
        float mod = penSize/dist;
        xvel += mvelX*mod;
        yvel += mvelY*mod;
        }
      }

    xvel *= 0.99;
    yvel *= 0.99;
  }
  
  void display(int i, int u) {
    float tcol = 0;
    if (col > 255) col = 255;
    if (i>0 && i<lwidth-1 && u>0 && u<lheight-1) {
      tcol = (+ v[i][u+1].col 
              + v[i+1][u].col 
              + v[i+1][u+1].col*0.5
              )*0.4;
      tcol = (int)(tcol+col*0.5);
      }
    else {
      tcol = (int)col;
      }
    fill(tcol);
    rect(x,y,res,res);
  }
}


/**
  * This sketch demonstrates how to use the <code>getLineIn</code> method of <code>Minim</code>. This method
  * returns an <code>AudioInput</code> object. An <code>AudioInput</code> represents a connection to the
  * computer's current record source (usually the line-in) and is used to monitor audio coming from an external source.
  * There are five versions of <code>getLineIn</code>:
  * <pre>
  * getLineIn()
  * getLineIn(int type)
  * getLineIn(int type, int bufferSize)
  * getLineIn(int type, int bufferSize, float sampleRate)
  * getLineIn(int type, int bufferSize, float sampleRate, int bitDepth)
  * </pre>
  * The value you can use for <code>type</code> is either <code>Minim.MONO</code> or <code>Minim.STEREO</code>.
  * <code>bufferSize</code> specifies how large you want the sample buffer to be, <code>sampleRate</code> specifies
  * the sample rate you want to monitor at, and <code>bitDepth</code> specifies what bit depth you want to monitor at.
  * <code>type</code> defaults to <code>Minim.STEREO</code>, <code>bufferSize</code> defaults to 1024,
  * <code>sampleRate</code> defaults to 44100, and <code>bitDepth</code> defaults to 16. If an <code>AudioInput</code>
  * cannot be created with the properties you request, <code>Minim</code> will report an error and return <code>null</code>.
  * <p>
  * When you run your sketch as an applet you will need to sign it in order to get an input.
  * <p>
  * Before you exit your sketch make sure you call the <code>close</code> method of any <code>AudioInput</code>'s
  * you have received from <code>getLineIn</code>.
  */
 
import ddf.minim.*;
import ddf.minim.analysis.*;

 import processing.opengl.*;
 
Minim minim;
AudioInput in;
FFT fft;


int cas = 0;
 
void setup()
{
  size(1024, 512, OPENGL);
 
  minim = new Minim(this);
//  minim.debugOn();
 
  // get a line in from Minim, default bit depth is 16
  in = minim.getLineIn(Minim.STEREO, 512);
   fft = new FFT(in.bufferSize(), in.sampleRate());

  background(0);
}
 
void draw()
{
	cas++;
	
	if(cas>width){
	background(0);
	cas=0;
	}
 // background(0);
  stroke(255,128,0,4);
  // draw the waveforms
  for(int i = 0; i < in.bufferSize() - 1; i++)
  {
    line(cas, 100 + in.left.get(i)*height*2, cas, 100 + in.left.get(i+1)*height*2);
   
  }
  
    // note that if jingle were a MONO file, this would be the same as using jingle.right or jingle.left
  fft.forward(in.mix);
  /*
  for(int i = 0; i < fft.specSize(); i++)
  {
    // draw the line for frequency band i, scaling it by 4 so we can see it a bit better
    stroke(255,constrain(fft.getBand(i)*120,0,200));
    line(cas, height-pow(i,0.5)*15, cas, 1+height-pow(i,0.5)*15);
  }
  */
  float w = int(width/fft.avgSize());

   for(int i = 0; i < fft.avgSize(); i++){
	   stroke(255);
	   rect(i*w, height, i*w + w, height - fft.getAvg(i));

	   }


  


}
 
 
void stop()
{
  // always close Minim audio classes when you are done with them
  in.close();
  //fft.colse();
  minim.stop();
 
  super.stop();
}
class Sampler
{
	int timer = 0;
	int durat = 30;
	
	boolean[] pressed = new boolean[kdown.length];
	boolean[] pressed2= new boolean[kdown.length];
	
	boolean map[][] = new boolean[durat][kdown.length];
	
	Synth[] s = new Synth[0];
	boolean recording,playing;
	
	Sampler()
	{
		recording = true;	
	}
	
	void run(){
		if(recording){
			for(int i =0;i<kdown.length;i++){
				pressed[i] = kdown[i];
				if(pressed[i]&&!pressed2){
					map[timer][i] = true;
				}
			}
			pressed2=pressed;
						
			timer ++;
			if(timer==durat){
				recording = false;
				println("sampled "+durat+" frames");
			}
		}
	
	}
	
	
	





}
/**
  * This sketch demonstrates how to use the <code>getLineIn</code> method of <code>Minim</code>. This method
  * returns an <code>AudioInput</code> object. An <code>AudioInput</code> represents a connection to the
  * computer's current record source (usually the line-in) and is used to monitor audio coming from an external source.
  * There are five versions of <code>getLineIn</code>:
  * <pre>
  * getLineIn()
  * getLineIn(int type)
  * getLineIn(int type, int bufferSize)
  * getLineIn(int type, int bufferSize, float sampleRate)
  * getLineIn(int type, int bufferSize, float sampleRate, int bitDepth)
  * </pre>
  * The value you can use for <code>type</code> is either <code>Minim.MONO</code> or <code>Minim.STEREO</code>.
  * <code>bufferSize</code> specifies how large you want the sample buffer to be, <code>sampleRate</code> specifies
  * the sample rate you want to monitor at, and <code>bitDepth</code> specifies what bit depth you want to monitor at.
  * <code>type</code> defaults to <code>Minim.STEREO</code>, <code>bufferSize</code> defaults to 1024,
  * <code>sampleRate</code> defaults to 44100, and <code>bitDepth</code> defaults to 16. If an <code>AudioInput</code>
  * cannot be created with the properties you request, <code>Minim</code> will report an error and return <code>null</code>.
  * <p>
  * When you run your sketch as an applet you will need to sign it in order to get an input.
  * <p>
  * Before you exit your sketch make sure you call the <code>close</code> method of any <code>AudioInput</code>'s
  * you have received from <code>getLineIn</code>.
  */
 
import ddf.minim.*;
 
Minim minim;
AudioInput in;
 
void setup()
{
  size(512, 200, P3D);
 
  minim = new Minim(this);
  minim.debugOn();
 
  // get a line in from Minim, default bit depth is 16
  in = minim.getLineIn(Minim.STEREO, 512);
}
 
void draw()
{
  background(0);
  stroke(255);
  // draw the waveforms
  for(int i = 0; i < in.bufferSize() - 1; i++)
  {
    line(i, 50 + in.left.get(i)*50, i+1, 50 + in.left.get(i+1)*50);
    line(i, 150 + in.right.get(i)*50, i+1, 150 + in.right.get(i+1)*50);
  }
}
 
 
void stop()
{
  // always close Minim audio classes when you are done with them
  in.close();
  minim.stop();
 
  super.stop();
}

int num = 50;
Node n[];

Recorder r;
boolean record = false;


void setup(){
	size(320,240,P3D);
	background(255);

	n = new Node[num];
	for(int i = 0;i<num;i++)
		n[i] = new Node(i);

	rectMode(CENTER);

	if(record){
		r = new Recorder("out","netCon.avi");
	}




}


void draw(){
	background(255);

	stroke(0);
	noFill();
	for(int i = 0;i<n.length;i++){
		if(n[i].alive)
		n[i].run();
		}

	if(record)
		r.add();

}

void destroy(int _id){
	Node[] pre;
	if(_id<1){
	pre = new Node[1];
	pre[0] = n[0];
	}else{
	pre = (Node[])subset(n,0,_id);
	}
	Node[] post = (Node[])subset(n,_id,n.length-pre.length);

	for(int i =1;i<post.length;i++){
		pre = (Node [])append(pre,post[i]);
	}

	n=pre;

}

void keyPressed(){
	if(key=='q'){
		if(record)
			r.finish();
		exit();
	}

}



class Node{

	float x,y,dx,dy;
	int id;
	float tresh = 40.0;
	int neighs[];
	boolean alive = true;

	Node(int _id){
		id=_id;
		dx=x=random(width);
		dy=y=random(height);
	}

	void run(){
		compute();
		draw();
	}

	void compute(){

		neighs = new int[0];

		for(int i = 0;i<num;i++){
			if(i!=id&&n[i].alive){
//				
				
				if(dist(n[i].dx,n[i].dy,dx,dy)<1){
				alive=false;
					//destroy(id);
				/*
				if(random(1000)>500){
						x-=10;
					}else{
						x+=10;
					}
					
					if(random(1000)>500){
						y-=10;
					}else{
						y+=10;
					}*/
				//y=random(height);
				}else if(dist(n[i].x,n[i].y,x,y)<tresh/1.5){
				x-=(n[i].x-x)/(tresh/5.0);
				y-=(n[i].y-y)/(tresh/5.0);
			}else if(dist(n[i].x,n[i].y,x,y)<tresh){
				neighs = (int[])expand(neighs,neighs.length+1);
				neighs[neighs.length-1] = i;

				x+=(n[i].x-x)/tresh;
				y+=(n[i].y-y)/tresh;
			}

			}
		}


		x=constrain(x,0,width);
		y=constrain(y,0,height);

		dx+=(x-dx)/20.0;
		dy+=(y-dy)/20.0;
	}



	void draw(){
		stroke(0,45);
		rect(dx,dy,3,3);

		stroke(0,10);
		for(int i = 0 ;i<neighs.length;i++){
			line(n[neighs[i]].dx,n[neighs[i]].dy,dx,dy);

		}


	}



}
class Recorder{
  String dir,name;
  int cntr = 0;

  Recorder(String _dir,String _name){
    dir = _dir;
    name=_name;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="6000000";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" msmpeg4v2 "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }



}
import traer.physics.*;

int num = 750;
Particle q[];

Particle mouse,mouse2;
ParticleSystem physics;

Recorder r;

color cols[] = new color[3];


float anim = 1;
int interval = 80;
int counter = 0;
float pos[][] = new float [num][2];
int cycle[] =new int[num];

float rot = 0;

void setup()
{
	size( 1280/2,720/2 ,P3D);
	//frameRate( 24 );
	//smooth();
	rectMode( CENTER );
	noStroke();
	cursor(CROSS);

	
	
	cols[0] = color(#000000);
	cols[1] = color(#ffffff);
	cols[2] = color(#431c00);

	
	physics = new ParticleSystem( 0, 0.001 );
	mouse = physics.makeParticle();
	mouse.makeFixed();
	
	mouse2 = physics.makeParticle();
	mouse2.makeFixed();
	
	mouse.moveTo( width/2,height/2.0,10 );

	r = new Recorder("out","phy4.mp4");

	q = new Particle[num];

	for(int i =0;i<q.length;i++){
		
		
		q[i] = physics.makeParticle(1.1,map(i,0,q.length-1,10,width-10), height-1,random(10)/* random(150)*/ );
		physics.makeAttraction( mouse, q[i], 100000, 1000 );
		physics.makeAttraction( mouse2, q[i], -1000, 1000 );
		q[i].setVelocity(anim,0,0);
		
		pos[i][0] = q[i].position().x();
		pos[i][1] = q[i].position().y();
		
		cycle[i] = (int)random(10000);
	}

	
	/*
		for(int i =0;i<q.length;i++){
			for(int j =0;j<q.length;j++){
				if(i!=j){
				physics.makeAttraction( q[i], q[j], -0.1, 10 );
				
				}
			}
		}
	*/
	
	background(cols[0]);


}

void draw(){
	
	counter++;
	mouse.moveTo( sin(counter/3.0)*width/5+width/2, cos(counter/10.0)*height/5+height/2 , 12 );
	mouse2.moveTo( cos(counter/3.0)*width/5+width/2, sin(counter/10.0)*height/5+height/2 , 10 );
	for(int j =0;j<q.length;j++){
		handleBoundaryCollisions( q[j] );
	}
	physics.tick(8);

	//background( 255 );

	fill( 255, 0, 0 );
	//ellipse( mouse.position().x(), mouse.position().y(), 35, 35 );
	
	fill( 0,15 );
	if(frameCount>2)
	for(int j =0;j<q.length;j++){
		float adda = 1;
		//if(j<30) //||j>q.length-30
		cycle[j]++;
			adda = ((sin(cycle[j]/2030.0)+1.0)/2.0)*10.0;
		
		stroke( lerpColor(cols[2],cols[1],constrain((PI+atan2(q[j].position().y()+sin(atan2(q[j].position().y()-pos[j][1],q[j].position().x()-pos[j][0])*30.0)*20.0 - pos[j][1] ,q[j].position().x()+cos(atan2(q[j].position().y()-pos[j][1],q[j].position().x()-pos[j][0])*30.0)*20.0 - pos[j][0]))/TWO_PI,0,1) ),/*(norm(q[j].velocity().x(),-8,8)*3.0+adda)*map(q[j].position().z(),-1,50,2.0,0.0000001)*/(interval-counter)/(interval+0.0)*15 );
		//line( q[j].position().x()+sin(j/3000.0)*10.0, q[j].position().y(), pos[j][0]+sin(j/30.0)*10.0, pos[j][1] );
		//println(atan2(	q[j].position().y()+sin(atan2(q[j].position().y()-pos[j][1],q[j].position().x()-pos[j][0])*30.0)*20.0 - pos[j][1] ,q[j].position().x()+cos(atan2(q[j].position().y()-pos[j][1],q[j].position().x()-pos[j][0])*30.0)*20.0 - pos[j][0]));
		
		line( q[j].position().x()+cos(atan2(q[j].position().y()-pos[j][1],q[j].position().x()-pos[j][0])*30.0)*20.0, q[j].position().y()+sin(atan2(q[j].position().y()-pos[j][1],q[j].position().x()-pos[j][0])*30.0)*20.0, pos[j][0], pos[j][1] );
		
		pos[j][0] = q[j].position().x();
		pos[j][1] = q[j].position().y();
		//pos[j][2] = q[j].position().z();
	}
	
	if(counter>interval){
		reset();
	}

	if(frameCount>4975){
		exit();
	}
	
	
}

void reset(){

	
	anim+=0.005;
	for(int i =0;i<q.length;i++){
		q[i].moveTo(map(i,0,q.length-1,10,width-10), height-1,random(10)/* random(150)*/ );
		q[i].setVelocity(anim,0,0);
		
		pos[i][0] = q[i].position().x();
		pos[i][1] = q[i].position().y();
		//pos[i][2] = q[i].position().z();

	}

	counter = 0;
	
	if(frameCount>1)
	r.add();
	filter(BLUR,0.81);
	fill(cols[0],50);
	rect(width/2,height/2,width,height);
	//box(width/2);
	//background(255);

}

void keyPressed(){
	if(key=='q'){
		r.finish();
		exit();
	}

}

// really basic collision strategy:
// sides of the window are walls
// if it hits a wall pull it outside the wall and flip the direction of the velocity
// the collisions aren't perfect so we take them down a notch too
void handleBoundaryCollisions( Particle p )
{
	if ( p.position().x() < 0 || p.position().x() > width )
		p.setVelocity( -0.9*p.velocity().x(), p.velocity().y(), 0 );
	if ( p.position().y() < 0 || p.position().y() > height )
		p.setVelocity( p.velocity().x(), -0.9*p.velocity().y(), 0 );
	if ( p.position().z() < 0 || p.position().z() > width )
		p.setVelocity( p.velocity().x(), p.velocity().y(), -0.9*p.velocity().z() );
	
	p.moveTo( constrain( p.position().x(), 0, width ), constrain( p.position().y(), 0, height ), constrain( p.position().z(), 0, width ));
}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import processing.serial.*;


Serial port;

void setup(){
	size(200,100,P3D);
	background(0);

	// List all the available serial ports:
	println(Serial.list());
	println("done!");
	
	if(Serial.list().length<1){
		println("error: Arduino not listed");
	exit();
	
	}else{
	
	/*  I know that the first port in the serial list on my mac
	is always my  Keyspan adaptor, so I open Serial.list()[0].
	Open whatever port is the one you're using.
	*/
	
	port = new Serial(this,Serial.list()[0],9600);
	textFont(createFont("Veranda",9));
	textMode(SCREEN);
	// Send a capital A out the serial port:
	port.write(65);
}
	fill(255);
	


}

byte val[];
int in = 0;

void draw(){
	fill(0);
	noStroke();
	rect(0,0,width,20);
	fill(255);
	
	stroke(255);
	point(frameCount%width,map(in,10,70,0,100));
	fill(255);
	text(in,10,10);
	
	if(port.available()>-1){
				
		int ina = port.read();
		if (ina>-1)
			in+=(ina-in)/5.0;
		//println(ina);
		port.clear();
		//println(in);
	}
	
	if(frameCount%width==0)
		background(0);
	
	

}    

import processing.opengl.*;

import oscP5.*;//import the OSC library
import netP5.*;

import blobDetection.*;



BlobDetection theBlobDetection;
Blob b[] = new Blob[0];


PFont font;
PImage source;
OSC osc;
//Senzor[] senzors;

boolean bang = false;

boolean overs[], overs2[];

float vibrant,vibt;
float[] vibs;

int[][] splits = new int[0][];
float [][] widths;// = new float[0][2];
float [][] heights;

int cas = 0;

void setup(){

	source = loadImage("partitionblack2.jpg");
	//source.loadPixels();

	size(source.width,source.height,OPENGL);

	//senzors = new Senzor[source.height];

	//for(int i = 0;i < senzors.length;i++){
	//	senzors[i] = new Senzor(i,i);
	//}

	vibs = new float[width];
	for(int i = 0;i<width;i++){
		vibs[i] = 0.0;
	}
	vibrant= vibt = height;

	noSmooth();

	font = createFont("Arial",9);
	textFont(font);
	//textMode(SCREEN);

	// blobl detection
	theBlobDetection = new BlobDetection(source.width, source.height);
	theBlobDetection.setPosDiscrimination(false);
	theBlobDetection.setThreshold(0.1f);
	theBlobDetection.computeBlobs(source.pixels);

	int g = 0;
	for (int n=0 ; n<theBlobDetection.getBlobNb() ; n++){
		if(b!=null){
			b= (Blob[])expand(b,b.length+1);
			//b[b.length-1] = new Blob();
			b[b.length-1] = theBlobDetection.getBlob(n);
			g++;

			println("no.: "+g+" has "+b[b.length-1].getEdgeNb()+"edges");
		}
	}


	overs  = new boolean[g];
	overs2  = new boolean[g];
	
	fillWidths();

	println("found "+g+" shapes");

	osc = new OSC("127.0.0.1",12000);
	osc.send(-1,1.0);
	frameRate(24);
}


void draw(){

	image (source,0,0,width,height);

	
	
	
	/*
	for(int i = 0;i < senzors.length;i++){
		senzors[i].run();
	}


	stroke(#FF0000,5);
	for(int i = 0;i < splits.length;i++){
		line(splits[i][0],0,splits[i][0],height);
		//line(splits[i][0],0,splits[i][0],height);
		}

	//rect(senzors[0].cas,vibt,3,3);
	//vibs[(int)senzors[0].cas] = vibrant;

	//vibrant+=(vibt-vibrant)/20.0;

	//stroke(#333333);
	//noStroke();
	stroke(#aa0000,160);

	pushStyle();
	strokeWeight(1);
	for(int i =1;i<vibs.length;i++){
		line(i,vibs[i],i,vibs[i-1]);
	}
	popStyle();

	//osc.send(0,vibs[0]);

*/	
	
	
	drawBlobsAndEdges(false,true);
	
	if(frameCount>1)
	for(int i = 0;i<overs.length;i++){
		if(overs[i]&&!overs2[i]){
			//println("bang "+i+" , "+map(0.5*(heights[i][0]+heights[i][1]),height,0,0.22,0.8)+" , "+map((widths[i][1]-widths[i][0]),0,100,0,1));
			osc.send(i,map(0.5*(heights[i][0]+heights[i][1]),height,0,0.22,0.8),map((widths[i][1]-widths[i][0]),0,100,0,1));
		}

	}
	
	for(int i =0 ;i<overs.length;i++)
	overs2[i] = overs[i];
		
	stroke(0);                                   
	line(cas,0,cas,height);
	cas +=4;
	if(cas>width)
		cas=0;
}

void genSplit(int _id){
	splits = (int[][])expand(splits,splits.length+1);
	splits[splits.length-1] = new int[2];
	splits[splits.length-1][0] = cas;
	splits[splits.length-1][1] = _id;


}

void keyPressed(){
	if(key==ENTER){
		save("out.png");
	}
}

void stop(){
	osc.send(-1,0.0);
	osc.osc.stop();
	super.stop();


}

float[] getBlobWidths(Blob _b){
	EdgeVertex A;
	float mina =width,maxa=0;

	for (int m=0;m<_b.getEdgeNb();m++)	{
		A = _b.getEdgeVertexA(m);

		if(A!=null){
			if(mina>A.x*width)
				mina = A.x*width;

			if(maxa<A.x*width)
				maxa = A.x*width;
		}
	}

	float a[] = {mina,maxa};
	return a;
}

float[] getBlobHeights(Blob _b){
	EdgeVertex A;
	float mina =width,maxa=0;

	for (int m=0;m<_b.getEdgeNb();m++)	{
		A = _b.getEdgeVertexA(m);

		if(A!=null){
			if(mina>A.y*height)
				mina = A.y*height;

			if(maxa<A.y*height)
				maxa = A.y*height;
		}
	}

	float a[] = {mina,maxa};
	return a;
}

void fillWidths(){
	widths = new float[b.length][2];
	heights = new float[b.length][2];

	for(int i = 0;i<b.length;i++){

		widths[i][0] = getBlobWidths(b[i])[0];
		widths[i][1] = getBlobWidths(b[i])[1];

		heights[i][0] = getBlobHeights(b[i])[0];
		heights[i][1] = getBlobHeights(b[i])[1];
	}
}

boolean over(int _id){
	boolean answr = false;
	overs[_id] = false;
	
	if(cas>widths[_id][0]&&cas<widths[_id][1]){
		answr = true;
		overs[_id] = true;
	}

	return answr;
}

void drawBlobsAndEdges(boolean drawBlobs, boolean drawEdges)
{
	pushStyle();
	noFill();
	rectMode(CENTER);

	//Blob bb;
	EdgeVertex eA,eB;
	for (int n=0 ; n<b.length ; n++)	{
		//bb=b[n];
		// Edges
		if (drawEdges){
			strokeWeight(3);
			stroke(255,0,0,180);
			if(over(n)){
				//rect(0.5*(widths[n][0]+widths[n][1]),0.5*(heights[n][0]+heights[n][1]),10,10);
				text(n,0.5*(widths[n][0]+widths[n][1]),0.5*(heights[n][0]+heights[n][1]));
				for (int m=0;m<b[n].getEdgeNb();m++){


					eA = b[n].getEdgeVertexA(m);
					eB = b[n].getEdgeVertexB(m);
					if (eA !=null && eB !=null){
						line(
						        eA.x*width, eA.y*height,
						        eB.x*width, eB.y*height
						);

					}
				}
			}
		}

		// Blobs
		if (drawBlobs){
			strokeWeight(1);
			stroke(255,0,0);
			rect(
			        b[n].xMin*width,b[n].yMin*height,
			        b[n].w*width,b[n].h*height
			);
		}

	}

	popStyle();


}

class OSC{
	OscP5 osc;
	NetAddress addr;
	int port;

	OSC(String _addr,int _port){
		port=_port;
		osc = new OscP5(this,_port-1);
		addr = new NetAddress(_addr,port);
	}

	void send(int _ident,float _whatX,float _whatY){
		OscMessage message = new OscMessage("/msg");
		String ident = (char)(_ident+65)+"";
		message.add(ident);
		//message.add("x ");
		message.add(_whatX);
		//message.add("y ");
		message.add(_whatY);
		osc.send(message, addr);
	}

	void send(int _ident,float _whatX,float _whatY,float _whatZ){
		OscMessage message = new OscMessage("/msg");
		String ident = (char)(_ident+65)+"";
		//message.add(ident);
		//message.add("x ");
		message.add(_whatX);
		//message.add("y ");
		message.add(_whatY);
		message.add(_whatZ);
		osc.send(message, addr);
	}


	void send(int _ident,float _what){
		OscMessage message = new OscMessage("/msg");
		String ident = (char)(_ident+65)+"";
		message.add(ident);
		message.add(_what);
		osc.send(message, addr);
	}

}

/*
class Senzor{
	float cas;
	float y;
	int id;
	int[] val;
	int lastval = 0;
	int runs = 0;
	int citlivost = 10;

	Senzor(int _id,float _y){
		y = _y;
		id = _id;
		cas = 0;
		val = new int[source.width];
		for(int i =0;i<source.width;i++){
			val[i] = (int)getVal(i);

		}
	}

	void run(){
		compute();
		draw();

	}

	void compute(){
		lastval = val[(int)cas];
		tick(5);
		if(runs==0){
			if(abs(val[(int)cas]-lastval)>citlivost){
				//if(val[(int)cas]<200){
				//println(id);
				genSplit(id);
			}
		}

		if(abs(val[(int)cas]-lastval)>citlivost)
			bang = true;


		if(abs(val[(int)cas])<10){
			vibt+=(y-vibt)/(senzors.length+0.0);
		}

	}

	void tick(float w){
		cas+=w;
		if(cas>=width){
			cas=0;
			runs++;
		}

	}

	void draw(){
		stroke(255-val[(int)cas]);
		line(cas,y,cas+1,y);
	}

	float getVal(int _x){
		return brightness(source.pixels[(int)y*source.width+_x]);
	}
}

*/
class Sampler
{
	int timer = 0;
	int durat = 120;
	float locvol = 0.1;

	boolean[] pressed = new boolean[kdown.length];
	boolean[] pressed2= new boolean[kdown.length];
	boolean[] ons = new boolean[kdown.length];

	boolean map[][] = new boolean[durat][kdown.length];

	Synth[] s = new Synth[6];
	boolean recording,playing;

	Sampler()
	{
		recording = true;

		for(int i = 0;i<s.length;i++){
			ons[i] = false;
			s[i] = new Synth("sine");
			s[i].set("freq", freqs[i]);
			s[i].set("amp", 0);
			s[i].create();
		}
	}

	void run(){
		if(recording){
			for(int i =0;i<kdown.length;i++){
				pressed[i] = kdown[i];

				//on note
				if(pressed[i]&&!pressed2[i]){
					map[timer][i] = true;
					//ons[i] = true;
				}

				//off note
				if(pressed2[i]&&!pressed[i]){
					map[timer][i] = true;
					//ons[i] = false;
				}
			}

			for(int i =0;i<kdown.length;i++){
				pressed2[i]=pressed[i];
			}

			timer ++;
			if(timer==durat){
				timer = 0;
				recording = false;
				playing = true;
				println("sampled "+durat+" frames");

			}
		}

		if(playing){
			for(int i =0;i<s.length;i++){
				if(!ons[i]&&map[timer][i]){
					s[i].set("amp", locvol); ons[i] = true;
				}else if(ons[i]&&map[timer][i]){
					s[i].set("amp", 0); ons[i] = false;
				}



			}

			timer++;

			if(timer>=durat){
				timer = 0;
				flush();
			}



		}
		
		if(!recording&&!playing){
			timer++;
			if(timer>=durat){
				timer = 0;
				}
		}

	}
	
	void flush(){
	for(int i =0;i<s.length;i++){
					s[i].set("amp", 0); ons[i] = false;
				}
	
	}

	void free(){
		for(int i = 0;i<s.length;i++){
			s[i].free();
		}
	}








}
import supercollider.*;

Synth synth[] = new Synth[6];
char [] chars = {'q','w','e','i','o','p'};
float [] freqs = {261.6,293.7,329.6,349.2,392,440,393.9};
boolean kdown[] = new boolean[6];

Sampler[] samp = new Sampler[0];

float vol = 1;
void setup ()
{
	size(300, 200,P3D);
	frameRate(30);

	// uses default sc server at 127.0.0.1:57110
	// does NOT create synth!
	for(int i = 0;i<synth.length;i++){
		kdown[i] = false;
		synth[i] = new Synth("midisynth1");
		synth[i].set("freq", freqs[i]);
		//synth[i].set("amp", 1);
		//synth[i].set("dur", 1);
		synth[i].set("gate",0);
		synth[i].set("filter",0);
		synth[i].set("vibrato",20);
		
		//synth[i].set("dur", 4);
		
		synth[i].create();
	}

	textFont(createFont("Arial",9));
	textMode(SCREEN);

	fill(255);
	noStroke();
	//synth[1] = new Synth("sprinkler");
	// 261.6,293.7,329.6,349.2,392,440,393.9

	// set initial arguments
	//synth.set("amp", 0.5);
	//var clockRate, clockTime, clock, centerFreq, freq, panPos, patch;
	//synth[0].set("amp", 0.5);

	//synth[1].set("freq", 80);

	// create synth
	//synth[0].create();
	//synth[1].create();
}

float pos = 0;

void draw ()
{
	background(0);
	//stroke(255);

	for(int i = 0;i<synth.length;i++){
		if(kdown[i]){
			fill(255);
		}else{
			fill(255,45);
		}

		rect(i*(width/(synth.length+0.0))+20,10,10,10);
		text(chars[i],i*(width/(synth.length+0.0))+23,30);
	}

	
	for(int i = 0;i<samp.length;i++){
		if(samp[i]!=null){
			samp[i].run();
			if(samp[i].recording){
				fill(255,15,12);
			}else if(samp[i].playing){
				fill(15,255,12);
			}
			
			rect(i*20+20,40,10,10);
			if(mousePressed){
				if(!samp[i].recording&&mouseX>=i*20+20&&mouseX<=i*20+20+10&&mouseY>=40&&mouseY<=50){
					samp[i].playing = !samp[i].playing;
					samp[i].flush();
					mousePressed=false;
					}
					
			}
		}
		
	}
	

}

void keyPressed ()
{

	if (key == chars[0])
	{synth[0].set("gate", vol); kdown[0] = true;}

	if (key == chars[1])
	{synth[1].set("gate", vol); kdown[1] = true;}

	if (key == chars[2])
	{synth[2].set("gate", vol); kdown[2] = true;}

	if (key == chars[3])
	{synth[3].set("gate", vol); kdown[3] = true;}

	if (key == chars[4])
	{synth[4].set("gate", vol); kdown[4] = true;}

	if (key == chars[5])
	{synth[5].set("gate", vol); kdown[5] = true;}

	if(key == ' ')addSynth();


}

void addSynth(){
	samp=(Sampler[])expand(samp,samp.length+1);
	samp[samp.length-1] = new Sampler();	
}


void keyReleased (){
	if (key == chars[0])
	{synth[0].set("gate", 0); kdown[0] = false;}

	if (key == chars[1])
	{synth[1].set("gate", 0); kdown[1] = false;}

	if (key == chars[2])
	{synth[2].set("gate", 0); kdown[2] = false;}

	if (key == chars[3])
	{synth[3].set("gate", 0); kdown[3] = false;}

	if (key == chars[4])
	{synth[4].set("gate", 0); kdown[4] = false;}

	if (key == chars[5])
	{synth[5].set("gate", 0); kdown[5] = false;}
}

void stop ()
{
	for(int i = 0;i<synth.length;i++){
		synth[i].free();
	}
	
	for(int i =0;i<samp.length;i++)
		samp[i].free();
	//synth[1].free();
}


import processing.opengl.*;
import codeanticode.glgraphics.*;
 
GLTexture srcTex, bloomMask, destTex;
GLTexture tex0, tex2, tex4, tex8, tex16;
GLTextureFilter extractBloom, blur, blend4, tonemap;
GLTextureParameters floatTexParams;
GLTextureFilterParameters bloomParam, toneParam;
GLGraphics glg1;
 
void setup() {
  size(800, 600, GLConstants.GLGRAPHICS);
 
  // Loading required filters.
  extractBloom = new GLTextureFilter(this, "ExtractBloom.xml");
  blur = new GLTextureFilter(this, "Blur.xml");
  blend4 = new GLTextureFilter(this, "Blend4.xml", 4);  
  tonemap = new GLTextureFilter(this, "ToneMap.xml", 2);
 
  bloomParam = new GLTextureFilterParameters(this);
  bloomParam.parFlt1 = 0.99; // bright threshold;  
  toneParam = new GLTextureFilterParameters(this);
  toneParam.parFlt1 = 0.86; // exposure;
  toneParam.parFlt2 = 0.5;  // bloom factor;
  toneParam.parFlt3 = 0.9;  // bright threshold;  
 
  glg1 = new GLGraphics(width, height, this, true);
  srcTex = glg1.getTexture();
  int w = srcTex.width;
  int h = srcTex.height;
  destTex = new GLTexture(this, w, h);
 
  // Initializing bloom mask and blur textures.
  floatTexParams = new GLTextureParameters();
  floatTexParams.format = GLTexture.FLOAT4;
  floatTexParams.minFilter = GLTexture.LINEAR;
  floatTexParams.magFilter = GLTexture.LINEAR;    
 
  bloomMask = new GLTexture(this, w, h, floatTexParams);
  tex0 = new GLTexture(this, w, h, floatTexParams);
  tex2 = new GLTexture(this, w / 2, h / 2, floatTexParams);
  tex4 = new GLTexture(this, w / 4, h / 4, floatTexParams);
  tex8 = new GLTexture(this, w / 8, h / 8, floatTexParams);
  tex16 = new GLTexture(this, w / 16, h / 16, floatTexParams);    
 
  srcTex.setFlippedY(true);  
  bloomMask.setFlippedY(true);  
  destTex.setFlippedY(true);  
  tex0.setFlippedY(true);  
  tex2.setFlippedY(true);      
  tex4.setFlippedY(true);      
  tex8.setFlippedY(true);  
  tex16.setFlippedY(true);
}
 
void draw() {
  glg1.beginDraw();
  glg1.stroke(255);
  glg1.background(0);    
  glg1.fill(255, 0, 0);
  glg1.rect(30, 30, 300, 200);
  glg1.stroke(0,255, 0);    
  glg1.line(0, 0, mouseX, mouseY);
  glg1.endDraw();  
 
  float fx = float(mouseX) / width;
  float fy = float(mouseY) / height;
 
  bloomParam.parFlt1 = fx;
  toneParam.parFlt1 = fy;    
  toneParam.parFlt3 = fx;
 
  // Extracting the bright regions from input texture.
  srcTex.filter(extractBloom, tex0, bloomParam);
 
  // Downsampling with blur.
  tex0.filter(blur, tex2);
  tex2.filter(blur, tex4);    
  tex4.filter(blur, tex8);    
  tex8.filter(blur, tex16);      
 
  // Blending downsampled textures.
  blend4.apply(new GLTexture[]{tex2, tex4, tex8, tex16  }, new GLTexture[]{ bloomMask });
 
  // Final tone mapping into destination texture.
  tonemap.apply(new GLTexture[]{srcTex, bloomMask  }, new GLTexture[]{destTex  }, toneParam);
 
  image(destTex, 0, 0, width, height);
} 
//import hardcorepawn.opengl.*;
import processing.opengl.*;
import java.nio.*;
import javax.media.opengl.*;
import javax.media.opengl.glu.*;
import com.sun.opengl.util.*;

PImage tex0,tex1,nulltex;
float a,b;

GL gl;
GLU glu;
GLSL glsl;
int[] tex;
int[] shaderimgloc;

int tangentLoc;
int binormalLoc;
int uir;
int cbs;

void setup()
{
	size(800,600,OPENGL);//"hardcorepawn.opengl.HCPGL");
	//size(800,600,OPENGL);
	gl=((PGraphicsOpenGL)g).gl;
	glu=((PGraphicsOpenGL)g).glu;
	gl.glEnable(GL.GL_CULL_FACE);
	gl.glCullFace(GL.GL_FRONT);

	tex0=loadImage("img.png");
	tex1=loadImage("img.png");
	nulltex=loadImage("img2.png");
	perspective(PI/3.0,4.0/3.0,1,1000);
	camera(0,0,-800,0,0,1,0,1,0);
	tex=new int[2];
	gl.glGenTextures(2,tex,0);
	gl.glBindTexture(GL.GL_TEXTURE_2D,tex[0]);
	gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, 4,tex0.width, tex0.height,
	                0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE,
	                IntBuffer.wrap(tex0.pixels));
	gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);	// Linear Filtering
	gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);	// Linear Filtering
	gl.glBindTexture(GL.GL_TEXTURE_2D,tex[1]);
	gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, 4,tex1.width, tex1.height,
	                0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE,
	                IntBuffer.wrap(tex1.pixels));
	gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);	// Linear Filtering
	gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);	// Linear Filtering
	glsl=new GLSL();
	//  glsl.loadVertexShader("textureSimple.vert");
	//  glsl.loadFragmentShader("textureSimple.frag");
	glsl.loadVertexShader("shiny.vert");
	glsl.loadFragmentShader("shiny.frag");
	glsl.useShaders();
	shaderimgloc=new int[2];
	//  shaderimgloc[0]=glsl.getUniformLocation("Tex");
	shaderimgloc[0]=glsl.getUniformLocation("Base");
	shaderimgloc[1]=glsl.getUniformLocation("NormalHeight");
	tangentLoc=glsl.getAttribLocation("tangent");
	binormalLoc=glsl.getAttribLocation("binormal");
	uir=glsl.getUniformLocation("u_invRad");
	cbs=glsl.getUniformLocation("cBumpSize");
	a=0;
	b=0;
	//  printCamera();
	textureMode(NORMALIZED);
	gl.glEnable(GL.GL_LIGHTING);
}

void draw()
{
	float mx=(mouseX-width/2.0)/(width/2.0);
	float my=(mouseY-height/2.0)/(height/2.0);
	a+=0.003;
	b+=0.00063;
	//  pointLight(255,255,255,0,0,-400);
	//  camera(0,0,-400,0,0,0,0,1,0);
	//  glu.gluLookAt(0,0,400,0,0,0,0,1,0);
	//  glu.
	background(50,0,0);
	glsl.startShader();
	fill(255,255,255);
	//  specular(0,0,0);
	ambient(250,250,250);
	//  shininess(2.0);
	gl.glActiveTexture(GL.GL_TEXTURE0+2);
	gl.glBindTexture(GL.GL_TEXTURE_2D, tex[0]);
	gl.glActiveTexture(GL.GL_TEXTURE0+1);
	gl.glBindTexture(GL.GL_TEXTURE_2D, tex[1]);

	gl.glUniform1i(shaderimgloc[0],2);
	gl.glUniform1i(shaderimgloc[1],1);
	gl.glVertexAttrib3f(tangentLoc,-1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	//  pointLight(220,220,250,40,0,-400);
	camera(400*sin(mx),0,-400*cos(mx),0,0,0,0,1,0);
	perspective(PI/3.0,4.0/3.0,1,1000);

	pointLight(255,255,255,0,0,-100);
	((PGraphicsOpenGL)g).beginGL();
	gl.glPushMatrix();
	rotateY(a);
	//  gl.glRotatef(360*a,0,1,0);

	gl.glBegin(GL.GL_QUADS);
	gl.glNormal3f(0,0,-1);
	gl.glVertexAttrib3f(tangentLoc,1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(-100,100,-100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(-100,-100,-100);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(100,-100,-100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(100,100,-100);
	//  gl.glEnd();
	//  gl.glBegin(GL.GL_QUADS);
	gl.glNormal3f(1,0,0);
	gl.glVertexAttrib3f(tangentLoc,0,0,1);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(100,-100,100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(100,100,100);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(100,100,-100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(100,-100,-100);

	gl.glNormal3f(0,0,1);
	gl.glVertexAttrib3f(tangentLoc,-1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(-100,-100,100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(-100,100,100);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(100,100,100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(100,-100,100);

	gl.glNormal3f(-1,0,0);
	gl.glVertexAttrib3f(tangentLoc,0,0,-1);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(-100,100,100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(-100,-100,100);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(-100,-100,-100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(-100,100,-100);

	gl.glNormal3f(0,1,0);
	gl.glVertexAttrib3f(tangentLoc,1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,0,-1);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(100,100,100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(-100,100,100);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(-100,100,-100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(100,100,-100);

	gl.glNormal3f(0,-1,0);
	gl.glVertexAttrib3f(tangentLoc,1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,0,-1);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(-100,-100,100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(100,-100,100);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(100,-100,-100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(-100,-100,-100);

	gl.glEnd();
	gl.glPopMatrix();
	/*  gl.glBegin(GL.GL_QUADSS);
	  gl.glVertexAttrib3f(tangentLoc,1,0,0);
	  gl.glVertexAttrib3f(binormalLoc,0,1,0);
	  gl.glNormal3f(0,0,-1);
	  gl.glTexCoord2f(1,0);
	  gl.glVertex3f(100,100,-100);
	  gl.glTexCoord2f(0,0);
	  gl.glVertex3f(-100,100,-100);
	  gl.glTexCoord2f(0,1);
	  gl.glVertex3f(-100,-100,-100);
	  gl.glTexCoord2f(1,1);
	  gl.glVertex3f(100,-100,-100);
	  gl.glEnd();*/



	glsl.endShader();
	((PGraphicsOpenGL)g).endGL();
}

class GLSL
{
  int programObject;
  GL gl;
  boolean vertexShaderEnabled;
  boolean vertexShaderSupported; 
  int vs;
  int fs;
  
  GLSL()
  {
    gl=((PGraphicsOpenGL)g).gl;
    String extensions = gl.glGetString(GL.GL_EXTENSIONS);
    vertexShaderSupported = extensions.indexOf("GL_ARB_vertex_shader") != -1;
    vertexShaderEnabled = true;    
    programObject = gl.glCreateProgramObjectARB(); 
    vs=-1;
    fs=-1;
  }
  
  void loadVertexShader(String file)
  {
    String shaderSource=join(loadStrings(file),"\n");
    vs = gl.glCreateShaderObjectARB(GL.GL_VERTEX_SHADER_ARB);
    gl.glShaderSourceARB(vs, 1, new String[]{shaderSource},(int[]) null, 0);
    gl.glCompileShaderARB(vs);
    checkLogInfo(gl, vs);
    gl.glAttachObjectARB(programObject, vs); 
  }

  void loadFragmentShader(String file)
  {
    String shaderSource=join(loadStrings(file),"\n");
    fs = gl.glCreateShaderObjectARB(GL.GL_FRAGMENT_SHADER_ARB);
    gl.glShaderSourceARB(fs, 1, new String[]{shaderSource},(int[]) null, 0);
    gl.glCompileShaderARB(fs);
    checkLogInfo(gl, fs);
    gl.glAttachObjectARB(programObject, fs); 
  }

  int getAttribLocation(String name)
  {
    return(gl.glGetAttribLocationARB(programObject,name));
  }
  
  int getUniformLocation(String name)
  {
    return(gl.glGetUniformLocationARB(programObject,name));
  }
    
  void useShaders()
  {
    gl.glLinkProgramARB(programObject);
    gl.glValidateProgramARB(programObject);
    checkLogInfo(gl, programObject);
  }
  
  void startShader()
  {
    gl.glUseProgramObjectARB(programObject); 
  }
  
  void endShader()
  {
    gl.glUseProgramObjectARB(0); 
  }
  
  void checkLogInfo(GL gl, int obj)  
  {
    IntBuffer iVal = BufferUtil.newIntBuffer(1);
    gl.glGetObjectParameterivARB(obj, GL.GL_OBJECT_INFO_LOG_LENGTH_ARB, iVal);
 
    int length = iVal.get();
    if (length <= 1)  
    {
      return;
    }
    ByteBuffer infoLog = BufferUtil.newByteBuffer(length);
    iVal.flip();
    gl.glGetInfoLogARB(obj, length, iVal, infoLog);
    byte[] infoBytes = new byte[length];
    infoLog.get(infoBytes);
    println("GLSL Validation >> " + new String(infoBytes));
  } 
}

import processing.opengl.*;

float factor = 100;

void setup(){
	size(600,400,OPENGL);
	background(255);

	camera(width/2,height/2,-100,width/2,height/2,0,0,1,0);

	noFill();
	stroke(0,25);
	//ortho(-width, width, -height, height, -50, 50);
	//ortho(0, width, 0, height, -10, 10);
	//ortho(-width/2, width/2, -height/2, height/2, -10, 10);
	//smooth();
	noSmooth();
}


void draw(){
	background(255);

	//ortho(-width/2, width/2, -height/2, height/2, -10, 10);

	
	
	//frustum(-width/2, width/2, -height/2, height/2, -1000, 20.0);

	pushMatrix();
	

	camera(sin(frameCount/302.0)*width/2+width/2,sin(frameCount/3000.3)*height/2+height/2,-100,width/2,height/2,0,0,1,0);
	


	
	//lights();

	pushMatrix();


	translate(width/2, height/2, 0);
	for(int i = 0;i<50;i+=1){
	rotateY(radians(i+frameCount/40.0));
	rotateX(radians(i/PI));
	rotateZ(radians(frameCount/(i+33.3)));
	noFill();
	pushMatrix();
	translate(noise(i*0.01+frameCount*0.01)*factor,noise(i*0.0133+frameCount*0.0133)*factor,noise(i*0.021+frameCount*0.01)*factor);
	box(100-i);
	popMatrix();
	fill(0,15);
	rect((100-i)*.5,100,50,50);
	rect((100-i)*.5,-100,5,-50);
	}
	popMatrix();

	popMatrix();
}


import processing.opengl.*;

int w = 320;
int h = 240;
int res = 8;

PImage shade;
PGraphics light;

float speed = 30.0;

Recorder r;

int map[] = new int[w*h/res];
color[] cs = new color[map.length];
int timer[] = new int[map.length];

float lift = 1;
float[] lifts = new float[map.length];


PGraphics frame[];

void setup(){
	size(w,h,OPENGL);
	background(255);
	noSmooth();
	
	textFont(createFont("Tahoma",8));
	//textMode(SCREEN);
	
	shade = loadImage("shade1.png");
	//imageMode(SCREEN);
	
	light = createGraphics(40,40,JAVA2D);
	light.beginDraw();
	light.stroke(255);
	light.strokeWeight(10);
	light.line(12,12,40,40);
	light.filter(BLUR,1.8);
	light.endDraw();
	
	r = new Recorder("out","charMap.mp4");
	
	for(int i = 0;i<map.length;i++){
		map[i] = (int)random(10);
		lifts[i] = map[i];
		timer[i] = 0;
		cs[i] = color(random(20,255),66,15);
	}

	fill(0);
	//stroke(0,150);
	noStroke();
	frame = new PGraphics[10];
	for(int i = 0;i<frame.length;i++)
	frame[i] = generateFrame(0,random(240,255),random(34,40),2+random(200)/100.0,5);

}


void draw(){

	//background(255);

	int x=0, y = res;
	int sum = 0;
	for(int i = 0;i<map.length;i++){
		//map[i] = (int)(10*(0.5*(sin((frameCount+x)/30.0)+1)));
		int curr = map[i];
		
		if(curr!=lifts[i]){
			timer[i] = 90;
		}
		lifts[i] = curr;
		
		color c = lerpColor(cs[i],color(curr*25),0.5);
		
		fill(c);
		rect(x-lifts[i]*lift,y-lifts[i]*lift-res,res,res);
		
		
		c = lerpColor(cs[i],color(curr*10),0.7);
		
		fill(c);
		beginShape();		
		vertex(x-lifts[i]*lift+res,y-lifts[i]*lift-res);
		vertex(x+res,y-res);
		vertex(x+res,y);
		vertex(x-lifts[i]*lift+res,y-lifts[i]*lift);
		endShape();
		
		
		c = lerpColor(cs[i],color(curr*5),0.8);
		
		
		fill(c);
		beginShape();		
		vertex(x-lifts[i]*lift,y-lifts[i]*lift);
		vertex(x-lifts[i]*lift+res,y-lifts[i]*lift);
		vertex(x+res,y);
		vertex(x,y);
		endShape();
		
		
		
		
		
		fill(0);
		text(curr,x-lifts[i]*lift+1,y-lifts[i]*lift-1);
		image(shade,x-lifts[i]*lift,y-lifts[i]*lift-res);
		x+=res;
		sum +=curr;
		
		if(timer[i]>0){
			timer[i]-=25;
			tint(255,timer[i]);
			image(light,x-lifts[i]*lift-10-res,y-lifts[i]*lift-res-10);
			noTint();
		}
		
		if(x>w){
			//fill(map(sum,w/res*3,w/res*6,255,0),155);
			//rect(0,y-res,w,res);
			sum=0;
			x=0;
			y+=res;
		}
	}
	
	image(frame[(int)random(frame.length)],random(-5),random(-5));
	
	r.add();

	if(random(100)>80)
	mutate(10);
}

void keyPressed(){
	if(key=='q'){
		r.finish();
		exit();
	}

}


PGraphics generateFrame(float _shade,float _al,float _wei,float _bl,int _reserva){
	PGraphics p;

	p = createGraphics(width+_reserva,height+_reserva,JAVA2D);
	p.beginDraw();
	p.stroke(_shade,_al);
	p.strokeWeight(_wei);
	p.noFill();
	p.rect(0,0,width+_reserva,height+_reserva);
	p.filter(BLUR,_bl);
	p.endDraw();

	
	return p;

}

void mutate(int mult){
	int which[] = new int[mult];

	for(int i = 0;i<mult;i++){
		which[i] = (int)random(map.length);
		
		if(random(500)>250){
		map[which[i]] ++;
		}else{
		map[which[i]] --;		
		}
		//map[which[i]]=(int)random(10);
		map[which[i]] = constrain(map[which[i]],0,9);
	}
}
class Recorder{
  String dir,name;
  int cntr = 0;

  Recorder(String _dir,String _name){
    dir = _dir;
    name=_name;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="6000000";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" msmpeg4v2 "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }



}
// Flow Field Following
// Daniel Shiffman <http://www.shiffman.net>
// The Nature of Code, Spring 2009

class Boid {

	// The usual stuff
	PVector loc;
	PVector vel;
	PVector acc;
	float r;
	float maxforce;    // Maximum steering force
	float maxspeed;    // Maximum speed
	Gif anim;
	PApplet parent;
	int desync,time = 0;
	
	Boid(PApplet _p,Gif _anim, PVector l, float ms, float mf) {
		parent = _p;
		if(rec){
			anim = new Gif(parent,"bird.gif");
		}else{
			anim = new Gif(parent,"birdR.gif");
		}
		
		//anim.setDelay(1500);
		loc = l.get();
		r = 3.0f;
		desync = (int)random(20);
		maxspeed = ms;
		maxforce = mf;
		acc = new PVector(0,0);
		vel = new PVector(0,0);
	}

	public void run() {
		if(time==desync)
			anim.play();
			
		time++;
	
		update();
		borders();
		render();
	}


	// Implementing Reynolds' flow field following algorithm
	// http://www.red3d.com/cwr/steer/FlowFollow.html
	void follow(FlowField f) {

		// Look ahead
		PVector ahead = vel.get();
		ahead.normalize();
		ahead.mult(32); // Arbitrarily look 32 pixels ahead
		PVector lookup = PVector.add(loc,ahead);

		// Draw in debug mode
		if (debug) {
			stroke(0);
			line(loc.x,loc.y,lookup.x,lookup.y);
			fill(0);
			ellipse(lookup.x,lookup.y,3,3);
		}

		// What is the vector at that spot in the flow field?
		PVector desired = f.lookup(lookup);
		// Scale it up by maxspeed
		desired.mult(maxspeed);
		// Steering is desired minus velocity
		PVector steer = PVector.sub(desired, vel);
		steer.limit(maxforce);  // Limit to maximum steering force
		acc.add(steer);
	}

	// Method to update location
	void update() {
		// Update velocity
		vel.add(acc);
		// Limit speed
		vel.limit(maxspeed);
		loc.add(vel);
		// Reset accelertion to 0 each cycle
		acc.mult(0);
	}

	void render() {
		// Draw a triangle rotated in the direction of velocity
		float theta = vel.heading2D() + PApplet.radians(90);
		fill(175);
		stroke(0);
		pushMatrix();
		translate(loc.x,loc.y);
		rotate(theta+PI/2.0);
		//tint(255,150);
		image(anim,-8,-8,anim.width/2,anim.height/2);
		popMatrix();
		
		stroke(0,30);
		
			line(loc.x,loc.y,loc.x,height);
		
	}

	// Wraparound
	void borders() {
		if (loc.x < -r) loc.x = width+r;
		if (loc.y < -r) loc.y = height+r;
		if (loc.x > width+r) loc.x = -r;
		if (loc.y > height+r) loc.y = -r;
	}

}



// Flow Field Following
// Daniel Shiffman <http://www.shiffman.net>
// The Nature of Code, Spring 2009

class FlowField {

  // A flow field is a two dimensional array of PVectors
  PVector[][] field;
  int cols, rows; // Columns and Rows
  int resolution; // How large is each "cell" of the flow field

  FlowField(int r) {
    resolution = r;
    // Determine the number of columns and rows based on sketch's width and height
    cols = width/resolution;
    rows = height/resolution;
    field = new PVector[cols][rows];
    init();
  }

  void init() {
    // Reseed noise so we get a new flow field every time
    noiseSeed((int)random(10000));
    float xoff = 0;
    for (int i = 0; i < cols; i++) {
      float yoff = 0;
      for (int j = 0; j < rows; j++) {
        // Use perlin noise to get an angle between 0 and 2 PI
        float theta = map(noise(xoff,yoff),0,1,0,TWO_PI);
        // Polar to cartesian coordinate transformation to get x and y components of the vector
        field[i][j] = new PVector(cos(theta),sin(theta));
        yoff += 0.1;
      }
      xoff += 0.1;
    }
  }

  // Draw every vector
  void display() {
    for (int i = 0; i < cols; i++) {
      for (int j = 0; j < rows; j++) {
        drawVector(field[i][j],i*resolution,j*resolution,resolution-2);
      }
    }

  }

  // Renders a vector object 'v' as an arrow and a location 'x,y'
  void drawVector(PVector v, float x, float y, float scayl) {
    pushMatrix();
    float arrowsize = 4;
    // Translate to location to render vector
    translate(x,y);
    stroke(100);
    // Call vector heading function to get direction (note that pointing up is a heading of 0) and rotate
    rotate(v.heading2D());
    // Calculate length of vector & scale it to be bigger or smaller if necessary
    float len = v.mag()*scayl;
    // Draw three lines to make an arrow (draw pointing up since we've rotate to the proper direction)
    line(0,0,len,0);
    line(len,0,len-arrowsize,+arrowsize/2);
    line(len,0,len-arrowsize,-arrowsize/2);
    popMatrix();
  }

  PVector lookup(PVector lookup) {
    int i = (int) constrain(lookup.x/resolution,0,cols-1);
    int j = (int) constrain(lookup.y/resolution,0,rows-1);
    return field[i][j].get();
  }


}




import gifAnimation.*;
import processing.opengl.*;
import codeanticode.gsvideo.*;
import supercollider.*;

boolean debug = false;

//PFont f;
Recorder r;
GSCapture cam;
Gif anima;

boolean rec = false;
boolean ive = false;

int num = 120;

Synth synth[] = new Synth[num];


// Flowfield object
FlowField flowfield;
// An ArrayList of boids
ArrayList boids;

float tresh = 0.5;
int cntr = 1;

int W=720,H=576/2;
color[] c,ac;
int bordr =10;
int rut = 30;
int dx = 1,dy =1;
boolean first = true;

boolean gotnew = false;
boolean getNew = true;
boolean cc = false;

int tii = 500;

void setup() {
	size(720, 376,OPENGL);
	noSmooth();
	frameRate(30);
	//f = createFont("Arial", 8 ,true);

	if(rec)
		r = new Recorder("out","crowCrowd5.mp4");

	flowfield = new FlowField(16);
	boids = new ArrayList();

	anima = new Gif(this,"bird.gif");
	
	for(int i = 0;i<synth.length;i++){
		synth[i] = new Synth("simpleSynth");
		synth[i].set("freq", i);
		synth[i].set("amp", 1/(num+1.0));
		synth[i].create();
	}

	for (int i = 0; i < num; i++) {
		boids.add(new Boid(this,anima,new PVector(random(width),random(height)),random(2,5),random(0.1f,0.5f)));
	}
	noSmooth();

	if(ive){
		cam = new GSCapture(this, 720/2,576/2, "v4lsrc");
		//W = cam.width;
		//H = cam.height;
		c = new color[W*H];
		ac = new color[W*H];
		println(W+":"+H);
	}
	noFill();

	background(0);
}

void draw() {
	if(ive){
		camcyc();
	}else{
		background(#222222);
	}
	//background(255);
	//fill(21,33,45,125);
	//noStroke();
	//rect(-1,-1,width+2,height+2);

	// Display the flowfield in "debug" mode
	if (debug) flowfield.display();
	// Tell all the boids to follow the flow field
	for (int i = 0; i < boids.size(); i++) {
		Boid b = (Boid) boids.get(i);
		b.follow(flowfield);
		b.run();
		synth[i].set("freq",map(b.loc.y,0,height,1220,10));
		//synth[i].set("amp",((0.5*(sin((b.time+b.desync)/(i+1.0))+1.0))*0.02));
	}

	if(frameCount%tii==0){
		flowfield.init();                                                   
		tii = (int)random(20,800);
	}

	// Instructions
	if(rec)
		r.add();

}


void keyPressed() {
	if(key==' '){
		debug = !debug;
	}else if(key=='q'){
		if(rec)
			r.finish();

		if(ive){
			cam.stop();
			cam.dispose();
		}
		
		for(int i  =0;i<synth.length;i++){
			synth[i].free();		
		}
		
		exit();
	}
}

// Make a new flowfield
void mousePressed() {
	flowfield.init();
}



void camcyc(){
	noFill();
	gotnew = true;

	if(cc){
		getNew = true;

	}

	if (cam.available()) {
		cam.read();

		//	gotnew = true;


	}

	if(getNew){


		if(first){
			c = cam.pixels;
			first = false;
		}else{
			c = cam.pixels;
		}

		for(int y = 0 ; y<H ;y+=dy){

			for(int x= 0 ; x<W ;x+=dx){
				stroke(ac[y*W+x]);
				point(x,y);
				if(gotnew){
					ac[y*W+x]=lerpColor(ac[y*W+x],color(brightness(c[y*W+x])),tresh);
				}
			}



		}
		//				r.add();
		//println("capture on frame :"+frameCount);
		//getNew = false;

	}

	if(cc){
		fill(0);
		rect(width-20,20,10,10);
	}
	//image(cam, 0, 0);
	// The following does the same, and is faster when just drawing the image
	// without any additional resizing, transformations, or tint.
	//set(160, 100, cam);


}





class Recorder{
  String dir,name;
  int cntr = 0;

  Recorder(String _dir,String _name){
    dir = _dir;
    name=_name;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="6000000";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" msmpeg4v2 "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }



}

PGraphics frame[];

void setup(){

	size(320,240,P3D);
	
	frame = new PGraphics[10];
	
	frameRate(24);
	
	for(int i = 0;i<frame.length;i++)
	frame[i] = generateFrame(0,random(240,255),random(34,40),2+random(200)/100.0);
	

}

void draw(){
	background(200);
	
	
	image(frame[(int)random(frame.length)],random(-5),random(-5));


}

PGraphics generateFrame(float _shade,float _al,float _wei,float _bl){
	PGraphics p;

	p = createGraphics(width+10,height+10,JAVA2D);
	p.beginDraw();
	p.stroke(_shade,_al);
	p.strokeWeight(_wei);
	p.noFill();
	p.rect(0,0,width+10,height+10);
	p.filter(BLUR,_bl);
	p.endDraw();

	
	return p;

}

import processing.opengl.*;

int num = 500;
Objectron o[];

Recorder r;
boolean rec= false;

void setup(){
	size(720,576,OPENGL);
	background(0);

	stroke(255);
	noFill();
	o = new Objectron[num];

	if(rec)
		r = new Recorder("out","flocking.mp4");


	for(int i = 0;i<num;i++)
		o[i] = new Objectron();
}

void draw(){


	fill(0,53);
	rect(0,0,width,height);
	noFill();


	//background(0);

	for(int i = 0;i<num;i++)
		o[i].run();

	pushStyle();
	noFill();
	stroke(0,200);
	strokeWeight(12);
	rect(0,0,width,height);
	popStyle();
	
	if(rec)
		r.add();

}

void keyPressed(){

	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}

}


class Objectron{
	PVector pos,vel,up;
	float speed = 2.1;
	float rat = 80;
	float ts = 10.0;

	int deaf = 100;
	boolean mono = false;
	int timer = 0;

	Objectron(){
		create();
	}


	void create(){
		pos = new PVector(random(width),random(height));
		vel = new PVector(random(-10,10),random(-10,10));
		up = new PVector(0,-1);

	}

	void calculate(){
		if(!mono)
			for(int i = 0;i<o.length;i++){
				float quo = dist(pos.x,pos.y,o[i].pos.x,o[i].pos.y);

				PVector tmp = o[i].vel;

				if(quo<rat/2&&!mono){
					mono = true;
					vel.add(random(-30,30)/100.0,random(-30,30)/100.0,0);
					deaf = (int)(random(10,300)/10.0);
					timer = 0;
				}

				if(quo<rat&&!mono){


					vel.add(tmp.x/map(quo,0,rat,100,3),tmp.y/map(quo,0,rat,100,3),0);
					//add((tmp.x-vel.x)/map(quo,0,rat*3,10000,1000),(tmp.y-vel.y)/map(quo,0,rat*3,10000,1000),0);
					//	line(o[i].pos.x,o[i].pos.y,pos.x,pos.y);
				}



			}

		if(mono){

			stroke(255,120);
			timer++;
			if(timer>deaf){
				mono = false;
				timer = 0;
			}
		}else{

			stroke(255,125);
		}

		vel.limit(5);


	}

	void run(){




		//if(out())create();
		/*
				if(vel.x<0){
					vel.add(cos(-PVector.angleBetween(vel,up))/(vel.mag()+0.1)*3.0,sin(-PVector.angleBetween(vel,up))/(vel.mag()+0.1)*3.0,0);
				}else{
					vel.add(cos(PVector.angleBetween(vel,up))/(vel.mag()+0.1)*3.0,sin(PVector.angleBetween(vel,up))/(vel.mag()+0.1)*3.0,0);
				}
		*/		
		calculate();

		pos.x += vel.x/speed;
		pos.y += vel.y/speed;

		bordr();

		pushMatrix();
		translate(pos.x,pos.y);

		pushMatrix();
		if(vel.x<0){
			rotate(-PVector.angleBetween(vel,up));
		}else{
			rotate(PVector.angleBetween(vel,up));
		}

		//rect(-3,-3,6,6);
		triangle(-2,-2,2,-2,0,-3-(vel.mag()+0.1));


		popMatrix();
		popMatrix();
	}

	boolean out(){
		boolean answr = false;
		if(pos.x<0||pos.x>width||pos.y<0||pos.y>height)
			answr = true;

		return answr;
	}

	void bordr(){
		if(pos.x<0)pos.x=width;
		if(pos.x>width)pos.x=0;

		if(pos.y<0)pos.y=height;
		if(pos.y>height)pos.y=0;


	}



	//rotate vector declaration
	PVector rotateV(PVector v, float ang){
		PVector axis=new PVector(0,0,-1);
		PVector vnorm = new PVector(v.x,v.y,v.z);
		float _parallel = axis.dot(v);
		axis.mult(_parallel);

		PVector parallel = axis;
		parallel.sub(v);
		PVector perp = parallel;
		PVector Cross = v.cross(axis);

		Cross.mult(sin(-ang));
		perp.mult(cos(-ang ));
		Cross.add(perp);
		parallel.add(Cross);

		PVector result = parallel;
		return result;
	}


}
class Recorder{
  String dir,name;
  int cntr = 0;

  Recorder(String _dir,String _name){
    dir = _dir;
    name=_name;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="6000000";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" msmpeg4v2 "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }



}
// .OBJ Loader
// by SAITO <http://users.design.ucla.edu/~tatsuyas> 
// Placing a virtual structure represented as mathematically 
// three-dimensional object.
// OBJModel.load() reads structure data of the object stored 
// as numerical data.
// OBJModel.draw() gives a visual form to the structure data.
// processing standard drawing functions can be used to manipulate
// the visual form to create deep visual experiences.
// Created 20 April 2005
import saito.objloader.*;
import processing.opengl.*;
OBJModel model;
float rotX;
float rotY;
               
void setup()
{ 
   size(400, 400, OPENGL);
   frameRate(30);
   smooth();
   //hint(ENABLE_OPENGL_4X_SMOOTH); 
   model = new OBJModel(this);
   model.load("krystof2.obj"); // dma.obj in data folder
    model.drawMode(POLYGON);
}

void draw()
{
   background(0);
   //stroke(255,80);
   noStroke();
   
   
   lights();
   //directionalLight(200, 200, 200, -1, 0, 0);
   ambientLight(102, 102, 102);

   
   pushMatrix();
   translate(width/2, height/2, 0);
   rotateX(rotY);
   rotateY(rotX);
   scale(70.0);
  
   model.draw();
   popMatrix();
}
void keyPressed()
{
   if(key == 'a')
   model.enableTexture();

   else if(key=='b')
   model.disableTexture();
}
void mouseDragged()
{
   rotX += (mouseX - pmouseX) * 0.01;
   rotY -= (mouseY - pmouseY) * 0.01;
}


/*class Vector
{
  float x,y,z;
  float nx,ny,nz;
  float mag;
  Vector(float _x, float _y, float _z)
  {
    x=_x;
    y=_y;
    z=_z;
    
    //calculate the normalised vector (vector of length 1) .. doesn't make sense for using vector for co-ords, but useful when an actual vector
    mag=sqrt(x*x+y*y+z*z);
    nx=x/mag;
    ny=y/mag;
    nz=z/mag;
  }
  
  Vector divide(float val)
  {
    return new Vector(x/val,y/val,z/val);
  }
}

// works out the distance between 2 points by their x,y,z co-ords.
float dist(Vector a, Vector b)
{
  float i=a.x-b.x;
  float j=a.y-b.y;
  float k=a.z-b.z;
  return sqrt(i*i+j*j+k*k);
}

float Dot(Vector a, Vector b)
{
  return(a.nx*b.nx + a.ny*b.ny + a.nz * b.nz);
}

Vector cross(Vector a, Vector b)
{
  return new Vector(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y-a.y*b.x);
}

class MyLight
{
  float x,y,z;
  color c;
  
  MyLight(float _x, float _y, float _z, color _c)
  {
    x=_x;
    y=_y;
    z=_z;
    c=_c;
  }
}

class MyPoly
{
  Vector[] points;
  Vector Normal;
  Vector Centre;
  BImage lightmap;
  //3 point polys only to begin with...  
  MyPoly(Vector a, Vector b, Vector c)
  {
    points=new Vector[3];
    points[0]=a;
    points[1]=b;
    points[2]=c;
    
    Vector ba=new Vector(a.x-b.x, a.y-b.y, a.z-b.z);
    Vector cb=new Vector(b.x-c.x, b.y-c.y, b.z-c.z);
    
    Normal=cross(ba,cb);
    
    Centre=new Vector((a.x+b.x+c.x)/3.0,(a.y+b.y+c.y)/3.0,(a.z+b.z+c.z)/3.0);
    lightmap=new BImage(20,20);
    
  }
  
  void draw(MyLight[] Lights, int NumLights)
  {
     Vector ToLight;
     float lightlevel;
     color lc;
    stroke(255,0,0);
    
    Vector ab=new Vector(points[1].x-points[0].x, points[1].y-points[0].y, points[1].z-points[0].z);
    Vector bc=new Vector(points[2].x-points[1].x, points[2].y-points[1].y, points[2].z-points[1].z);
    Vector ca=new Vector(points[0].x-points[2].x, points[0].y-points[2].y, points[0].z-points[2].z);

    Vector GlobalLight=new Vector(Lights[0].x,Lights[0].y,Lights[0].z);
//    Vector Tangent=cross(ab,Normal);
 //   Vector Bitangent=cross(Tangent,Normal);
  //  Vector LocalLight=new Vector(Dot(GlobalLight,Tangent),Dot(GlobalLight,Bitangent),Dot(GlobalLight,Normal));
    
            
    Vector deltax=ab.divide(20);
    Vector deltay=bc.divide(20);

    for(int u=0;u<20;u++)
    {
      for(int v=0;v<=u;v++)
      {
        float a=points[0].x + u*deltax.x + v*deltay.x;
        float b=points[0].y + u*deltax.y + v*deltay.y;
        float c=points[0].z + u*deltax.z + v*deltay.z;
        color finalcolor=color(0,0,0);
        for(int w=0;w<NumLights;w++)
        {
          Vector d=new Vector(Lights[w].x-a,Lights[w].y-b,Lights[w].z-c);
          float ll=Dot(Normal,d);
//          color pc=color(red(Lights[w].c)*ll,0,0);
          Vector T=cross(ab,Normal);
          Vector B=cross(T,Normal);
          Vector LocalLight=new Vector(Dot(d,B),Dot(d,T),Dot(d,Normal));
          color bumpc=bump.get(u,v);
          Vector BumpNormal=new Vector((red(bumpc)-128)/128.0,(green(bumpc)-128)/128.0,(blue(bumpc)-128)/128.0);
          float NewPower=Dot(BumpNormal,LocalLight);
          color pc=color(NewPower*red(Lights[w].c),NewPower*green(Lights[w].c),NewPower*blue(Lights[w].c));
          finalcolor=color(red(finalcolor)+red(pc),green(finalcolor)+green(pc),blue(finalcolor)+blue(pc));          
        }
        lightmap.pixels[u+v*20]=finalcolor;
      }
    }
    fill(255,255,255);
    beginShape(POLYGON);
    texture(lightmap);
    vertex(points[0].x,points[0].y,points[0].z,0,0);
    vertex(points[1].x,points[1].y,points[1].z,19,0);
    vertex(points[2].x,points[2].y,points[2].z,19,19);
    endShape();
  }
}

class scene
{
  MyPoly[] Polys;
  MyLight[] Lights;
  int NumPolys;
  int NumLights;
  scene(int x, int y)
  {
    Polys=new MyPoly[x];
    Lights=new MyLight[y];
    NumPolys=0;
    NumLights=0;
  }
  
  void AddPoly(MyPoly a)
  {
    if(NumPolys<Polys.length)
    {
//      println("Adding Poly " + NumPolys);
      Polys[NumPolys]=a;
      NumPolys++;
    }
  }
  
  void AddLight(MyLight a)
  {
    if(NumLights<Lights.length)
    {
//      println("Adding light " + NumLights);
      Lights[NumLights]=a;
      NumLights++;
    }
  }
  
  void draw()
  {
    for(int i=0;i<NumPolys;i++)
    {
//      println("Drawing Plane " + i);
      Polys[i].draw(Lights,NumLights);
    }
  }
}

scene world;
BImage bump;

void setup()
{
  size(300,300);
  background(0);
  bump=loadImage("bump.jpg");
  world=new scene(100,3);
  world.AddLight(new MyLight(100,100,100,color(0,0,255)));
  world.AddLight(new MyLight(100,100,100,color(0,255,0)));
  world.AddLight(new MyLight(100,100,100,color(255,0,0)));
//  world.AddPoly(new MyPoly(new Vector(35,-35,0),new Vector(35,35,0),new Vector(-35,35,0)));
//  world.AddPoly
  Vector a=new Vector(-35,35,35);
  Vector b=new Vector(35,35,35);
  Vector c=new Vector(35,-35,35);
  Vector d=new Vector(-35,-35,35);
  Vector e=new Vector(35,35,-35);
  Vector f=new Vector(-35,35,-35);
  Vector g=new Vector(-35,-35,-35);
  Vector h=new Vector(35,-35,-35);
  
  world.AddPoly(new MyPoly(c,b,a));
  world.AddPoly(new MyPoly(a,d,c));
  world.AddPoly(new MyPoly(d,a,f));
  world.AddPoly(new MyPoly(f,g,d));
  world.AddPoly(new MyPoly(f,e,h));
  world.AddPoly(new MyPoly(h,g,f));
  world.AddPoly(new MyPoly(e,b,c));
  world.AddPoly(new MyPoly(c,h,e));
  world.AddPoly(new MyPoly(e,f,a));
  world.AddPoly(new MyPoly(a,b,e));
  world.AddPoly(new MyPoly(g,h,c));
  world.AddPoly(new MyPoly(c,d,g));
  
//  translate(width/2.0, height/2.0,0);
//  world.draw();
  
}

float an=0;
float an2=0;
float an3=0;

void loop()
{
  background(40,40,40);
  push();
  translate(width/2.0, height/2.0,0);
//  rotateY(an2);
  an+=0.05;
  an2+=0.0312;
  an3-=0.0412;
  world.Lights[0].x=100*sin(an3);
  world.Lights[0].y=100*sin(an);
  world.Lights[0].z=100*cos(an2);
  world.Lights[1].x=100*cos(an2);
  world.Lights[1].y=100*sin(an3);
  world.Lights[1].z=100*sin(an);
  world.Lights[2].x=100*cos(an);
  world.Lights[2].y=100*sin(an2);
  world.Lights[2].z=100*cos(an3);
  
  
  float mx=(mouseX-width/2.0)/(width/2.0);
  float my=(mouseY-height/2.0)/(height/2.0);
  
  rotateY(mx*PI);
  rotateX(my*PI);
  
  for(int i=0;i<world.NumLights;i++)
  {
  push();
  noStroke();
  translate(world.Lights[i].x,world.Lights[i].y,world.Lights[i].z);
  fill(world.Lights[i].c);
  sphere(5);
  pop();
  }

  world.draw();
  pop();
  for(int x=0;x<12;x++)
  {
    image(world.Polys[x].lightmap,x*20,0,20,20);
  }
}
*/
import processing.opengl.*;

import progl.renderers.*;
import progl.*;


ProGLShape circleShape;


void setup(){
  size(800, 600, ProGLGraphics.graphics());
  smooth();
  
  circleShape = new ProGLShape();
  initCircleShape();
}


void initCircleShape(){
  circleShape.beginRecord();
  
  stroke(255, 50);
  noFill();
  
  for (int i = 0; i < 4000; i++){
    rotateX(random(TWO_PI));
    rotateY(random(TWO_PI));

    translate(random(-20, 20), random(-20, 20), random(-1f));
    float diameter = random(5, 50);
    ellipse(0, 0, diameter, diameter);
  }

  circleShape.endRecord();
}

float angle = 0;

void draw(){
  background(0);
  angle += 0.1;
  translate(400, 300, -200);
  rotateX(PI / 2f);
  rotateZ(angle);
  circleShape.draw();
}

void mousePressed(){
  initCircleShape();
}

class Recorder{
  String dir,name;
  int cntr = 0;

  Recorder(String _dir,String _name){
    dir = _dir;
    name=_name;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="6000000";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" msmpeg4v2 "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }



}
import point2line.*;
import processing.opengl.*;

//Vect2 normalizedVelocity = vel.normalized();
Synchronid[] s;
int pocet = 4000;
int ID = 0;

Recorder r;
boolean rec = false;

void setup(){
	size(320,240,OPENGL);
	background(0);
	frameRate(50);
	frame.setAlwaysOnTop(true);

	s = new Synchronid[pocet];

	for(int i =0;i<pocet;i++){
		s[i] = new Synchronid();
	}

	if(rec)
		r =  new Recorder("out","syncAsync.mp4");
}

void draw(){
	background(0);

	stroke(255,30);
	strokeWeight(1);

	for(int i =0;i<pocet;i++){
		s[i].draw();
	}

	stroke(0);
	strokeWeight(10);
	noFill();
	rect(0,0,width,height);

	if(rec)
		r.add();
}                               

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
	}

	exit();
}

class Synchronid{

	Vect2 vel;
	float x,y,unit;
	int id;

	Synchronid(){

		vel = new Vect2(width,0);
		x = (ID/(pocet+0.0))*width;
		y= height/3.0;
		unit = 100+ID/PI;//random(100,1000);
		id=ID;
		ID++;
	}

	void draw(){

		vel.rotate(PI*frameCount/unit/(mouseY*30.0+4.0));
		unit = 100+(id*mouseX/PI);

		pushMatrix();
		translate(x,y);
		line(vel.x,vel.y,0,0);
		popMatrix();
	}
}
import java.text.*;
import com.sun.opengl.util.*;
import com.sun.opengl.util.j2d.*;
import processing.opengl.*;


VTextRenderer textRender;

void setup()
{
	size(200,200);
	textRender = new VTextRenderer( "Tahoma", 32 );
}

void draw()
{
	background(0);
	fill(255);
	textRender.print( "singing in the rain", 0, 10, 0, 0.2 );
}


class VTextRenderer
{
	VTextRenderer( String fontName, int size )
	{
		_fontName = fontName;
		_fontSize = size;
		_textRender = new TextRenderer( new Font(fontName, Font.TRUETYPE_FONT, size), true, true, null, true );
		_textRender.setColor( 1.0f, 1.0, 1.0, 1.0 );
		//_textRender.setUseVertexArrays( true );
	}

	VTextRenderer( String fontName, int size, boolean antialiased, boolean mipmap )
	{
		_fontName = fontName;
		_fontSize = size;
		_textRender = new TextRenderer( new Font(fontName, Font.TRUETYPE_FONT, size), antialiased, true, null, mipmap );
		_textRender.setColor( 1.0f, 1.0, 1.0, 1.0 );
		//_textRender.setUseVertexArrays( true );
	}


	void print( String str, int x, int y )
	{
		_textRender.beginRendering( width, height, true );
		_textRender.draw( str, x, y );
		_textRender.endRendering();
		_textRender.flush();
	}

	void print( String str, float x, float y, float z )
	{
		print( str, x, y, z, 1.0f );
	}

	void print( String str, float x, float y, float z, float s )
	{
		_textRender.begin3DRendering();
		_textRender.draw3D( str, x, y, z, s );
		_textRender.end3DRendering();
		_textRender.flush();
	}

	void setColor( float c )
	{
		setColor( c, c, c, 1 );
	}

	void setColor( float c, float a )
	{
		setColor( c, c, c, a );
	}

	void setColor( float r, float g, float b )
	{
		setColor( r, g, b, 1 );
	}

	void setColor( float r, float g, float b, float a )
	{
		_textRender.setColor( r, g, b, a );
	}

	void setSmoothing( boolean flag )
	{
		_textRender.setSmoothing( flag );
	}


	/// ____________________________________________________
	/// Members
	int _w, _h;

	String _fontName;
	int _fontSize;
	TextRenderer _textRender;
	Font font;

}

Squad squad;

void setup(){
	size(640,480,P3D);
	squad = new Squad(0,12);
	rectMode(CENTER);
}

void draw(){
	background(255);

	squad.run();

}

class Squad{
	Soldier s[];
	int num,id,cx=0,cy=0;
	float x,y,tx,ty;
	float heading,h2,th;
	float speed = 0.3;

	Squad(int _id,int _num){
		id = _id;
		num = _num;
		s = new Soldier[num];
		x=width/2;
		y=height/2;



		for(int i =0;i<num;i++){
			s[i] = new Soldier(this,100,i);
		}



		tx = width/2;//mouseX;
		ty = 0;//mouseY;
	}

	void run(){


		if(dist(x,y,tx,ty)>1.0){
			x+=cos(heading)*speed;
			y+=sin(heading)*speed;
		}


		heading =  atan2(ty-y,tx-x);


		//println(th);

		
		

		pushMatrix();
		translate(0,height/2);
		pushMatrix();
		rotateX(radians(50));

		
		translate(0,-420,-170);
		
		
		
		fill(255,255,0,70);
		rect(width/2,height/2,width,height);
		
		
		pushMatrix();
		translate(x,y);

		pushMatrix();
		rotate(heading+PI/2);



		stroke(0);
		line(0,-10,0,-30);

		for(int i =0;i<num;i++){
			s[i].draw();
		}

		popMatrix();

		popMatrix();

		popMatrix();

		popMatrix();
	}




}


class Soldier{
	PImage gfx;
	int health,type,id;
	int roz = 5;
	float x,y;
	float tx,ty;
	Squad parent;
	float speed = 0.1;

	Soldier(Squad _p,int _health,int _id){
		parent = _p;
		health = _health;
		id = _id;
		x=0;
		y=0;

		parent.cx=(id*roz)%20;
		tx = parent.cx-10;//(id*roz)%15;//+random(-2,2);

		if(parent.cx%20==0){
			parent.cy++;
		}
		ty = parent.cy*roz;//tx%15;


	}

	void draw(){
		noStroke();
		fill(0);

		x+=(tx-x)*speed;
		y+=(ty-y)*speed;

		pushMatrix();
		translate(x,y);
		rect(0,0,3,3);
		popMatrix();


	}



}

void mousePressed(){
	squad.tx = mouseX;
	squad.ty = mouseY;
}
PImage img;
float tresh = 127.0;

void setup(){

	img = loadImage("Kandinsky_OnWhite2.jpg");
	int[][] matrix = new int[img.width][img.height];
	
	for(int x = 0;x<img.width;x++){
		for(int y = 0 ; y<img.height;y++){
			if(brightness(img.pixels[y*img.width+x])>tresh){
					matrix[x][y] = 1;
			}else{
					matrix[x][y] = 0;
			}
		}
	
	}
	
	String[] data = new String[matrix[0].length];

	for(int y = 0;y<matrix[0].length;y++){
		data[y] = "";
		for(int x = 0;x<matrix.length;x++){		
			data[y]+=matrix[x][y]+" ";
		}
	
	}
	
	saveStrings("out.txt",data);
	exit();
}
import processing.opengl.*;

Tree t;
Branch b[] = new Branch[0];

void setup(){
	size(400,300,P3D);

	stroke(0,85);
	t = new Tree(new float[]{2.0,-3.0,0.0});
}

void draw(){
	background(255);
	t.live();
}

class Tree{

	String code =  "";
	float settings[] = new float[0];
	int newBranch[] = new int[0];

	float uhly[] = {2.0,-3.0,0.0};

	Tree(float _uhly[]){
		uhly=_uhly;
		
		
		
		gen();
		
		println(code);
		println("branchesAt:");
		println(newBranch);

		b = (Branch[])expand(b,b.length+1);
		b[b.length-1] = new Branch(1.0,settings,0);

		if(newBranch!=null)
			for(int i = 0;i<newBranch.length;i++){
				gen();
				b = (Branch[])expand(b,b.length+1);
				b[b.length-1] = new Branch(1.0,settings,i,0);

			}
	}

	void live(){
		for(int i =0;i<b.length;i++){
			b[i].live();
		}
	}
	
	
		void gen(){
			code =  "";
			code = codeGen(20,20,30,5);

			newBranch = new int[0];
			settings = new float[0];
			

			for(int i =0 ;i<code.length();i++){
				settings = (float[])expand(settings,settings.length+1);
				if(code.charAt(i)=='A'){
					settings[settings.length-1] = uhly[0];
				}else if(code.charAt(i)=='B'){
					settings[settings.length-1] = uhly[1];
				}else if(code.charAt(i)=='C'){
					settings[settings.length-1] = uhly[2];
				}else if(code.charAt(i)=='D'){
					newBranch = (int[])expand(newBranch,newBranch.length+1);
					newBranch[newBranch.length-1] = i;
				}
			}
		}


	String codeGen(int a,int b,int c,int d){
		String res = "";
		for(int i =0 ;i<a+b+c+d;i++){
			float q =  random(a+b+c+d);
			if(q<=a){
				res+="AAAAA";
			}else if(q<=a+b&&q>a){
				res+="BB";
			}else if(q<=a+b+c&&q>a+b){
				res+="C";
			}else if(q>c&&i>(a+b+c+d)/3.0){
				res+="D";
			}
		}
		return res;
	}
}

class Branch{
	float loms [];
	float step;
	int id;
	int parId;
	float rx,ry,x,y;
	float xes[],yes[];

	Branch(float _step,float[] _loms,int _id){
		loms=_loms;
		yes=new float[loms.length];
		xes=new float[loms.length];
		step = _step;
		id = _id;
		x=rx=width/2.0;
		y=ry=height;
		live();
	}

	Branch(float _step,float[] _loms,int _id,int _parId){
		loms=_loms;
		step = _step;
		id = _id;
		parId = parId;
		yes=new float[loms.length];
		xes=new float[loms.length];
		//x=rx=parent.xes[t.newBranch[id]];
		//y=ry=parent.yes[t.newBranch[id]];
		println("branch no. "+id+" created");
		x=rx=b[parId].xes[t.newBranch[id]];
		y=ry=b[parId].yes[t.newBranch[id]];
	}

	void live(){
		rx=x;
		ry=y;

		pushMatrix();

		translate(rx,ry);
		for(int i = 0;i<loms.length;i++){

			yes[i]=modelY(0,0,0);
			xes[i]=modelX(0,0,0);

			translate(0,-step);

			ry+=step;

			rotate(radians(loms[i]));

			line(0,0,0,-step);
		}

		popMatrix();


	}
}
void mousePressed(){
	saveFrame("a-###.png");
}
import processing.opengl.*;


float[] uhly = {90,-2,2};
int num = 30;

Totem t[] = new Totem[0];
Recorder r;

boolean rec = false;

String src;
int cnt = 0;

void setup(){
	size(720,486,OPENGL);



	stroke(255,20);
	background(0);

	//if(rec)
		r = new Recorder("out","lsys.mp4");
	
	xpa();

}

void xpa(){

	src = "";
	for(int i =0 ;i<num;i++){
		float q =  random(1000);
		if(q<=333){
			src+="CCCCCCCCC";
		}else if(q<=666&&q>333){
			src+="BBBBBBB";
		}else if(q<=1000&&q>666){
			src+="A";
		}
	}

	t = (Totem[])expand(t,t.length+1);
	t[t.length-1] =  new Totem(src,width/2,height/2);


}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}else if(key=='r'){
	rec=true;
	}
	keyPressed = false;
}

void mousePressed(){

	xpa();
}

void draw(){
	//background(0);

	fill(0,85);
	rect(0,0,width,height);
	
	for(int i=0;i<t.length;i++){
		t[i].live();                                                                                      
		//t[i].degen();
		}
		
		if(rec)
			r.add();

}



class Totem{
	float sx,sy,xx,yy;
	String code;
	char repo[];
	float step = 5.5;
	int last;
	boolean fin = false;
	float uhlyQ[];
	float qx=0,qy=0,rr=0;
	
	Totem(String _a,float _x,float _y){
		code = _a+"";
		xx=sx = _x;
		yy=sy = _y;
		uhlyQ = uhly;
	}
	
	

	void degen(){
		
		


		int  len = code.length();
		//		println(len);
		repo = new char[len];

		last = code.lastIndexOf("C");


		for(int i =0;i<len;i++){
			repo[i] = code.charAt(i);
		}

		code = "";

		for(int i =0;i<len;i++){
			if(last!=i){
				code+=repo[i];
			}else{
				code+='A';
			}
		}


	}

	void live(){
		sy=yy;
		sx=xx;
		
		for(int i = 0;i<uhlyQ.length;i++){
			uhlyQ[i]+=random(-10,10)/10000.0;
		}
		
		qx += (mouseX/10.0-qx)/100.0;
		qy += (mouseY/10.0-qy)/100.0;
		rr += 30*(dist(pmouseX,pmouseY,mouseX,mouseY)-rr)/3000.0;

		int e = code.lastIndexOf("C");

		pushMatrix();

		translate(sx,sy);
		for(int i = 0;i<code.length();i++){

			translate(0,step);

			sy-=step;

			if(code.charAt(i)=='A'){
				rotate(radians(uhlyQ[0])+rr);
			}else if(code.charAt(i)=='B'){
				rotate(radians(uhlyQ[1]+qx));
			}else if(code.charAt(i)=='C'){
				rotate(radians(uhlyQ[2]+qy));
			}
			//	if(i>e&&frameCount%15==0)
			line(0,0,0,step);
			//line(-5,0,5,0);
		}



		popMatrix();

	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import processing.opengl.*;

PImage hand;
float[] uhly = {-45,7,0};
int num = 40;

Totem t[] = new Totem[0];
Recorder r;

boolean rec = false;

String src;
int cnt = 0;

void setup(){
	size(720,486,OPENGL);


	hand = loadImage("hand.png");
	stroke(255,20);
	background(0);

	//if(rec)
		r = new Recorder("out","lsys.mp4");
	
	xpa();

}

void xpa(){

	src = "";
	for(int i =0 ;i<num;i++){
		float q =  random(1000);
		if(q<=333){
			src+="CCCCCCCCC";
		}else if(q<=900&&q>333){
			src+="BBC";
		}else if(q<=1000&&q>900){
			src+="A";
		}
	}

	t = (Totem[])expand(t,t.length+1);
	t[t.length-1] =  new Totem(src,width/2,height/2);


}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}else if(key=='r'){
	rec=true;
	}
	keyPressed = false;
}

void mousePressed(){

	xpa();
}

void draw(){
	background(0);

	//fill(0,85);
	//rect(0,0,width,height);
	
	for(int i=0;i<t.length;i++){
		t[i].live();                                                                                      
		//t[i].degen();
		}
		
		if(rec)
			r.add();

}



class Totem{
	float sx,sy,xx,yy;
	String code;
	char repo[];
	float step = 2;
	int last;
	boolean fin = false;
	float uhlyQ[];
	float qx=0,qy=0,rr=0;
	
	Totem(String _a,float _x,float _y){
		code = _a+"";
		xx=sx = _x;
		yy=sy = _y;
		uhlyQ = uhly;
		
		/*
		for(int i = 0;i<uhlyQ.length;i++){
			uhlyQ[i]+=random(-10,10)/10.0;
		}*/
		
		qx=mouseX/10.0;
		qy=mouseY/100.0;
	}
	
	

	void degen(){
		
		
		

		int  len = code.length();
		//		println(len);
		repo = new char[len];

		last = code.lastIndexOf("C");


		for(int i =0;i<len;i++){
			repo[i] = code.charAt(i);
		}

		code = "";

		for(int i =0;i<len;i++){
			if(last!=i){
				code+=repo[i];
			}else{
				code+='A';
			}
		}
		
	}

	void live(){
		sy=yy;
		sx=xx;
		
		strokeWeight(2);
		
		step +=random(-100,100)/10000.0;
		
		for(int i = 0;i<uhlyQ.length;i++){
			uhlyQ[i]+=random(-10,10)/10000.0;
		}
		
		qx += (mouseX/100.0-qx)/100.0;
		qy += (mouseY/1000.0-qy)/100.0;
		//rr += 30*(dist(pmouseX,pmouseY,mouseX,mouseY)-rr)/3000.0;

		int e = code.lastIndexOf("C");

		pushMatrix();

		translate(sx,sy);
		for(int i = 0;i<code.length();i++){

			translate(0,step);

			sy-=step;

			if(code.charAt(i)=='A'){
				rotate(radians(uhlyQ[0])+qy);
			}else if(code.charAt(i)=='B'){
				rotate(radians(uhlyQ[1]+qx));
			}else if(code.charAt(i)=='C'){
				rotate(radians(uhlyQ[2]));
			}
			//	if(i>e&&frameCount%15==0)
			line(0,0,0,step);
			//line(-5,0,5,0);
		}
		
		float scal = 10.0;
		image(hand,(-hand.width/scal/2.0)-10,0,hand.width/scal,hand.height/scal);



		popMatrix();

	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import processing.opengl.*;

PImage hand;
float[] uhly = {-45,7,0};
int num = 40;

Tree tree;
Recorder r;

boolean rec = false;

String src;
int cnt = 0;

void setup(){
	size(720,486,OPENGL);

	tree=  new Tree();
	hand = loadImage("hand.png");
	stroke(255,20);
	background(0);

	//if(rec)
	r = new Recorder("out","lsys.mp4");
}

void draw(){
	background(0);

	//fill(0,85);
	//rect(0,0,width,height);

	tree.live();

	if(rec)
		r.add();
}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}else if(key=='r'){
		rec=true;
	}
	keyPressed = false;
}

class Tree{
	Totem t[];
	
	Tree(){
		t = new Totem[0];
		addd();
	}

	void live(){
		for(int i=0;i<t.length;i++){
			t[i].live();
		}
	}

	void addd(){

		src = "";
		for(int i =0 ;i<num;i++){
			float q =  random(1000);
			if(q<=333){
				src+="CCCCCCCCC";
			}else if(q<=900&&q>333){
				src+="BBC";
			}else if(q<=980&&q>900){
				src+="A";
			}else if(q>980){
				src+="D";
			}
		}

		t = (Totem[])expand(t,t.length+1);
		t[t.length-1] =  new Totem(src,width/2,height/2);
	}
}

class Totem{
	float sx,sy,xx,yy;
	String code;
	char repo[];
	float step = 2;
	int last;
	boolean fin = false;
	float uhlyQ[];
	float qx=0,qy=0,rr=0;

	Totem(String _a,float _x,float _y){
		code = _a+"";
		xx=sx = _x;
		yy=sy = _y;
		uhlyQ = uhly;

		qx=mouseX/10.0;
		qy=mouseY/100.0;
	}

	void degen(){
		int  len = code.length();
		repo = new char[len];

		last = code.lastIndexOf("C");

		for(int i =0;i<len;i++){
			repo[i] = code.charAt(i);
		}

		code = "";

		for(int i =0;i<len;i++){
			if(last!=i){
				code+=repo[i];
			}else{
				code+='A';
			}
		}
	}

	void live(){
		sy=yy;
		sx=xx;

		strokeWeight(2);

		step +=random(-100,100)/10000.0;

		for(int i = 0;i<uhlyQ.length;i++){
			uhlyQ[i]+=random(-10,10)/10000.0;
		}

		qx += (mouseX/100.0-qx)/100.0;
		qy += (mouseY/1000.0-qy)/100.0;
		pushMatrix();

		translate(sx,sy);
		for(int i = 0;i<code.length();i++){

			translate(0,step);

			sy-=step;

			if(code.charAt(i)=='A'){
				rotate(radians(uhlyQ[0])+qy);
			}else if(code.charAt(i)=='B'){
				rotate(radians(uhlyQ[1]+qx));
			}else if(code.charAt(i)=='C'){
				rotate(radians(uhlyQ[2]));
			}else if(code.charAt(i)=='D'){
				fill(255,100);
				rect(0,0,20,20);
			}
			line(0,0,0,step);
		}

		float scal = 10.0;
		image(hand,(-hand.width/scal/2.0)-10,0,hand.width/scal,hand.height/scal);

		popMatrix();
	}
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

PImage img;

Recorder r;
boolean rec = false;

int num1 = 32;
int num2 = 32;

Neuron n[][];
Neuron in[] = new Neuron[2];
Neuron out[] = new Neuron[3];
float rs[],gs[],bs[];

void setup(){

	size(50*2,50,OPENGL);

	img = loadImage("kandinsky2.png");


	rs = new float[img.pixels.length];
	gs = new float[img.pixels.length];
	bs = new float[img.pixels.length];

	n = new Neuron[2][num1];

	for(int i = 0;i<n.length;i++){
		for(int w = 0;w<n[i].length;w++){
			if(i==0){
				n[i][w] = new Neuron(w,2,i);
			}else{
				n[i][w] = new Neuron(w,n[i].length,i);
			}
		}
	}

	in[0] = new Neuron(0,2,-1);
	in[1] = new Neuron(1,2,-1);

	out[0] = new Neuron(0,num1,-2);
	out[1] = new Neuron(1,num1,-2);
	out[2] = new Neuron(2,num1,-2);

	if(rec)
		r = new Recorder("out",in.length+"x"+num1+"x"+num1+"x"+out.length+"mp4");

}

void draw(){
	background(0);
	image(img,img.width,0);

	for(int y = 0;y<img.height;y++){
		for(int x = 0;x<img.width;x++){
			in[0].listen(x*50);
			in[1].listen(y*50);


			//inputs
			for(int i = 0;i<in.length;i++){
				in[i].compute();
			}


			//layers
			for(int i = 0;i<n.length;i++){
				for(int w = 0;w<n[i].length;w++){
					n[i][w].compute();
				}
			}

			//outputs
			for(int i = 0;i<out.length;i++){
				out[i].compute();
			}


			rs[y*img.width+x] = 0.5*abs(out[0].sum-red(img.pixels[y*img.width+x]));
			gs[y*img.width+x] = 0.5*abs(out[1].sum-green(img.pixels[y*img.width+x]));
			bs[y*img.width+x] = 0.5*abs(out[2].sum-blue(img.pixels[y*img.width+x]));



			noFill();
			stroke(out[0].sum,out[1].sum,out[2].sum);
			rect(x,y,1,1);

			int which = y*img.width+x;//(int)random(img.pixels.length);//y*img.width+x;
			backProp(out[0],250,map(rs[which] ,0,255,1,0.0));
			backProp(out[1],250,map(gs[which] ,0,255,1,0.0));
			backProp(out[2],250,map(bs[which] ,0,255,1,0.0));

		}
	}


	if(rec)
		r.add();

}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}

}

void backProp(Neuron _n,float rate,float target){
	Neuron current = _n;

	int top = 0;
	float vals = 0;

	for(int i =0;i<current.ins.length;i++){
		if(vals<current.weights[i]){
			vals = current.weights[i];//127-abs(current.weights[i]*n[1][current.ins[i]].sum-current.sum);
			top = i;
		}

		//current.weights[i]+=((2-target)-current.weights[top])/rate;
	}

	current.weights[top]+=(target-current.weights[top])/rate;

	Neuron next = n[1][current.ins[top]];
	vals = 0;
	top = 0;

	for(int i =0;i<next.ins.length;i++){
		if(vals<next.weights[i]){
			vals = next.weights[i];//127-abs(next.weights[i]*n[1][next.ins[i]].sum-next.sum);
			top = i;
		}
		//next.weights[i]+=((2-target)-next.weights[top])/rate;
	}

	next.weights[top]+=(target-next.weights[top])/rate;

	Neuron next2 = n[0][next.ins[top]];
	vals = 0;
	top = 0;

	for(int i =0;i<next2.ins.length;i++){
		if(vals<next2.weights[i]){
			vals = next2.weights[i];//127-abs(next2.weights[i]*n[1][next2.ins[i]].sum-next2.sum);
			top = i;
		}
		//next2.weights[i]+=((2-target)-next2.weights[top])/rate;
	}

	next2.weights[top]+=(target-next2.weights[top])/rate;

}


class Neuron{

	float x,y;
	int id,layer;
	int ins[];

	boolean active = true;

	float sum,sum2,rate = 20.0;
	float tresh;
	float weights[];

	Neuron(int _id,int _num,int _layer){
		id = _id;
		layer = _layer;

		tresh = 1.5;

		if(layer!=-2){
			x = layer*50+100;
			y = _id*5+5;
		}else{
			x = -layer*50+100;
			y = _id*5+5;
		}



		ins = new int[_num];
		weights = new float[_num];

		for(int i =0;i<weights.length;i++){
			weights[i] = random(0,100)/100.0;
			ins[i] = i;
		}


	}

	void listen(int a){
		sum = a;
	}

	void compute(){

		//	weights[i]+=random(100.0)/1000.0;

		for(int i = 0;i<weights.length;i++)
			weights[i] = constrain(weights[i],0,1);

		switch (layer){

		case -2:
			sum2 = 0;
			for(int i =0;i<ins.length;i++){
				//weights[i]+=random(100.0)/1000.0;

					sum2+=n[-layer-1][i].sum*weights[i];
				
			}
			
			//sum2=sum2/(ins.length+0.0);
			sum+=(sigmoidal(sum2)-sum)/rate;

			break;

		case 1:
			sum2 = 0;
			for(int i =0;i<ins.length;i++){
				//weights[i]+=random(-100.0,100.0)/10000.0;

					sum2+=n[layer-1][i].sum*weights[i];
				
			}
			//sum2=sum2/(ins.length+0.0);
			sum+=(sigmoidal(sum2)-sum)/rate;


			if(sum>tresh){
				active=true;
			}else{
				active = false;
			}

			break;

		case 0:
			sum2=((in[0].sum*weights[0])+(in[1].sum*weights[1]));
			//sum2=sum2/(ins.length+0.0);
			sum+=(sigmoidal(sum2)-sum)/rate;



			break;

		}

	}
	
	float sigmoidal(float inputValue){
		/*
			method just takes input as some real number and calculates the sigmoidal function of that value and return the same.
		*/
		return(float)((1.0/(1.0+Math.exp(-1.0*inputValue))));
		
		
	}


	void act(){

		compute();

		noFill();
		if(active){
			stroke(255,0,0);
		}else{
			stroke(255);
		}

		rect(x,y,3,3);



		stroke(255,20);

		if(layer>0){
			for(int i =0;i<ins.length;i++){
				line(n[layer-1][ins[i]].x,n[layer-1][ins[i]].y,x,y);
			}
		}else if(layer == 0){
			for(int i =0;i<ins.length;i++){
				line(in[ins[i]].x,in[ins[i]].y,x,y);
			}
		}else if(layer == -2){
			for(int i =0;i<ins.length;i++){
				line(n[-layer-1][ins[i]].x,n[-layer-1][ins[i]].y,x,y);
			}
		}


	}

}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

Neuron n[];
Neuron outs[];

int total;
float rs[],gs[],bs[];

PImage img;

float noiss[][];

int counts[] = { 2,32,16,3 };

float learnRate = 12000;

float treshold = 1.0;
float netEcho = 10.0;

void backProp(Neuron _first,float target,float rate){
	Neuron temp = _first;
	
	//input layer has no weights
	//if(temp.id>counts[0]){

		for(int q =0;q<counts.length;q++){

			float best = 0;
			int which = 0;

			for(int i =0;i<temp.ins.length;i++){
				if(temp.w[i]*n[temp.ins[i]].sum>best){
					best = temp.w[i]*n[temp.ins[i]].sum;
					which = i;
				}
				//temp.w[i]*=0.99999;
			}

			temp.w[which]+=(target-temp.w[which])/rate;//(target - temp.w[which])/rate;
			Neuron last = temp;
			temp = n[last.ins[which]];

		}
		
		
	//}
}


void setup(){

	size(512,320,P3D);


	img = loadImage("kandinsky2.png");

	rs = new float[img.pixels.length];
	gs = new float[img.pixels.length];
	bs = new float[img.pixels.length];
	noiss = new float[2][img.pixels.length];
	
	for(int i =0;i<noiss[0].length;i++){
		noiss[0][i] = random(255);
		noiss[1][i] = random(255);
	}
	
	total = 0;

	for(int i = 0; i < counts.length; i++){
		total+=counts[i];
	}
	//println(total-1);
	n = new Neuron[total];

	int iid = 0;
	int layer = 0;
	for(int i = 0; i < counts.length; i++){

		for(int w = 0; w < counts[i]; w++){

			if(i==0)
				n[iid] = new Neuron(iid,20+iid*10,20);
			if(i==1)
				n[iid] = new Neuron(iid,20+iid*10-20,100,0,1);
			if(i==2)
				n[iid] = new Neuron(iid,20+iid*10-340,180,1);
			if(i==3)
				n[iid] = new Neuron(iid,20+iid*10-(340+160),260,true);

			//println(iid+" = "+i);

			iid++;
		}

	}

	outs = new Neuron[counts[3]];
	for(int i = 0; i < outs.length; i++){
		outs[i] = n[n.length-i-1];
	}

	noFill();
	stroke(255);




}

void draw(){

	
	
	background(0);
	noFill();

	for(int y = 0;y<img.width;y++){

		for(int x = 0;x<img.width;x++){

			n[0].listen(noiss[0][y*img.width+x]);
			n[1].listen(noiss[1][y*img.width+x]);


			//pushMatrix();
			//translate(img.width*2,0);
			for(int i = 2; i < n.length; i++){
				n[i].compute();
			}
			//popMatrix();

			

			int which = y*img.width+x;
			rs[which] =  abs( red(img.pixels[which]) -  outs[0].sum );
			gs[which] = abs( green(img.pixels[which]) - outs[1].sum );
			bs[which] = abs(  blue(img.pixels[which]) - outs[2].sum );

				
			pushMatrix();
			translate(20,20);
			stroke(outs[0].sum,outs[1].sum,outs[2].sum);
			rect(x,y,1,1);
			popMatrix();
			
			backProp(n[n.length-1],map(rs[which],0,255,2,0),learnRate);
			backProp(n[n.length-2],map(gs[which],0,255,2,0),learnRate);
			backProp(n[n.length-3],map(bs[which],0,255,2,0),learnRate);
			

		}
	}
	

	pushMatrix();
	translate(img.width*2,0);
	for(int i = 0; i < n.length; i++){
		n[i].act();
	}
	popMatrix();
}



class Neuron{

	float x,y,w[];
	int id,ins[];
	int layer;
	float sum,ssum;
	boolean active = true;
	float tresh = treshold;
	

	//types


	//input layer neuron
	Neuron(int _id,float _x,float _y){

		layer = 0;
		x=_x;
		y=_y;
		id=_id;

		ins = new int[1];
		w = new float[1];
		ins[0] = 0;w[0] = 0;

	}


	//1st layer
	Neuron(int _id,float _x,float _y,int a, int b){

		layer = 1;
		x=_x;
		y=_y;
		id=_id;

		ins = new int[2];
		w = new float[2];

		ins[0] = a;
		ins[1] = b;

		w[0] = random(0,200)/100.0;
		w[1] = random(0,200)/100.0;
	}


	//2nd .. nNd layer neuron
	Neuron(int _id,float _x,float _y,int _layer){

		layer = 2;
		x=_x;
		y=_y;
		id=_id;

		ins = new int[getLayerCount(_layer)];
		ins = getLayerIDs(_layer);
		w = new float[ins.length];

		for(int i = 0; i < w.length; i++){
			w[i] = random(0,200)/100.0;
		}




	}


	//output layer neuron
	Neuron(int _id,float _x,float _y,boolean last){
		layer = 3;
		x=_x;
		y=_y;
		id=_id;

		ins = new int[getLayerCount(2)];
		ins = getLayerIDs(2);

		w = new float[ins.length];
		for(int i = 0; i < w.length; i++){
			w[i] = random(0,200)/100.0;
		}

	}




	int[] getLayerIDs(int _wha){

		int g = getLayerCount(_wha);
		int l1[] = new int[g];


		int cnt = 0;
		for(int i =0;i<n.length;i++){
			if(n[i]!=null){
				if(n[i].layer==_wha){
					l1[cnt]=i;cnt++;}}
		}

		int temp[] = new int[g];

		for(int i =0;i<ins.length;i++){
			temp[i] = l1[i];
		}

		return temp;

	}

	int getLayerCount(int _wha){

		int g = 0;
		for(int i =0;i<n.length;i++){
			if(n[i]!=null){
				if(n[i].layer==_wha)
					g++;}
		}
		return g;
	}

	void compute(){
		
		for(int i =0;i<w.length;i++){
			//w[i]*=1+random(-100,100)/1000.0;
			w[i] = constrain(w[i],0,20);
		}
		
		//tresh = treshold;

		if(id>1){
			ssum = 0;

			for(int i =0;i<ins.length;i++){
				if(n[ins[i]].active)
				ssum += n[ins[i]].sum*w[i];
			}

			sum += ((ssum/(ins.length+0.01))-sum)/netEcho;

			
			if(sum>tresh){
				active = true;
				//sum=ssum;

			}else{
				active = false;
			}
		}


	}

	void listen(float q){
		sum = q;
	}

	void act(){


		//	compute();

		if(active){
			stroke(255);
		}else{
			stroke(120,0,0);
		}
		rect(x,y,3,3);


		for(int i = 0; i < ins.length; i++)
		{
			stroke(255,w[i]*10.0);
			line(n[ins[i]].x,n[ins[i]].y,x,y);

		}
	}




}

Neuron n [];
Monitor m;
int num = 620;

boolean visible = false;

boolean tc []= {true,false,true,false,true,false,true,false,true,false};

void setup(){
	size(300,400,OPENGL);
	background(0);

	n = new Neuron[num];
	m = new Monitor();

	for(int i = 0;i<n.length;i++){
		n[i] = new Neuron(i,5,random(10,width-10),random(20,height-20));

	}

	textFont(createFont("Veranda",9));

	fill(255);
	rectMode(CENTER);

}

void draw(){

	background(0);

	for(int i = 0; i < n.length; i++){
		if(visible){
			n[i].compute();
		}else{
			n[i].act();

		}
	}

	m.act();

}

void keyPressed(){

	if(key==' ')
	visible=!visible;

}

class Neuron{

	boolean state = true;
	int ins[];
	float weights[];
	int id;
	float treshold = 0,sum,lastSum;
	float x,y;
	int nn;


	Neuron(int _id, int _nn,float _x,float _y){
		id=_id;
		x=_x;
		y=_y;
		nn = _nn;

		nn=constrain(nn,1,n.length-2);

		reset();
	}

	void reset(){

		ins = new int[nn];
		weights = new float[ins.length];

		for(int i = 0; i < ins.length; i++){
			ins[i] = -1;
		}

		for(int i = 0; i < ins.length; i++){

			int temp = (int)random(n.length);

			if(temp==id||!other(temp)){
				while(temp==id||!other(temp)){
					temp=(temp+1)%(ins.length);
				}
			}

			ins[i] = temp;
			weights[i] = random(-100,100)/10.0;

		}

	}

	boolean other(int in){
		boolean ans = true;

		for(int i = 0; i < ins.length; i++)
		{
			if(in==ins[i])
				ans = false;
		}
		return ans;

	}


	void compute(){
		lastSum = 0;
		for(int i = 0; i < ins.length; i++){
			if(n[ins[i]].state)
				lastSum+=weights[i];
		}

		lastSum/=ins.length+0.0;

		sum += (lastSum-sum)/10.5;

		if(sum > treshold){
			state = true;
		}else{
			state = false;
		}


		addNoise(0.05);

	}

	void setActive(){
		state = true;
	}

	void addNoise(float we){
		treshold+=random(-we,we)/1000.0;
		treshold=constrain(treshold,-1,1);
	}

	void act()  {

		compute();


		for(int i = 0; i < ins.length; i++){
			stroke(255,map(weights[i],-5,10,0,30));
			line(n[ins[i]].x,n[ins[i]].y,x,y);
			
			float distA = dist(n[ins[(i+1)%ins.length]].x,n[ins[i]].y,x,y);
			float distB = dist(n[ins[i]].x,n[ins[i]].y,x,y);
					
	
		}

		
		if(state){
			fill(255,0,0,map(sum,-10,10,0,255));
		}else{
			fill(255,map(sum,-10,10,0,255));
		}
		rect(x,y,3,3);
		



	}


}

void mousePressed(){
	for(int i =0;i<n.length;i++)
		n[i].reset();

}

class Monitor{
	boolean senz[];
	int ins[];
	float rate = 20.0;
	int run;
	boolean rightResult = true;
	int vals[];

	int happy = 0,sad = 0;

	Monitor(){
		senz = new boolean[tc.length];
		initial();

	}

	void initial(){
		ins = new int[senz.length];

		vals = new int[senz.length];


		for(int i = 0; i < ins.length; i++){
			ins[i] = -1;
			vals[i] = 0;
		}

		for(int i = 0; i < ins.length; i++){

			int temp = (int)random(n.length);

			if(!other(temp)){
				while(!other(temp)){
					temp=(temp+1)%(ins.length);
				}
			}

			ins[i] = temp;


		}


		run = 0;
	}

	boolean other(int in){
		boolean ans = true;

		for(int i = 0; i < ins.length; i++)
		{
			if(in==ins[i])
				ans = false;
		}
		return ans;

	}


	void act(){


		run++;

		stroke(255,0,0,200);
		float perc = 0;
		int right = 0;

		for(int i = 0; i < ins.length; i++){
			senz[i] = n[ins[i]].state;
			if(senz[i]){
				fill(255);
				vals[i]+=3;
			}else{
				fill(0);
			}

			line(i*10+width/2.0-(tc.length*10/2.0),10,n[ins[i]].x,n[ins[i]].y);
			rect(i*10+width/2.0-(tc.length*10/2.0),10,10,10);


			if(tc[i]){
				fill(255);

			}else{
				fill(0);
			}

			rect(i*10+width/2.0-(tc.length*10/2.0),height-10,10,10);

			fill(255,vals[i]);
			rect(i*10+width/2.0-(tc.length*10/2.0),height-20,10,10);

			if(senz[i]=tc[i]){
				feedback(ins[i],10.0,num*10);

			}else{

				feedback(ins[i],-10.0,num*10);

			}

		}

		if(run>200){
			run=0;
			tc = new boolean[10];

			for(int i = 0; i < tc.length; i++)
			{
				if(random(500.0)>250.0){
					tc[i]=false;
				}else{
					tc[i]=true;
				}
				vals[i] = 0;
			}

		}




		fill(255);
		text("+"+happy+"/ -"+sad,10,10);


	}

	void feedback(int qq,float target,int depth){


		int current = qq;
		int next = 0;

		for(int e = 0;e<depth;e++){

			float mm = -2.0;
			int top = 0;

			for(int i =0;i<n[current].ins.length;i++){

				if(mm<n[current].weights[i]){
					mm = n[current].weights[i];
					top = i;
					next = n[current].ins[top];
				}
			}


			n[current].weights[top]+=(target-n[current].weights[top])/(rate+map(e,0,depth,0,rate*10.0));
			current = next;

		}
	}




}





float boom = 0.96078444;//-1.00622;//-1.0056844;//-1.010625;
float TRESH = 6.1764708;// 0.675;

float INSCALE = 1.0;

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

int layers[];
Neuro n[][];

float mapperR = 1.0,mapperG = 1.0,mapperB = 1.0;

float IN[];
float OUT[];

boolean learning = true;

PImage img;
Recorder r;
boolean rec = false;

float sqerr = 255.0;
float er[];//,eg[],eb[];

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

void setup(){
	img = loadImage("kandinsky3.png");

	layers= new int[3];
	layers[0] = (img.width);
	layers[1] = (int)(img.width*0.3);
	layers[2] = (img.width);


	size(img.width+40,img.height+40,OPENGL);

	er = new float[img.width];
	//eg = new float[img.pixels.length];
	//eb = new float[img.pixels.length];

	reset();

	noFill();
	rectMode(CENTER);

	if(rec){
		String name = "";
		for(int i =0;i<layers.length;i++){
			if(i>0)
				name+="x";
			name+=layers[i];
		}
		name+=".mp4";
		r = new Recorder("out",name);
	}
	

}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

void draw(){

	background(0);

	//interact();

	pushMatrix();
	translate(20,20);

	for(int y = 0;y<img.height;y++){
		for(int x = 0;x<img.width;x++){

			int which = y*img.width+x;
			IN[x] = x;//brightness(img.pixels[which]);//+random(-5,5);
			
			globComp();
			
			er[x] = abs(brightness(img.pixels[which])-OUT[x]);
			sqerr+=(er[x]-sqerr)/(img.pixels.length+0.0);
			
			stroke(OUT[x]);
			line(x,y,x+1,y);

		}
	}
	
		popMatrix();

	




	if(learning){

		for(int y = 0;y<img.height;y++){
			for(int x = 0;x<img.width;x++){


				float power = (img.pixels.length+0.0);
				backProp(n[n.length-1][0],
				         (er[x]),
				         power);
					 
					 //println();

			}
		}
		//exit();

		//if(frameCount%100==0)
			println(sqerr);

	}




	if(rec)
		r.add();


}

void globComp(){
	for(int i = 0;i<n.length;i++){
		for(int q = 0;q<n[i].length;q++){
			n[i][q].compute();
		}
	}

}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

void reset(){

	n = new Neuro[layers.length][0];
	for(int i = 0;i<n.length;i++){
		for(int q = 0;q<layers[i];q++){
			n[i] = (Neuro[])expand(n[i],n[i].length+1);
			if(i==0&&q==layers[0]-1){
				n[i][q] = new Neuro(0);
			}else{
			n[i][q] = new Neuro(i,q);
			}
		}
	}

	IN = new float[layers[0]];
	OUT = new float[layers[layers.length-1]];



}


/////////////////////////////////////////////////////
/////////////////////////////////////////////////////


void interact(){
	TRESH = map(mouseX,0,width,0,100);
	//TRESH = 0.68;
}


/////////////////////////////////////////////////////
/////////////////////////////////////////////////////


void mousePressed(){
	println(boom+" : "+TRESH+" : "+INSCALE);
	reset();

}


/////////////////////////////////////////////////////
/////////////////////////////////////////////////////


void keyPressed(){
	if(key=='w')
	{	saveWeights();
	}else if(key=='r'){
		loadWeights();
	}else if(key == 'l'){
		learning=!learning;
	}else if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}


}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

float sigmoidal(float inputValue){

	//println((mouseX-width/2.0)+":"+(mouseY-height/2.0));
	return(float)((boom/((boom)+Math.exp(TRESH*(inputValue)))));

}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

float derivative(float input){

	return(1.0-(sigmoidal(input)*(1.0-sigmoidal(input)))*4.0);
}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

void saveWeights(){

	String data[] = new String[0];
	data = (String[])expand(data,data.length+1);
	data[data.length-1] = ":";

	for(int i =0;i<n.length;i++){
		data[data.length-1] += " "+layers[i];
	}

	for(int i =1;i<n.length;i++){


		for(int q =0;q<n[i].length;q++){
			data = (String[])expand(data,data.length+1);
			data[data.length-1] = i+" "+q+" :";
			for(int r = 0;r<n[i][q].w.length;r++)
				data[data.length-1] += " "+n[i][q].w[r]*10000000.0;
		}
	}


	String name = "";
	for(int i =0;i<layers.length;i++){
		if(i>0)
			name+="x";
		name+=layers[i];
	}

	saveStrings(name+".txt",data);
	println("state saved");
}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

void loadWeights(){
	String name = "";
	for(int i =0;i<layers.length;i++){
		if(i>0)
			name+="x";
		name+=layers[i];
	}

	String[] data = loadStrings(name+".txt");

	String header = data[0]+"";
	String code[] = splitTokens(header," :");
	boolean valid = false;

	int err = 0;
	if(code.length==layers.length){
		for(int i = 0;i<code.length;i++){
			if(parseInt(code[i])!=layers[i])
				err+=1;
		}
	}

	if(err==0){
		valid = true;
	}



	if(valid){
		for(int i =1;i<data.length;i++){
			String radek = data[i]+"";
			String temp[] = splitTokens(radek,",: ");
			int lay = parseInt(temp[0]);
			int which = parseInt(temp[1]);
			for(int q = 0;q<n[lay][which].w.length;q++){
				n[lay][which].w[q] = parseFloat(temp[q+2])/10000000.0;
			}

		}
		println("new weight set loaded");
	}else{
		println("data in file do not represent a data for current network");
	}

}


/////////////////////////////////////////////////////
/////////////////////////////////////////////////////


void backProp(Neuro _first,float target,float rate){
	Neuro temp = _first;

	//input layer has no weights
	//if(temp.id>counts[0]){

	for(int q =0;q<n.length-1;q++){

		int rr = (int)random(temp.ins.length);
		float best = temp.w[rr];
		int which = rr;

		for(int i =0;i<temp.ins.length;i++){
			if(temp.w[i] > best){
				best =temp.w[i];
				which = i;
			}
		}

		//if(q>0)
		temp.w[which]+=(target-temp.w[which])/(rate);
		Neuro last = temp;
		temp = n[last.layer-1][last.ins[which]];


	}

}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

void drawFunction(){
	stroke(255);
	for(int i =0;i<width;i++){
		rect(i,(sigmoidal(i/(width+0.0)))*height,1,1);
	}
}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

class Neuro{

	float x,y,w[],tresh;
	int id,ins[],layer;
	float sum,sum2;
	boolean biased = false;

	Neuro(int _layer,int _id){

		id = _id;
		layer = _layer;

		if(layer!=0){
			ins = new int[n[layer-1].length];
			w =  new float[ins.length];


			if(layer==n.length-1){
				int g = 0;
				for(int i =0;i<n[layer-1].length;i++){
					ins[g] = i;
					w[g] = random(-500,500)/1000.0;
					g++;
				}
			}else{

				int g = 0;
				for(int i =0;i<n[layer-1].length;i++){
					ins[g] = i;
					w[g] = random(-500,500)/1000.0;
					g++;
				}
			}


		}

		x = id*10;
		y = layer *10;

		tresh = TRESH;
	}
	
	Neuro(int _bias){
		layer = 0;
		id = layers[0]-1;
		sum = _bias;
		biased = true;
	}

	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////

	void compute(){



		if(layer!=0){

			//for(int i =0;i<w.length;i++){//w[i]+=random(-10,10)/10000000.0;
				//w[i] = constrain(w[i],-1,1);}

			sum2 = 0;

			if(layer>0&&layer<n.length-1){
				for(int i = 0;i<ins.length;i++){
					sum2+=w[i]*n[layer-1][ins[i]].sum;
				}
				sum2/=(ins.length+0.0);
				sum2 = sigmoidal(sum2);

			}else{

				for(int i = 0;i<ins.length;i++){
					sum2+=(w[i]*n[layer-1][ins[i]].sum);
				}
				
				//sum2/=ins.length;

				//if(layer==n.length-1)
				
			}

			//sum2 = 
			sum = sum2;//(sum2-sum)/10.51;
		}else{
			if(!biased)
			sum = IN[id];
		}

		if(layer == layers.length-1){
			OUT[id] = sum;
		}

	}

	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////

	void act(){

		if(layer!=0)
			for(int i = 0;i<ins.length;i++){
				stroke(255,w[i]*12700000);
				line(n[layer-1][ins[i]].x,n[layer-1][ins[i]].y,x,y);
			}

		stroke(255,sum);
		rect(x,y,3,3);
	}
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
int num = 64*64*64;
int cntr = 0;
Neuron n[];
Monitor m;
Recorder r;

boolean rec = true;
boolean obr = false;

PImage img;
PGraphics input;


/////////////////////////////////////////////////// >> SETUP

void setup(){
	size(128*2,64*2,OPENGL);

	n = new Neuron[num];

	generateIn();

	for(int i =0;i<num;i++){
		n[i] = new Neuron(i,30,0.0);
	}

	m = new Monitor(64,16);

	if(rec)
		r = new Recorder ("out","ai.mp4");

	stroke(255);
	noFill();
	rectMode(CENTER);

}



/////////////////////////////////////////////////// >> LOOP

void draw(){
	background(0);

	noFill();
	for(int i =0;i<num;i++){
		n[i].compute();
	}

	m.act();


	if(rec)
		r.add();
}


/////////////////////////////////////////////////// >> FUNCT

void generateIn(){
	obr=!obr;
	if(obr){
		img = loadImage("input.png");
	}else{
		img = loadImage("input2.png");

	}
	input = createGraphics(img.width,img.height,JAVA2D);
	input.beginDraw();
	input.image(img,0,0);
	input.endDraw();

	input.loadPixels();

}

void mousePressed(){
	generateIn();

}

void keyPressed(){
	if(key=='q'){

		if(rec)
			r.finish();
		exit();
	}
}

/////////////////////////////////////////////////// >> NEURON

class Neuron{

	float weight,trigger,x,y;
	int id,ins[],out,in;
	float sum = 0;
	float mods[];
	boolean bang = true;


	/////////////////////////////////////////////////// >> construct

	Neuron(int _id,int _in,float _trigger){
		id=_id;
		in = _in;

		trigger = _trigger;
		

		/*
				if(cntr<input.pixels.length){

					weight = input.pixels[cntr];
					cntr ++;

				}else{
				
				if(id<input.pixels.length){
			weight = (int)((brightness(input.pixels[id])/255.0)-0.5);//random(255);
		}else{
		*/
				
		weight = random(0.1,10.0);
				
				
		//}

		x = 0;//random(width);
		y = 0;//random(height/2.0);

		ins = new int[(int)random(in-2)+1];
		mods = new float[ins.length];


		for(int i =0;i<ins.length;i++){
			ins[i] = -1;
			mods[i] = random(-1000.0,1000.0)/500.0;
		}

		for(int i =0;i<ins.length;i++){

			int a = (int)random(num);
			int counter = 0;

			if(a==id||!checkValidity(a)){
				while(a==id||!checkValidity(a)){
					counter ++;
					a = (int)random(num);
					if(counter>100)
						return;
				}
			}

			ins[i] = a;

		}

		int _out = (int)random(num);

		int c = 0;

		if(_out==id){
			while(_out==id){
				c++;
				_out = (int)random(num);
				if(c>1000)
					return;
			}
		}

		out =_out;
		//println(id+" created");

	}


	/////////////////////////////////////////////////// >> validity

	boolean checkValidity(int number){
		boolean answr = true;
		for(int i = 0;i<ins.length;i++){
			if(number==ins[i])
				answr = false;
		}
		return answr;

	}


	/////////////////////////////////////////////////// >> noise

	void noiseMe(float kolik){
		for(int i =0;i<ins.length;i++){
			mods[i]+=random(-kolik,kolik)/100000.0;
			mods[i] = constrain(mods[i],-2.0,2.0);
		}

	}


	/////////////////////////////////////////////////// >> compute

	void compute(){

		noiseMe(10000.0);

		weight = constrain(weight,-10,10);

		float sum2 = 0;

		for(int i =0;i<ins.length;i++){
			if(n[ins[i]].bang)
				sum2+=n[ins[i]].weight*mods[i];
		}

		sum+=(sum2-sum)/8.0;

		
		if (sum > trigger*(in+0.0)){
			bang = true;
		}else{
			bang = false;

		}



	}


	/////////////////////////////////////////////////// >> act

	void act(){

		compute();


		if(bang){
			stroke(255,0,0);
			//fill(255,0,0,25);
		}else{
			stroke(map(sum/in,-2,0,0,255),100);
			//noFill();
		}
		rect(x,y,weight/25.0,weight/25.0);
		stroke(255,20);
		for(int i =0;i<ins.length;i++){
			if(mods[i]>0.98&&n[ins[i]].bang)
				line(x,y,n[ins[i]].x,n[ins[i]].y);

		}
		//stroke(255,0,0,155);
		//line(x,y,n[out].x,n[out].y);

	}

}


/////////////////////////////////////////////////// >> MONITOR

class Monitor{

	int w,h,x,y;
	int no[];
	float val[];
	float diff[];

	float rate = 3.0;


	/////////////////////////////////////////////////// >> construct

	Monitor(int _x,int _y){
		x=_x;
		y=_y;
		w=input.width;
		h=input.height;

		no = new int[w*h];
		val = new float[w*h];
		diff = new float[input.width*input.height];


		for(int i =0;i<no.length;i++){
			no[i] = -1;

			int q = (int)random(num);
			if(!checkValidity(q)){

				int counter = 0;

				while(!checkValidity(q)){
					counter ++;
					q = (int)random(num);
					if(counter>100)
						return;
				}


			}

			no[i] = q;

		}

	}


	/////////////////////////////////////////////////// >> act

	void act(){

		for(int i =0;i<val.length;i++){
			val[i] = n[no[i]].sum;
		}

		noStroke();
		for(int X =0;X<w;X++){
			for(int Y =0;Y<h;Y++){
				diff[Y*h+X] = abs(brightness(input.pixels[Y*h+X])-map(val[Y*h+X],-2,2,0,255));
				fill(map(val[Y*h+X],-2,2,0,255));
				rect(x+X,y+Y,1,1);

			}
		}

		for(int i =0;i<val.length;i++){
			diff[i] = abs(brightness(input.pixels[i])-map(val[i],-2,2,0,255));
			feedback(i,map(diff[i],255,0,-2.0,2.0),30);
		}

		noFill();
		
		for(int X =0;X<w;X++){
			for(int Y =0;Y<h;Y++){
				stroke(diff[Y*h+X]);
				rect(w+x+X,y+Y,1,1);

			}
		}


	}

	/*	int[] trace(int ina){
			int[] res = new int[0];

			res = (int[])expand(res,res.length+1);
			res[res.length-1] = n[no[i]].id;

			for(int i = 0;i<n[no[i]])

				return res;
		}*/


	/////////////////////////////////////////////////// >> feedback

	void feedback(int qq,float target,int depth){


		int current = qq;
		int next = 0;

		for(int e = 0;e<depth;e++){

			float mm = -2.0;
			int top = 0;

			for(int i =0;i<n[current].ins.length;i++){

				if(mm<n[current].mods[i]){
					mm = n[current].mods[i]*n[n[current].ins[i]].weight;
					top = i;
					next = n[current].ins[top];
				}
			}


			n[current].mods[top]+=(target-n[current].mods[top])/rate;
			current = next;

		}
	}
	
	void feedback2(int qq,float target,int depth){


		int current = qq;
		int next = 0;

		for(int e = 0;e<depth;e++){

			float mm = -2.0;
			int top = 0;

			for(int i =0;i<n[current].ins.length;i++){

				if(mm<n[current].mods[i]){
					mm = n[current].mods[i]*n[n[current].ins[i]].weight;
					top = i;
					next = n[current].ins[top];
				}
				
				n[current].mods[i]+=(target-n[current].mods[i])/(rate*(abs(n[current].mods[i]-n[current].mods[top])));
			}


			n[current].mods[top]+=(target-n[current].mods[top])/rate;
			current = next;

		}
	}


	/////////////////////////////////////////////////// >> validity


	boolean checkValidity(int number){
		boolean answr = true;
		for(int i = 0;i<val.length;i++){
			if(number==val[i])
				answr = false;
		}
		return answr;

	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import processing.opengl.*;


Recorder r;

String code = "";
float[] rada = new float[0];
float[] uhly = {2.0,-5.0,35.0,-90.0};
float step = 10.0;
float x,y;

boolean rec = false;

void setup(){
	size(800,550,OPENGL);

	x = width-(2*width/PI);
	y = height/2.0;
	code = codeGen(10,0,0,0);

	for(int i =0 ;i<code.length();i++){
		rada = (float[])expand(rada,rada.length+1);
		if(code.charAt(i)=='A'){
			rada[rada.length-1] = uhly[0];
		}else if(code.charAt(i)=='B'){
			rada[rada.length-1] = uhly[1];
		}else if(code.charAt(i)=='C'){
			rada[rada.length-1] = uhly[2];
		}else if(code.charAt(i)=='D'){
			rada[rada.length-1] = uhly[3];
		}
	}
	
	textFont(createFont("Vernda",9));
	//textMode(SCREEN);

	stroke(255,15);
	fill(255,95);
	
	smooth();

	if(rec)
	r = new Recorder("out","output2.mp4");


}


void draw(){
	
	rada[frameCount%rada.length] = mouseX/(10+1.0);
	background(0);

	float[] qasi = rada;
	
	
	for(int q = 1;q<rada.length;q++){
	qasi = randomize(q);
	
		pushMatrix();
	translate(x,y);

	for(int i =0;i<rada.length;i++){
		
		rotate(radians(qasi[i]));
		line(0,0,0,-step);
		translate(0,-step);
	}
	text(q,0,0);
	popMatrix();
	
	}
	
	
	if(rec)
		r.add();



}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		
		exit();
	
	}

}

float[] randomize(int _in){
	return sort(rada,_in);
}



String codeGen(int a,int b,int c,int d){
	String res = "";
	for(int i =0 ;i<a+b+c+d;i++){
		float q =  random(a+b+c+d);
		if(q<=a){
			res+="AAAAA";
		}else if(q<=a+b&&q>a){
			res+="BB";
		}else if(q<=a+b+c&&q>a+b){
			res+="C";
		}else if(q>c&&i>(a+b+c+d)/3.0){
			res+="D";
		}
	}
	return res;
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
class Modul{

	String code = "";
	float[] rada = new float[0];
	float[] uhly = {2.0,-5.0,35.0,-90.0};
	float step = 10.0;
	float x,y;
	int id;

	Modul(float _x,float _y,int _id){
		id = _id;
		x = _x;//width-(2*width/PI);
		y = _y;//height/2.0;
		code = codeGen(10,0,0,0);

		for(int i =0 ;i<code.length();i++){
			rada = (float[])expand(rada,rada.length+1);
			if(code.charAt(i)=='A'){
				rada[rada.length-1] = uhly[0];
			}else if(code.charAt(i)=='B'){
				rada[rada.length-1] = uhly[1];
			}else if(code.charAt(i)=='C'){
				rada[rada.length-1] = uhly[2];
			}else if(code.charAt(i)=='D'){
				rada[rada.length-1] = uhly[3];
			}
		}

	}

	void live(){

		rada[frameCount%rada.length] += (dist(x,y,mouseX,mouseY)/(10+1.0)-rada[frameCount%rada.length])/1.1;
		//
		for(int i = 0;i<m.length;i++){
			if(i!=id)
				rada[frameCount%rada.length] += (m[i].rada[frameCount%rada.length]-rada[frameCount%rada.length])/(m.length+1.0);
		}

		float[] qasi = rada;


		for(int q = 1;q<rada.length;q++){
			qasi = randomize(q);

			pushMatrix();
			translate(x,y);

			for(int i =0;i<rada.length;i++){
				pushStyle();
				if(i==(frameCount%rada.length))
				{
					stroke(#FF0000,55);

				}
				rotate(radians(qasi[i]+(2.0-dist(modelX(0,0,0),modelY(0,0,0),x,y)/6.0)));
				line(0,0,0,-step);
				popStyle();
				translate(0,-step);
			}
			text(q,0,0);
			popMatrix();

		}

	}

	float[] randomize(int _in){
		return sort(rada,_in);
	}



	String codeGen(int a,int b,int c,int d){
		String res = "";
		for(int i =0 ;i<a+b+c+d;i++){
			float q =  random(a+b+c+d);
			if(q<=a){
				res+="AAAAA";
			}else if(q<=a+b&&q>a){
				res+="BB";
			}else if(q<=a+b+c&&q>a+b){
				res+="C";
			}else if(q>c&&i>(a+b+c+d)/3.0){
				res+="D";
			}
		}
		return res;
	}


}
import processing.opengl.*;


Recorder r;
Modul m[] = new Modul[3];


boolean rec = false;

void setup(){
	size(720,576,OPENGL);
	for(int i =0 ; i< m.length;i++){

		m[i] = new Modul(map(i,0,m.length-1,100,width-100),height/3.0*2.0+random(-100,100),i);
	}

	textFont(createFont("Vernda",9));
	//textMode(SCREEN);

	stroke(255,15);
	fill(255,95);

	smooth();

	if(rec)
		r = new Recorder("out","dance.mp4");


}


void draw(){

	background(0);

	for(int i =0 ; i< m.length;i++){
		m[i].live();
		
		pushStyle();
		
		stroke(255,255-dist(m[i].x,m[i].y,mouseX,mouseY)/3.0);
			line(m[i].x,m[i].y,m[i].x,height);
			
		
		popStyle();
	}


	if(rec)
		r.add();



}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();

		exit();

	}

}


class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

/*
She is dancing I am dreaming,.
my first, yet imperfect, artificial neural network is learning the shapes of my crappy hand written letter 'A'.. as well as she is teaching me how the neural net actually works.
The movements is caused by changes in her node-weights and gives quite good illustration of her (quite weak) functionality.

Enjoy the neural dance. 

*/

Neuron n [];
Monitor m;
int num;

boolean rec = true;

Recorder r;

int nextOne = 0;
PImage img,imgs[];

boolean visible = true;

boolean tc [];//= {true,false,true,false,true,false,true,false,true,false};

void setup(){
	size(576,320,OPENGL);
	background(0);


	img = loadImage("a.png");


	imgs = new PImage[9];
	for(int i = 1; i < 10; i++){

		imgs[i-1] = loadImage("a00"+i+".png");

	}
	tc= new boolean[img.pixels.length];

	for(int i = 0; i < tc.length; i++){
		if(brightness(img.pixels[i])>127){
			tc[i] = true;
		}else{
			tc[i] = false;
		}
	}

	num = 2000;
	n = new Neuron[num];
	m = new Monitor(3.0);

	for(int i = 0;i<n.length;i++){
		n[i] = new Neuron(i,5,random(width/2.0-15,width/2.0+15)+40,map(i,0,num,70,height-5), 30.0);

	}

	textFont(createFont("Veranda",9));

	fill(255);
	rectMode(CENTER);

	if(rec)
		r= new Recorder("out","learningNN.avi");

}

void draw(){

	background(0);

	for(int i = 0; i < n.length; i++){
		if(!visible){
			n[i].compute();
		}else{
			n[i].act();

		}
	}

	m.act();

	if(rec)
		r.add();

}

void keyPressed(){

	if(key==' '){
		visible=!visible;
	}else if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}else if(keyCode==ENTER){
	saveFrame("frame-####.png");
	}
}

class Neuron{

	boolean state = true;
	int ins[];
	float weights[];
	int id;
	float treshold = 0,sum,lastSum;
	float x,y,rate;
	int nn;


	Neuron(int _id, int _nn,float _x,float _y,float _rate){
		id=_id;
		x=_x;
		y=_y;
		nn = _nn;
		rate = _rate;

		nn=constrain(nn,1,n.length-2);

		reset();
	}

	void reset(){

		ins = new int[nn];
		weights = new float[ins.length];

		for(int i = 0; i < ins.length; i++){
			ins[i] = -1;
		}

		for(int i = 0; i < ins.length; i++){

			int temp = (int)random(id-nn-1,id+100*nn+1);

			if(temp==id||!other(temp)||temp==n.length-1){
				while(temp==id||!other(temp)||temp==n.length-1){
					temp = (int)random(id-nn-1,id+100*nn+1);//=(temp+1)%(ins.length);

					temp = constrain(temp,id-nn-1,n.length-1);
				}
			}
			
			
					temp = constrain(temp,0,n.length-1);


			ins[i] = temp;
			weights[i] = random(-10,10)/10.0;

		}

	}

	boolean other(int in){
		boolean ans = true;

		for(int i = 0; i < ins.length; i++)
		{
			if(in==ins[i])
				ans = false;
		}
		return ans;

	}


	void compute(){
		lastSum = 0;
		for(int i = 0; i < ins.length; i++){
			if(n[ins[i]].state)
				lastSum+=weights[i];
		}

		lastSum/=ins.length+0.0;

		sum += (lastSum-sum)/rate;

		
		x+=((map(sum,-3,3,15,width-15)+40)-x)/40.0;
		
		if(sum > treshold){
			state = true;
		}else{
			state = false;
		}


		addNoise(0.05);

	}

	void setActive(){
		state = true;
	}

	void addNoise(float we){
		treshold+=random(-we,we)/1000.0;
		treshold=constrain(treshold,-1,1);
	}

	void act()  {

		compute();


		for(int i = 0; i < ins.length; i++){
			stroke(255,map(weights[i],-3,3,2,25));
			line(n[ins[i]].x,n[ins[i]].y,x,y);

			//float distA = dist(n[ins[(i+1)%ins.length]].x,n[ins[i]].y,x,y);
			//float distB = dist(n[ins[i]].x,n[ins[i]].y,x,y);


		}


		if(state){
			fill(255,0,0,map(sum,-5,5,0,100));
		}else{
			fill(255,map(sum,-5,5,0,100));
		}
		rect(x,y,3,3);




	}


}

void mousePressed(){
	for(int i =0;i<n.length;i++)
		n[i].reset();

}

class Monitor{
	boolean senz[];
	int ins[];
	float rate = 20.0;
	int run;
	boolean rightResult = true;
	int vals[];

	int happy = 0,sad = 0;

	Monitor(float _rate){
		rate = _rate;
		senz = new boolean[tc.length];
		initial();

	}

	void initial(){
		ins = new int[senz.length];

		vals = new int[senz.length];


		for(int i = 0; i < ins.length; i++){
			ins[i] = -1;
			vals[i] = 0;
		}

		for(int i = 0; i < ins.length; i++){

			int temp = (int)random(tc.length+1);

			if(!other(temp)){
				while(!other(temp)){
					temp=(temp+1)%(ins.length);
				}
			}

			ins[i] = temp;


		}


		run = 0;
	}

	boolean other(int in){
		boolean ans = true;

		for(int i = 0; i < ins.length; i++)
		{
			if(in==ins[i])
				ans = false;
		}
		return ans;

	}


	void act(){


		int XX=0,YY=0;

		run++;

		//stroke(255,0,0,200);
		noStroke();
		float perc = 0;
		int right = 0;
		
		stroke(255,15);
		noFill();
		
		rect(width/2.0+40-1,15+16-2,36,36);
		rect(width/2.0-1,15+16-2,36,36);
		rect(width/2.0-40-1,15+16-2,36,36);
		
		
		for(int i = 0; i < ins.length; i++){
			senz[i] = n[ins[i]].state;
			if(senz[i]){
				fill(255);
				vals[i]+=3;
			}else{
				fill(0);
			}

			line(XX*2+width/2.0-(img.width)+40,15+YY*2,n[ins[i]].x,n[ins[i]].y);


			if(XX>=img.width){
				XX=0;
				YY++;
			}

			rect(XX*2+width/2.0-(img.width)+40,15+YY*2,2,2);


			if(tc[i]){
				fill(255);

			}else{
				fill(0);
			}

			rect(XX*2+width/2.0-(img.width)-40,15+YY*2,2,2);

			fill(255,vals[i]);
			rect(XX*2+width/2.0-(img.width),15+YY*2,2,2);

			if(senz[i]=tc[i]){
				feedback(ins[i],10.0,num);

			}else{

				feedback(ins[i],-10.0,num);

			}

			XX++;

		}


		if(run>200){
			run=0;

			img = imgs[nextOne%imgs.length];
			nextOne ++;

			img.updatePixels();
			tc= new boolean[img.pixels.length];

			for(int i = 0; i < tc.length; i++){
				if(brightness(img.pixels[i])>127){
					tc[i] = true;
				}else{
					tc[i] = false;
				}
				vals[i] = 0;
			}



		}




		fill(255,255*(sin(frameCount/30.0)+1));
		text("learning ..",10,10);


	}

	void feedback(int qq,float target,int depth){


		int current = qq;
		int next = 0;

		for(int e = 0;e<depth;e++){

			float mm = -2.0;
			int top = 0;

			for(int i =0;i<n[current].ins.length;i++){

				if(mm<n[current].weights[i]){
					mm = n[current].weights[i];
					top = i;
					next = n[current].ins[top];
				}
			}


			n[current].weights[top]+=(target-n[current].weights[top])/(rate+map(e,0,depth,0,rate*2.0));
			current = next;

		}
	}




}



class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}


float boom = 9.333329;
float TRESH = 11.75;

float sigmoidal(float inputValue){

	//println((mouseX-width/2.0)+":"+(mouseY-height/2.0));
	return(float)((boom/((boom)+Math.exp(TRESH*(inputValue)))));

}

float derivative(float input){

	return(1.0-(sigmoidal(input)*(1.0-sigmoidal(input)))*2.0);
}


void setup(){
	size(255,255,OPENGL);
	

}


void draw(){
	background(255);
	
	TRESH = map(mouseY,height,0,0,30);
	boom = map(mouseX,0,width,-5,5);
	
	for(int i =0;i<width;i++){
		stroke(0);
		float y = sigmoidal(map(i,0,width,-1,1))*height;
		line(i,y,i,y+1);
		stroke(255,0,0);
		float _y = derivative(map(i,0,width,-1,1))*height;
		line(i,_y,i,_y+1);
	
	}
	
	stroke(0,40);
	line(0,height/2.0,width,height/2.0);
	line(width/2.0,0,width/2.0,height);


}

void mouseClicked(){
	println(TRESH+" : "+boom);


}

PImage clanek;
Kostra k;


void setup(){
	size(400,400,P3D);

	clanek = loadImage("bone.png");

	k = new Kostra(10);

}


void draw(){
	background(255);

	k.live();


}


class Kostra{
	Clanek c[];
	int pocet;

	Kostra(int _pocet){
		pocet = _pocet;
		seta();
	}

	void seta(){

		c = new Clanek[pocet];
		for(int i =0;i<c.length;i++){
			c[i]= new Clanek();
		}

	}

	void live(){
		for(int i =0;i<c.length;i++){
			c[i].live();
		}

	}

}

class Clanek{
	PImage img;
	float x,y;
	Clanek(){
		
		img = clanek;
	}

	void live(){
		image(img,x,y,img.width/2.0,img.height/2.0);

	}



}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

int pocet = 8;
int variace = 3;

float zaznam = 0.1;

boolean rec = false;
//Recorder r;
ThinkCenter alph;
PImage input;
PGraphics inna;

float prumer = 0,prumer2 = 0;
float prums[] = new float[pocet];
float prums2[] = new float[pocet];

void setup(){
	size(1000,400,OPENGL);
	background(0);

	alph = new ThinkCenter(pocet,variace);
	input = loadImage("input.png");

	inna = createGraphics(width,height,JAVA2D);
	inna.beginDraw();
	inna.image(input,0,0);
	inna.endDraw();



	textFont(createFont("Veranda",9));
	//textMode(SCREEN);
	//textAlign(RIGHT);

	//	if(rec)
	//		r = new Recorder("out","ai.mp4");

	//noSmooth();
	smooth();
	fill(255);
	
}

void mousePressed(){
	alph = new ThinkCenter(pocet,variace);

}

void draw(){
	//zaznam = mouseX/1000.0;
	stroke(255);
	if((frameCount*zaznam)%width==0){
		fill(0,123);
		rect(0,0,width,height);}
	fill(0);
	rect(0,0,variace*20+2,pocet*10+6);

	alph.stat();
	
	
	if(alph.alive){
		stroke(255,0,0,20);
		line((frameCount*zaznam)%width,0,(frameCount*zaznam)%width,height);
	}
	
	stroke(255,0,0,95);
	line((frameCount*zaznam)%width-1,prumer2*4+height/2,(frameCount*zaznam)%width,prumer*4+height/2);
	
	stroke(255,25);
	for(int i = 0;i<prums.length;i++){
	line((frameCount*zaznam)%width-1,prums2[i]*4+height/2,(frameCount*zaznam)%width,prums[i]*4+height/2);
	}
	
	prumer2 = prumer;
	prums2 = prums;
	
	//	if(rec)
	//		r.add();

	//	alph.degenerate((int)random(alph.n.length));// = new ThinkCenter(pocet,variace);
	//	stroke(255,0,0);
	//	line(((frameCount)*zaznam)%width,0,((frameCount)*zaznam)%width,height);
		//prumer = 0;
		//for(int i = 0;i<alph.n.length;i++){
		//prumer +=	alph.n[i].weight;
	//}
		//}

}

void keyPressed(){
	if(key=='q'){

		//		if(rec)
		//			r.finish();


		exit();
	}else if(key=='1'){
	alph.n[0].degen(0);
	}else if(key=='2'){
	alph.n[0].degen(1);
	}else if(key=='3'){
	alph.n[0].degen(2);
	}

}

class ThinkCenter{
	Neuron n[];
	int num;
	int connex;
	int qa [];
	
	boolean alive = false;
	int alCt = 0;
	
	ThinkCenter(int _num,int _connex){
		//int[] q = inna.pixels;
		num = _num;
		connex = _connex;

		n = new Neuron[num];
		qa =new int[num];
		
		for(int i = 0; i < num;i++){
			qa[i] = (int)random(-100,100);
		}
		
		//qa[5] = 2;

		for(int i = 0; i < num;i++){
			n[i] = new Neuron(i,qa[i%qa.length],connex,num);
		}

	}
	
	void degenerate(int which){
		n[which].degen(0);// = new Neuron(which,qa[which%qa.length],connex,num);
	}

	void stat(){

		//degenerate(0);
		
		int temp[] = new int[num];
		for(int i =0;i<n.length;i++){
		temp[i] = n[i].sum();
		n[i].weight = temp[i];
		}
		
		//all
		
		//for(int i =0;i<n.length;i++){
		//n[i].weight = temp[i];
		//}
		
		
	
	
		for(int i =0;i<n.length;i++){
			//if(mousePressed)
			
			fill(255);
			//text(n[i].weight,10,i*10+10);
			//text(" = ",10,i*10+10);
			
			prumer += (n[i].weight-prumer)/(num*50+1.0);
			prums[i] += (n[i].weight-prums[i])/(num*50+1.0);
			
			for(int q = 0;q<n[i].ins.length;q++){
				fill(map(n[n[i].ins[q]].weight,-100,100,0,255));
				//stroke(map(n[n[i].ins[q]].weight,-100,100,0,255),10);

				text(n[i].ins[q],10+q*20,i*10+10);
				//line(width-5,n[i].ins[q]*10+10,10+q*20,i*10+10);
			}





			//pixe
			/*
			for(int q = 0;q<n[i].ins.length;q++){
				//if(n[n[i].ins[q]].weight>0){
				//	stroke(255,62);}else{stroke(0,62);
				//}
				
				
				stroke(map(n[n[i].ins[q]].weight,-100,100,0,255));
				line(i,q,i+.6,q);
		}*/



		}
	}




}

class Neuron{
	int id;
	int weight;
	int ins[],outs[];


	Neuron(int _id,int _weight, int _con,int _len){
		id = _id;
		weight = _weight;
		ins = new int[_con];
		for(int i =0;i<_con;i++){
			ins[i] = -1;
		}
		for(int i =0;i<_con;i++){
			//	if(i!=id){

			int a = (int)random(_len);
			int counter = 0;

			if(a==id||!checkValidity(a)){
				while(a==id||!checkValidity(a)){
					counter ++;
					a = (int)random(_len);
					if(counter>1000)
						break;
				}
			}

			ins[i] = a;
			//}
		}
	}
	
	void degen(int which){
			int a = (int)random(pocet);
			int counter = 0;

			if(a==id||!checkValidity(a)){
				while(a==id||!checkValidity(a)){
					counter ++;
					a = (int)random(pocet);
					if(counter>1000)
						break;
				}
			}

			ins[which] = a;
	}


	boolean checkValidity(int number){
		boolean answr = true;
		for(int i = 0;i<ins.length;i++){
			if(number==ins[i])
				answr = false;
		}
		return answr;

	}

	int sum(){
		int waaa = weight;
		int _weight = 0;
		for(int i = 0;i<ins.length;i++){
			_weight += alph.n[ins[i]].weight;
			if(_weight>100)_weight = -100;
			if(_weight<-100)_weight = 100;
		}
		//if(_weight>-100&&_weight<100)
		//weight+=(int)((_weight-weight)/20.0);
		//if(abs(weight-_weight)<150)
			waaa += (_weight-waaa)/2.0;
			return waaa;
	}

}




float uhly[] = {2.0,-3.0,0.0};
Branch kmen;
Branch vetve[];

color c;

void setup(){

	size(400,400,P3D);

	c = color(255);

	vetve = new Branch[0];
	kmen = new Branch(2.0);
	
	stroke(c);
}

void draw(){
	background( 255-brightness(c) );

	kmen.live();


}

class Branch{
	float loms [];
	float step;

	int id;
	int parId;

	float rx,ry,x,y;
	float xes[],yes[];

	String code =  "";
	float settings[] = new float[0];
	int newBranch[] = new int[0];


	//kmen constructor
	Branch(float _step){

		gen(10,10,10,5);

		loms=settings;
		yes=new float[loms.length];
		xes=new float[loms.length];
		step = _step;
		id = 0;
		x=rx=width/2.0;
		y=ry=height;
		live();
		
		for(int i =0 ;i<newBranch.length;i++){
			vetve = (Branch[])expand(vetve,vetve.length+1);
			vetve[vetve.length-1] = new Branch(1.0,i+1,0);
		}
	}

	Branch(float _step,int _id,int _parId){
		gen(10,10,10,5);
		loms=settings;

		step = _step;
		id = _id;
		parId = parId;
		yes=new float[loms.length];
		xes=new float[loms.length];
		//x=rx=parent.xes[t.newBranch[id]];
		//y=ry=parent.yes[t.newBranch[id]];
		println("branch no. "+id+" created");
		x=rx=kmen.xes[newBranch[id]];
		y=ry=kmen.yes[newBranch[id]];
	}

	void live(){
		rx=x;
		ry=y;

		pushMatrix();

		translate(rx,ry);
		for(int i = 0;i<loms.length;i++){

			yes[i]=modelY(0,0,0);
			xes[i]=modelX(0,0,0);

			translate(0,-step);

			ry+=step;



			rotate(radians(loms[i]));

			for(int q = 0;q<newBranch.length;q++){
				if(i==newBranch[q]){
					rect(0,0,3,3);
				}
				
			}
			
			line(0,0,0,-step);
		}

		popMatrix();


	}


	void gen(int _a,int _b,int _c,int _d){
		code =  "";
		code = codeGen(_a,_b,_c,_d);

		newBranch = new int[0];
		settings = new float[0];


		for(int i =0 ;i<code.length();i++){
			settings = (float[])expand(settings,settings.length+1);
			if(code.charAt(i)=='A'){
				settings[settings.length-1] = uhly[0];
			}else if(code.charAt(i)=='B'){
				settings[settings.length-1] = uhly[1];
			}else if(code.charAt(i)=='C'){
				settings[settings.length-1] = uhly[2];
			}else if(code.charAt(i)=='D'){
				newBranch = (int[])expand(newBranch,newBranch.length+1);
				newBranch[newBranch.length-1] = i;
			}
		}
	}


	String codeGen(int a,int b,int c,int d){
		String res = "";
		for(int i =0 ;i<a+b+c+d;i++){
			float q =  random(a+b+c+d);
			if(q<=a){
				res+="AAAAA";
			}else if(q<=a+b&&q>a){
				res+="BB";
			}else if(q<=a+b+c&&q>a+b){
				res+="C";
			}else if(q>c&&i>(a+b+c+d)/3.0){
				res+="D";
			}
		}
		return res;
	}
}
/**
* 	Neural Network _alpha 0.4
*	by krystof pesek
*/

backPropagation bp;

int cntt = 0;
float error = 0.0;

float rate=1.0;
long epochs=100;
int nodesInEachLayer[]=new int[3];
int tag=0;
float meanSquareError=0.01;
String inputFile="input.txt";
String outputFile="output.txt";
int percentage=0;
int noOfSamples=0;
boolean prnt;

int num;

void setup(){
	size(300,300,OPENGL);

	num = 20;

	nodesInEachLayer[0]=6;
	nodesInEachLayer[1]=6;
	nodesInEachLayer[2]=1;

	//generateInOut();

	cycle(false);
}

void generateInOut(){
	String t[] = new String[num];
	for(int i =0;i<t.length;i++){
		t[i] = "";
		for(int w =0;w<nodesInEachLayer[0];w++){
			if(random(100)>=50){
				t[i] += 1+"";
			}else{
				t[i] += 0+"";
			}
			if(w!=nodesInEachLayer[0]-1){
				t[i] += " ";
			}
		}
	}
	saveStrings("input.txt",t);



	for(int i =0;i<t.length;i++)
	{
		t[i] = "";
		for(int w =0;w<nodesInEachLayer[2];w++){
			if(random(100)>=50){
				t[i] += 1+"";
			}else{
				t[i] += 0+"";
			}
			if(w!=nodesInEachLayer[2]-1){
				t[i] += " ";
			}
		}
	}
	saveStrings("output.txt",t);


}

void draw(){
	//background(0);

	//generateInOut();
	cycle(false);

	fill(255);

	pushMatrix();
	translate(20,20);
	
	
	
	println(error);
	for(int i =0;i<num;i++){
		error += (bp.test(i+1)-error)/num;
		stroke(map(bp.test(i+1),error*0.999,1,0,255),200);
		line(map(i,0,num,10,width-10),frameCount%height,map(i+1,0,num,10,width-10),frameCount%height);
		line(map(i,0,num,10,width-10),frameCount%height,-1+map(i,0,num,10,width-10),frameCount%height);
	}

	popMatrix();



}

void cycle(boolean _prnt){
	prnt=_prnt;

	float sampleMatrix[][]=new float[100][100];
	float desiredOutput[]=new float[100];
	float weightMatrix[][][]=new float[2][100][100];

	Network network=new Network();
	ReadAndWrite readAndWrite=new ReadAndWrite();

	// Initialize the weights in the network
	weightMatrix=network.randomiser(nodesInEachLayer);

	//Read input from the input file and store it in matrix
	sampleMatrix=readAndWrite.makeMatrix(nodesInEachLayer[0],inputFile,percentage);
	noOfSamples=readAndWrite.noOfSamples();

	//Read output from output file and store it in a vector form.
	desiredOutput=readAndWrite.readOutput(1,outputFile);

	//Call backPropagation	and send all the specification to start the training of neural network
	bp=new backPropagation(rate,epochs,weightMatrix,nodesInEachLayer,sampleMatrix,desiredOutput,noOfSamples,meanSquareError);

	//for(int i =0;i<num;i++)
	//backPropagation.testing(i);
	//epochs=0;

}


class Network{
	float[][][] randomiser(int nodesInEachLayer[]){

		/*
			 This method simply set the weights to some random values between 1 and 0. The input to this method is a array specifying all the nuber od nodes in each layer of the network. The output from this method is a 3D matrix which has all the weights initialized to some random values.
		*/

		int i;
		int j;
		int k;
		float weightMatrix[][][]=new float[2][100][100];
		Random random=new Random();

		for(k=0;k<2;k++){
			for(i=0;i<nodesInEachLayer[k];i++){
				for(j=0;j<nodesInEachLayer[k+1];j++){
					weightMatrix[k][i][j]=random.nextFloat();
				}// End of j
			}// End of i
		}// End of k
		return(weightMatrix);

	}// End of method randomiser.


	float[][] multiply(float matrixOne[][],float matrixTwo[][][],int rowsInOne, int coloumsInOne,int coloumsInTwo,int matrixNumber){
		/*
			It will perform two matrix multiplication. The input to this method are a 2D matrix , 3D matrix,  number of rows in first matrix, number of coloums in first matrix , number of coloums in second matrix and a number specifying weather it is matrix one or matrix two in the 3D matrix. The output from this method is a 2D matrix which is the product of the two input matrix.	
		*/


		float multipliedMatrix[][]=new float[rowsInOne][coloumsInTwo];

		int i;
		int j;
		int k;

		for(i=0;i<rowsInOne;i++){
			for(j=0;j<coloumsInTwo;j++){
				multipliedMatrix[i][j]=0.0;
				for(k=0;k<coloumsInOne;k++){
					//System.out.println("i "+i+" j "+j+" k "+k);
					multipliedMatrix[i][j]=multipliedMatrix[i][j]+matrixOne[i][k]*matrixTwo[matrixNumber-1][k][j];
				}// End of k

			}// End of j

		}// End of i

		return(multipliedMatrix);


	}// End of method multiply.


	float[][][] transpose(float matrix[][][],int noOfRows,int noOfColoums,int number){
		/*
			This method takes inputs as a 3D matrix, the number of rows in the matrix, number of coloumns in the matrix and a number specifying weather it is matrix one or matrix two in the 3D matrix . It returns a 3D matrix which is the transpose of the input matrix.
		*/

		int i;
		int j;
		float temp[][][]=new float[2][100][100];
		for(i=0;i<noOfRows;i++){
			for(j=0;j<noOfColoums;j++){
				temp[number-1][j][i]=matrix[number-1][i][j];

			}// End of j
		}// End of i
		return(temp);
	}// End of method transpose.

}// End of class Network.


class ReadAndWrite{
	int lengthOfFile=0;



	float[][] makeMatrix(int sampleSize,String fileName,int percentage){
		/*
		This method reads the input file and takes the samples from it and put it in a matrix form. The input to this method are the number of attributes in the sample and the file name from which the sample has to be read. It then read the whole file and make a matrix out of it.

		*/


		//float inputMatrix[0][0];
		//String fileName = _fileName;
		//String loadStrings()

		float inputMatrix[][]=new float[100][sampleSize];
		String lineOfFile=" ";

		int i;
		int j;
		int counter=0;
		float temp;
		int factor;

		try{
		//	println(sketchPath+"/"+fileName);
			RandomAccessFile file = new RandomAccessFile(sketchPath+"/"+fileName,"rw");

			lengthOfFile=(int)((file.length())/(int)(2*sampleSize));
			temp=(lengthOfFile*(percentage/100.0));
			factor=lengthOfFile-(int)(temp);

			if(factor!=0){
				temp=lengthOfFile-lengthOfFile/factor;
			}
			if((temp==0)||(factor==0)){
				System.out.println("Error : No training data available ");
				temp=lengthOfFile;
				epochs=1;
				factor=0;

			}

			for(i=0;i<temp;i++){
				if(factor!=0){
					if(i%factor==0){
						file.readLine();
					}
				}
				lineOfFile=file.readLine();

				StringTokenizer st= new StringTokenizer(lineOfFile);
				for(j=0;j<sampleSize;j++){
					inputMatrix[counter][j]=Float.parseFloat(st.nextToken());
					// System.out.print(inputMatrix[i][j]+"  ");

				}// End of j
				//System.out.println();
				counter++;

			}// End of i

			file.close();
		}catch(Exception e){
			System.out.println("ERROR 1 "+e.toString());
		}
		return(inputMatrix);

	}// End of method makeMatrix.



	int noOfSamples(){
		/*
			This method just returns te number of samples in the file as it is srored in the variable lengthOfFile which has the value from the method 
		*/
		return(lengthOfFile);
	}// End of method noOfSamples.



	float[] readOutput(int nodesInOutputLayer,String fileName){

		/*
			This method reads the output file and takes the samples from it and put it in a vector form. The input to this method are array specifying the nodes in each Layer of the network and the fileme of the output file. It then read the whole file and make a vector out of it.

		*/	


		int i;
		float desiredOutput[]=new float[100];
		String lineOfFile=" ";

		try{
			RandomAccessFile file = new RandomAccessFile(sketchPath+"/"+fileName,"rw");
			for(i=1;i<=((int)(file.length()/(2)));i++){
				lineOfFile=file.readLine();
				desiredOutput[i-1]=Float.parseFloat(lineOfFile);
				//System.out.println("desired output "+desiredOutput[i-1]);

			}// End of i

			file.close();
		}catch(Exception e){
			System.out.println("ERROR 2 "+e.toString());
		}

		return(desiredOutput);

	}// End of method readOutput.




}// End of class ReadAndWrite


class backPropagation{
	float rate;
	long epochs;
	long i;
	long j;
	int noOfSamples;
	float weightMatrix[][][]=new float[2][100][100];
	float desiredOutput[]=new float[100];
	float sampleInput[][]=new float[100][100];
	int nodesInEachLayer[]=new int[3];
	float meanSquareError;

	Network network=new Network();

	backPropagation(float rate,long epochs,float weightMatrix[][][],int nodesInEachLayer[],float sampleInput[][],float desiredOutput[],int noOfSamples,float meanSquareError){
		this.rate=rate;
		this.epochs=epochs;
		this.noOfSamples=noOfSamples;
		this.weightMatrix=weightMatrix;
		this.sampleInput=sampleInput;
		this.desiredOutput=desiredOutput;
		this.nodesInEachLayer=nodesInEachLayer;
		this.meanSquareError=meanSquareError;

		startTraining();


	}// End of constructor.

	void startTraining(){
		cntt ++;
		println("generation "+(cntt*epochs));
		/*
			This the method which is called by the constructor and it does the whole mauplation of the weights in the network. The main loop is repeated as many times as the epochs. It uses the backPropagation algorithm to calculate the weight change for all the sample in one step and then add the weight change into the weights of the network. It uses the batch mode updation therefore the weight are not changed untill each epoch. The observed output is calculated by multipying the input sample matrix which is builed by makeMatrix() method in ReadAndWrite class with the weightMatrix of the network and then passing it to the transfer function. The transfer function used is the log sig which is also declared in this class. This method calculates the Mean square error and display it on the terminal after each epoch.
		*/
		int i;
		int j;
		int k;
		int l;

		float MSE=0.0;
		float inputToHiddenLayer[][]=new float[noOfSamples][nodesInEachLayer[1]];
		float activationOfHiddenLayer[][]=new float[noOfSamples][nodesInEachLayer[1]];
		float inputToOutputLayer[][]=new float[noOfSamples][nodesInEachLayer[2]];
		float observedOutput[][]=new float[noOfSamples][nodesInEachLayer[2]];
		float benifitOfOutputLayer[]=new float[noOfSamples];
		float benifitOfHiddenLayer[][]=new float[noOfSamples][nodesInEachLayer[1]];
		float derivative[]=new float[noOfSamples];
		float temp1[][]=new float[noOfSamples][1];
		float temp2[]=new float[noOfSamples];
		float temp3[][]=new float[noOfSamples][nodesInEachLayer[1]];
		String st=new String();


		try{
			RandomAccessFile file = new RandomAccessFile("mse.txt","rw");



			for(i=0;i<epochs;i++){
				MSE=0.0;
				inputToHiddenLayer=network.multiply(sampleInput,weightMatrix,noOfSamples,nodesInEachLayer[0],nodesInEachLayer[1],1);


				for(k=0;k<noOfSamples;k++){
					for(j=0;j<nodesInEachLayer[1];j++){
						activationOfHiddenLayer[k][j]=sigmoidal(inputToHiddenLayer[k][j]);
						//System.out.print(" "+activationOfHiddenLayer[k][j]);
					}// End of j
					//System.out.println();
				}// End of k


				inputToOutputLayer=network.multiply(activationOfHiddenLayer,weightMatrix,noOfSamples,nodesInEachLayer[1],nodesInEachLayer[2],2);

				for(k=0;k<noOfSamples;k++){
					for(j=0;j<nodesInEachLayer[2];j++){
						observedOutput[k][j]=sigmoidal(inputToOutputLayer[k][j]);
						//System.out.print(" "+inputToOutputLayer[k][j]);
					}//end of j

					benifitOfOutputLayer[k]=desiredOutput[k]-observedOutput[k][0];
					derivative[k]=observedOutput[k][0]*(1.0-observedOutput[k][0]);
					temp1[k][0]=derivative[k]*benifitOfOutputLayer[k];
					temp2[k]=temp1[k][0]*rate;
					for(j=0;j<nodesInEachLayer[1];j++){
						weightMatrix[1][j][nodesInEachLayer[2]-1]=weightMatrix[1][j][nodesInEachLayer[2]-1]+activationOfHiddenLayer[k][j]*temp2[k];

					}//end of j


					MSE=MSE+benifitOfOutputLayer[k]*benifitOfOutputLayer[k];

				}//end of k
				MSE=MSE/noOfSamples;


				st=String.valueOf(MSE);

				file.writeBytes(st);
				file.writeBytes(" ");

				if(MSE<=meanSquareError){
					System.out.println("Network Converged");
					System.out.println("Number Of Epochs = "+i);
					System.out.println("Mean Square Error"+MSE);
					break;

				}

				if(prnt)
					System.out.println("Mean Square Error :"+MSE);
				benifitOfHiddenLayer=network.multiply(temp1,network.transpose(weightMatrix,nodesInEachLayer[1],1,2),noOfSamples,1,nodesInEachLayer[1],2);
				for(k=0;k<noOfSamples;k++){
					for(j=0;j<nodesInEachLayer[1];j++){
						temp3[k][j]=rate*benifitOfHiddenLayer[k][j]*activationOfHiddenLayer[k][j]*(1.0-activationOfHiddenLayer[k][j]);

					}
					for(l=0;l<nodesInEachLayer[1];l++){
						for(j=0;j<nodesInEachLayer[0];j++){
							weightMatrix[0][j][l]=weightMatrix[0][j][l]+sampleInput[k][j]*temp3[k][l];
						}//end of j
					}//end of l
				}//end of k


				String q;
				for(l=0;l<2;l++)
					for(j=0;j<nodesInEachLayer[l];j++){
						for(k=0;k<nodesInEachLayer[l+1];k++){
							q = (weightMatrix[l][j][k]+"  ");
						}
						//System.out.println();
					}

			}//end of for i=epochs

			file.close();
		}catch(Exception e){
			System.out.println("ERROR 3 "+e.toString());
		}

	}// End of method startTraining.


	float sigmoidal(float inputValue){
		/*
			method just takes input as some real number and calculates the sigmoidal function of that value and return the same.
		*/
		return(float)((1.0/(1.0+Math.exp(-1.0*inputValue))));


	}// End of method sigmoidal.


	void testing(int sampleNo){
		int i;
		int j;
		float sum;
		float sample[]=new float[nodesInEachLayer[0]];
		float temp[]=new float[nodesInEachLayer[1]];
		for(i=0;i<nodesInEachLayer[0];i++){
			sample[i]=sampleInput[sampleNo-1][i];
		}
		for(j=0;j<nodesInEachLayer[1];j++){
			sum=0.0;
			for(i=0;i<nodesInEachLayer[0];i++){

				sum=sum+sample[i]*weightMatrix[0][i][j];

			}
			temp[j]=sigmoidal(sum);
		}
		sum=0.0;
		for(i=0;i<nodesInEachLayer[1];i++){
			sum=sum+temp[i]*weightMatrix[1][i][0];
		}
		sum=sigmoidal(sum);
		System.out.println("The Observed Output is "+sum );
		System.out.println("The Desired Output is "+desiredOutput[sampleNo-1]);

	}

	float test(int sampleNo){

		int i;
		int j;
		float sum;
		float sample[]=new float[nodesInEachLayer[0]];
		float temp[]=new float[nodesInEachLayer[1]];
		for(i=0;i<nodesInEachLayer[0];i++){
			sample[i]=sampleInput[sampleNo-1][i];
		}
		for(j=0;j<nodesInEachLayer[1];j++){
			sum=0.0;
			for(i=0;i<nodesInEachLayer[0];i++){

				sum=sum+sample[i]*weightMatrix[0][i][j];

			}
			temp[j]=sigmoidal(sum);
		}
		sum=0.0;
		for(i=0;i<nodesInEachLayer[1];i++){
			sum=sum+temp[i]*weightMatrix[1][i][0];
		}
		sum=sigmoidal(sum);



		return sum;

	}





}// End of class backPropagation




import traer.physics.*;




Hero hero,soldier;
World world;

float gravity = 0.3;
float density = 0.07;

void setup(){
	size(320,240,OPENGL);

	hint(DISABLE_OPENGL_2X_SMOOTH) ;

	hero = new Hero((int)(width/3)*2,230,"figurka3.png");	
	
	noSmooth();

	frameRate(30);


	world = new World();

	//rectMode(CENTER);
	noFill();
	stroke(255,100);
}


void gradient(color a,color b,int steps){
	noStroke();
	for(int i =0;i<steps;i++){
		fill(lerpColor(a,b,map(i,0,steps-1,0,1)));
		rect(0,map(i,0,steps,0,height),width,height/(steps+1.0));
	
	}

}

void draw(){


	//background(0);
	gradient(color(#5d5d6d),color(50),24);
	
	float akcel = degrees(atan2(hero.senzor.position().y()-hero.hlavaP.position().y(),hero.senzor.position().x()-hero.hlavaP.position().x())-HALF_PI);
	float naklon = degrees(atan2(hero.truP[5].position().y()-hero.hlavaP.position().y(),hero.truP[5].position().x()-hero.hlavaP.position().x())-HALF_PI);



	float acc = (naklon);//(naklon+akcel)/2.0;
	float ang = 90;
	acc = constrain(acc,-ang,ang);

	//println(acc);
	//if(frameCount%10==0)
	//	println(acc);
	
	
	//hero.trupQ[0] = map(sin(frameCount/20.0),-1,1,hero.initialQ[18]-2,hero.initialQ[18]+2);
	//hero.trupQ[1] = map(sin(frameCount/20.0),-1,1,hero.initialQ[19]+2,hero.initialQ[19]-2);
/*

	float val = map(mouseX,0,width,0,1);
	float val2 = map(mouseY,0,width,1,2);
	hero.nohaLQ[0] = hero.initialQ[10]*(1.0-val*val2);//map(acc,ang,-ang,+2,hero.initialQ[10]-4.5);
	hero.nohaLQ[1] = hero.initialQ[11]*(1.0+val*val2);//map(acc,ang,-ang,hero.initialQ[11]-2,hero.initialQ[11]+4.5);
	hero.nohaLQ[2] = hero.initialQ[12]*(1.0-val);//map(acc,-ang,ang,hero.initialQ[12]-3,hero.initialQ[12]+3);
	hero.nohaLQ[3] = hero.initialQ[13]*(1.0-val);//map(acc,ang,-ang,hero.initialQ[13]-3,hero.initialQ[13]+3);

	hero.nohaRQ[0] = hero.initialQ[14]*1.5;//map(acc,-ang,ang,+2,hero.initialQ[14]-4.5);
	hero.nohaRQ[1] = hero.initialQ[15]*0.5;//map(acc,-ang,ang,hero.initialQ[15]-2,hero.initialQ[15]+4.5);
	hero.nohaRQ[2] = hero.initialQ[16]-(sin(frameCount/30.0))*6.0;//map(acc,ang,-ang,hero.initialQ[16]-3,hero.initialQ[16]+3);
	hero.nohaRQ[3] = hero.initialQ[17]+(sin(frameCount/30.0))*6.0;//map(acc,-ang,ang,hero.initialQ[17]-3,hero.initialQ[17]+3);


		
	
	
	hero.nohaLQ[0] = map(acc,ang,-ang,hero.initialQ[10]+2,hero.initialQ[10]-4.5);
	hero.nohaLQ[1] = map(acc,ang,-ang,hero.initialQ[11]-2,hero.initialQ[11]+4.5);
	hero.nohaLQ[2] = map(acc,-ang,ang,hero.initialQ[12]-3,hero.initialQ[12]+3);
	hero.nohaLQ[3] = map(acc,ang,-ang,hero.initialQ[13]-3,hero.initialQ[13]+3);

	hero.nohaRQ[0] = map(acc,-ang,ang,hero.initialQ[14]+2,hero.initialQ[14]-4.5);
	hero.nohaRQ[1] = map(acc,-ang,ang,hero.initialQ[15]-2,hero.initialQ[15]+4.5);
	hero.nohaRQ[2] = map(acc,ang,-ang,hero.initialQ[16]-3,hero.initialQ[16]+3);
	hero.nohaRQ[3] = map(acc,-ang,ang,hero.initialQ[17]-3,hero.initialQ[17]+3);


	hero.rukaRQ[0] = map(acc,ang,-ang,hero.initialQ[6],hero.initialQ[6]+5);
	hero.rukaRQ[1] = map(acc,ang,-ang,hero.initialQ[7],hero.initialQ[7]-5);
	hero.rukaRQ[2] = map(acc,ang,-ang,hero.initialQ[8],hero.initialQ[8]+2);
	hero.rukaRQ[3] = map(acc,ang,-ang,hero.initialQ[9],hero.initialQ[9]-2);

	hero.trupQ[0] = map(acc,ang,-ang,hero.initialQ[18]-2,hero.initialQ[18]+2);
	hero.trupQ[1] = map(acc,ang,-ang,hero.initialQ[19]+2,hero.initialQ[19]-2);


	hero.nohaLQ[0] = map(sin(frameCount/10.0),1,-1,hero.initialQ[10],hero.initialQ[10]-4.5);
	hero.nohaLQ[1] = map(sin(frameCount/10.0),1,-1,hero.initialQ[11],hero.initialQ[11]+4.5);
	hero.nohaLQ[2] = map(sin(frameCount/10.0),-1,1,hero.initialQ[12]-3,hero.initialQ[12]+3);
	hero.nohaLQ[3] = map(sin(frameCount/10.0),1,-1,hero.initialQ[13]-3,hero.initialQ[13]+3);

	hero.nohaRQ[0] = map(sin(frameCount/10.0),1,-1,hero.initialQ[14],hero.initialQ[14]-4.5);
	hero.nohaRQ[1] = map(sin(frameCount/10.0),1,-1,hero.initialQ[15],hero.initialQ[15]+4.5);
	hero.nohaRQ[2] = map(sin(frameCount/10.0),-1,1,hero.initialQ[16]-3,hero.initialQ[16]+1);
	hero.nohaRQ[3] = map(sin(frameCount/10.0),1,-1,hero.initialQ[17]-3,hero.initialQ[17]+1);
	*/


	//hero.rukaRQ[2] = map(sin(frameCount/5.0),-1,1,hero.initialQ[8]-4,hero.initialQ[8]+4);
	//hero.rukaRQ[3] = map(sin(frameCount/5.0),1,-1,hero.initialQ[9]-4,hero.initialQ[9]+4);


	pushMatrix();

	//scale(2.0);
		//translate(-hero.hlavaP.position().x()/2-20,-hero.hlavaP.position().y()/2-30);
	hero.act();
	//soldier.act();
	//line(rukaL2P.position().x(),rukaL2P.position().y(),anchor.position().x(),anchor.position().y());
	world.render();

	popMatrix();
}


void keyPressed(){
	if(key=='w'){
		hero.control = 0;
	}else if(key == 't'){
		hero.testing = !hero.testing;

	}

}


void mousePressed(){

	println(mouseX+" : "+mouseY);

}



class Hero{

	PImage mapa;
	String skin;
	int maska[];
	int anchors[][] = {{4,22},{5,7},

	                   {4,1},{2,0},{2,1},{1,0},
	                   {1,0},{1,0},

	                   {4,2},{1,1},{2,2},{1,1}
	                  };

	int positions[][] = {{0,0},{6,-3},

	                     {-1,4},{0,7},{4,4},{0,7},
	                     {2,6},{1,6},

	                     {1,-4},{-1,6},{7,-4},{1,6}

	                    };


	float mass[] = {
	                       0.6,0.15,

	                       0.15,0.15,0.15,0.15,
	                       0.03,0.03,

	                       0.12,0.1,0.12,0.1
	               };

	float rotation[] = new float[12];

	float limits[][] = {
	                           {-180,180},{-46.8,36.77},

	                           {138.0,-25.0},{5.2,-113.0},{138.0,-25.0},{5.2,-113.0},
	                           {-34.0,59.0},{-34.0,59.0},

	                           {178.0,-39.0},{158.0,-1.0},{169.0,-115.0},{133.0,-10.0}

	                   };

	PGraphics part[] = new PGraphics[12];

	String marks[] = new String[0];

	int x,y;
	int control = 0;

	ParticleSystem physics;

	boolean testing = false;

	Particle truP[] = new Particle[11];
	Spring truS[]  = new Spring[28];

	Particle nohaL1P;
	Spring nohaL1S[] = new Spring[3];
	Particle nohaL2P;
	Spring nohaL2S[] = new Spring[3];

	Particle nohaR1P;
	Spring nohaR1S[] = new Spring[3];
	Particle nohaR2P;
	Spring nohaR2S[] = new Spring[3];


	Particle rukaL1P;
	Spring rukaL1S[] = new Spring[3];
	Particle rukaL2P;
	Spring rukaL2S[] = new Spring[3];

	Particle rukaR1P;
	Spring rukaR1S[] = new Spring[3];
	Particle rukaR2P;
	Spring rukaR2S[] = new Spring[3];

	Particle hlavaP;
	Spring hlavaS[] = new Spring[2];

	Particle senzor;
	Spring senzorS;

	
	float[] check = new float[2];

	float hlavaSila = 3.0;
	float hlavaDamp = 0.01;

	float ruceSila = 3.0;
	float ruceDamp = 0.001;

	float nohySila = 5.0;
	float nohyDamp = 0.001;

	float hlavaQ[] = new float[2];
	float trupQ[] = new float[2];

	float rukaLQ[] = new float[4];
	float rukaRQ[] = new float[4];

	float nohaLQ[] = new float[4];
	float nohaRQ[] = new float[4];

	float initialQ[] = new float[20];

	
	//////////////////////
	Hero(int _x,int _y,String _skin){
		x = _x;
		y= _y;
		skin = _skin+"";
		reload();

		physics = new ParticleSystem( gravity, density );
		setPhy();

		initialQ[0] = hlavaQ[0];
		initialQ[1] = hlavaQ[1];

		initialQ[2] = rukaLQ[0];
		initialQ[3] = rukaLQ[1];
		initialQ[4] = rukaLQ[2];
		initialQ[5] = rukaLQ[3];

		initialQ[6] = rukaRQ[0];
		initialQ[7] = rukaRQ[1];
		initialQ[8] = rukaRQ[2];
		initialQ[9] = rukaRQ[3];

		initialQ[10] = nohaLQ[0];
		initialQ[11] = nohaLQ[1];
		initialQ[12] = nohaLQ[2];
		initialQ[13] = nohaLQ[3];

		initialQ[14] = nohaRQ[0];
		initialQ[15] = nohaRQ[1];
		initialQ[16] = nohaRQ[2];
		initialQ[17] = nohaRQ[3];

		initialQ[18] = trupQ[0];
		initialQ[19] = trupQ[1];
		
		check[0] = nohaL2S[2].currentLength();
		check[1] = nohaR2S[2].currentLength();
		

	}


	void setPhy(){

		// torso
		truP[0] = physics.makeParticle( mass[0], x-7, y-16, 0.0 );
		truP[1] = physics.makeParticle( mass[0], x-7, y-22, 0.0 );
		truP[2] = physics.makeParticle( mass[0], x-1, y-22, 0.0 );
		truP[3] = physics.makeParticle( mass[0], x-1, y-16, 0.0 );
		truP[4] = physics.makeParticle( mass[0], x,y-12, 0.0 );
		truP[5] = physics.makeParticle( mass[0], x-4,y-9, 0.0 );
		truP[6] = physics.makeParticle( mass[0], x-8,y-12, 0.0 );

		truP[7] = physics.makeParticle( mass[0], x-9,y-19, 0.0 );
		truP[8] = physics.makeParticle( mass[0], x+1,y-19, 0.0 );

		truP[9] = physics.makeParticle( mass[0], x-1,y-8, 0.0 );
		truP[10] = physics.makeParticle( mass[0], x-7,y-8, 0.0 );

		truS[0] = physics.makeSpring(truP[0], truP[1],1,1,1);
		truS[1] = physics.makeSpring(truP[1], truP[2],1,1,1);
		truS[2] = physics.makeSpring(truP[2], truP[3],1,1,1);
		truS[3] = physics.makeSpring(truP[3], truP[4],1,1,1);
		truS[4] = physics.makeSpring(truP[4], truP[5],1,1,1);
		truS[5] = physics.makeSpring(truP[5], truP[6],1,1,1);
		truS[6] = physics.makeSpring(truP[6], truP[0],1,1,1);
		truS[7] = physics.makeSpring(truP[5], truP[0],1,1,1);
		truS[8] = physics.makeSpring(truP[5], truP[1],1,1,1);
		truS[9] = physics.makeSpring(truP[5], truP[2],1,1,1);
		truS[10] = physics.makeSpring(truP[5], truP[3],1,1,1);
		truS[11] = physics.makeSpring(truP[0], truP[3],1,1,1);
		truS[12] = physics.makeSpring(truP[0], truP[2],1,1,1);
		truS[13] = physics.makeSpring(truP[1], truP[3],1,1,1);
		truS[14] = physics.makeSpring(truP[4], truP[6],1,1,1);

		truS[15] = physics.makeSpring(truP[0], truP[7],1,1,1);
		truS[16] = physics.makeSpring(truP[1], truP[7],1,1,1);

		truS[17] = physics.makeSpring(truP[2], truP[8],1,1,1);
		truS[18] = physics.makeSpring(truP[3], truP[8],1,1,1);

		truS[19] = physics.makeSpring(truP[4], truP[9],1,1,1);
		truS[20] = physics.makeSpring(truP[5], truP[9],1,1,1);

		truS[21] = physics.makeSpring(truP[6], truP[10],1,1,1);
		truS[22] = physics.makeSpring(truP[5], truP[10],1,1,1);

		truS[23] = physics.makeSpring(truP[7], truP[8],1,1,1);
		truS[24] = physics.makeSpring(truP[9], truP[6],1,1,1);
		truS[25] = physics.makeSpring(truP[10], truP[4],1,1,1);

		truS[26] = physics.makeSpring(truP[0], truP[4],1,1,1);
		truS[27] = physics.makeSpring(truP[3], truP[6],1,1,1);


		for(int i =0;i<truS.length;i++){
			truS[i].setRestLength( truS[i].currentLength() );
			truS[i].setStrength( 14.0);
			truS[i].setDamping( 0.0001 );
		}

		trupQ[0] = truS[3].currentLength();
		trupQ[1] = truS[6].currentLength();



		////
		hlavaP = physics.makeParticle( mass[1], x-4, y-28, 0 );

		hlavaS[0] = physics.makeSpring( truP[1], hlavaP, 1,1,1 );
		hlavaS[1] = physics.makeSpring( truP[2], hlavaP, 1,1,1 );

		for(int i =0;i<hlavaS.length;i++){
			hlavaQ[i]=hlavaS[i].currentLength();
			hlavaS[i].setRestLength( hlavaS[i].currentLength() );
			hlavaS[i].setStrength( hlavaSila);
			hlavaS[i].setDamping( hlavaDamp );
		}

		senzor = physics.makeParticle( 0.1 , x-4, y-23, 0 );
		senzorS = physics.makeSpring( hlavaP, senzor, 1,1,1 );
		senzorS.setRestLength( senzorS.currentLength() );
		senzorS.setStrength( 3.0 );
		senzorS.setDamping( 0.1 );

		////
		nohaL1P = physics.makeParticle( mass[2], x-7, y-2, 0 );

		nohaL1S[0] = physics.makeSpring( truP[6], nohaL1P, 1,1,1 );
		nohaL1S[1] = physics.makeSpring( truP[5], nohaL1P, 1,1,1 );
		nohaL1S[2] = physics.makeSpring( truP[10], nohaL1P, 1,1,1 );


		nohaLQ[0] = nohaL1S[0].currentLength();
		nohaLQ[1] = nohaL1S[1].currentLength();

		for(int i =0;i<nohaL1S.length;i++){
			nohaL1S[i].setRestLength( nohaL1S[i].currentLength() );
			nohaL1S[i].setStrength( nohySila);
			nohaL1S[i].setDamping( nohyDamp );

		}

		//////
		nohaL2P = physics.makeParticle( mass[3], x-7, y+4, 0 );

		nohaL2S[0] = physics.makeSpring( truP[6], nohaL2P, 1,1,1 );
		nohaL2S[1] = physics.makeSpring( truP[5], nohaL2P, 1,1,1 );
		nohaL2S[2] = physics.makeSpring( nohaL1P, nohaL2P, 1,1,1 );


		nohaLQ[2] = nohaL2S[0].currentLength();
		nohaLQ[3] = nohaL2S[1].currentLength();


		for(int i =0;i<nohaL2S.length;i++){
			nohaL2S[i].setRestLength( nohaL2S[i].currentLength() );
			nohaL2S[i].setStrength( nohySila);
			nohaL2S[i].setDamping( nohyDamp );

		}


		////
		nohaR1P = physics.makeParticle( mass[4], x-1, y-2, 0 );

		nohaR1S[0] = physics.makeSpring( truP[4], nohaR1P, 1,1,1 );
		nohaR1S[1] = physics.makeSpring( truP[5], nohaR1P, 1,1,1 );
		nohaR1S[2] = physics.makeSpring( truP[9], nohaR1P, 1,1,1 );


		nohaRQ[0] = nohaR1S[0].currentLength();
		nohaRQ[1] = nohaR1S[1].currentLength();

		for(int i =0;i<nohaL1S.length;i++){
			nohaR1S[i].setRestLength( nohaR1S[i].currentLength() );
			nohaR1S[i].setStrength( nohySila);
			nohaR1S[i].setDamping( nohyDamp );

		}

		//////
		nohaR2P = physics.makeParticle( mass[5], x-1 , y+4, 0 );

		nohaR2S[0] = physics.makeSpring( truP[4], nohaR2P, 1,1,1 );
		nohaR2S[1] = physics.makeSpring( truP[5], nohaR2P, 1,1,1 );
		nohaR2S[2] = physics.makeSpring( nohaR1P, nohaR2P, 1,1,1 );


		nohaRQ[2] = nohaR2S[0].currentLength();
		nohaRQ[3] = nohaR2S[1].currentLength();


		for(int i =0;i<nohaR2S.length;i++){
			nohaR2S[i].setRestLength( nohaR2S[i].currentLength() );
			nohaR2S[i].setStrength( nohySila);
			nohaR2S[i].setDamping( nohyDamp );

		}



		//////////////////// RUCE

		////
		rukaL1P = physics.makeParticle( mass[8], x-13, y-19, 0 );

		rukaL1S[0] = physics.makeSpring( truP[1], rukaL1P, 1,1,1 );
		rukaL1S[1] = physics.makeSpring( truP[0], rukaL1P, 1,1,1 );
		rukaL1S[2] = physics.makeSpring( truP[7], rukaL1P, 1,1,1 );


		rukaLQ[0] = rukaL1S[0].currentLength();
		rukaLQ[1] = rukaL1S[1].currentLength();

		for(int i =0;i<rukaL1S.length;i++){
			rukaL1S[i].setRestLength( rukaL1S[i].currentLength() );
			rukaL1S[i].setStrength( ruceSila);
			rukaL1S[i].setDamping( ruceDamp );

		}

		//////
		rukaL2P = physics.makeParticle( mass[9], x-18, y-19, 0 );

		rukaL2S[0] = physics.makeSpring( truP[1], rukaL2P, 1,1,1 );
		rukaL2S[1] =physics.makeSpring( truP[0], rukaL2P, 1,1,1 );
		rukaL2S[2] = physics.makeSpring( rukaL1P, rukaL2P, 1,1,1 );

		rukaLQ[2] = rukaL2S[0].currentLength();
		rukaLQ[3] = rukaL2S[1].currentLength();

		for(int i =0;i<rukaL2S.length;i++){
			rukaL2S[i].setRestLength( rukaL2S[i].currentLength() );
			rukaL2S[i].setStrength( ruceSila);
			rukaL2S[i].setDamping( ruceDamp );

		}


		////
		rukaR1P = physics.makeParticle( mass[10], x+5, y-19, 0 );

		rukaR1S[0] = physics.makeSpring( truP[2], rukaR1P, 1,1,1 );
		rukaR1S[1] = physics.makeSpring( truP[3], rukaR1P, 1,1,1 );
		rukaR1S[2] = physics.makeSpring( truP[8], rukaR1P, 1,1,1 );


		rukaRQ[0] = rukaR1S[0].currentLength();
		rukaRQ[1] = rukaR1S[1].currentLength();


		for(int i =0;i<rukaR1S.length;i++){
			rukaR1S[i].setRestLength( rukaR1S[i].currentLength() );
			rukaR1S[i].setStrength( ruceSila);
			rukaR1S[i].setDamping( ruceDamp );

		}

		//////
		rukaR2P = physics.makeParticle( mass[11], x+11, y-19, 0 );

		rukaR2S[0] = physics.makeSpring( truP[2], rukaR2P, 1,1,1 );
		rukaR2S[1] = physics.makeSpring( truP[3], rukaR2P, 1,1,1 );
		rukaR2S[2] = physics.makeSpring( rukaR1P, rukaR2P, 1,1,1 );


		rukaRQ[2] = rukaR2S[0].currentLength();
		rukaRQ[3] = rukaR2S[1].currentLength();

		for(int i =0;i<rukaR2S.length;i++){
			rukaR2S[i].setRestLength( rukaR2S[i].currentLength() );
			rukaR2S[i].setStrength( ruceSila);
			rukaR2S[i].setDamping( ruceDamp );
		}



	}



	void act(){
		physics.advanceTime( 0.2 );
		move();
		compute();
		render2();

	}

	void move(){

		hlavaS[0].setRestLength(hlavaQ[0]);
		hlavaS[1].setRestLength(hlavaQ[1]);
		//L noha
		nohaL1S[0].setRestLength(nohaLQ[0]);
		nohaL1S[1].setRestLength(nohaLQ[1]);

		nohaL2S[0].setRestLength(nohaLQ[2]);
		nohaL2S[1].setRestLength(nohaLQ[3]);

		//R noha
		nohaR1S[0].setRestLength( nohaRQ[0]);
		nohaR1S[1].setRestLength( nohaRQ[1]);

		nohaR2S[0].setRestLength( nohaRQ[2]);
		nohaR2S[1].setRestLength( nohaRQ[3]);

		//L ruka
		rukaL1S[0].setRestLength( rukaLQ[0]);
		rukaL1S[1].setRestLength( rukaLQ[1]);

		rukaL2S[0].setRestLength( rukaLQ[2]);
		rukaL2S[1].setRestLength( rukaLQ[3]);


		//R ruka
		rukaR1S[0].setRestLength( rukaRQ[0]);
		rukaR1S[1].setRestLength( rukaRQ[1]);

		rukaR2S[0].setRestLength( rukaRQ[2]);
		rukaR2S[1].setRestLength( rukaRQ[3]);

		//trup
		truS[3].setRestLength( trupQ[0]);
		truS[6].setRestLength( trupQ[1]);

	}

	void compute(){

		x=(int)((truP[1].position().x()+truP[3].position().x()+truP[6].position().x()+truP[4].position().x())/4.0)+4;
		y=(int)((truP[1].position().y()+truP[3].position().y()+truP[6].position().y()+truP[4].position().y())/4.0)+12;

		move();

		partRotate(0,atan2( (truP[1].position().y()+truP[2].position().y())*.5-truP[5].position().y(),(truP[1].position().x()+truP[2].position().x())*.5-truP[5].position().x())+ HALF_PI );

		//noha L
		partRotate(2,atan2(nohaL1P.position().y()-truP[10].position().y(),nohaL1P.position().x()-truP[10].position().x())-HALF_PI);
		partRotate(3,atan2(nohaL2P.position().y()-nohaL1P.position().y(),nohaL2P.position().x()-nohaL1P.position().x())-HALF_PI  );

		//nohaR
		partRotate(4,atan2(nohaR1P.position().y()-truP[9].position().y(),nohaR1P.position().x()-truP[9].position().x())-HALF_PI  );
		partRotate(5,atan2(nohaR2P.position().y()-nohaR1P.position().y(),nohaR2P.position().x()-nohaR1P.position().x())-HALF_PI  );


		//kotniky inactive
		partRotate(6,atan2(nohaL2P.position().y()-nohaL1P.position().y(),nohaL2P.position().x()-nohaL1P.position().x())-HALF_PI );
		partRotate(7,atan2(nohaR2P.position().y()-nohaR1P.position().y(),nohaR2P.position().x()-nohaR1P.position().x())-HALF_PI );


		// hlava
		partRotate(1,atan2(hlavaP.position().y()-lerp(truP[1].position().y(),truP[2].position().y(),0.5),hlavaP.position().x()-lerp(truP[1].position().x(),truP[2].position().x(),0.5))+ HALF_PI );

		//ruka L
		partRotate(8,atan2(rukaL1P.position().y()-truP[7].position().y(),rukaL1P.position().x()-truP[7].position().x())  +HALF_PI-PI);
		partRotate(9,atan2(rukaL2P.position().y()-rukaL1P.position().y(),rukaL2P.position().x()-rukaL1P.position().x()) - HALF_PI);


		//ruka R
		partRotate(10,atan2(rukaR1P.position().y()-truP[8].position().y(),rukaR1P.position().x()-truP[8].position().x()) - HALF_PI);
		partRotate(11,atan2(rukaR2P.position().y()-rukaR1P.position().y(),rukaR2P.position().x()-rukaR1P.position().x()) - HALF_PI);
		//float finetune = map(mouseX,0,width,0,1);
		//println(finetune);

		collide();

	}

	void partRotate(int i,float kolik){

		rotation[i] = (kolik);//map(kolik,-PI,PI,-180,180);//limits[i][0],limits[i][1]);

	}

	void fillGraphics(){

		for(int i = 0;i<part.length;i++){
			String temp[] = splitTokens(marks[i],",");
			int x = -(parseInt(temp[0])+2);
			int y = -(parseInt(temp[1])+2);
			part[i].beginDraw();
			part[i].image(mapa,x,y);
			part[i].endDraw();
		}

	}

	void collide(){

		float fri = 0.5;
		float dmp = 0.00;
		
		/////////
		
		if(nohaL2P.position().y()>world.y){

			
			
			nohaL2P.moveTo(nohaL2P.position().x(),world.y,0);
			
			//nohaL2P.setVelocity(0,0,0);
			nohaL2P.makeFixed();
		}
		
		
		if(nohaR2P.position().y()>world.y&&nohaR2P.velocity().y()>0){

			nohaR2P.moveTo(nohaR2P.position().x(),world.y,0);
			
			nohaR2P.makeFixed();
			
		}
		
		
		
		
	
		                                                                                  
		
		
		/*
		if(nohaR2P.position().y()>world.y){
			nohaR2P.setVelocity(nohaR2P.velocity().x()*fri,nohaR2P.velocity().y(),0.0);
			
		}
		
		if(nohaL2P.position().y()>world.y){
			nohaL2P.setVelocity(nohaL2P.velocity().x()*fri,nohaL2P.velocity().y(),0.0);
			
		}
		
		*/
		
		
		
		
		
		
		///////

		for(int i =0;i<truP.length;i++){
			if(truP[i].position().y()>world.y){

				truP[i].moveTo(truP[i].position().x(),world.y,0);
			}
		
		}

		if(nohaL1P.position().y()>world.y){

			//nohaL1P.setVelocity(nohaL1P.velocity().x()*fri,nohaL1P.velocity().y()*-dmp,0.0);
			nohaL1P.moveTo(nohaL1P.position().x(),world.y,0);
			//nohaL1P.makeFixed();
		}

		

		if(nohaR1P.position().y()>world.y){
			nohaR1P.moveTo(nohaR1P.position().x(),world.y,0);
			//nohaR1P.makeFixed();
		}

		

		if(rukaL1P.position().y()>world.y){

			//rukaL1P.setVelocity(rukaL1P.velocity().x()*fri,rukaL1P.velocity().y()*-dmp,0.0);
			rukaL1P.moveTo(rukaL1P.position().x(),world.y,0);
			//rukaL1P.makeFixed();
		}

		if(rukaL2P.position().y()>world.y){

			//rukaL2P.setVelocity(rukaL2P.velocity().x()*fri,rukaL2P.velocity().y()*-dmp,0.0);
			rukaL2P.moveTo(rukaL2P.position().x(),world.y,0);
			//rukaL2P.makeFixed();
		}

		if(rukaR1P.position().y()>world.y){

			//rukaR1P.setVelocity(rukaR1P.velocity().x()*fri,rukaR1P.velocity().y()*-dmp,0.0);
			rukaR1P.moveTo(rukaR1P.position().x(),world.y,0);
			//rukaR1P.makeFixed();
		}

		if(rukaR2P.position().y()>world.y){

			//rukaR2P.setVelocity(rukaR2P.velocity().x()*fri,rukaR2P.velocity().y()*-dmp,0.0);
			rukaR2P.moveTo(rukaR2P.position().x(),world.y,0);
			//rukaR2P.makeFixed();
		}

		if(hlavaP.position().y()>world.y){

			//hlavaP.setVelocity(hlavaP.velocity().x()*fri,hlavaP.velocity().y()*-dmp,0.0);
			hlavaP.moveTo(hlavaP.position().x(),world.y,0);
			//hlavaP.makeFixed();
		}




	}



	void render(){

		//level0 poziceGlob
		pushMatrix();
		translate(x,y);


		//level1 trup
		pushMatrix();
		translate(positions[0][0],positions[0][1]);
		pushMatrix();

		translate(-anchors[0][0],-anchors[0][1]);
		rotate( (rotation[0]));

		//LEVA RUKA
		//level 2 rukaL1
		pushMatrix();
		translate(positions[8][0],positions[8][1]);
		pushMatrix();
		translate(-anchors[8][0],-anchors[8][1]);
		rotate( (rotation[8])-rotation[0]);
		image(part[8],-anchors[8][0],-anchors[8][1]);

		//level 3 rukaL2
		pushMatrix();
		translate(positions[9][0],positions[9][1]);
		pushMatrix();
		translate(-anchors[9][0],-anchors[9][1]);
		rotate( (rotation[9]-(rotation[8])));
		image(part[9],-anchors[9][0],-anchors[9][1]);



		popMatrix();
		popMatrix();
		//level 3 rukaL2 end
		popMatrix();
		popMatrix();
		//level 2 rukaL1 end

		//trup image
		image(part[0],-anchors[0][0],-anchors[0][1]);


		//LEVA NOHA
		//level 2 hohaL1
		pushMatrix();
		translate(positions[2][0],positions[2][1]);
		pushMatrix();
		translate(-anchors[2][0],-anchors[2][1]);
		rotate( (rotation[2]-rotation[0]));
		image(part[2],-anchors[2][0],-anchors[2][1]);
		//level 3 hohaL2
		pushMatrix();
		translate(positions[3][0],positions[3][1]);
		pushMatrix();
		translate(-anchors[3][0],-anchors[3][1]);
		rotate( (rotation[3]-(rotation[2])));
		//level 4 botaL
		pushMatrix();
		translate(positions[6][0],positions[6][1]);
		pushMatrix();
		translate(-anchors[6][0],-anchors[6][1]);
		rotate( (rotation[6])-((rotation[3])));
		image(part[6],-anchors[6][0],-anchors[6][1]);
		popMatrix();
		popMatrix();
		//level 4 botaL end
		image(part[3],-anchors[3][0],-anchors[3][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaL2 end
		popMatrix();
		popMatrix();
		//level 2 hohaL1 end


		//PRAVA NOHA
		//level 2 hohaR1
		pushMatrix();
		translate(positions[4][0],positions[4][1]);
		pushMatrix();
		translate(-anchors[4][0],-anchors[4][1]);
		rotate( (rotation[4])-rotation[0]);
		image(part[4],-anchors[4][0],-anchors[4][1]);
		//level 3 hohaR2
		pushMatrix();
		translate(positions[5][0],positions[5][1]);
		pushMatrix();
		translate(-anchors[5][0],-anchors[5][1]);
		rotate( (rotation[5])-(rotation[4]));
		//level 4 botaR
		pushMatrix();
		translate(positions[7][0],positions[7][1]);
		pushMatrix();
		translate(-anchors[7][0],-anchors[7][1]);
		rotate( (rotation[7])-(rotation[5]));
		image(part[7],-anchors[7][0],-anchors[7][1]);
		popMatrix();
		popMatrix();
		//level 4 botaR end
		image(part[5],-anchors[5][0],-anchors[5][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaR2 end
		popMatrix();
		popMatrix();
		//level 2 hohaR1 end


		//HLAVA
		//level2 hlava
		pushMatrix();
		translate(positions[1][0],positions[1][1]);
		pushMatrix();
		translate(-anchors[1][0],-anchors[1][1]);
		rotate( (rotation[1])-rotation[0]);
		image(part[1],-anchors[1][0],-anchors[1][1]);
		popMatrix();
		popMatrix();
		//level 2 hlava end

		//PRAVA RUKA
		//level 2 rukaR1
		pushMatrix();
		translate(positions[10][0],positions[10][1]);
		pushMatrix();
		translate(-anchors[10][0],-anchors[10][1]);
		rotate( (rotation[10])-rotation[0]);
		image(part[10],-anchors[10][0],-anchors[10][1]);

		//level 3 rukaR2
		pushMatrix();
		translate(positions[11][0],positions[11][1]);
		pushMatrix();
		translate(-anchors[11][0],-anchors[11][1]);
		rotate( (rotation[11])-rotation[10]);
		image(part[11],-anchors[11][0],-anchors[11][1]);

		popMatrix();
		popMatrix();
		//level 3 rukaR2 end
		popMatrix();
		popMatrix();
		//level 2 rukaR1 end

		popMatrix();
		popMatrix();
		//level1 trup end

		popMatrix();
		//level0 glob end


		if(testing){
			tint(255,50);
			stroke(255,70);

			for(int i =0;i<truP.length;i++){
				//truP[i].moveTo( truP[i].position().x(), truP[i].position().y(), 0.0 );
				rect(truP[i].position().x(),truP[i].position().y(),1,1);
			}

			for(int i =0;i<truS.length;i++){
				Particle p1 = truS[i].getOneEnd();
				Particle p2 = truS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<nohaL1S.length;i++){
				Particle p1 = nohaL1S[i].getOneEnd();
				Particle p2 = nohaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaL2S.length;i++){
				Particle p1 = nohaL2S[i].getOneEnd();
				Particle p2 = nohaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaR1S.length;i++){
				Particle p1 = nohaR1S[i].getOneEnd();
				Particle p2 = nohaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaR2S.length;i++){
				Particle p1 = nohaR2S[i].getOneEnd();
				Particle p2 = nohaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<rukaL1S.length;i++){
				Particle p1 = rukaL1S[i].getOneEnd();
				Particle p2 = rukaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaL2S.length;i++){
				Particle p1 = rukaL2S[i].getOneEnd();
				Particle p2 = rukaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaR1S.length;i++){
				Particle p1 = rukaR1S[i].getOneEnd();
				Particle p2 = rukaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaR2S.length;i++){
				Particle p1 = rukaR2S[i].getOneEnd();
				Particle p2 = rukaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<hlavaS.length;i++){
				Particle p1 = hlavaS[i].getOneEnd();
				Particle p2 = hlavaS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			rect(nohaL1P.position().x(),nohaL1P.position().y(),1,1);
			rect(nohaL2P.position().x(),nohaL2P.position().y(),1,1);

			rect(nohaR1P.position().x(),nohaR1P.position().y(),1,1);
			rect(nohaR2P.position().x(),nohaR2P.position().y(),1,1);

			rect(hlavaP.position().x(),hlavaP.position().y(),1,1);


			rect(rukaL1P.position().x(),rukaL1P.position().y(),1,1);
			rect(rukaL2P.position().x(),rukaL2P.position().y(),1,1);

			rect(rukaR1P.position().x(),rukaR1P.position().y(),1,1);
			rect(rukaR2P.position().x(),rukaR2P.position().y(),1,1);


			rect(senzor.position().x(),senzor.position().y(),1,1);
			line(senzor.position().x(),senzor.position().y(),hlavaP.position().x(),hlavaP.position().y());

		}else{
			noTint();
		}

	}


	void render2(){

		//level0 poziceGlob
		//pushMatrix();
		//translate(x,y);


		//LEVA RUKA
		//level 2 rukaL1
		pushMatrix();
		translate(anchors[8][0]+truP[7].position().x(),anchors[8][1]+truP[7].position().y());
		pushMatrix();
		translate(-anchors[8][0],-anchors[8][1]);
		rotate( (rotation[8]));
		image(part[8],-anchors[8][0]+1,-anchors[8][1]);


		popMatrix();
		popMatrix();
		//level 2 rukaL1 end

		
		//level 3 rukaL2
		pushMatrix();
		translate(rukaL1P.position().x()+anchors[9][0],rukaL1P.position().y()+anchors[9][1]);
		pushMatrix();
		translate(-anchors[9][0],-anchors[9][1]);
		rotate( (rotation[9]));
		image(part[9],-anchors[9][0]-1,-anchors[9][1]-2);
		popMatrix();
		popMatrix();
		//level 3 rukaL2 end
		
		//level1 trup
		pushMatrix();
		translate(anchors[0][0]+truP[5].position().x(),anchors[0][1]+truP[5].position().y());
		pushMatrix();

		translate(-anchors[0][0],-anchors[0][1]);
		rotate( (rotation[0]));
		//trup image
		image(part[0],-anchors[0][0],-anchors[0][1]+9);

		popMatrix();
		popMatrix();
		//level1 trup end



		



		//LEVA NOHA
		//level 2 hohaL1
		pushMatrix();
		translate(anchors[2][0]+truP[10].position().x(),anchors[2][1]+truP[10].position().y());
		pushMatrix();
		translate(-anchors[2][0],-anchors[2][1]);
		rotate( (rotation[2]));
		image(part[2],-anchors[2][0]+2,-anchors[2][1]);

		popMatrix();
		popMatrix();
		//level 2 hohaL1 end

		//level 3 hohaL2
		pushMatrix();
		translate(anchors[3][0]+nohaL1P.position().x(),anchors[3][1]+nohaL1P.position().y());
		pushMatrix();
		translate(-anchors[3][0],-anchors[3][1]);
		rotate( (rotation[3]));
		image(part[3],-anchors[3][0],-anchors[3][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaL2 end



		//PRAVA NOHA
		//level 2 hohaR1
		pushMatrix();
		translate(truP[9].position().x()+anchors[4][0],truP[9].position().y()+anchors[4][1]);
		pushMatrix();
		translate(-anchors[4][0],-anchors[4][1]);
		rotate( (rotation[4]));
		image(part[4],-anchors[4][0],-anchors[4][1]);
		popMatrix();
		popMatrix();
		//level 2 hohaR1 end



		//level 3 hohaR2
		pushMatrix();
		translate(anchors[5][0]+nohaR1P.position().x(),anchors[5][1]+nohaR1P.position().y());
		pushMatrix();
		translate(-anchors[5][0]-1,-anchors[5][1]);
		rotate( (rotation[5]));
		/*/level 4 botaR
		pushMatrix();
		translate(positions[7][0],positions[7][1]);
		pushMatrix();
		translate(-anchors[7][0],-anchors[7][1]);
		rotate( (rotation[7])-(rotation[5]));
		image(part[7],-anchors[7][0],-anchors[7][1]);
		popMatrix();
		popMatrix();
		//level 4 botaR end*/
		image(part[5],-anchors[5][0],-anchors[5][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaR2 end


		//HLAVA
		//level2 hlava
		pushMatrix();
		translate(0.5*(truP[1].position().x()+truP[2].position().x())+anchors[1][0],0.5*(truP[1].position().y()+truP[2].position().y())+anchors[1][1]);
		pushMatrix();
		translate(-anchors[1][0],-anchors[1][1]);
		rotate( (rotation[1]));
		image(part[1],-anchors[1][0],-anchors[1][1]);
		popMatrix();
		popMatrix();
		//level 2 hlava end

		//PRAVA RUKA
		//level 2 rukaR1
		pushMatrix();
		translate(anchors[10][0]+truP[8].position().x(),anchors[10][1]+truP[8].position().y());
		pushMatrix();
		translate(-anchors[10][0],-anchors[10][1]);
		rotate( (rotation[10]));
		image(part[10],-anchors[10][0],-anchors[10][1]);

		popMatrix();
		popMatrix();
		//level 2 rukaR1 end

		//level 3 rukaR2
		pushMatrix();
		translate(anchors[11][0]+rukaR1P.position().x(),anchors[11][1]+rukaR1P.position().y());
		pushMatrix();
		translate(-anchors[11][0],-anchors[11][1]);
		rotate( (rotation[11]) );
		image(part[11],-anchors[11][0],-anchors[11][1]);

		popMatrix();
		popMatrix();
		//level 3 rukaR2 end




		//popMatrix();
		//level0 glob end


		if(testing){
			tint(255,50);
			stroke(255,70);

			for(int i =0;i<truP.length;i++){
				//truP[i].moveTo( truP[i].position().x(), truP[i].position().y(), 0.0 );
				rect(truP[i].position().x(),truP[i].position().y(),1,1);
			}

			for(int i =0;i<truS.length;i++){
				Particle p1 = truS[i].getOneEnd();
				Particle p2 = truS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<nohaL1S.length;i++){
				Particle p1 = nohaL1S[i].getOneEnd();
				Particle p2 = nohaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaL2S.length;i++){
				Particle p1 = nohaL2S[i].getOneEnd();
				Particle p2 = nohaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaR1S.length;i++){
				Particle p1 = nohaR1S[i].getOneEnd();
				Particle p2 = nohaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaR2S.length;i++){
				Particle p1 = nohaR2S[i].getOneEnd();
				Particle p2 = nohaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<rukaL1S.length;i++){
				Particle p1 = rukaL1S[i].getOneEnd();
				Particle p2 = rukaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaL2S.length;i++){
				Particle p1 = rukaL2S[i].getOneEnd();
				Particle p2 = rukaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaR1S.length;i++){
				Particle p1 = rukaR1S[i].getOneEnd();
				Particle p2 = rukaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaR2S.length;i++){
				Particle p1 = rukaR2S[i].getOneEnd();
				Particle p2 = rukaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<hlavaS.length;i++){
				Particle p1 = hlavaS[i].getOneEnd();
				Particle p2 = hlavaS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			rect(nohaL1P.position().x(),nohaL1P.position().y(),1,1);
			rect(nohaL2P.position().x(),nohaL2P.position().y(),1,1);

			rect(nohaR1P.position().x(),nohaR1P.position().y(),1,1);
			rect(nohaR2P.position().x(),nohaR2P.position().y(),1,1);

			rect(hlavaP.position().x(),hlavaP.position().y(),1,1);


			rect(rukaL1P.position().x(),rukaL1P.position().y(),1,1);
			rect(rukaL2P.position().x(),rukaL2P.position().y(),1,1);

			rect(rukaR1P.position().x(),rukaR1P.position().y(),1,1);
			rect(rukaR2P.position().x(),rukaR2P.position().y(),1,1);


			rect(senzor.position().x(),senzor.position().y(),1,1);
			line(senzor.position().x(),senzor.position().y(),hlavaP.position().x(),hlavaP.position().y());

		}else{
			noTint();
		}

	}

	void reload(){

		mapa = loadImage(skin);
		maska = new int[mapa.pixels.length];

		marks = new String[0];
		for(int y =0;y<mapa.height;y++){
			for(int x =0;x<mapa.width;x++){
				int which = y*mapa.width+x;
				if(brightness(mapa.pixels[which])==0){
					maska[which] = 0;
				}else if(brightness(mapa.pixels[which])>254){
					marks = (String[])expand(marks,marks.length+1);
					marks[marks.length-1] = ""+x+","+y;
				}else{
					maska[which] = 255;
				}
			}
		}

		mapa.mask(maska);


		//hlava
		part[0] = createGraphics(8,16,JAVA2D);

		//trup
		part[1] = createGraphics(9,9,JAVA2D);


		//nohaL1
		part[2]= createGraphics(4,8,JAVA2D);
		//nohaL2
		part[3]= createGraphics(4,7,JAVA2D);

		//nohaR1
		part[4]= createGraphics(4,8,JAVA2D);
		//nohaR2
		part[5]= createGraphics(4,7,JAVA2D);

		//botaL
		part[6]= createGraphics(4,4,JAVA2D);
		//botaR
		part[7]= createGraphics(4,4,JAVA2D);

		//rukaL1
		part[8] = createGraphics(5,9,JAVA2D);
		//rukaL2
		part[9] = createGraphics(3,11,JAVA2D);

		//rukaR1
		part[10] = createGraphics(5,9,JAVA2D);
		//rukaR2
		part[11]= createGraphics(3,11,JAVA2D);


		fillGraphics();

		for(int i =0;i<rotation.length;i++){
			rotation[i] = 0;//random(-30,30);

		}

	}

}





class World{
	float y = height-5;

	void render(){
		stroke(0);
		fill(6);
		rect(0,y,width,height-y);

	}

}
import traer.physics.*;




Hero hero,soldier;
World world;
Recorder r;


float gravity = 0.3;
float density = 0.07;

boolean rec = false;

void setup(){
	size(320,240,OPENGL);

	hint(DISABLE_OPENGL_2X_SMOOTH) ;

	hero = new Hero((int)(width/3)*2,210,"figurka3.png");	
	
	noSmooth();

	frameRate(30);


	world = new World();

	//rectMode(CENTER);
	noFill();
	stroke(255,100);
	
	if(rec)
	r = new Recorder("out","tanec.mp4");
}


void gradient(color a,color b,int steps){
	noStroke();
	for(int i =0;i<steps;i++){
		fill(lerpColor(a,b,map(i,0,steps-1,0,1)));
		rect(0,map(i,0,steps,0,height),width,height/(steps+1.0));
	
	}

}

void draw(){


	//background(0);
	gradient(color(#5d5d6d),color(50),24);
	
	float akcel = degrees(atan2(hero.senzor.position().y()-hero.hlavaP.position().y(),hero.senzor.position().x()-hero.hlavaP.position().x())-HALF_PI);
	float naklon = degrees(atan2(hero.truP[5].position().y()-hero.hlavaP.position().y(),hero.truP[5].position().x()-hero.hlavaP.position().x())-HALF_PI);



	float acc = (naklon);//(naklon+akcel)/2.0;
	float ang = 90;
	acc = constrain(acc,-ang,ang);

	//println(acc);
	//if(frameCount%10==0)
	//	println(acc);
	
	
	if(frameCount>100){


// float val = map(mouseX,0,width,0,1);
  //       float val2 = map(mouseY,0,width,1,2);
         
		hero.trupQ[0] = map(sin(frameCount/20.0),-1,1,hero.initialQ[18]-4,hero.initialQ[18]+4);
		hero.trupQ[1] = map(sin(frameCount/20.0),-1,1,hero.initialQ[19]+4,hero.initialQ[19]-4);

		hero.hlavaQ[0] = hero.initialQ[0]+sin(frameCount/22.0);
		hero.hlavaQ[1] = hero.initialQ[1]-sin(frameCount/22.0);                           

	}
/*

	float val = map(mouseX,0,width,0,1);
	float val2 = map(mouseY,0,width,1,2);
	hero.nohaLQ[0] = hero.initialQ[10]*(1.0-val*val2);//map(acc,ang,-ang,+2,hero.initialQ[10]-4.5);
	hero.nohaLQ[1] = hero.initialQ[11]*(1.0+val*val2);//map(acc,ang,-ang,hero.initialQ[11]-2,hero.initialQ[11]+4.5);
	hero.nohaLQ[2] = hero.initialQ[12]*(1.0-val);//map(acc,-ang,ang,hero.initialQ[12]-3,hero.initialQ[12]+3);
	hero.nohaLQ[3] = hero.initialQ[13]*(1.0-val);//map(acc,ang,-ang,hero.initialQ[13]-3,hero.initialQ[13]+3);

	hero.nohaRQ[0] = hero.initialQ[14]*1.5;//map(acc,-ang,ang,+2,hero.initialQ[14]-4.5);
	hero.nohaRQ[1] = hero.initialQ[15]*0.5;//map(acc,-ang,ang,hero.initialQ[15]-2,hero.initialQ[15]+4.5);
	hero.nohaRQ[2] = hero.initialQ[16]-(sin(frameCount/30.0))*6.0;//map(acc,ang,-ang,hero.initialQ[16]-3,hero.initialQ[16]+3);
	hero.nohaRQ[3] = hero.initialQ[17]+(sin(frameCount/30.0))*6.0;//map(acc,-ang,ang,hero.initialQ[17]-3,hero.initialQ[17]+3);


		
	
	
	hero.nohaLQ[0] = map(acc,ang,-ang,hero.initialQ[10]+2,hero.initialQ[10]-4.5);
	hero.nohaLQ[1] = map(acc,ang,-ang,hero.initialQ[11]-2,hero.initialQ[11]+4.5);
	hero.nohaLQ[2] = map(acc,-ang,ang,hero.initialQ[12]-3,hero.initialQ[12]+3);
	hero.nohaLQ[3] = map(acc,ang,-ang,hero.initialQ[13]-3,hero.initialQ[13]+3);

	hero.nohaRQ[0] = map(acc,-ang,ang,hero.initialQ[14]+2,hero.initialQ[14]-4.5);
	hero.nohaRQ[1] = map(acc,-ang,ang,hero.initialQ[15]-2,hero.initialQ[15]+4.5);
	hero.nohaRQ[2] = map(acc,ang,-ang,hero.initialQ[16]-3,hero.initialQ[16]+3);
	hero.nohaRQ[3] = map(acc,-ang,ang,hero.initialQ[17]-3,hero.initialQ[17]+3);


	hero.rukaRQ[0] = map(acc,ang,-ang,hero.initialQ[6],hero.initialQ[6]+5);
	hero.rukaRQ[1] = map(acc,ang,-ang,hero.initialQ[7],hero.initialQ[7]-5);
	hero.rukaRQ[2] = map(acc,ang,-ang,hero.initialQ[8],hero.initialQ[8]+2);
	hero.rukaRQ[3] = map(acc,ang,-ang,hero.initialQ[9],hero.initialQ[9]-2);

	hero.trupQ[0] = map(acc,ang,-ang,hero.initialQ[18]-2,hero.initialQ[18]+2);
	hero.trupQ[1] = map(acc,ang,-ang,hero.initialQ[19]+2,hero.initialQ[19]-2);


	hero.nohaLQ[0] = map(sin(frameCount/10.0),1,-1,hero.initialQ[10],hero.initialQ[10]-4.5);
	hero.nohaLQ[1] = map(sin(frameCount/10.0),1,-1,hero.initialQ[11],hero.initialQ[11]+4.5);
	hero.nohaLQ[2] = map(sin(frameCount/10.0),-1,1,hero.initialQ[12]-3,hero.initialQ[12]+3);
	hero.nohaLQ[3] = map(sin(frameCount/10.0),1,-1,hero.initialQ[13]-3,hero.initialQ[13]+3);

	hero.nohaRQ[0] = map(sin(frameCount/10.0),1,-1,hero.initialQ[14],hero.initialQ[14]-4.5);
	hero.nohaRQ[1] = map(sin(frameCount/10.0),1,-1,hero.initialQ[15],hero.initialQ[15]+4.5);
	hero.nohaRQ[2] = map(sin(frameCount/10.0),-1,1,hero.initialQ[16]-3,hero.initialQ[16]+1);
	hero.nohaRQ[3] = map(sin(frameCount/10.0),1,-1,hero.initialQ[17]-3,hero.initialQ[17]+1);
	*/


	//hero.rukaRQ[2] = map(sin(frameCount/5.0),-1,1,hero.initialQ[8]-4,hero.initialQ[8]+4);
	//hero.rukaRQ[3] = map(sin(frameCount/5.0),1,-1,hero.initialQ[9]-4,hero.initialQ[9]+4);


	pushMatrix();

	scale(2.0);
	translate(-hero.hlavaP.position().x()/2-20,-hero.hlavaP.position().y()/2-10);
	hero.act();
	//soldier.act();
	//line(rukaL2P.position().x(),rukaL2P.position().y(),anchor.position().x(),anchor.position().y());
	world.render();

	popMatrix();
	
	if(rec)
	r.add();
}


void keyPressed(){
	if(key=='w'){
		hero.control = 0;
	}else if(key == 't'){
		hero.testing = !hero.testing;

	}else if(key == 'q'){
		if(rec)
		r.finish();
		exit();
	
	}else if(key==' '){
		save("shot.png");
	}

}


void mousePressed(){

	println(mouseX+" : "+mouseY);

}



class Hero{

	PImage mapa;
	String skin;
	int maska[];
	int anchors[][] = {{4,22},{5,7},

	                   {4,1},{2,0},{2,1},{1,0},
	                   {1,0},{1,0},

	                   {4,2},{1,1},{2,2},{1,1}
	                  };

	int positions[][] = {{0,0},{6,-3},

	                     {-1,4},{0,7},{4,4},{0,7},
	                     {2,6},{1,6},

	                     {1,-4},{-1,6},{7,-4},{1,6}

	                    };


	float mass[] = {
	                       0.6,0.15,

	                       0.15,0.15,0.15,0.15,
	                       0.03,0.03,

	                       0.12,0.1,0.12,0.1
	               };

	float rotation[] = new float[12];

	float limits[][] = {
	                           {-180,180},{-46.8,36.77},

	                           {138.0,-25.0},{5.2,-113.0},{138.0,-25.0},{5.2,-113.0},
	                           {-34.0,59.0},{-34.0,59.0},

	                           {178.0,-39.0},{158.0,-1.0},{169.0,-115.0},{133.0,-10.0}

	                   };

	PGraphics part[] = new PGraphics[12];

	String marks[] = new String[0];

	int x,y;
	int control = 0;

	ParticleSystem physics;

	boolean testing = false;

	Particle truP[] = new Particle[11];
	Spring truS[]  = new Spring[28];

	Particle nohaL1P;
	Spring nohaL1S[] = new Spring[3];
	Particle nohaL2P;
	Spring nohaL2S[] = new Spring[3];

	Particle nohaR1P;
	Spring nohaR1S[] = new Spring[3];
	Particle nohaR2P;
	Spring nohaR2S[] = new Spring[3];


	Particle rukaL1P;
	Spring rukaL1S[] = new Spring[3];
	Particle rukaL2P;
	Spring rukaL2S[] = new Spring[3];

	Particle rukaR1P;
	Spring rukaR1S[] = new Spring[3];
	Particle rukaR2P;
	Spring rukaR2S[] = new Spring[3];

	Particle hlavaP;
	Spring hlavaS[] = new Spring[2];

	Particle senzor;
	Spring senzorS;

	
	float[] check = new float[2];

	float hlavaSila = 3.0;
	float hlavaDamp = 0.01;

	float ruceSila = 3.0;
	float ruceDamp = 0.001;

	float nohySila = 5.0;
	float nohyDamp = 0.001;

	float hlavaQ[] = new float[2];
	float trupQ[] = new float[2];

	float rukaLQ[] = new float[4];
	float rukaRQ[] = new float[4];

	float nohaLQ[] = new float[4];
	float nohaRQ[] = new float[4];

	float initialQ[] = new float[20];

	
	//////////////////////
	Hero(int _x,int _y,String _skin){
		x = _x;
		y= _y;
		skin = _skin+"";
		reload();

		physics = new ParticleSystem( gravity, density );
		setPhy();

		initialQ[0] = hlavaQ[0];
		initialQ[1] = hlavaQ[1];

		initialQ[2] = rukaLQ[0];
		initialQ[3] = rukaLQ[1];
		initialQ[4] = rukaLQ[2];
		initialQ[5] = rukaLQ[3];

		initialQ[6] = rukaRQ[0];
		initialQ[7] = rukaRQ[1];
		initialQ[8] = rukaRQ[2];
		initialQ[9] = rukaRQ[3];

		initialQ[10] = nohaLQ[0];
		initialQ[11] = nohaLQ[1];
		initialQ[12] = nohaLQ[2];
		initialQ[13] = nohaLQ[3];

		initialQ[14] = nohaRQ[0];
		initialQ[15] = nohaRQ[1];
		initialQ[16] = nohaRQ[2];
		initialQ[17] = nohaRQ[3];

		initialQ[18] = trupQ[0];
		initialQ[19] = trupQ[1];
		
		check[0] = nohaL2S[2].currentLength();
		check[1] = nohaR2S[2].currentLength();
		

	}


	void setPhy(){

		// torso
		truP[0] = physics.makeParticle( mass[0], x-7, y-16, 0.0 );
		truP[1] = physics.makeParticle( mass[0], x-7, y-22, 0.0 );
		truP[2] = physics.makeParticle( mass[0], x-1, y-22, 0.0 );
		truP[3] = physics.makeParticle( mass[0], x-1, y-16, 0.0 );
		truP[4] = physics.makeParticle( mass[0], x,y-12, 0.0 );
		truP[5] = physics.makeParticle( mass[0], x-4,y-9, 0.0 );
		truP[6] = physics.makeParticle( mass[0], x-8,y-12, 0.0 );

		truP[7] = physics.makeParticle( mass[0], x-9,y-19, 0.0 );
		truP[8] = physics.makeParticle( mass[0], x+1,y-19, 0.0 );

		truP[9] = physics.makeParticle( mass[0], x-1,y-8, 0.0 );
		truP[10] = physics.makeParticle( mass[0], x-7,y-8, 0.0 );

		truS[0] = physics.makeSpring(truP[0], truP[1],1,1,1);
		truS[1] = physics.makeSpring(truP[1], truP[2],1,1,1);
		truS[2] = physics.makeSpring(truP[2], truP[3],1,1,1);
		truS[3] = physics.makeSpring(truP[3], truP[4],1,1,1);
		truS[4] = physics.makeSpring(truP[4], truP[5],1,1,1);
		truS[5] = physics.makeSpring(truP[5], truP[6],1,1,1);
		truS[6] = physics.makeSpring(truP[6], truP[0],1,1,1);
		truS[7] = physics.makeSpring(truP[5], truP[0],1,1,1);
		truS[8] = physics.makeSpring(truP[5], truP[1],1,1,1);
		truS[9] = physics.makeSpring(truP[5], truP[2],1,1,1);
		truS[10] = physics.makeSpring(truP[5], truP[3],1,1,1);
		truS[11] = physics.makeSpring(truP[0], truP[3],1,1,1);
		truS[12] = physics.makeSpring(truP[0], truP[2],1,1,1);
		truS[13] = physics.makeSpring(truP[1], truP[3],1,1,1);
		truS[14] = physics.makeSpring(truP[4], truP[6],1,1,1);

		truS[15] = physics.makeSpring(truP[0], truP[7],1,1,1);
		truS[16] = physics.makeSpring(truP[1], truP[7],1,1,1);

		truS[17] = physics.makeSpring(truP[2], truP[8],1,1,1);
		truS[18] = physics.makeSpring(truP[3], truP[8],1,1,1);

		truS[19] = physics.makeSpring(truP[4], truP[9],1,1,1);
		truS[20] = physics.makeSpring(truP[5], truP[9],1,1,1);

		truS[21] = physics.makeSpring(truP[6], truP[10],1,1,1);
		truS[22] = physics.makeSpring(truP[5], truP[10],1,1,1);

		truS[23] = physics.makeSpring(truP[7], truP[8],1,1,1);
		truS[24] = physics.makeSpring(truP[9], truP[6],1,1,1);
		truS[25] = physics.makeSpring(truP[10], truP[4],1,1,1);

		truS[26] = physics.makeSpring(truP[0], truP[4],1,1,1);
		truS[27] = physics.makeSpring(truP[3], truP[6],1,1,1);


		for(int i =0;i<truS.length;i++){
			truS[i].setRestLength( truS[i].currentLength() );
			truS[i].setStrength( 14.0);
			truS[i].setDamping( 0.0001 );
		}

		trupQ[0] = truS[3].currentLength();
		trupQ[1] = truS[6].currentLength();



		////
		hlavaP = physics.makeParticle( mass[1], x-4, y-28, 0 );

		hlavaS[0] = physics.makeSpring( truP[1], hlavaP, 1,1,1 );
		hlavaS[1] = physics.makeSpring( truP[2], hlavaP, 1,1,1 );

		for(int i =0;i<hlavaS.length;i++){
			hlavaQ[i]=hlavaS[i].currentLength();
			hlavaS[i].setRestLength( hlavaS[i].currentLength() );
			hlavaS[i].setStrength( hlavaSila);
			hlavaS[i].setDamping( hlavaDamp );
		}

		senzor = physics.makeParticle( 0.1 , x-4, y-23, 0 );
		senzorS = physics.makeSpring( hlavaP, senzor, 1,1,1 );
		senzorS.setRestLength( senzorS.currentLength() );
		senzorS.setStrength( 3.0 );
		senzorS.setDamping( 0.1 );

		////
		nohaL1P = physics.makeParticle( mass[2], x-7, y-2, 0 );

		nohaL1S[0] = physics.makeSpring( truP[6], nohaL1P, 1,1,1 );
		nohaL1S[1] = physics.makeSpring( truP[5], nohaL1P, 1,1,1 );
		nohaL1S[2] = physics.makeSpring( truP[10], nohaL1P, 1,1,1 );


		nohaLQ[0] = nohaL1S[0].currentLength();
		nohaLQ[1] = nohaL1S[1].currentLength();

		for(int i =0;i<nohaL1S.length;i++){
			nohaL1S[i].setRestLength( nohaL1S[i].currentLength() );
			nohaL1S[i].setStrength( nohySila);
			nohaL1S[i].setDamping( nohyDamp );

		}

		//////
		nohaL2P = physics.makeParticle( mass[3], x-7, y+4, 0 );

		nohaL2S[0] = physics.makeSpring( truP[6], nohaL2P, 1,1,1 );
		nohaL2S[1] = physics.makeSpring( truP[5], nohaL2P, 1,1,1 );
		nohaL2S[2] = physics.makeSpring( nohaL1P, nohaL2P, 1,1,1 );


		nohaLQ[2] = nohaL2S[0].currentLength();
		nohaLQ[3] = nohaL2S[1].currentLength();


		for(int i =0;i<nohaL2S.length;i++){
			nohaL2S[i].setRestLength( nohaL2S[i].currentLength() );
			nohaL2S[i].setStrength( nohySila);
			nohaL2S[i].setDamping( nohyDamp );

		}


		////
		nohaR1P = physics.makeParticle( mass[4], x-1, y-2, 0 );

		nohaR1S[0] = physics.makeSpring( truP[4], nohaR1P, 1,1,1 );
		nohaR1S[1] = physics.makeSpring( truP[5], nohaR1P, 1,1,1 );
		nohaR1S[2] = physics.makeSpring( truP[9], nohaR1P, 1,1,1 );


		nohaRQ[0] = nohaR1S[0].currentLength();
		nohaRQ[1] = nohaR1S[1].currentLength();

		for(int i =0;i<nohaL1S.length;i++){
			nohaR1S[i].setRestLength( nohaR1S[i].currentLength() );
			nohaR1S[i].setStrength( nohySila);
			nohaR1S[i].setDamping( nohyDamp );

		}

		//////
		nohaR2P = physics.makeParticle( mass[5], x-1 , y+4, 0 );

		nohaR2S[0] = physics.makeSpring( truP[4], nohaR2P, 1,1,1 );
		nohaR2S[1] = physics.makeSpring( truP[5], nohaR2P, 1,1,1 );
		nohaR2S[2] = physics.makeSpring( nohaR1P, nohaR2P, 1,1,1 );


		nohaRQ[2] = nohaR2S[0].currentLength();
		nohaRQ[3] = nohaR2S[1].currentLength();


		for(int i =0;i<nohaR2S.length;i++){
			nohaR2S[i].setRestLength( nohaR2S[i].currentLength() );
			nohaR2S[i].setStrength( nohySila);
			nohaR2S[i].setDamping( nohyDamp );

		}



		//////////////////// RUCE

		////
		rukaL1P = physics.makeParticle( mass[8], x-13, y-19, 0 );

		rukaL1S[0] = physics.makeSpring( truP[1], rukaL1P, 1,1,1 );
		rukaL1S[1] = physics.makeSpring( truP[0], rukaL1P, 1,1,1 );
		rukaL1S[2] = physics.makeSpring( truP[7], rukaL1P, 1,1,1 );


		rukaLQ[0] = rukaL1S[0].currentLength();
		rukaLQ[1] = rukaL1S[1].currentLength();

		for(int i =0;i<rukaL1S.length;i++){
			rukaL1S[i].setRestLength( rukaL1S[i].currentLength() );
			rukaL1S[i].setStrength( ruceSila);
			rukaL1S[i].setDamping( ruceDamp );

		}

		//////
		rukaL2P = physics.makeParticle( mass[9], x-18, y-19, 0 );

		rukaL2S[0] = physics.makeSpring( truP[1], rukaL2P, 1,1,1 );
		rukaL2S[1] =physics.makeSpring( truP[0], rukaL2P, 1,1,1 );
		rukaL2S[2] = physics.makeSpring( rukaL1P, rukaL2P, 1,1,1 );

		rukaLQ[2] = rukaL2S[0].currentLength();
		rukaLQ[3] = rukaL2S[1].currentLength();

		for(int i =0;i<rukaL2S.length;i++){
			rukaL2S[i].setRestLength( rukaL2S[i].currentLength() );
			rukaL2S[i].setStrength( ruceSila);
			rukaL2S[i].setDamping( ruceDamp );

		}


		////
		rukaR1P = physics.makeParticle( mass[10], x+5, y-19, 0 );

		rukaR1S[0] = physics.makeSpring( truP[2], rukaR1P, 1,1,1 );
		rukaR1S[1] = physics.makeSpring( truP[3], rukaR1P, 1,1,1 );
		rukaR1S[2] = physics.makeSpring( truP[8], rukaR1P, 1,1,1 );


		rukaRQ[0] = rukaR1S[0].currentLength();
		rukaRQ[1] = rukaR1S[1].currentLength();


		for(int i =0;i<rukaR1S.length;i++){
			rukaR1S[i].setRestLength( rukaR1S[i].currentLength() );
			rukaR1S[i].setStrength( ruceSila);
			rukaR1S[i].setDamping( ruceDamp );

		}

		//////
		rukaR2P = physics.makeParticle( mass[11], x+11, y-19, 0 );

		rukaR2S[0] = physics.makeSpring( truP[2], rukaR2P, 1,1,1 );
		rukaR2S[1] = physics.makeSpring( truP[3], rukaR2P, 1,1,1 );
		rukaR2S[2] = physics.makeSpring( rukaR1P, rukaR2P, 1,1,1 );


		rukaRQ[2] = rukaR2S[0].currentLength();
		rukaRQ[3] = rukaR2S[1].currentLength();

		for(int i =0;i<rukaR2S.length;i++){
			rukaR2S[i].setRestLength( rukaR2S[i].currentLength() );
			rukaR2S[i].setStrength( ruceSila);
			rukaR2S[i].setDamping( ruceDamp );
		}



	}



	void act(){
		physics.advanceTime( 0.2 );
		move();
		compute();
		render2();

	}

	void move(){

		hlavaS[0].setRestLength(hlavaQ[0]);
		hlavaS[1].setRestLength(hlavaQ[1]);
		//L noha
		nohaL1S[0].setRestLength(nohaLQ[0]);
		nohaL1S[1].setRestLength(nohaLQ[1]);

		nohaL2S[0].setRestLength(nohaLQ[2]);
		nohaL2S[1].setRestLength(nohaLQ[3]);

		//R noha
		nohaR1S[0].setRestLength( nohaRQ[0]);
		nohaR1S[1].setRestLength( nohaRQ[1]);

		nohaR2S[0].setRestLength( nohaRQ[2]);
		nohaR2S[1].setRestLength( nohaRQ[3]);

		//L ruka
		rukaL1S[0].setRestLength( rukaLQ[0]);
		rukaL1S[1].setRestLength( rukaLQ[1]);

		rukaL2S[0].setRestLength( rukaLQ[2]);
		rukaL2S[1].setRestLength( rukaLQ[3]);


		//R ruka
		rukaR1S[0].setRestLength( rukaRQ[0]);
		rukaR1S[1].setRestLength( rukaRQ[1]);

		rukaR2S[0].setRestLength( rukaRQ[2]);
		rukaR2S[1].setRestLength( rukaRQ[3]);

		//trup
		truS[3].setRestLength( trupQ[0]);
		truS[6].setRestLength( trupQ[1]);

	}

	void compute(){

		x=(int)((truP[1].position().x()+truP[3].position().x()+truP[6].position().x()+truP[4].position().x())/4.0)+4;
		y=(int)((truP[1].position().y()+truP[3].position().y()+truP[6].position().y()+truP[4].position().y())/4.0)+12;

		move();

		partRotate(0,atan2( (truP[1].position().y()+truP[2].position().y())*.5-truP[5].position().y(),(truP[1].position().x()+truP[2].position().x())*.5-truP[5].position().x())+ HALF_PI );

		//noha L
		partRotate(2,atan2(nohaL1P.position().y()-truP[10].position().y(),nohaL1P.position().x()-truP[10].position().x())-HALF_PI);
		partRotate(3,atan2(nohaL2P.position().y()-nohaL1P.position().y(),nohaL2P.position().x()-nohaL1P.position().x())-HALF_PI  );

		//nohaR
		partRotate(4,atan2(nohaR1P.position().y()-truP[9].position().y(),nohaR1P.position().x()-truP[9].position().x())-HALF_PI  );
		partRotate(5,atan2(nohaR2P.position().y()-nohaR1P.position().y(),nohaR2P.position().x()-nohaR1P.position().x())-HALF_PI  );


		//kotniky inactive
		partRotate(6,atan2(nohaL2P.position().y()-nohaL1P.position().y(),nohaL2P.position().x()-nohaL1P.position().x())-HALF_PI );
		partRotate(7,atan2(nohaR2P.position().y()-nohaR1P.position().y(),nohaR2P.position().x()-nohaR1P.position().x())-HALF_PI );


		// hlava
		partRotate(1,atan2(hlavaP.position().y()-lerp(truP[1].position().y(),truP[2].position().y(),0.5),hlavaP.position().x()-lerp(truP[1].position().x(),truP[2].position().x(),0.5))+ HALF_PI );

		//ruka L
		partRotate(8,atan2(rukaL1P.position().y()-truP[7].position().y(),rukaL1P.position().x()-truP[7].position().x())  +HALF_PI-PI);
		partRotate(9,atan2(rukaL2P.position().y()-rukaL1P.position().y(),rukaL2P.position().x()-rukaL1P.position().x()) - HALF_PI);


		//ruka R
		partRotate(10,atan2(rukaR1P.position().y()-truP[8].position().y(),rukaR1P.position().x()-truP[8].position().x()) - HALF_PI);
		partRotate(11,atan2(rukaR2P.position().y()-rukaR1P.position().y(),rukaR2P.position().x()-rukaR1P.position().x()) - HALF_PI);
		//float finetune = map(mouseX,0,width,0,1);
		//println(finetune);

		collide();

	}

	void partRotate(int i,float kolik){

		rotation[i] = (kolik);//map(kolik,-PI,PI,-180,180);//limits[i][0],limits[i][1]);

	}

	void fillGraphics(){

		for(int i = 0;i<part.length;i++){
			String temp[] = splitTokens(marks[i],",");
			int x = -(parseInt(temp[0])+2);
			int y = -(parseInt(temp[1])+2);
			part[i].beginDraw();
			part[i].image(mapa,x,y);
			part[i].endDraw();
		}

	}

	void collide(){

		float fri = 0.5;
		float dmp = 0.00;
		
		/////////
		
		if(nohaL2P.position().y()>world.y){

			
			
			nohaL2P.moveTo(nohaL2P.position().x(),world.y,0);
			
			//nohaL2P.setVelocity(0,0,0);
			nohaL2P.makeFixed();
		}
		
		
		if(nohaR2P.position().y()>world.y&&nohaR2P.velocity().y()>0){

			nohaR2P.moveTo(nohaR2P.position().x(),world.y,0);
			
			nohaR2P.makeFixed();
			
		}
		
		
		
		
	
		                                                                                  
		
		
		/*
		if(nohaR2P.position().y()>world.y){
			nohaR2P.setVelocity(nohaR2P.velocity().x()*fri,nohaR2P.velocity().y(),0.0);
			
		}
		
		if(nohaL2P.position().y()>world.y){
			nohaL2P.setVelocity(nohaL2P.velocity().x()*fri,nohaL2P.velocity().y(),0.0);
			
		}
		
		*/
		
		
		
		
		
		
		///////

		for(int i =0;i<truP.length;i++){
			if(truP[i].position().y()>world.y){

				truP[i].moveTo(truP[i].position().x(),world.y,0);
			}
		
		}

		if(nohaL1P.position().y()>world.y){

			//nohaL1P.setVelocity(nohaL1P.velocity().x()*fri,nohaL1P.velocity().y()*-dmp,0.0);
			nohaL1P.moveTo(nohaL1P.position().x(),world.y,0);
			//nohaL1P.makeFixed();
		}

		

		if(nohaR1P.position().y()>world.y){
			nohaR1P.moveTo(nohaR1P.position().x(),world.y,0);
			//nohaR1P.makeFixed();
		}

		

		if(rukaL1P.position().y()>world.y){

			//rukaL1P.setVelocity(rukaL1P.velocity().x()*fri,rukaL1P.velocity().y()*-dmp,0.0);
			rukaL1P.moveTo(rukaL1P.position().x(),world.y,0);
			//rukaL1P.makeFixed();
		}

		if(rukaL2P.position().y()>world.y){

			//rukaL2P.setVelocity(rukaL2P.velocity().x()*fri,rukaL2P.velocity().y()*-dmp,0.0);
			rukaL2P.moveTo(rukaL2P.position().x(),world.y,0);
			//rukaL2P.makeFixed();
		}

		if(rukaR1P.position().y()>world.y){

			//rukaR1P.setVelocity(rukaR1P.velocity().x()*fri,rukaR1P.velocity().y()*-dmp,0.0);
			rukaR1P.moveTo(rukaR1P.position().x(),world.y,0);
			//rukaR1P.makeFixed();
		}

		if(rukaR2P.position().y()>world.y){

			//rukaR2P.setVelocity(rukaR2P.velocity().x()*fri,rukaR2P.velocity().y()*-dmp,0.0);
			rukaR2P.moveTo(rukaR2P.position().x(),world.y,0);
			//rukaR2P.makeFixed();
		}

		if(hlavaP.position().y()>world.y){

			//hlavaP.setVelocity(hlavaP.velocity().x()*fri,hlavaP.velocity().y()*-dmp,0.0);
			hlavaP.moveTo(hlavaP.position().x(),world.y,0);
			//hlavaP.makeFixed();
		}




	}



	void render(){

		//level0 poziceGlob
		pushMatrix();
		translate(x,y);


		//level1 trup
		pushMatrix();
		translate(positions[0][0],positions[0][1]);
		pushMatrix();

		translate(-anchors[0][0],-anchors[0][1]);
		rotate( (rotation[0]));

		//LEVA RUKA
		//level 2 rukaL1
		pushMatrix();
		translate(positions[8][0],positions[8][1]);
		pushMatrix();
		translate(-anchors[8][0],-anchors[8][1]);
		rotate( (rotation[8])-rotation[0]);
		image(part[8],-anchors[8][0],-anchors[8][1]);

		//level 3 rukaL2
		pushMatrix();
		translate(positions[9][0],positions[9][1]);
		pushMatrix();
		translate(-anchors[9][0],-anchors[9][1]);
		rotate( (rotation[9]-(rotation[8])));
		image(part[9],-anchors[9][0],-anchors[9][1]);



		popMatrix();
		popMatrix();
		//level 3 rukaL2 end
		popMatrix();
		popMatrix();
		//level 2 rukaL1 end

		//trup image
		image(part[0],-anchors[0][0],-anchors[0][1]);


		//LEVA NOHA
		//level 2 hohaL1
		pushMatrix();
		translate(positions[2][0],positions[2][1]);
		pushMatrix();
		translate(-anchors[2][0],-anchors[2][1]);
		rotate( (rotation[2]-rotation[0]));
		image(part[2],-anchors[2][0],-anchors[2][1]);
		//level 3 hohaL2
		pushMatrix();
		translate(positions[3][0],positions[3][1]);
		pushMatrix();
		translate(-anchors[3][0],-anchors[3][1]);
		rotate( (rotation[3]-(rotation[2])));
		//level 4 botaL
		pushMatrix();
		translate(positions[6][0],positions[6][1]);
		pushMatrix();
		translate(-anchors[6][0],-anchors[6][1]);
		rotate( (rotation[6])-((rotation[3])));
		image(part[6],-anchors[6][0],-anchors[6][1]);
		popMatrix();
		popMatrix();
		//level 4 botaL end
		image(part[3],-anchors[3][0],-anchors[3][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaL2 end
		popMatrix();
		popMatrix();
		//level 2 hohaL1 end


		//PRAVA NOHA
		//level 2 hohaR1
		pushMatrix();
		translate(positions[4][0],positions[4][1]);
		pushMatrix();
		translate(-anchors[4][0],-anchors[4][1]);
		rotate( (rotation[4])-rotation[0]);
		image(part[4],-anchors[4][0],-anchors[4][1]);
		//level 3 hohaR2
		pushMatrix();
		translate(positions[5][0],positions[5][1]);
		pushMatrix();
		translate(-anchors[5][0],-anchors[5][1]);
		rotate( (rotation[5])-(rotation[4]));
		//level 4 botaR
		pushMatrix();
		translate(positions[7][0],positions[7][1]);
		pushMatrix();
		translate(-anchors[7][0],-anchors[7][1]);
		rotate( (rotation[7])-(rotation[5]));
		image(part[7],-anchors[7][0],-anchors[7][1]);
		popMatrix();
		popMatrix();
		//level 4 botaR end
		image(part[5],-anchors[5][0],-anchors[5][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaR2 end
		popMatrix();
		popMatrix();
		//level 2 hohaR1 end


		//HLAVA
		//level2 hlava
		pushMatrix();
		translate(positions[1][0],positions[1][1]);
		pushMatrix();
		translate(-anchors[1][0],-anchors[1][1]);
		rotate( (rotation[1])-rotation[0]);
		image(part[1],-anchors[1][0],-anchors[1][1]);
		popMatrix();
		popMatrix();
		//level 2 hlava end

		//PRAVA RUKA
		//level 2 rukaR1
		pushMatrix();
		translate(positions[10][0],positions[10][1]);
		pushMatrix();
		translate(-anchors[10][0],-anchors[10][1]);
		rotate( (rotation[10])-rotation[0]);
		image(part[10],-anchors[10][0],-anchors[10][1]);

		//level 3 rukaR2
		pushMatrix();
		translate(positions[11][0],positions[11][1]);
		pushMatrix();
		translate(-anchors[11][0],-anchors[11][1]);
		rotate( (rotation[11])-rotation[10]);
		image(part[11],-anchors[11][0],-anchors[11][1]);

		popMatrix();
		popMatrix();
		//level 3 rukaR2 end
		popMatrix();
		popMatrix();
		//level 2 rukaR1 end

		popMatrix();
		popMatrix();
		//level1 trup end

		popMatrix();
		//level0 glob end


		if(testing){
			tint(255,50);
			stroke(255,70);

			for(int i =0;i<truP.length;i++){
				//truP[i].moveTo( truP[i].position().x(), truP[i].position().y(), 0.0 );
				rect(truP[i].position().x(),truP[i].position().y(),1,1);
			}

			for(int i =0;i<truS.length;i++){
				Particle p1 = truS[i].getOneEnd();
				Particle p2 = truS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<nohaL1S.length;i++){
				Particle p1 = nohaL1S[i].getOneEnd();
				Particle p2 = nohaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaL2S.length;i++){
				Particle p1 = nohaL2S[i].getOneEnd();
				Particle p2 = nohaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaR1S.length;i++){
				Particle p1 = nohaR1S[i].getOneEnd();
				Particle p2 = nohaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaR2S.length;i++){
				Particle p1 = nohaR2S[i].getOneEnd();
				Particle p2 = nohaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<rukaL1S.length;i++){
				Particle p1 = rukaL1S[i].getOneEnd();
				Particle p2 = rukaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaL2S.length;i++){
				Particle p1 = rukaL2S[i].getOneEnd();
				Particle p2 = rukaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaR1S.length;i++){
				Particle p1 = rukaR1S[i].getOneEnd();
				Particle p2 = rukaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaR2S.length;i++){
				Particle p1 = rukaR2S[i].getOneEnd();
				Particle p2 = rukaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<hlavaS.length;i++){
				Particle p1 = hlavaS[i].getOneEnd();
				Particle p2 = hlavaS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			rect(nohaL1P.position().x(),nohaL1P.position().y(),1,1);
			rect(nohaL2P.position().x(),nohaL2P.position().y(),1,1);

			rect(nohaR1P.position().x(),nohaR1P.position().y(),1,1);
			rect(nohaR2P.position().x(),nohaR2P.position().y(),1,1);

			rect(hlavaP.position().x(),hlavaP.position().y(),1,1);


			rect(rukaL1P.position().x(),rukaL1P.position().y(),1,1);
			rect(rukaL2P.position().x(),rukaL2P.position().y(),1,1);

			rect(rukaR1P.position().x(),rukaR1P.position().y(),1,1);
			rect(rukaR2P.position().x(),rukaR2P.position().y(),1,1);


			rect(senzor.position().x(),senzor.position().y(),1,1);
			line(senzor.position().x(),senzor.position().y(),hlavaP.position().x(),hlavaP.position().y());

		}else{
			noTint();
		}

	}


	void render2(){

		//level0 poziceGlob
		//pushMatrix();
		//translate(x,y);


		//LEVA RUKA
		//level 2 rukaL1
		pushMatrix();
		translate(anchors[8][0]+truP[7].position().x(),anchors[8][1]+truP[7].position().y());
		pushMatrix();
		translate(-anchors[8][0],-anchors[8][1]);
		rotate( (rotation[8]));
		image(part[8],-anchors[8][0]+1,-anchors[8][1]);


		popMatrix();
		popMatrix();
		//level 2 rukaL1 end

		
		//level 3 rukaL2
		pushMatrix();
		translate(rukaL1P.position().x()+anchors[9][0],rukaL1P.position().y()+anchors[9][1]);
		pushMatrix();
		translate(-anchors[9][0],-anchors[9][1]);
		rotate( (rotation[9]));
		image(part[9],-anchors[9][0]-1,-anchors[9][1]-2);
		popMatrix();
		popMatrix();
		//level 3 rukaL2 end
		
		//level1 trup
		pushMatrix();
		translate(anchors[0][0]+truP[5].position().x(),anchors[0][1]+truP[5].position().y());
		pushMatrix();

		translate(-anchors[0][0],-anchors[0][1]);
		rotate( (rotation[0]));
		//trup image
		image(part[0],-anchors[0][0],-anchors[0][1]+9);

		popMatrix();
		popMatrix();
		//level1 trup end



		



		//LEVA NOHA
		//level 2 hohaL1
		pushMatrix();
		translate(anchors[2][0]+truP[10].position().x(),anchors[2][1]+truP[10].position().y());
		pushMatrix();
		translate(-anchors[2][0],-anchors[2][1]);
		rotate( (rotation[2]));
		image(part[2],-anchors[2][0]+2,-anchors[2][1]);

		popMatrix();
		popMatrix();
		//level 2 hohaL1 end

		//level 3 hohaL2
		pushMatrix();
		translate(anchors[3][0]+nohaL1P.position().x(),anchors[3][1]+nohaL1P.position().y());
		pushMatrix();
		translate(-anchors[3][0],-anchors[3][1]);
		rotate( (rotation[3]));
		image(part[3],-anchors[3][0],-anchors[3][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaL2 end



		//PRAVA NOHA
		//level 2 hohaR1
		pushMatrix();
		translate(truP[9].position().x()+anchors[4][0],truP[9].position().y()+anchors[4][1]);
		pushMatrix();
		translate(-anchors[4][0],-anchors[4][1]);
		rotate( (rotation[4]));
		image(part[4],-anchors[4][0],-anchors[4][1]);
		popMatrix();
		popMatrix();
		//level 2 hohaR1 end



		//level 3 hohaR2
		pushMatrix();
		translate(anchors[5][0]+nohaR1P.position().x(),anchors[5][1]+nohaR1P.position().y());
		pushMatrix();
		translate(-anchors[5][0]-1,-anchors[5][1]);
		rotate( (rotation[5]));
		/*/level 4 botaR
		pushMatrix();
		translate(positions[7][0],positions[7][1]);
		pushMatrix();
		translate(-anchors[7][0],-anchors[7][1]);
		rotate( (rotation[7])-(rotation[5]));
		image(part[7],-anchors[7][0],-anchors[7][1]);
		popMatrix();
		popMatrix();
		//level 4 botaR end*/
		image(part[5],-anchors[5][0],-anchors[5][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaR2 end


		//HLAVA
		//level2 hlava
		pushMatrix();
		translate(0.5*(truP[1].position().x()+truP[2].position().x())+anchors[1][0],0.5*(truP[1].position().y()+truP[2].position().y())+anchors[1][1]);
		pushMatrix();
		translate(-anchors[1][0],-anchors[1][1]);
		rotate( (rotation[1]));
		image(part[1],-anchors[1][0],-anchors[1][1]);
		popMatrix();
		popMatrix();
		//level 2 hlava end

		//PRAVA RUKA
		//level 2 rukaR1
		pushMatrix();
		translate(anchors[10][0]+truP[8].position().x(),anchors[10][1]+truP[8].position().y());
		pushMatrix();
		translate(-anchors[10][0],-anchors[10][1]);
		rotate( (rotation[10]));
		image(part[10],-anchors[10][0],-anchors[10][1]);

		popMatrix();
		popMatrix();
		//level 2 rukaR1 end

		//level 3 rukaR2
		pushMatrix();
		translate(anchors[11][0]+rukaR1P.position().x(),anchors[11][1]+rukaR1P.position().y());
		pushMatrix();
		translate(-anchors[11][0],-anchors[11][1]);
		rotate( (rotation[11]) );
		image(part[11],-anchors[11][0],-anchors[11][1]);

		popMatrix();
		popMatrix();
		//level 3 rukaR2 end




		//popMatrix();
		//level0 glob end


		if(testing){
			tint(255,50);
			stroke(255,70);

			for(int i =0;i<truP.length;i++){
				//truP[i].moveTo( truP[i].position().x(), truP[i].position().y(), 0.0 );
				rect(truP[i].position().x(),truP[i].position().y(),1,1);
			}

			for(int i =0;i<truS.length;i++){
				Particle p1 = truS[i].getOneEnd();
				Particle p2 = truS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<nohaL1S.length;i++){
				Particle p1 = nohaL1S[i].getOneEnd();
				Particle p2 = nohaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaL2S.length;i++){
				Particle p1 = nohaL2S[i].getOneEnd();
				Particle p2 = nohaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaR1S.length;i++){
				Particle p1 = nohaR1S[i].getOneEnd();
				Particle p2 = nohaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<nohaR2S.length;i++){
				Particle p1 = nohaR2S[i].getOneEnd();
				Particle p2 = nohaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<rukaL1S.length;i++){
				Particle p1 = rukaL1S[i].getOneEnd();
				Particle p2 = rukaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaL2S.length;i++){
				Particle p1 = rukaL2S[i].getOneEnd();
				Particle p2 = rukaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaR1S.length;i++){
				Particle p1 = rukaR1S[i].getOneEnd();
				Particle p2 = rukaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}


			for(int i =0;i<rukaR2S.length;i++){
				Particle p1 = rukaR2S[i].getOneEnd();
				Particle p2 = rukaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			for(int i =0;i<hlavaS.length;i++){
				Particle p1 = hlavaS[i].getOneEnd();
				Particle p2 = hlavaS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

			rect(nohaL1P.position().x(),nohaL1P.position().y(),1,1);
			rect(nohaL2P.position().x(),nohaL2P.position().y(),1,1);

			rect(nohaR1P.position().x(),nohaR1P.position().y(),1,1);
			rect(nohaR2P.position().x(),nohaR2P.position().y(),1,1);

			rect(hlavaP.position().x(),hlavaP.position().y(),1,1);


			rect(rukaL1P.position().x(),rukaL1P.position().y(),1,1);
			rect(rukaL2P.position().x(),rukaL2P.position().y(),1,1);

			rect(rukaR1P.position().x(),rukaR1P.position().y(),1,1);
			rect(rukaR2P.position().x(),rukaR2P.position().y(),1,1);


			rect(senzor.position().x(),senzor.position().y(),1,1);
			line(senzor.position().x(),senzor.position().y(),hlavaP.position().x(),hlavaP.position().y());

		}else{
			noTint();
		}

	}

	void reload(){

		mapa = loadImage(skin);
		maska = new int[mapa.pixels.length];

		marks = new String[0];
		for(int y =0;y<mapa.height;y++){
			for(int x =0;x<mapa.width;x++){
				int which = y*mapa.width+x;
				if(brightness(mapa.pixels[which])==0){
					maska[which] = 0;
				}else if(brightness(mapa.pixels[which])>254){
					marks = (String[])expand(marks,marks.length+1);
					marks[marks.length-1] = ""+x+","+y;
				}else{
					maska[which] = 255;
				}
			}
		}

		mapa.mask(maska);


		//hlava
		part[0] = createGraphics(8,16,JAVA2D);

		//trup
		part[1] = createGraphics(9,9,JAVA2D);


		//nohaL1
		part[2]= createGraphics(4,8,JAVA2D);
		//nohaL2
		part[3]= createGraphics(4,7,JAVA2D);

		//nohaR1
		part[4]= createGraphics(4,8,JAVA2D);
		//nohaR2
		part[5]= createGraphics(4,7,JAVA2D);

		//botaL
		part[6]= createGraphics(4,4,JAVA2D);
		//botaR
		part[7]= createGraphics(4,4,JAVA2D);

		//rukaL1
		part[8] = createGraphics(5,9,JAVA2D);
		//rukaL2
		part[9] = createGraphics(3,11,JAVA2D);

		//rukaR1
		part[10] = createGraphics(5,9,JAVA2D);
		//rukaR2
		part[11]= createGraphics(3,11,JAVA2D);


		fillGraphics();

		for(int i =0;i<rotation.length;i++){
			rotation[i] = 0;//random(-30,30);

		}

	}

}





class World{
	float y = height-5;

	void render(){
		stroke(0);
		fill(6);
		rect(0,y,width,height-y);

	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

boolean rec = false;
Recorder r;

int w = 720/2;
int h = 386/2;
Cell c[] = new Cell[w*h];

float graph[] = new float[w];
float graph2[] = new float[w];

float tps = 0;
float dps = 0;

int loncnt = 0;
int death = 0;

void setup(){
	size(w,h+100,OPENGL);


	for(int Y = 0;Y<h;Y++){
		for(int X = 0;X<w;X++){
			c[Y*w+X] = new Cell(X,Y);
		}
	}

	if(rec)
		r = new Recorder("out","cornwayOnSteroids5.mp4");

	noFill();

	stroke(255);

	textFont(createFont("Veranda",9));


}


void draw(){
	
	fill(0);
	
	rect(0,h,w,100);
	
	
	
	noFill();


	stroke(255,200);
	int oncnt = 0;
	for(int i = 0;i<c.length;i++){
		c[i].act();
		if(c[i].active)
			oncnt++;

	}


	//print("mapa: "+oncnt+" @ ");
	//for(int i =0;i<w/2;i++)
	//print(c[i].state?"A":"B");
	//println(" ");

	
		graph[graph.length-1] = oncnt;
		graph2[graph.length-1] += (oncnt-graph2[graph.length-1])/(7.0);
	

	stroke(#ffcc00);
	float top = 0;
	float bottom = c.length;
	int tp = 0,dp = 0;


	for(int i = 0;i<graph.length;i++){
		if(graph[i]>top){
			top = graph[i];
			tp = i;
		}

		if(graph[i]<bottom&&graph[i]!=0){
			dp = i;
			bottom = graph[i];
		}
	}
	tps += (tp-tps)/3.0;
	dps += (dp-dps)/3.0;


	pushStyle();
	strokeWeight(4);
	for(int i = 0;i<graph.length;i++){

		stroke(#FFcc00,150);

		if(tps<dps){
			if(i>tps&&i<dps)
				stroke(#FFcc00);
		}else{
			if(i>dps&&i<tps)
				stroke(#FFcc00);
		}
		//stroke(#FFcc00,150);
		line(i,map(graph[i],bottom,top,height,h),i,map(graph[(i+graph.length-1)%graph.length],bottom,top,height,h));

		stroke(#FFFFFF,200);
		line(i,map(graph2[i],bottom,top,height,h),i,map(graph2[(i+graph.length-1)%graph.length],bottom,top,height,h));

	}
	popStyle();

	for(int i = 0;i<graph.length-1;i++){
		graph[i] = graph[i+1];
		graph2[i] = graph2[i+1];
	}

	for(int i = 0;i<c.length;i++){
		c[i].update();

	}

	stroke(#FF0000,200);
	line(tps,h+50,tps,h);
	line(dps,h+50,dps,height);

	line(tps,h,dps,height);


	stroke(255,15);
	int step = 1;

	for(int i =0;i<width-step;i+=step){
		pushMatrix();
	translate(i,map(graph2[i],bottom,top,height,h));
	rotate(atan2(map(graph2[i],bottom,top,height,h)-map(graph2[i+step],bottom,top,height,h),-step)+HALF_PI);

	//line(i,map(graph2[i],bottom,top,height,h),i+step,map(graph2[i+step],bottom,top,height,h));
	line(300,0,-300,0);
	popMatrix();
}
	fill(255,20);
	//triangle(tps,h,tps,height,dps,height);
	pushMatrix();
	translate(lerp(tps,dps,0.5),lerp(h,height,0.5));
	rotate(atan2(h-height,tps-dps));
	fill(#ff0000,200);
	text("slope: "+(90-degrees(atan2(height-h,dps-tps)-HALF_PI)),-30,0);
	popMatrix();
	fill(255);
	text("cycle: "+frameCount +" fr.",10,h+12);

	text("population: "+oncnt,10,h+21);
	fill(255,50);
	//arc(dps,height,80,80,atan2(h-height,tps-dps),0);

	
	noStroke();
	fill(0);
	rect(0,0,w,h);
	noFill();
	
	stroke(255);
	rect(0,h,w-1,100-1);
	
	for(int i = 0;i<c.length;i++){
		c[i].draw();
	}
	
	if(loncnt==oncnt){
		death++;
	}else{
		death = 0;
		
	}
	
	
	fill(255);
	if(death>width){
		text("..stable state acheived",width-170,h+10);
	}
	
	if(death>width*2){
		if(rec)
			r.finish();
		
		exit();
	}
	
	loncnt = oncnt;

	if(rec)
		r.add();


}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}
}

class Cell{

	boolean state,active,nextstate;
	int neighs[] = new int[8];
	int x,y;
	int id;
	int alive = 0;

	Cell(int _x,int _y){
		x=_x;
		y=_y;
		id = y*width+x;



		//if(id>w&&id<h*w-w-1){

		int s = 0;
		neighs[0] = ((y+h-1+s)%(h)) * w + ((x+w-1+s)%(w));
		neighs[1] = ((y+h-1+s)%(h)) * w + ((x+w+s)%(w));
		neighs[2] = ((y+h-1+s)%(h)) * w + ((x+w+1+s)%(w));
		neighs[3] = ((y+h+s)%(h)) * w + ((x+w+1+s)%(w));
		neighs[4] = ((y+h+1+s)%(h)) * w + ((x+w+1+s)%(w));
		neighs[5] = ((y+h+1+s)%(h)) * w + ((x+w+s)%(w));
		neighs[6] = ((y+h+1+s)%(h)) * w + ((x+w-1+s)%(w));
		neighs[7] = ((y+h+s)%(h)) * w + ((x+w-1+s)%(w));
		active =true;

		if(random(50)>25){state=true;}else{state=false;}
		//state=false;


		/*}else{
			state=false;
			active = false;
	}*/

	}

	void act(){
		live();
	}

	void live(){
		
			int counter = 0;
			for(int i =0;i<8;i++){
				//	try{
				if(c[neighs[i]].state)
					counter++;
				/*	}catch(ArrayIndexOutOfBoundsException e){
						println(id+" @ "+i+" = "+x+" : "+y);
					}*/
			}


			//elegant algo
			if(!state){
				if(counter==3)
					nextstate = true;



			}else{
				if(counter < 2){
					nextstate = false;
				}else if(counter > 3){
					nextstate = false;
				}
				
			}

			if(nextstate==state){				
				alive++;
			}else{
				alive = 0;
				active = true;
			}

			if(alive>30){
				active = false;
			}
		//		alive = 0;
		//		int s = 0;
		//		nextstate = c[((y+h+s)%(h)) * w + ((x+w+1+s)%(w))].state;
				//c[((y+h+s)%(h)) * w + ((x+w+1+s)%(w))].nextstate = !c[((y+h+s)%(h)) * w + ((x+w+1+s)%(w))].state;
		//	}



		
	}

	void update(){
		state = nextstate;
	}

	void draw(){

		if(state){
			rect(x,y,0.4,0.4);
		}
	}
}



class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
void setup(){
	size(200,200,OPENGL);
	stroke(255);
}

int count = 0;

void draw(){
	background(0);
	line(0,count%height,width,count%height);
	count++;

}
/**
 * Getting Started with Capture.
 * 
 * GSVideo version by Andres Colubri. 
 * 
 * Reading and displaying an image from an attached Capture device. 
 */ 
import codeanticode.gsvideo.*;

GSCapture cam;
Recorder r;
boolean rec  = false;

//float qa [][] = new float[320][240];

int w = 32*2;
int h = 24*2;
int X=0,Y=0;

int inter = 1;

void setup() {
	size(w*10, h*6,P3D);


	//float qa [][] = new float[width][height];
	/*
	// List functionality still not ready on Linux
	String[] cameras = GSCapture.list();

	if (cameras.length == 0)
{
	  println("There are no cameras available for capture.");
	  exit();
} else {
	  println("Available cameras:");
	  for (int i = 0; i < cameras.length; i++)
	    println(cameras[i]);
	  cam = new GSCapture(this, 320, 240, cameras[0]);
}

	However, different cameras can be selected by using their device file:
	cam = new GSCapture(this, 640, 480, "/dev/video0");
	cam = new GSCapture(this, 640, 480, "/dev/video1");
	etc.
	*/
	cam = new GSCapture(this,640,480);
	background(0);

	//tint(255,90);

	r = new Recorder("vid","tick60_3.mp4");
	//tint(255,90);
}

void draw() {
	if (cam.available() == true) {
		try{
		cam.read();

		
		cam.filter(GRAY);

		}catch(java.lang.NullPointerException e){
			println("weird error! @ "+frameCount);
		}


		X+=w;
		if(X>=width){
			Y+=h;
			X=0;
		}

		if(Y>=height){

			if(rec)
				r.add();

			Y=0;
			X=0;

		}
		
		
	int xx = (int)(((int)random(width/w))*w);
	int yy = (int)(((int)random(height/h))*h);

	if(cam!=null)
		image(cam, xx, yy,w,h);
	}

	// The following does the same, and is faster when just drawing the image
	// without any additional resizing, transformations, or tint.
	//set(0, 0, cam);




}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();

	}else if(key == 'r'){
		rec = !rec;
		if(rec)println("recording on");
		if(!rec)println("recording off");
	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
Recorder r;

float Xshift = 0.96078444;
float AMP = 7.0588236;

int layers[] = {2,2,2,3};

float rate = 100000.0*layers.length;
float sqerr = 1000.0;

PImage img;
PImage result;

ProcessingUnit pu[];

boolean learning = true;
boolean test = false;
boolean rec = false;


void setup(){

	img = loadImage("test32.png");

	size(img.width+40,img.height+40,OPENGL);

	if(test){
		pu = new ProcessingUnit[1];
		
		
		pu[0] = new ProcessingUnit(0,0,color(#FFCC00),0);
		pu[0].createNeurons();

	}else{
		pu = new ProcessingUnit[img.pixels.length];


		int cntr = 0;
		for(int y = 0;y<img.height;y++){
			for(int x = 0;x<img.width;x++){
				pu[cntr] = new ProcessingUnit(x,y,color(img.pixels[cntr]),cntr);
				pu[cntr].createNeurons();
				cntr++;

			}
		}
	}
	
	if(rec)
		r=new Recorder("out","neuroStation.mp4");
}



void draw(){


	if(test){
		
		pu[0].act();
		background(pu[0].current());
		println(sqerr);
		
	}else{

		background(0);

		pushMatrix();
		translate(20,20);


		for(int x =0;x<img.width;x++){
			for(int y =0;y<img.height;y++){

				int which = y*img.width+x;
				pu[which].act();

				stroke(pu[which].current());
				line(x,y,x+1,y);
			}
		}

		popMatrix();


		println(sqerr);

	}
	
	if(rec)
		r.add();

}

void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();
		exit();
	
	}else if(key=='l'){
		learning = !learning;
	}

}




class Neuron{
	float w[];
	int ins[];
	int id,layer;
	float sum;
	float err = 0.0;
	int puid;
	boolean bias = false;

	Neuron(int _id,int _layer,int _puid,boolean _bias){

		bias = _bias;
		id = _id;
		layer = _layer;
		puid = _puid;

		if(layer==0){
			ins = new int[1];
			ins[0] = 0;
			w = new float[1];
			w[0] = 1.0;
		}

		if(layer>0){
			ins = new int[pu[puid].n[layer-1].length];
			w = new float[pu[puid].n[layer-1].length];

			for(int i = 0;i<ins.length;i++){
				ins[i] = i;
				w[i] = random(0,100)/100.0;

			}

		}

	}

	void compute(){

		if(layer>0&&layer<layers.length-1){
			sum = 0;

			for(int i =0;i<ins.length;i++){
				sum+=pu[puid].n[layer-1][i].sum*w[i];
			}
			//sum/=(ins.length+0.0);
			float res = sigmoidal(sum);
			sum = res;
		}else if(layer==0){
			if(!bias){
			sum = pu[puid].IN[id];
			}else{
				if(id%2==0){
			sum = 1;}else{
			sum = 0;
			}
			}
		}else{
			sum = 0;

			for(int i =0;i<ins.length;i++){
				sum+=pu[puid].n[layer-1][i].sum*w[i];
			}

			//sum/=(ins.length+0.0);
			//float res = sigmoidal(sum);
			//sum = res;
			pu[puid].OUT[id] = sum;

		}
	}

	void learn(){
		if(layer>0){
			//load current state
			float ress[] = new float[pu[puid].OUT.length];
			float _w []= new float[w.length];

			for(int i =0;i<pu[puid].OUT.length;i++){
				ress[i] = pu[puid].OUT[i];
			}

			for(int i =0;i<w.length;i++){
				_w[i]=w[i];
			}


			for(int q =0;q<pu[puid].OUT.length;q++){
				for(int i =0;i<w.length;i++){
					w[i]+=random(-10.0*abs(ress[q]-pu[puid].desire[q]),10.0*abs(ress[q]-pu[puid].desire[q]))/rate;
					w[i] = constrain(w[i],0.0,1.0);

					for(int r1 =0;r1<layers.length;r1++){
						for(int r2 =0;r2<layers[r1];r2++){
							pu[puid].n[r1][r2].compute();
						}
					}

					if(abs(ress[q]-pu[puid].desire[q])<abs(pu[puid].OUT[q]-pu[puid].desire[q]))
						w[i] = _w[i];

				}
			}



		}
	}

}

float sigmoidal(float inputValue){
	return(float)((Xshift/((Xshift)+Math.exp(AMP*(inputValue)))));
}

float derivative(float input){
	return(1.0-(sigmoidal(input)*(1.0-sigmoidal(input)))*4.0);
}
class ProcessingUnit{

	Neuron n[][];

	float IN[],OUT[];
	float res[],desire[];

	color c;
	int X,Y;
	int id;

	ProcessingUnit(int inA, int inB,color _c,int _id){
		X=inA;
		Y=inB;
		c=_c;
		id = _id;

		reset(map(X,0,img.width,0,1),map(Y,0,img.height,0,1));

	}

	void createNeurons(){
		n = new Neuron[layers.length][0];

		for(int i =0;i<layers.length;i++){
			for(int q = 0;q<layers[i];q++){
				n[i] = (Neuron[])expand(n[i],n[i].length+1);
				n[i][n[i].length-1] = new Neuron(q,i,id,false);
			}

		}

		//first run
		for(int r1 =0;r1<layers.length;r1++){
			for(int r2 =0;r2<layers[r1];r2++){
				n[r1][r2].compute();
			}
		}

	}

	void reset(float _A,float _B){
		// ceate inputs
		IN = new float[layers[0]];

		IN[0] =  _A;
		IN[1] =  _B;

		//for(int i =0;i<IN.length;i++){
		//	IN[i] = map(i,0,IN.length-1,0,1);
		//}

		//create ouput and desired result

		OUT = new float[layers[layers.length-1]];
		res = new float[OUT.length];
		desire = new float[OUT.length];

		//for(int i =0;i<OUT.length;i++){
		desire[0] = red(c);
		desire[1] = green(c);
		desire[2] = blue(c);
		//}

		//init matrix





	}

	void iterate(int kolik){
		

		for(int d =0;d<kolik;d++){


			//collect inputs
			//for(int i =0;i<IN.length;i++){
			//	IN[i] = map(i,0,IN.length,0,1);
			//}

			//proceed matrix


			//learn matrix
			for(int i =0;i<layers.length;i++){
				for(int q =0;q<layers[i];q++){
					n[i][q].learn();
				}
			}

			//collect result
			for(int i = 0;i<OUT.length;i++){
				res[i] = abs(desire[i]-OUT[i]);
				sqerr += ((res[i])-sqerr)/(OUT.length+0.0);
			}
		}

	}

	void act(){
		
		
		
		if(learning){
			iterate(1);
		}else{
			
			IN[0] += ((random(0,100)/100.0)-IN[0])/3.0;

		IN[1] += ((random(0,100)/100.0)-IN[1])/3.0;

		IN[0]= constrain(IN[0],0,1);
		IN[1]= constrain(IN[1],0,1);
		
			for(int i =0;i<layers.length;i++){
				for(int q =0;q<layers[i];q++){
					n[i][q].compute();
				}
			}
		}
	}

	color current(){
		return color(OUT[0]*255,OUT[1]*255,OUT[2]*255);
	}


}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
Recorder r;

int X = 0,Y = 0;

float Xshift = 0.96078444;
float AMP = 7.0588236;

int layers[] = {32*32,16,16,1};

float rate = 100000.0*layers.length;
float sqerr = 1000.0;

PImage img;
PImage result;

ProcessingUnit pu;

boolean learning = true;
boolean test = false;
boolean rec = false;


void setup(){

	img = loadImage("test32.png");

	size(img.width+40,img.height+40,OPENGL);

	pu = new ProcessingUnit(0,0,color(#FFCC00),0);
	pu.createNeurons();

	if(rec)
		r=new Recorder("out","neuroStation.mp4");
}

void draw(){
        
	
	pu.act();
	
	//background(pu.current());
	
	println(sqerr);

	if(rec)
		r.add();

}

void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();
		exit();

	}else if(key=='l'){
		learning = !learning;
	}
}


class Neuron{
	float w[];
	int ins[];
	int id,layer;
	float sum;
	float err = 0.0;
	int puid;
	boolean bias = false;

	Neuron(int _id,int _layer,int _puid,boolean _bias){

		bias = _bias;
		id = _id;
		layer = _layer;
		puid = _puid;

		if(layer==0){
			ins = new int[1];
			ins[0] = 0;
			w = new float[1];
			w[0] = 1.0;
		}

		if(layer>0){
			ins = new int[pu.n[layer-1].length];
			w = new float[pu.n[layer-1].length];

			for(int i = 0;i<ins.length;i++){
				ins[i] = i;
				w[i] = random(-10,10)/100.0;

			}

		}

	}

	void compute(){

		if(layer>0&&layer<layers.length-1){
			sum = 0;

			for(int i =0;i<ins.length;i++){
				sum+=pu.n[layer-1][i].sum*w[i];
			}
			//sum/=(ins.length+0.0);
			float res = sigmoidal(sum);
			sum = res;
		}else if(layer==0){
			if(!bias){
				sum = pu.IN[id];
			}else{				
					sum = 1.0;
			}
		}else{
			sum = 0;

			for(int i =0;i<ins.length;i++){
				sum+=pu.n[layer-1][i].sum*w[i];
			}

			//sum/=(ins.length+0.0);
			//float res = sigmoidal(sum);
			//sum = res;
			pu.OUT[id] = sum;

		}
	}

	void learn(){
		if(layer>0){
			//load current state
			float ress[] = new float[pu.OUT.length];
			float _w []= new float[w.length];
		
			//backup
			for(int i =0;i<pu.OUT.length;i++){
				ress[i] = pu.OUT[i];
			}

			for(int i =0;i<w.length;i++){
				_w[i]=w[i];
			}

			//comparation
			for(int q =0;q<pu.OUT.length;q++){
				for(int i =0;i<w.length;i++){
					w[i]+=random(-10.0*abs(ress[q]-pu.desire[q]),10.0*abs(ress[q]-pu.desire[q]))/rate;
					w[i] = constrain(w[i],0.0,1.0);

					for(int r1 =0;r1<layers.length;r1++){
						for(int r2 =0;r2<layers[r1];r2++){
							pu.n[r1][r2].compute();
						}
					}

					if(abs(ress[q]-pu.desire[q])<abs(pu.OUT[q]-pu.desire[q]))
						w[i] = _w[i];
				}
			}
		}
	}
}

float sigmoidal(float inputValue){
	return(float)((Xshift/((Xshift)+Math.exp(AMP*(inputValue)))));
}

float derivative(float input){
	return(1.0-(sigmoidal(input)*(1.0-sigmoidal(input)))*4.0);
}
class ProcessingUnit{

	Neuron n[][];

	float IN[],OUT[];
	float res[],desire[];

	color c;
	int X,Y;
	int id;

	ProcessingUnit(int inA, int inB,color _c,int _id){
		X=inA;
		Y=inB;
		c=_c;
		id = _id;

		
		
		reset(map(X,0,img.width,0,1),map(Y,0,img.height,0,1));
		X++;
		if(X)
		Y++;

	}

	void createNeurons(){
		n = new Neuron[layers.length][0];

		for(int i =0;i<layers.length;i++){
			for(int q = 0;q<layers[i];q++){
				if(i==0&&q==layers[i]-1){

					n[i] = (Neuron[])expand(n[i],n[i].length+1);
					n[i][n[i].length-1] = new Neuron(q,i,id,false);
					n[i] = (Neuron[])expand(n[i],n[i].length+1);
					n[i][n[i].length-1] = new Neuron(q,i,id,true);
					
					
				}else{
					
					n[i] = (Neuron[])expand(n[i],n[i].length+1);
					n[i][n[i].length-1] = new Neuron(q,i,id,false);

				}
			}

		}

		//first run
		for(int r1 =0;r1<layers.length;r1++){
			for(int r2 =0;r2<layers[r1];r2++){
				n[r1][r2].compute();
			}
		}

	}

	void reset(float _A,float _B){
		// ceate inputs
		IN = new float[layers[0]];

		IN[0] =  _A;
		IN[1] =  _B;

		//for(int i =0;i<IN.length;i++){
		//	IN[i] = map(i,0,IN.length-1,0,1);
		//}

		//create ouput and desired result

		OUT = new float[layers[layers.length-1]];
		res = new float[OUT.length];
		desire = new float[OUT.length];

		//for(int i =0;i<OUT.length;i++){
		desire[0] = brightness(c);
		//desire[1] = green(c);
		//desire[2] = blue(c);
		//}

		//init matrix





	}

	void iterate(int kolik){


		for(int d =0;d<kolik;d++){


			//collect inputs
			//for(int i =0;i<IN.length;i++){
			//	IN[i] = map(i,0,IN.length,0,1);
			//}

			//proceed matrix


			//learn matrix
			for(int i =0;i<layers.length;i++){
				for(int q =0;q<layers[i];q++){
					n[i][q].learn();
				}
			}

			//collect result
			for(int i = 0;i<OUT.length;i++){
				res[i] = abs(desire[i]-OUT[i]);
				sqerr += ((res[i])-sqerr)/(OUT.length+0.0);
			}
		}

	}

	void act(){



		if(learning){
			iterate(1);
			stroke(current());
			line(IN[0],IN[1],IN[0]+1,IN[1]);
		}else{

			IN[0] += ((random(0,100)/100.0)-IN[0])/3.0;

			IN[1] += ((random(0,100)/100.0)-IN[1])/3.0;

			IN[0]= constrain(IN[0],0,1);
			IN[1]= constrain(IN[1],0,1);

			for(int i =0;i<layers.length;i++){
				for(int q =0;q<layers[i];q++){
					n[i][q].compute();
				}
			}
		}
	}

	color current(){
		return color(OUT[0]*255);
	}
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import traer.physics.*;


ParticleSystem physics;

boolean testing = false;

Particle truP[] = new Particle[7];
Spring truS[]  = new Spring[12];

Particle nohaL1P;
Spring nohaL1S[] = new Spring[2];

Particle nohaL2P;
Spring nohaL2S[] = new Spring[1];

Particle nohaR1P;
Spring nohaR1S[] = new Spring[2];

Particle nohaR2P;
Spring nohaR2S[] = new Spring[1];


Particle rukaL1P;
Spring rukaL1S[] = new Spring[1];

Particle rukaL2P;
Spring rukaL2S[] = new Spring[1];

Particle rukaR1P;
Spring rukaR1S[] = new Spring[1];

Particle rukaR2P;
Spring rukaR2S[] = new Spring[1];



Particle hlavaP;
Spring hlavaS[] = new Spring[2];

Particle anchor;
Spring spagat;

float ruceSila = 3.0;
float ruceDamp = 0.05;

float nohySila = 3.0;
float nohyDamp = 0.1;


float hlavaSila = 3.0;
float hlavaDamp = 0.1;

Hero hero;
World world;

void setup(){
	size(320,240,OPENGL);

	hero = new Hero();
	noSmooth();

	frameRate(30);

	physics = new ParticleSystem( 0.5, 0.01 );


	// torso
	truP[0] = physics.makeParticle( hero.mass[0], hero.x-7, hero.y-16, 0.0 );
	truP[1] = physics.makeParticle( hero.mass[0], hero.x-7, hero.y-20, 0.0 );
	truP[2] = physics.makeParticle( hero.mass[0], hero.x-1, hero.y-20, 0.0 );
	truP[3] = physics.makeParticle( hero.mass[0], hero.x-1, hero.y-16, 0.0 );
	truP[4] = physics.makeParticle( hero.mass[0], hero.x,hero.y-9, 0.0 );
	truP[5] = physics.makeParticle( hero.mass[0], hero.x-4,hero.y-4, 0.0 );
	truP[6] = physics.makeParticle( hero.mass[0], hero.x-8,hero.y-9, 0.0 );

	truS[0] = physics.makeSpring(truP[0], truP[1],1,1,1);
	truS[1] = physics.makeSpring(truP[1], truP[2],1,1,1);
	truS[2] = physics.makeSpring(truP[2], truP[3],1,1,1);
	truS[3] = physics.makeSpring(truP[3], truP[4],1,1,1);
	truS[4] = physics.makeSpring(truP[4], truP[5],1,1,1);
	truS[5] = physics.makeSpring(truP[5], truP[6],1,1,1);
	truS[6] = physics.makeSpring(truP[6], truP[0],1,1,1);
	truS[7] = physics.makeSpring(truP[5], truP[0],1,1,1);
	truS[8] = physics.makeSpring(truP[5], truP[1],1,1,1);
	truS[9] = physics.makeSpring(truP[5], truP[2],1,1,1);
	truS[10] = physics.makeSpring(truP[5], truP[3],1,1,1);
	truS[11] = physics.makeSpring(truP[0], truP[3],1,1,1);

	for(int i =0;i<truS.length;i++){
		truS[i].setRestLength( truS[i].currentLength() );
		truS[i].setStrength( 14.0);
		truS[i].setDamping( 0.0001 );

	}



	////
	hlavaP = physics.makeParticle( hero.mass[1], hero.x-4, hero.y-28, 0 );

	hlavaS[0] = physics.makeSpring( truP[1], hlavaP, 1,1,1 );
	hlavaS[1] = physics.makeSpring( truP[2], hlavaP, 1,1,1 );

	for(int i =0;i<hlavaS.length;i++){
		hlavaS[i].setRestLength( hlavaS[i].currentLength() );
		hlavaS[i].setStrength( hlavaSila);
		hlavaS[i].setDamping( hlavaDamp );

	}

	////
	nohaL1P = physics.makeParticle( hero.mass[2], hero.x-9, hero.y-2, 0 );

	nohaL1S[0] = physics.makeSpring( truP[5], nohaL1P, 1,1,1 );
	nohaL1S[1] = physics.makeSpring( truP[6], nohaL1P, 1,1,1 );

	for(int i =0;i<nohaL1S.length;i++){
		nohaL1S[i].setRestLength( nohaL1S[i].currentLength() );
		nohaL1S[i].setStrength( nohySila);
		nohaL1S[i].setDamping( nohyDamp );

	}

	//////
	nohaL2P = physics.makeParticle( hero.mass[3], hero.x-9, hero.y+2, 0 );

	//nohaL2S[0] = physics.makeSpring( truP[5], nohaL2P, 1,1,1 );
	nohaL2S[0] = physics.makeSpring( nohaL1P, nohaL2P, 1,1,1 );

	for(int i =0;i<nohaL2S.length;i++){
		nohaL2S[i].setRestLength( nohaL2S[i].currentLength() );
		nohaL2S[i].setStrength( nohySila);
		nohaL2S[i].setDamping( nohyDamp );

	}


	////
	nohaR1P = physics.makeParticle( hero.mass[4], hero.x+1, hero.y-2, 0 );

	nohaR1S[0] = physics.makeSpring( truP[5], nohaR1P, 1,1,1 );
	nohaR1S[1] = physics.makeSpring( truP[4], nohaR1P, 1,1,1 );

	for(int i =0;i<nohaL1S.length;i++){
		nohaR1S[i].setRestLength( nohaR1S[i].currentLength() );
		nohaR1S[i].setStrength( nohySila);
		nohaR1S[i].setDamping( nohyDamp );

	}

	//////
	nohaR2P = physics.makeParticle( hero.mass[5], hero.x+1, hero.y+2, 0 );

	//nohaR2S[0] = physics.makeSpring( truP[5], nohaR2P, 1,1,1 );
	nohaR2S[0] = physics.makeSpring( nohaR1P, nohaR2P, 1,1,1 );

	for(int i =0;i<nohaR2S.length;i++){
		nohaR2S[i].setRestLength( nohaR2S[i].currentLength() );
		nohaR2S[i].setStrength( nohySila);
		nohaR2S[i].setDamping( nohyDamp );

	}



	//////////////////// RUCE

	////
	rukaL1P = physics.makeParticle( hero.mass[8], hero.x-14, hero.y-20, 0 );

	//rukaL1S[0] = physics.makeSpring( truP[0], rukaL1P, 1,1,1 );
	rukaL1S[0] = physics.makeSpring( truP[1], rukaL1P, 1,1,1 );

	for(int i =0;i<rukaL1S.length;i++){
		rukaL1S[i].setRestLength( rukaL1S[i].currentLength() );
		rukaL1S[i].setStrength( ruceSila);
		rukaL1S[i].setDamping( ruceDamp );

	}

	//////
	rukaL2P = physics.makeParticle( hero.mass[9], hero.x-20, hero.y-20, 0 );

	//rukaL2S[0] = physics.makeSpring( truP[0], rukaL2P, 1,1,1 );
	rukaL2S[0] = physics.makeSpring( rukaL1P, rukaL2P, 1,1,1 );

	for(int i =0;i<rukaL2S.length;i++){
		rukaL2S[i].setRestLength( rukaL2S[i].currentLength() );
		rukaL2S[i].setStrength( ruceSila);
		rukaL2S[i].setDamping( ruceDamp );

	}


	////
	rukaR1P = physics.makeParticle( hero.mass[10], hero.x+5, hero.y-20, 0 );

	rukaR1S[0] = physics.makeSpring( truP[2], rukaR1P, 1,1,1 );
	//rukaR1S[0] = physics.makeSpring( truP[3], rukaR1P, 1,1,1 );

	for(int i =0;i<rukaR1S.length;i++){
		rukaR1S[i].setRestLength( rukaR1S[i].currentLength() );
		rukaR1S[i].setStrength( ruceSila);
		rukaR1S[i].setDamping( ruceDamp );

	}

	//////
	rukaR2P = physics.makeParticle( hero.mass[11], hero.x+11, hero.y-20, 0 );

	//rukaR2S[0] = physics.makeSpring( truP[3], rukaR2P, 1,1,1 );
	rukaR2S[0] = physics.makeSpring( rukaR1P, rukaR2P, 1,1,1 );

	for(int i =0;i<rukaR2S.length;i++){
		rukaR2S[i].setRestLength( rukaR2S[i].currentLength() );
		rukaR2S[i].setStrength( ruceSila);
		rukaR2S[i].setDamping( ruceDamp );

	}



	anchor = physics.makeParticle( 1.0, width/2+20, 0, 0 );
	anchor.makeFixed();

	spagat = physics.makeSpring( rukaL2P, anchor, 1,1,10 );
	spagat.setRestLength(spagat.currentLength());
	spagat.setStrength( 10.4);
	spagat.setDamping( 0.41 );
	

	//
	//s = physics.makeSpring( p, anchor, 1.0, 0.1, 100 );
	world = new World();

	rectMode(CENTER);
	noFill();
	stroke(255,100);
}


void draw(){
	//anchor.moveTo(mouseX,mouseY,0);
	physics.advanceTime( 0.2 );

	background(0);

	pushMatrix();
	
	
	
	hero.act();
	line(rukaL2P.position().x(),rukaL2P.position().y(),anchor.position().x(),anchor.position().y());
	world.render();

	if(testing){
		stroke(255,70);
	
		for(int i =0;i<truP.length;i++){
			truP[i].moveTo( truP[i].position().x(), truP[i].position().y(), 0.0 );
			rect(truP[i].position().x(),truP[i].position().y(),1,1);
		}
		
			for(int i =0;i<truS.length;i++){
				Particle p1 = truS[i].getOneEnd();
				Particle p2 = truS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			for(int i =0;i<nohaL1S.length;i++){
				Particle p1 = nohaL1S[i].getOneEnd();
				Particle p2 = nohaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			
			for(int i =0;i<nohaL2S.length;i++){
				Particle p1 = nohaL2S[i].getOneEnd();
				Particle p2 = nohaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			
			for(int i =0;i<nohaR1S.length;i++){
				Particle p1 = nohaR1S[i].getOneEnd();
				Particle p2 = nohaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			
			for(int i =0;i<nohaR2S.length;i++){
				Particle p1 = nohaR2S[i].getOneEnd();
				Particle p2 = nohaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			for(int i =0;i<rukaL1S.length;i++){
				Particle p1 = rukaL1S[i].getOneEnd();
				Particle p2 = rukaL1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			
			for(int i =0;i<rukaL2S.length;i++){
				Particle p1 = rukaL2S[i].getOneEnd();
				Particle p2 = rukaL2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			
			for(int i =0;i<rukaR1S.length;i++){
				Particle p1 = rukaR1S[i].getOneEnd();
				Particle p2 = rukaR1S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			
			for(int i =0;i<rukaR2S.length;i++){
				Particle p1 = rukaR2S[i].getOneEnd();
				Particle p2 = rukaR2S[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}
			
			for(int i =0;i<hlavaS.length;i++){
				Particle p1 = hlavaS[i].getOneEnd();
				Particle p2 = hlavaS[i].getTheOtherEnd();
				line(p1.position().x(),p1.position().y(),p2.position().x(),p2.position().y());
			}

		rect(nohaL1P.position().x(),nohaL1P.position().y(),1,1);
		rect(nohaL2P.position().x(),nohaL2P.position().y(),1,1);

		rect(nohaR1P.position().x(),nohaR1P.position().y(),1,1);
		rect(nohaR2P.position().x(),nohaR2P.position().y(),1,1);

		rect(hlavaP.position().x(),hlavaP.position().y(),1,1);


		rect(rukaL1P.position().x(),rukaL1P.position().y(),1,1);
		rect(rukaL2P.position().x(),rukaL2P.position().y(),1,1);

		rect(rukaR1P.position().x(),rukaR1P.position().y(),1,1);
		rect(rukaR2P.position().x(),rukaR2P.position().y(),1,1);
	
	}
popMatrix();
}

void mousePressed(){

	truP[6].addVelocity(20,0,0);
}

void keyPressed(){
	if(key=='w'){
		hero.control = 0;
	}else if(key=='2'){
		hero.control = 1;
	}else if(key=='a'){
		hero.control = 2;
	}else if(key=='z'){
		hero.control = 3;
	}else if(key=='d'){
		hero.control = 4;
	}else if(key=='c'){
		hero.control = 5;
	}else if(key=='q'){
		hero.control = 8;
	}else if(keyCode==TAB){
		hero.control = 9;
	}else if(key=='e'){
		hero.control = 10;
	}else if(key=='r'){
		hero.control = 11;
	}else if(key == 't'){
		testing = !testing;
	
	}

}



class Hero{
	PImage mapa;
	int maska[];
	int anchors[][] = {{4,10},{5,7},

	                   {2,1},{1,0},{2,1},{1,0},
	                   {1,0},{1,0},

	                   {4,2},{1,1},{2,2},{1,1}
	                  };

	int positions[][] = {{0,0},{6,-3},

	                     {-1,4},{0,7},{4,4},{0,7},
	                     {2,6},{1,6},

	                     {1,-4},{-1,6},{7,-4},{1,6}

	                    };


	float mass[] = {
	                       0.6,0.15,

	                       0.15,0.15,0.15,0.15,
	                       0.03,0.03,

	                       0.12,0.1,0.12,0.1
	               };

	float rotation[] = new float[12];

	float limits[][] = {
	                           {-180,180},{-46.8,36.77},

	                           {138.0,-25.0},{5.2,-113.0},{138.0,-25.0},{5.2,-113.0},
	                           {-34.0,59.0},{-34.0,59.0},

	                           {178.0,-39.0},{158.0,-1.0},{169.0,-115.0},{133.0,-10.0}

	                   };

	PGraphics part[] = new PGraphics[12];

	String marks[] = new String[0];

	int x,y;
	int control = 0;

	Hero(){
		x = width/2;
		y= height/2;
		reload();

	}

	void act(){
		compute();
		render();

	}

	void compute(){

		x=(int)((truP[1].position().x()+truP[3].position().x()+truP[6].position().x()+truP[4].position().x())/4.0)+4;
		y=(int)((truP[1].position().y()+truP[3].position().y()+truP[6].position().y()+truP[4].position().y())/4.0)+10;
		partRotate(0,atan2(truP[3].position().y()-truP[0].position().y(),truP[3].position().x()-truP[0].position().x()) );

		//noha L
		partRotate(2,atan2(nohaL1P.position().y()-truP[6].position().y(),nohaL1P.position().x()-truP[6].position().x())-HALF_PI);
		partRotate(3,atan2(nohaL2P.position().y()-nohaL1P.position().y(),nohaL2P.position().x()-nohaL1P.position().x())-HALF_PI  );
		
		//nohaR
		partRotate(4,atan2(nohaR1P.position().y()-truP[4].position().y(),nohaR1P.position().x()-truP[4].position().x())-HALF_PI  );
		partRotate(5,atan2(nohaR2P.position().y()-nohaR1P.position().y(),nohaR2P.position().x()-nohaR1P.position().x())-HALF_PI  );
		
		
		//kotniky inactive
		partRotate(6,atan2(nohaL2P.position().y()-nohaL1P.position().y(),nohaL2P.position().x()-nohaL1P.position().x())-HALF_PI );
		partRotate(7,atan2(nohaR2P.position().y()-nohaR1P.position().y(),nohaR2P.position().x()-nohaR1P.position().x())-HALF_PI );
		
		

		partRotate(1,atan2(hlavaP.position().y()-lerp(truP[1].position().y(),truP[2].position().y(),0.5),hlavaP.position().x()-lerp(truP[1].position().x(),truP[2].position().x(),0.5))+ HALF_PI );

		//ruka L
		partRotate(8,atan2(rukaL1P.position().y()-truP[1].position().y(),rukaL1P.position().x()-truP[1].position().x())  +HALF_PI-PI);
		partRotate(9,atan2(rukaL2P.position().y()-rukaL1P.position().y(),rukaL2P.position().x()-rukaL1P.position().x()) - HALF_PI);


		//ruka R
		partRotate(10,atan2(rukaR1P.position().y()-truP[2].position().y(),rukaR1P.position().x()-truP[2].position().x()) - HALF_PI);
		partRotate(11,atan2(rukaR2P.position().y()-rukaR1P.position().y(),rukaR2P.position().x()-rukaR1P.position().x()) - HALF_PI);
		//float finetune = map(mouseX,0,width,0,1);
		//println(finetune);

		collide();

	}

	void partRotate(int i,float kolik){

		rotation[i] = (kolik);//map(kolik,-PI,PI,-180,180);//limits[i][0],limits[i][1]);

	}

	void fillGraphics(){

		for(int i = 0;i<part.length;i++){
			String temp[] = splitTokens(marks[i],",");
			int x = -(parseInt(temp[0])+2);
			int y = -(parseInt(temp[1])+2);
			part[i].beginDraw();
			part[i].image(mapa,x,y);
			part[i].endDraw();
		}

	}

	void collide(){
		
		float fri = 1.0;
		float dmp = 0.01;

		for(int i =0;i<truP.length;i++){
			if(truP[i].position().y()>world.y){
				
				truP[i].setVelocity(truP[i].velocity().x()*fri,truP[i].velocity().y()*-dmp,0.0);
				truP[i].moveTo(truP[i].position().x(),world.y,0);
			}
		}
		
		if(nohaL1P.position().y()>world.y){
			
			nohaL1P.setVelocity(nohaL1P.velocity().x()*fri,nohaL1P.velocity().y()*-dmp,0.0);
			nohaL1P.moveTo(nohaL1P.position().x(),world.y,0);
		}
		
		if(nohaL2P.position().y()>world.y){
			
			nohaL2P.setVelocity(nohaL2P.velocity().x()*fri,nohaL2P.velocity().y()*-dmp,0.0);
			nohaL2P.moveTo(nohaL2P.position().x(),world.y,0);
		}
		
		if(nohaR1P.position().y()>world.y){
			
			nohaR1P.setVelocity(nohaR1P.velocity().x()*fri,nohaR1P.velocity().y()*-dmp,0.0);
			nohaR1P.moveTo(nohaR1P.position().x(),world.y,0);
		}
		
		if(nohaR2P.position().y()>world.y){
			
			nohaR2P.setVelocity(nohaR2P.velocity().x()*fri,nohaR2P.velocity().y()*-dmp,0.0);
			nohaR2P.moveTo(nohaR2P.position().x(),world.y,0);
		}
		
		if(rukaL1P.position().y()>world.y){
			
			rukaL1P.setVelocity(rukaL1P.velocity().x()*fri,rukaL1P.velocity().y()*-dmp,0.0);
			rukaL1P.moveTo(rukaL1P.position().x(),world.y,0);
		}
		
		if(rukaL2P.position().y()>world.y){
			
			rukaL2P.setVelocity(rukaL2P.velocity().x()*fri,rukaL2P.velocity().y()*-dmp,0.0);
			rukaL2P.moveTo(rukaL2P.position().x(),world.y,0);
		}
		
		if(rukaR1P.position().y()>world.y){
			
			rukaR1P.setVelocity(rukaR1P.velocity().x()*fri,rukaR1P.velocity().y()*-dmp,0.0);
			rukaR1P.moveTo(rukaR1P.position().x(),world.y,0);
		}
		
		if(rukaR2P.position().y()>world.y){
			
			rukaR2P.setVelocity(rukaR2P.velocity().x()*fri,rukaR2P.velocity().y()*-dmp,0.0);
			rukaR2P.moveTo(rukaR2P.position().x(),world.y,0);
		}
		
		if(hlavaP.position().y()>world.y){
			
			hlavaP.setVelocity(hlavaP.velocity().x()*fri,hlavaP.velocity().y()*-dmp,0.0);
			hlavaP.moveTo(hlavaP.position().x(),world.y,0);
		}	
		



	}
	
	

	void render(){

		//level0 poziceGlob
		pushMatrix();
		translate(x,y);


		//level1 trup
		pushMatrix();
		translate(positions[0][0],positions[0][1]);
		pushMatrix();

		translate(-anchors[0][0],-anchors[0][1]);
		rotate( (rotation[0]));

		//LEVA RUKA
		//level 2 rukaL1
		pushMatrix();
		translate(positions[8][0],positions[8][1]);
		pushMatrix();
		translate(-anchors[8][0],-anchors[8][1]);
		rotate( (rotation[8])-rotation[0]);
		image(part[8],-anchors[8][0],-anchors[8][1]);

		//level 3 rukaL2
		pushMatrix();
		translate(positions[9][0],positions[9][1]);
		pushMatrix();
		translate(-anchors[9][0],-anchors[9][1]);
		rotate( (rotation[9]-(rotation[8])));
		image(part[9],-anchors[9][0],-anchors[9][1]);



		popMatrix();
		popMatrix();
		//level 3 rukaL2 end
		popMatrix();
		popMatrix();
		//level 2 rukaL1 end

		//trup image
		image(part[0],-anchors[0][0],-anchors[0][1]);


		//LEVA NOHA
		//level 2 hohaL1
		pushMatrix();
		translate(positions[2][0],positions[2][1]);
		pushMatrix();
		translate(-anchors[2][0],-anchors[2][1]);
		rotate( (rotation[2]-rotation[0]));
		image(part[2],-anchors[2][0],-anchors[2][1]);
		//level 3 hohaL2
		pushMatrix();
		translate(positions[3][0],positions[3][1]);
		pushMatrix();
		translate(-anchors[3][0],-anchors[3][1]);
		rotate( (rotation[3]-(rotation[2])));
		//level 4 botaL
		pushMatrix();
		translate(positions[6][0],positions[6][1]);
		pushMatrix();
		translate(-anchors[6][0],-anchors[6][1]);
		rotate( (rotation[6])-((rotation[3])));
		image(part[6],-anchors[6][0],-anchors[6][1]);
		popMatrix();
		popMatrix();
		//level 4 botaL end
		image(part[3],-anchors[3][0],-anchors[3][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaL2 end
		popMatrix();
		popMatrix();
		//level 2 hohaL1 end


		//PRAVA NOHA
		//level 2 hohaR1
		pushMatrix();
		translate(positions[4][0],positions[4][1]);
		pushMatrix();
		translate(-anchors[4][0],-anchors[4][1]);
		rotate( (rotation[4])-rotation[0]);
		image(part[4],-anchors[4][0],-anchors[4][1]);
		//level 3 hohaR2
		pushMatrix();
		translate(positions[5][0],positions[5][1]);
		pushMatrix();
		translate(-anchors[5][0],-anchors[5][1]);
		rotate( (rotation[5])-(rotation[4]));
		//level 4 botaR
		pushMatrix();
		translate(positions[7][0],positions[7][1]);
		pushMatrix();
		translate(-anchors[7][0],-anchors[7][1]);
		rotate( (rotation[7])-(rotation[5]));
		image(part[7],-anchors[7][0],-anchors[7][1]);
		popMatrix();
		popMatrix();
		//level 4 botaR end
		image(part[5],-anchors[5][0],-anchors[5][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaR2 end
		popMatrix();
		popMatrix();
		//level 2 hohaR1 end


		//HLAVA
		//level2 hlava
		pushMatrix();
		translate(positions[1][0],positions[1][1]);
		pushMatrix();
		translate(-anchors[1][0],-anchors[1][1]);
		rotate( (rotation[1]));
		image(part[1],-anchors[1][0],-anchors[1][1]);
		popMatrix();
		popMatrix();
		//level 2 hlava end

		//PRAVA RUKA
		//level 2 rukaR1
		pushMatrix();
		translate(positions[10][0],positions[10][1]);
		pushMatrix();
		translate(-anchors[10][0],-anchors[10][1]);
		rotate( (rotation[10])-rotation[0]);
		image(part[10],-anchors[10][0],-anchors[10][1]);

		//level 3 rukaR2
		pushMatrix();
		translate(positions[11][0],positions[11][1]);
		pushMatrix();
		translate(-anchors[11][0],-anchors[11][1]);
		rotate( (rotation[11])-rotation[10]);
		image(part[11],-anchors[11][0],-anchors[11][1]);

		popMatrix();
		popMatrix();
		//level 3 rukaR2 end
		popMatrix();
		popMatrix();
		//level 2 rukaR1 end

		popMatrix();
		popMatrix();
		//level1 trup end

		popMatrix();
		//level0 glob end

	}

	void reload(){

		mapa = loadImage("figurka.png");
		maska = new int[mapa.pixels.length];

		marks = new String[0];
		for(int y =0;y<mapa.height;y++){
			for(int x =0;x<mapa.width;x++){
				int which = y*mapa.width+x;
				if(brightness(mapa.pixels[which])==0){
					maska[which] = 0;
				}else if(brightness(mapa.pixels[which])>254){
					marks = (String[])expand(marks,marks.length+1);
					marks[marks.length-1] = ""+x+","+y;
				}else{
					maska[which] = 255;
				}
			}
		}

		mapa.mask(maska);

		println(map(mouseX,0,width,-TWO_PI,TWO_PI));

		//hlava
		part[0] = createGraphics(8,16,JAVA2D);

		//trup
		part[1] = createGraphics(9,9,JAVA2D);


		//nohaL1
		part[2]= createGraphics(4,8,JAVA2D);
		//nohaL2
		part[3]= createGraphics(4,7,JAVA2D);

		//nohaR1
		part[4]= createGraphics(4,8,JAVA2D);
		//nohaR2
		part[5]= createGraphics(4,7,JAVA2D);

		//botaL
		part[6]= createGraphics(4,4,JAVA2D);
		//botaR
		part[7]= createGraphics(4,4,JAVA2D);

		//rukaL1
		part[8] = createGraphics(5,9,JAVA2D);
		//rukaL2
		part[9] = createGraphics(3,11,JAVA2D);

		//rukaR1
		part[10] = createGraphics(5,9,JAVA2D);
		//rukaR2
		part[11]= createGraphics(3,11,JAVA2D);


		fillGraphics();

		for(int i =0;i<rotation.length;i++){
			rotation[i] = 0;//random(-30,30);

		}

	}

}





class World{
	float y = height-5;

	void render(){
		stroke(255);
		line(0,y,width,y);

	}

}

PGraphics pdf;

PImage result;
PFont a,b,c,d;
String word = "hello";
int sel = 0;

int counter = 0;
int multi = 100;

String[] input;
String slova[] = new String[0];

int alphas[] = {5,5,5,5};

void setup(){

	result = loadImage("JANA50-CELA-final.jpg");

	size(result.width,result.height,OPENGL);


	input = loadStrings("portugalsko50jana2.txt");

	for(int i =0;i<input.length;i++){
		String temp[] = splitTokens(input[i]," ,.!()");
		for(int q = 0;q<temp.length;q++){
			if(!temp[q].equals(" ")&&!temp[q].equals(":")){
				slova = (String[])expand(slova,slova.length+1);

				slova[slova.length-1] = temp[q]+"";}
		}

	}




	a = createFont("Veranda",12);
	b = createFont("Veranda",10);
	c = createFont("Veranda",12);
	d = createFont("Veranda",9);

	println("fonts initialized");

	pdf = createGraphics(width, height, PDF, "output.pdf");

	pdf.beginDraw();
	pdf.background(255);
	pdf.textAlign(CENTER);
	background(255);
	noStroke();
}



void draw(){

	//image(result,0,0);

	for(int i =0;i<multi;i++){
		int x, y;
		x= (int)random(width);
		y = (int)random(height);

		int which = y*result.width+x;
		which = constrain(which,0,result.pixels.length);


		if(brightness(result.pixels[which])<200){

			word = slova[(int)random(slova.length)];

			sel = (int)random(4);

			switch (sel){
			case 0:
				textFont(a);
				pdf.textFont(a);
				fill(result.pixels[which],alphas[0]);
				pdf.fill(result.pixels[which],alphas[0]);
				break;
			case 1:
				textFont(b);

				pdf.textFont(b);
				fill(result.pixels[which],alphas[1]);
				pdf.fill(result.pixels[which],alphas[1]);
				break;
			case 2:
				textFont(c);

				pdf.textFont(c);
				fill(result.pixels[which],alphas[2]);
				pdf.fill(result.pixels[which],alphas[2]);
				break;
			case 3:
				textFont(a);

				pdf.textFont(d);
				fill(result.pixels[which],alphas[3]);
				pdf.fill(result.pixels[which],alphas[3]);
				break;
			}


			text(word,x,y);

			//if(mousePressed)
			pdf.text(word,x,y);
			//counter ++;}

		}
	}


}

void keyPressed(){

	if(key=='q'){
		pdf.dispose();
		pdf.endDraw();
		exit();
	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
/*
The shining of friday afternoon


At the beginning there was a noise;
so deep as a complete silence

no matter, no space, no time
no observer, therefore nothing at all

nobody knows how it happend;
that noise produced first pattern
the pattern we called the life

that all happened without glory
it was just naural, just like that
as natural as we can understand

now I am cheering that noise, cheering the nature,
cheering everything out of my understanding
because that made us, and we made it like this

we are that patterns in the noise which is surrounding us,
which our minds are inhabitants of

we are just natural consequence
quite rare in our scale,
but nothing more or less

of course I know I am wrong
just a noise is always true

that is the think I repeat endlessly
nothing more I ever wish to say

kof
*/


float speed = 25*70.0;

Noda[] n = new Noda[0];
Recorder r;

boolean rec = false;
PImage vitruv,now;

void setup(){


	vitruv = loadImage("vitruvian_man.jpg");
	now = loadImage("now.png");
	
	size(vitruv.width,vitruv.height,OPENGL);
	background(0);


	for(int i =0;i<6;i++){
		for(int yy = 0;yy<width;yy+=1){

			for(int xx = 0;xx<width;xx+=1){
				if(brightness(vitruv.pixels[yy*width+xx])<128){
					n = (Noda[])expand(n,n.length+1);
					n[n.length-1] = new Noda(xx,yy,width);
				}

			}
		}
	}
	if(rec)
		r = new Recorder("vid","theShininOfAFridayAfternoon.mp4");

	noFill();
	stroke(255,50);

}


void draw(){

	background(0);



		for(int i = 0 ; i<n.length ; i++){

			n[i].act();
		}

	
	/*if(frameCount>speed&&frameCount<speed+2){
		println(frameCount);
		image(now,0,0);
		//exit();
	}*/


	if(rec)
		r.add();
	
	if(frameCount>speed*2){
		if(rec)
			r.finish();
		exit();
	}


}

void keyPressed(){

	if(key=='q'){
	if(rec)
		r.finish();
	exit();}
}


class Noda{

	float x,y;
	float X,Y;
	float tx,ty;
	float spread = 10.0;

	Noda(float _x,float _y,float _spread){

		X = x = _x;
		Y = y = _y;
		spread = _spread;
		tx = random( -spread , spread);
		ty = random( -spread , spread);


	}

	void act(){
		compute();
		draw();

	}

	void compute(){

		x = map(sin((frameCount-speed)/speed),-1,1,X-tx,X+tx);
		y = map(sin((frameCount-speed)/speed),-1,1,Y-ty,Y+ty);

	}

	void draw(){
		rect(x,y,1,1);
	}


}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
/**
 * Loop. 
 * Built-in video library replaced with gsvideo by Andres Colubri
 * 
 * Move the cursor across the screen to draw. 
 * Shows how to load and play a QuickTime movie file.  
 */
import jmcvideo.*;

JMCMovie m2;
Recorder r;


boolean rec  = true;
int x=0,y=0;

float tres = 5;
float lastval = 0;
int framer = 0;
boolean newf = true;

void setup() {
	size(13*50, 2*30, P3D);
	background(0);
	frameRate(29);
	// Load and play the video in a loop
	m2 = new JMCMovie(this, "test2.avi");
	m2.mute() ;

	r = new Recorder("out","raw.mp4");

	m2.play();
	//m2.pause();

}




void draw() {




	image(m2, x, y);
	framer++;

}

void move(){

	x+=m2.width;
	if(x>=width&&y==0){
		x=0;
		y+=m2.height;
	}else if(x>=width-m2.width){
		x=0;
		y+=m2.height;
	
	}

	if(y>=height){
		if(rec)
			r.add();
		x=0;
		y=0;

	}

}

void keyPressed(){

	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}else{
		move();
	}

}

Hero hero;


void setup(){
	size(200,200,OPENGL);

	hero = new Hero();
	noSmooth();


}


void draw(){

	background(0);

	hero.render();



}

void mousePressed(){

	hero.reload();
}

void keyPressed(){
	if(key=='w'){
		hero.control = 0;
	}else if(key=='2'){
		hero.control = 1;
	}else if(key=='a'){
		hero.control = 2;
	}else if(key=='z'){
		hero.control = 3;
	}else if(key=='d'){
		hero.control = 4;
	}else if(key=='c'){
		hero.control = 5;
	}else if(key=='q'){
		hero.control = 8;
	}else if(keyCode==TAB){
		hero.control = 9;
	}else if(key=='e'){
		hero.control = 10;
	}else if(key=='r'){
		hero.control = 11;
	}

}



class Hero{
	PImage mapa;
	int maska[];
	int anchors[][] = {{4,10},{5,7},

	                   {2,1},{1,0},{2,1},{1,0},
	                   {1,0},{1,0},

	                   {4,2},{1,1},{2,2},{1,1}
	                  };

	int positions[][] = {{0,0},{6,-3},

	                     {-1,4},{0,7},{4,4},{0,7},
	                     {2,6},{1,6},

	                     {1,-4},{-1,6},{7,-4},{1,6}

	                    };

	float rotation[] = new float[12];

	float limits[][] = {
	                           {-180,180},{-46.8,36.77},

	                           {138.0,-25.0},{5.2,-113.0},{138.0,-25.0},{5.2,-113.0},
	                           {-34.0,59.0},{-34.0,59.0},

	                           {178.0,-39.0},{158.0,-1.0},{169.0,-115.0},{133.0,-10.0}

	                   };

	PGraphics part[] = new PGraphics[12];

	String marks[] = new String[0];

	int x,y;
	int control = 0;

	Hero(){
		x = width/2;
		y= height/2;
		reload();

	}

	void fillGraphics(){




		for(int i = 0;i<part.length;i++){
			String temp[] = splitTokens(marks[i],",");
			int x = -(parseInt(temp[0])+2);
			int y = -(parseInt(temp[1])+2);
			part[i].beginDraw();
			part[i].image(mapa,x,y);
			part[i].endDraw();
		}

	}

	void reload(){

		mapa = loadImage("figurka.png");
		maska = new int[mapa.pixels.length];

		marks = new String[0];
		for(int y =0;y<mapa.height;y++){
			for(int x =0;x<mapa.width;x++){
				int which = y*mapa.width+x;
				if(brightness(mapa.pixels[which])==0){
					maska[which] = 0;
				}else if(brightness(mapa.pixels[which])>254){
					marks = (String[])expand(marks,marks.length+1);
					marks[marks.length-1] = ""+x+","+y;
				}else{
					maska[which] = 255;
				}
			}
		}

		mapa.mask(maska);

		println(marks.length);

		//hlava
		part[0] = createGraphics(8,16,JAVA2D);

		//trup
		part[1] = createGraphics(9,9,JAVA2D);


		//nohaL1
		part[2]= createGraphics(4,8,JAVA2D);
		//nohaL2
		part[3]= createGraphics(4,7,JAVA2D);

		//nohaR1
		part[4]= createGraphics(4,8,JAVA2D);
		//nohaR2
		part[5]= createGraphics(4,7,JAVA2D);

		//botaL
		part[6]= createGraphics(4,4,JAVA2D);
		//botaR
		part[7]= createGraphics(4,4,JAVA2D);

		//rukaL1
		part[8] = createGraphics(5,9,JAVA2D);
		//rukaL2
		part[9] = createGraphics(3,11,JAVA2D);

		//rukaR1
		part[10] = createGraphics(5,9,JAVA2D);
		//rukaR2
		part[11]= createGraphics(3,11,JAVA2D);


		fillGraphics();

		for(int i =0;i<rotation.length;i++){
			rotation[i] = 0;//random(-30,30);

		}

	}


	void partRotate(int i,float kolik){

		rotation[i] += (map(mouseX,0,width,limits[i][0],limits[i][1])-rotation[i])/10.0;

	}

	void render(){

		partRotate(control,200.0);



		//level0 poziceGlob
		pushMatrix();
		translate(x,y);


		//level1 trup
		pushMatrix();
		translate(positions[0][0],positions[0][1]);
		pushMatrix();

		translate(-anchors[0][0],-anchors[0][1]);
		rotate(radians(rotation[0]));

		//LEVA RUKA
		//level 2 rukaL1
		pushMatrix();
		translate(positions[8][0],positions[8][1]);
		pushMatrix();
		translate(-anchors[8][0],-anchors[8][1]);
		rotate(radians(rotation[8]));
		image(part[8],-anchors[8][0],-anchors[8][1]);

		//level 3 rukaL2
		pushMatrix();
		translate(positions[9][0],positions[9][1]);
		pushMatrix();
		translate(-anchors[9][0],-anchors[9][1]);
		rotate(radians(rotation[9]));
		image(part[9],-anchors[9][0],-anchors[9][1]);



		popMatrix();
		popMatrix();
		//level 3 rukaL2 end
		popMatrix();
		popMatrix();
		//level 2 rukaL1 end

		//trup image
		image(part[0],-anchors[0][0],-anchors[0][1]);


		//LEVA NOHA
		//level 2 hohaL1
		pushMatrix();
		translate(positions[2][0],positions[2][1]);
		pushMatrix();
		translate(-anchors[2][0],-anchors[2][1]);
		rotate(radians(rotation[2]));
		image(part[2],-anchors[2][0],-anchors[2][1]);
		//level 3 hohaL2
		pushMatrix();
		translate(positions[3][0],positions[3][1]);
		pushMatrix();
		translate(-anchors[3][0],-anchors[3][1]);
		rotate(radians(rotation[3]));
		//level 4 botaL
		pushMatrix();
		translate(positions[6][0],positions[6][1]);
		pushMatrix();
		translate(-anchors[6][0],-anchors[6][1]);
		rotate(radians(rotation[6]));
		image(part[6],-anchors[6][0],-anchors[6][1]);
		popMatrix();
		popMatrix();
		//level 4 botaL end
		image(part[3],-anchors[3][0],-anchors[3][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaL2 end
		popMatrix();
		popMatrix();
		//level 2 hohaL1 end


		//PRAVA NOHA
		//level 2 hohaR1
		pushMatrix();
		translate(positions[4][0],positions[4][1]);
		pushMatrix();
		translate(-anchors[4][0],-anchors[4][1]);
		rotate(radians(rotation[4]));
		image(part[4],-anchors[4][0],-anchors[4][1]);
		//level 3 hohaR2
		pushMatrix();
		translate(positions[5][0],positions[5][1]);
		pushMatrix();
		translate(-anchors[5][0],-anchors[5][1]);
		rotate(radians(rotation[5]));
		//level 4 botaR
		pushMatrix();
		translate(positions[7][0],positions[7][1]);
		pushMatrix();
		translate(-anchors[7][0],-anchors[7][1]);
		rotate(radians(rotation[7]));
		image(part[7],-anchors[7][0],-anchors[7][1]);
		popMatrix();
		popMatrix();
		//level 4 botaR end
		image(part[5],-anchors[5][0],-anchors[5][1]);
		popMatrix();
		popMatrix();
		//level 3 hohaR2 end
		popMatrix();
		popMatrix();
		//level 2 hohaR1 end









		//HLAVA
		//level2 hlava
		pushMatrix();
		translate(positions[1][0],positions[1][1]);
		pushMatrix();
		translate(-anchors[1][0],-anchors[1][1]);
		rotate(radians(rotation[1]));
		image(part[1],-anchors[1][0],-anchors[1][1]);
		popMatrix();
		popMatrix();
		//level 2 hlava end

		//PRAVA RUKA
		//level 2 rukaR1
		pushMatrix();
		translate(positions[10][0],positions[10][1]);
		pushMatrix();
		translate(-anchors[10][0],-anchors[10][1]);
		rotate(radians(rotation[10]));
		image(part[10],-anchors[10][0],-anchors[10][1]);

		//level 3 rukaR2
		pushMatrix();
		translate(positions[11][0],positions[11][1]);
		pushMatrix();
		translate(-anchors[11][0],-anchors[11][1]);
		rotate(radians(rotation[11]));
		image(part[11],-anchors[11][0],-anchors[11][1]);

		popMatrix();
		popMatrix();
		//level 3 rukaR2 end
		popMatrix();
		popMatrix();
		//level 2 rukaR1 end

		popMatrix();
		popMatrix();
		//level1 trup end

		popMatrix();
		//level0 glob end

	}





}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
int X, Y;

Recorder r;
boolean rec = false;

int top = 4;
int numx = 320/top,numy = 240/top;

Cell c[][] = new Cell[numx*top][numy*top];
color col[] = {color(0),color(50),color(120),color(255)};

int shiftx=0,shifty=0;

int scaler = 4;
String filename;

void setup(){
	size(320,240,OPENGL);
	background(0);

	noCursor();

	filename =  "machines/looper2_"+c.length+"x"+c[0].length;

	frameRate(30);

	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			c[x][y] = new Cell(x,y);
		}
	}

	//if(rec){
		r = new Recorder("out","cellularComuter.mp4");
	//}


	//for(int x=0;x<c.length;x++){
	//	c[x][30].state=1;
	//}

	noStroke();


}

void loadState(){
	try{
		String temp[] = loadStrings(filename+".txt");

		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].state = parseInt(temp[y].charAt(x))-48;
			}
		}

	}catch(NullPointerException e){
		println("no such a file, please save before");
	}
	println("machine loaded: "+filename+".txt");
}

void saveState(){

	String data[] = new String[0];

	for(int y=0;y<c[0].length;y++){
		data = (String[])expand(data,data.length+1);
		data[data.length-1] = "";
		for(int x=0;x<c.length;x++){
			data[data.length-1]+=c[x][y].state!=0?"1":"0";
		}
	}

	saveStrings(filename,data);
	println("saved as: "+filename+".txt");


}


void loadStateFromImage(){
	try{
		PImage temp = loadImage(filename+".png");


		if(temp.width==c.length&&temp.height==c[0].length){

			c = new Cell[numx*top][numy*top];

			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y] = new Cell(x,y);
					if((brightness(color(temp.pixels[y*temp.width+x]))) != 0.0){
						c[x][y].state=1;
					}else{
						c[x][y].state=0;
					}
				}
			}

			println("state loaded sucessfully from: "+filename+".bmp");



		}else{
			println("error: stored values does not correpondent to dimensions");

		}

	}catch(NullPointerException e){
		println("error: saved record does not found " +e);
	}


}



void saveStateToImage(){
	PImage temp = createImage(c.length,c[0].length,RGB);


	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			if(c[x][y].state>0){temp.pixels[y*temp.width+x]=color(255);}else{temp.pixels[y*temp.width+x]=color(0);}
		}
	}

	temp.save(filename+".bmp");
	println("state saved as image: "+filename+".bmp");


}

void draw(){

	background(0);

	step(1);


	pushMatrix();
	translate(-shiftx,-shifty);


	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			c[x][y].draw();
		}
	}

	noFill();
	stroke(255);
	rect(-1,-1,1,1);
	rect(c.length*scaler+1,-1,1,1);
	rect(-1,c[0].length*scaler+1,1,1);
	rect(c.length*scaler-1,c[0].length*scaler+1,1,1);
	noStroke();

	popMatrix();



	X = constrain((int)((mouseX/scaler)+shiftx/scaler),0,c.length-1);
	Y = constrain((int)((mouseY/scaler)+shifty/scaler),0,c[0].length-1);

	c[X][Y].sel=true;

	if(mousePressed){
		if(mouseButton==LEFT)
			c[X][Y].state=1;
		if(mouseButton==RIGHT)
			c[X][Y].state=0;
		if(mouseButton==3){
			c[X][Y].state=3;
			mousePressed=false;
		}
	}


	if(rec){
		r.add();
	}
}

void keyPressed(){
	if(key==' '){
		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].calm();
			}

		}
	}else if(key=='='){
		scaler++;
	}else if(key=='-'){
		scaler--;
	}else if(key =='s'){
		saveState();
	}else if(key =='l'){
		loadState();
	}else if(keyCode==LEFT){
		shiftx-=3;
	}else if(keyCode==RIGHT){
		shiftx+=3;
	}else if(keyCode==UP){
		shifty-=3;
	}else if(keyCode==DOWN){
		shifty+=3;
	}else if(keyCode==DELETE){
		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].state=c[x][y].nextState=0;
			}
		}
	}else if(keyCode==ENTER){
		c[X][Y].state=3;


	}else if(keyCode == 155){
		saveStateToImage();

	}else if(keyCode==36){
		loadStateFromImage();
	}else if(key == 'q'){

		if(rec){
			r.finish();
		}
		exit();
	}else if(key == 'a'){
		rec=!rec;
	}


	scaler=constrain(scaler,1,top);
	keyPressed=false;
}

void step(int n){
	boolean anim = false;
	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			if(c[x][y].state>1){
				anim=true;
				break;
			}
		}
	}

	if(anim){
		if(frameCount%n==0){
			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y].act();
				}
			}

			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y].update();
				}
			}
		}
	}

}

class Cell{
	//state 0=black, 1=wire, 2= tail, 3=head
	int state = 0;
	int nextState = 0;
	int x,y;
	boolean sel = false;

	Cell(int _x,int _y){
		x=_x;
		y=_y;
	}

	void act(){
		compute();


	}

	void draw(){



		if(state>0){

			noStroke();
			fill(col[state]);
			rect(x*scaler,y*scaler,scaler,scaler);
		}

		if(sel){
			stroke(255);
			fill(col[state]);
			rect(x*scaler,y*scaler,scaler,scaler);
		}
		sel=false;



	}

	void compute(){

		//is wire?
		if(state>0){

			if(state==3){
				nextState = 2;
			}else if(state==2){
				nextState=	1;
			}else if(state==1){
				nextState=1;

				int q = getStates(3);
				if(q==1||q==2){
					nextState=3;
				}
			}

		}else{
			nextState=0;
		}

	}

	void update(){
		state=nextState;
	}

	int getStates(int wh){
		int cnt = 0;

		if(c[(x+c.length-1)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length-1)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length-1)%c.length][(y+c[0].length)%c[0].length].state==wh)cnt++;

		return cnt;

	}

	void calm(){

		if(state>0){
			nextState=1;
			update();
		}

	}
}
import promidi.*;
import codeanticode.gsvideo.*;

MidiIO midiIO;
MidiOut midiOut;
Note note;

int notes[] = {75, 41, 62, 71, 89, 61, 98, 93, 65, 43, 47, 78, 107, 108, 90, 45, 71, 73, 66, 89};//new int[0];

ImgPlr one;


GSCapture cam;
int step = 12;

boolean doublesize = false;

PImage msk;

/*

 midiOut.sendController(

      new promidi.Controller(myNumber,int(xPos/6)+2)

    );
 midiOut.sendProgramChange(

        new ProgramChange(myNumber)

      );

*/

void setup(){

	size(480,480,OPENGL);

	background(0);
	frameRate(25);

	//smooth();
	/*
	int g = 0;
	for(int i = width/2;i<width;i+=step){
			notes = (int[])expand(notes,notes.length+1);
			notes[notes.length-1] = (int)random(40,110);//(int)map(i,width/2,width,20,100);
			print(notes[notes.length-1]+", ");
			g++;
}
	println("");
	println("created "+g+" of senzors");
	*/
	msk = loadImage("mask.png");
	for(int i = 0 ;i<notes.length;i++)
		notes[i] = i*2+60;

	midiIO = MidiIO.getInstance(this);

	midiOut = midiIO.getMidiOut(1,1);

	if(doublesize){
		cam = new GSCapture(this,320,240);
	}else{
		cam = new GSCapture(this,640,480);

	}

	//print a list with all available devices

	//midiIO.printDevices();




	one = new ImgPlr(loadImage("title.png"));

	noStroke();
	rectMode(CENTER);

}


void draw(){


	background(255);

	one.act();

	image(msk,0,0,width,height);
}


void keyPressed(){

	if(key=='q'){
		try{
			exit();
		}catch(NullPointerException e){
			println("buckEnd!");
		}
	}else if(key==' '){

		one.refresh();


	}else if(keyCode==UP){
		one.speed++;
		println(one.speed);
	}else if(keyCode==DOWN){
		one.speed--;
		println(one.speed);
	}

	one.speed=constrain(one.speed,1,30);
}





class ImgPlr{

	PImage store;
	float rot = 0;
	float speed = 1;
	int mem[] = new int[0];
	int mem2[] = new int[0];
	float tresh = 30;

	ImgPlr(PImage _src){
		store = _src;


		for(int i = width/2;i<width;i+=step){
			mem = (int[])expand(mem,mem.length+1);
			mem[mem.length-1] = 0;
			mem2 = (int[])expand(mem2,mem2.length+1);
			mem2[mem2.length-1] = 0;
		}
		refresh();
	}

	void act(){
		rot+=speed;



		pushMatrix();
		translate(width/2,height/2);
		rotate(radians(rot));

		if(doublesize){
			image(store,-store.width,-store.height,store.width*2,store.height*2);

		}else{
			image(store,-store.width/2,-store.height/2);


		}
		popMatrix();

		int g = 0;

		for(int i = width/2;i<width;i+=step){
			mem[g] = (int)brightness(get(i,height/2));
			fill(abs(mem[g]-mem2[g]));
			rect(i,height/2,4,4);


			if(abs(mem2[g]-mem[g])>tresh){
				if(rot>2)
					playNote( notes[g] , (int)constrain((abs(mem2[g]-mem[g])-tresh)*30,5,1000) );
			}

			mem2[g] = mem[g];


			g++;
		}

		if(rot>360){
			rot=0;
			refresh();
		}

	}

	void refresh(){
		if (cam.available() == true) {
			try{
				cam.read();
				store=cam;
				//cam.resize(0,320);


			}catch(java.lang.NullPointerException e){
				println("weird error! @ "+frameCount);
			}
		}

		int g = 0;

	}



}



void playNote(int tone,int len){

	note = new Note(tone,(int)map(len,0,1000,20,127),len);
	midiOut.sendNote(note);

}


Recorder r;
int num = 2;
Layer l[] = new Layer[num];


boolean rec = false;



void setup(){

	size(720,480,OPENGL);
	noSmooth();

	stroke(0);
	strokeWeight(3);

	for(int i = 0 ;i<num;i++){
		l[i] = new Layer( 10.5 , 12.5, 1.0, i );

	}

	strokeWeight(1.7);


	if(rec)
		r = new Recorder("out","moire5.mp4");
}


void draw(){
	pushStyle();
	fill(255);
	stroke(0);
	strokeWeight(10);
	rect(0,0,width,height);

	popStyle();

	for(int i =0;i<l.length;i++){
		l[i].act();
	}

	if(rec)
		r.add();


}

void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();

		exit();

	}

}



class Layer{

	float cx,cy;
	float x,y;
	float rozsek;

	float rot = 0;
	float sp;
	int id;

	Layer(float _down,float _up,float _sp,int _id){
		id = _id;
		cx= width/2;
		cy= height/2;
		x = random(width/2.0);//cos(frameCount/sp)*50+cx;
		y = height/2.0;//random(height);//sin(frameCount/sp)*50+cy;
		rozsek = random(_down,_up);

		sp = random(280.0,300.0);

	}

	void act(){
		if(frameCount>25)
			rot+=sp;

		if(id==0){
			x = mouseX;
			y = mouseY;
		}else{
			x+=(cx-x)/sp;
			y+=(cy-y)/sp;
		}

		noFill();


		for(float f = 0;f<width/2;f+=rozsek){
			ellipse(x,y,f,f);

		}


	}


}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

class Mozek{
	Keuron k[][];
	int[] layers = LAYERS;

	Mozek(){

		k = new Keuron[layers.length][0];

		// create keurons
		for(int i = 0;i < layers.length;i++){
			GRAPY+=GRAPSTEP;
			GRAPX=0;



			for(int t = 0;t < layers[i];t++){

				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this);
				GRAPX+=GRAPSTEP;
			}

			if(i==0){


				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this,0);

				GRAPX+=GRAPSTEP;
				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this,1);
				GRAPX+=GRAPSTEP;

			}



		}

		// fill keurons with connexions
		for(int i = 0;i < layers.length;i++){
			for(int t = 0;t < layers[i];t++){
				fillIns(i,t);
			}
		}

	}

	void act(){
		for(int i = 0;i < layers.length;i++){
			for(int t = 0;t < layers[i];t++){
				k[i][t].act();
			}
		}

	}

	int[] getIns(int lay,int kolik){

		int temp[] = new int[kolik];
		int vse[] = new int[LAYERS[lay]];
		int zbytek[] = new int[0];


		for(int i =0;i<vse.length;i++){
			vse[i] = k[lay][i].id;
		}

		for(int i =0;i<kolik;i++){

			int rand = (int)random(vse.length);
			temp[i] = rand;

			zbytek = new int[0];
			for(int t = 0;t<vse.length;t++){
				if(vse[t]!=rand){
					zbytek = (int[])expand(zbytek,zbytek.length+1);
					zbytek[zbytek.length-1] = vse[t];
				}
			}

			vse = new int[zbytek.length];
			for(int r = 0;r<zbytek.length;r++){
				vse[r] = zbytek[r];
			}

		}

		return temp;

	}

	int[] getIns2(int lay){

		int vse[] = new int[k[lay].length];
		for(int i =0;i<vse.length;i++){
			vse[i] = i;
		}
		return vse;

	}

	void fillIns(int l,int n){

		if(l!=0){
			k[l][n].ins = getIns2(l-1);
			k[l][n].initW();
		}
	}

}

class Keuron{

	float x,y;

	float val;
	int id;
	int[] ins;
	float[] w;
	boolean active;
	int layer;
	Mozek parent;

	Keuron(int _layer,Mozek _parent){
		id = register;
		register++;
		parent = _parent;

		// prvni / posledni / jine?
		layer = _layer;

		ins = new int[0];
		val = 0;//random(0,100)*0.01;
		active = true;

		x = GRAPX;
		y = GRAPY;

		if(layer==0){
			val = IN[id];
		}

	}

	Keuron(int _layer,Mozek _parent,float _val){
		id = register;
		register++;
		parent = _parent;

		// prvni / posledni / jine?
		layer = _layer;

		ins = new int[0];
		val = _val;
		x = GRAPX;
		y = GRAPY;

	}

	void initW(){
		w = new float[ins.length];
		for(int i =0;i<w.length;i++){
			w[i] = random(-100,100)*0.01;
		}

	}

	void act(){
		//if(!learning)
		refresh();

		if(STOCHAIST){

			if(layer!=0)
				stochaist(NOISEAMOUNT);
		}

	}

	void refresh(){
		if(layer>0){
			//if(learning){
			float soucet = 0;

			for(int i = 0;i<ins.length;i++){
				w[i] = constrain(w[i],-1,1);
				//if(parent.k[layer-1][ins[i]].active)
				soucet += parent.k[layer-1][ins[i]].val*w[i];
			}


			val = sigmoid2(soucet,ins.length,SLOPE);
			val = constrain(val,0,255);
			//}

		}else{
			val = IN[id]*255;
		}

	}

	void stochaist(float kolik){

		val += random(-100,100)/kolik;
		val = constrain(val,0.0,1.0);

	}

}
// layer set
int[] LAYERS = {16,16,16,8};

// sigmoidal slope
float SLOPE = 2.0;

//learning constant 0.296875 : 1.0
float SPEED = 1.2;//0.19;
float TEACHSPEED = 1000.25;//0.25;//SPEED/0.296875;//0.64;

// noise ?
boolean STOCHAIST = false;
// so how much (1/x) ?
float NOISEAMOUNT = 10000.0;

//inputs
float IN[] = new float[LAYERS[0]];

int CURRENT = 0;

int tarvals[];

// brain class
Mozek m;

// x,y
float GRAPX = 0;
float GRAPY = 0;
float GRAPSTEP = 10;

// global id register
int register = 0;


float result[];
float smoothing[];

boolean learning = true;

void setup(){


	size(255,200,P3D);
	background(255);
	stroke(0);

	tarvals =new int[width];
	smoothing =new float[width];

	result = new float[width];

	tarvals[0] = 128;//random(0,100)*0.01;
	for(int i = 1 ;i<tarvals.length;i++){
		tarvals[i] = tarvals[i-1]+(int)random(-3,3);
		tarvals[i] = constrain(tarvals[i],1,255);
		smoothing[i] = 0;
	}

	m = new Mozek();

	//println(nf(parseInt(binary(200)),8));

}




void draw(){
	background(255);

	/*
	fill(255,15);
	noStroke();
	rect(0,0,width,height);
	noFill();
	stroke(0);

	*/
	int i = (frameCount%width);

	//for(int i =0;i<width;i++){
	String a = ""+nf(parseInt(binary(tarvals[i])),8);

	IN[0] = parseInt(""+a.charAt(0));
	IN[1] = parseInt(""+a.charAt(1));


	IN[2] = parseInt(""+a.charAt(2));
	IN[3] = parseInt(""+a.charAt(3));

	IN[4] = parseInt(""+a.charAt(4));
	IN[5] = parseInt(""+a.charAt(5));

	IN[6] = parseInt(""+a.charAt(6));
	IN[7] = parseInt(""+a.charAt(7));

	a = ""+nf(parseInt(binary(i)),8);

	IN[8] = parseInt(""+a.charAt(0));
	IN[9] = parseInt(""+a.charAt(1));

	IN[10] = parseInt(""+a.charAt(2));
	IN[11] = parseInt(""+a.charAt(3));

	IN[12] = parseInt(""+a.charAt(4));
	IN[13] = parseInt(""+a.charAt(5));

	IN[14] = parseInt(""+a.charAt(6));
	IN[15] = parseInt(""+a.charAt(7));



	String res = "";

	for(int er = 0;er<m.k[LAYERS.length-1].length;er++){
		if(m.k[LAYERS.length-1][er].val>=0.0){
			res += "1";
		}else{
			res += "0";

		}
	}


	result[i] = unbinary(res);



	smoothing[i] += (result[i]-smoothing[i])/2.0;

	stroke(255,0,0);
	rect(i,tarvals[i],2,2);

	
	 res = ""+nf(parseInt(binary(tarvals[i])),8);

	if(learning){

		for(int b = 0;b<LAYERS[LAYERS.length-1];b++){

			teach(parseInt(""+res.charAt(b)),1,TEACHSPEED);

		}
		//m.act();

	}

	m.act();


	//}


	//m.act();
	//interact();



	for( i = 0;i<result.length;i++){
		stroke(0);
		line(i,smoothing[i],i,smoothing[i]+1);

	}

	illustrate(10,10);

}

void mousePressed(){

	tarvals[0] = 128;//random(0,100)*0.01;
	for(int i = 1 ;i<tarvals.length;i++){
		tarvals[i] = tarvals[i-1]+(int)random(-3,3);
		tarvals[i] = constrain(tarvals[i],1,255);
		//smoothing[i] = 0;
	}


}

void keyPressed(){

	if(key == ' '){
		learning = !learning;
		println("learning: "+learning);

	}else if(key == 'w'){
		for(int i = 0;i<LAYERS.length;i++){

			for(int l = 0;l<LAYERS[i];l++){
				println(m.k[i][l].w[0]);
			}
		}
	}
}

void interact(){
	mapping();
}

void mapping(){

	float spmin = 0.0;

	float spmax = 1;

	float tmin = 0;
	float tmax = 1;

	SPEED = map(mouseX,0,width,spmin,spmax);
	TEACHSPEED = map(height-mouseY,0,height,tmin,tmax);

	if(mousePressed){
		println("X:"+map(mouseX,0,width,spmin,spmax));

		println("Y:"+map(height-mouseY,0,height,tmin,tmax)+"\n");

	}
}

void illustrate(float x,float y){

	pushMatrix();
	translate(x,y);
	for(int i =0;i<m.k.length;i++){

		for(int t =0;t<m.k[i].length;t++){

			Keuron tmp = m.k[i][t];
			stroke(map(tmp.val,0,1,255,0));
			rect(tmp.x,tmp.y,2,2);

			if(i!=0){
				for(int q = 0;q<m.k[i][t].ins.length;q++){
					Keuron kdo = m.k[tmp.layer-1][tmp.ins[q]];
					stroke(0,5);
					line(tmp.x,tmp.y,kdo.x,kdo.y);
				}
			}
		}
	}
	popMatrix();

}

void teach(float target,float top,float rate){

	target = norm(target,0,top);

	Keuron temp;

	for(int i = LAYERS.length-1;i>0;i--){
		for(int t = 0;t<LAYERS[i];t++){


			temp = m.k[i][t];

			for(int q = 0;q<temp.w.length;q++){
				//m.k[i-1][q].val -= (target-m.k[i-1][q].val)*(rate/m.k[i-1].length);
				//m.k[i-1][t].w[q] += TEACHSPEED*((derivative(map(m.k[i-1][q].val-target,-1,1,0,1),1,SLOPE))-m.k[i-1][q].val);
				temp.w[q] += ((derivative(map(m.k[i-1][temp.ins[q]].val-target,-1,1,0,1),1,SLOPE))-temp.w[q])/TEACHSPEED;
			}

			//m.k[i-1][closest].val += (1.0-m.k[i-1][closest].val)*rate;


		}
	}



}



// toxi's

public float sigmoid(float x, float normV, float sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0f / (1.0f + (float)Math.exp(-x));
}


public double sigmoid(double x, double normV, double sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0 / (1.0 + Math.exp(-x));
}

// kof mod

float sigmoid2(float x, float norm, float slope) {
	x = (x / norm * 2 - 1) * 5 * slope;
	return (float) (1.0/( 1.0 + Math.pow( Math.E ,(-1.0 * x ))));
}


float derivative(float input,float norm,float slope){

	return(float)(1.0-(sigmoid2(input,norm,slope)*(1.0-sigmoid2(input,norm,slope)))*4.0);
}
//BPN taken from
//<http://www.patol.com/java/NN/index.html>
//
//	3 Layer Back Propagation Neural Network Class (BPN.class)
//
//	Author: Patocchi L.(patol@info.isbiel.ch, lorenz@cerfim.ch)
//	Date:		21st Mai 1996
//	
//	This class simulates a 3 layered neural network providing learning
//	functions and in future also disk IOs 
//
public class BPN {
  static final double	FIRE =			0.999;
  static final double 	NEUTRAL =		0.0;
  static final double 	DOWN =			-0.999;	
  static final double 	INIT =			-1.0;
  static final double	DELTA =			0.0;
  static final double	OUTPUT =		1.0;
  double instantError;
  double totalError;
  double absoluteError;
  double inpA[];          // activations
  double hidA[];          // activations
  double hidN[];          // sum of products
  double hidD[];          // output error
  double hidW[][];        // connection weights
  double outA[];          // activations
  double outN[];          // sum of products
  double outD[];          // output error
  double oldD[];          // old output error
  double outW[][];        // connection weights
  int Ninp;               // number of neurons on input  layer
  int Nhid;               // number of neurons on hidden layer
  int Nout;               // number of neurons on output layer
  double eida;            // learning rate
  double theta;           // sigmoid thresold
  double elast;           // elastics of sigmoid
  double momentum;	
  BPN(int i, int h, int o, double ei, double th, double el, double mo){		
    Ninp = i;
    Nhid = h;
    Nout = o;	
    this.inpA = new double[i];		
    this.hidW = new double[h][i];
    this.hidA = new double[h];
    this.hidN = new double[h];
    this.hidD = new double[h];		
    this.outW = new double[o][h];
    this.outA = new double[o];
    this.outN = new double[o];
    this.outD = new double[o];
    this.oldD = new double[o];		
    eida 	= ei;
    theta	= th;
    elast	= el;
    momentum = mo;		
    this.init();		
  }
  private double sigmoid( double x){
    // sig = 1.0 - Math.exp(-1.5* x + theta);
    double sig = ( 1.0 / (1.0 + Math.exp(-1.0 * elast * x + theta)) * 2.0 - 1.0);
    return sig; // (sig < -1.0)? (-1.0):(sig> 1.0)? (1.0): sig;
  }
  private double d1sigmoid(double x){
    //double sig = sigmoid(n,x);
    return 2.0 * Math.exp(-1.0 * elast * x -  theta)/(1+Math.exp(-2.0 * elast * x -  theta)); 
  }
  void feedForward(){
    double	sum2;
    for(int i = 0; i < Nhid; i++){
      sum2 = 0.0;
      for(int j = 0; j < Ninp; j++) sum2 += hidW[i][j] * inpA[j];
      hidN[i] = sum2;
      hidA[i] = sigmoid(sum2);
    }		
    for(int i = 0; i < Nout; i++){
      sum2 = 0.0;
      for(int j = 0; j < Nhid; j++) sum2 += outW[i][j] * hidA[j];
      outN[i] = sum2;
    }
  }	
  double computeDelta(int m){
    outD[m] = (outA[m] - sigmoid(outN[m])) * (d1sigmoid(outN[m]) + 0.1);
    for(int i = 0; i < Nhid; i++) outW[m][i] += outD[m] * hidA[i] * eida ;
    return outD[m]; // /(sig1(n,n->outN[m])+0.1);
  }	
  void updateWeights(){
    double	sum2;
    for(int m = 0; m < Nhid; m++){
      sum2 = 0.0;
      for(int i = 0; i < Nout; i++){ 
        sum2 += outD[i] * outW[i][m];
      };
      sum2 *= d1sigmoid(hidN[m]);
      for(int i = 0; i < Ninp; i++) hidW[m][i] += eida * sum2 * inpA[i];
    }
  }
  double frandom(double min, double max){
    return Math.random()*(max - min) + min;
  }
  void propagate(double[] vector) throws ArrayIndexOutOfBoundsException{
    double	sum2;
    if(vector.length != Ninp)
      throw new ArrayIndexOutOfBoundsException("Error: Vector size don't match Network input size !"); 	
    for(int i = 0; i < Ninp; i++) inpA[i] = vector[i];  	
    for(int i = 0; i < Nhid ; i++){
      sum2 = 0.0;
      for(int j = 0; j < Ninp; j++) sum2 += hidW[i][j] * inpA[j];
      hidA[i] = sigmoid(sum2);
    }
    for(int i = 0; i < Nout; i++){
      sum2 = 0.0;
      for(int j = 0; j < Nhid; j++) sum2 += outW[i][j] * hidA[j];
      outA[i] = sigmoid(sum2);
    }	
  }
  void init(){
    for(int i = 0; i < Ninp; i++) inpA[i] = frandom(-1.0,1.0);
    for(int i = 0; i < Nhid;i++){
      hidA[i] = frandom(-1.0,1.0);
      for(int m = 0; m < Ninp; m++) hidW[i][m] = frandom(-1.0,1.0);
    }
    for(int i = 0; i < Nout; i++)
      for(int m = 0; m < Nhid; m++) outW[i][m] = frandom(-1.0,1.0);	
    totalError	= 0.0;
    absoluteError	= 0.0;
  }	
  void trickForlearning(double min, double max){
    int i;
    for(i = 0; i < Ninp; i++) inpA[i] += frandom(min,max);
    inpA[i] = (inpA[i] > FIRE)? FIRE: (inpA[i] < DOWN) ? DOWN : inpA[i];
  }	
  void learnVector(double[] in, double out []) throws ArrayIndexOutOfBoundsException{
    if(in.length != Ninp)
      throw new ArrayIndexOutOfBoundsException("Error: In Vector size don't match Network input size !");
    if(out.length != Nout)
      throw new ArrayIndexOutOfBoundsException("Error: Out Vector size don't match Network output size !");	
    for(int i = 0; i < Ninp; i++) inpA[i] = in[i];
    for(int i = 0; i < Nout; i++) outA[i] = out[i];	
    this.feedForward();	
    totalError		= 0.0;
    absoluteError	= 0.0;		
    for(int j = 0; j < Nout ; j++){
      instantError 	= computeDelta(j);
      totalError 	+= instantError;
      absoluteError	+= Math.abs(instantError);
    }	  
    updateWeights();	
    eida *= momentum;
  }
  public boolean saveNeuro(String path, String name){
    int i,j;
    if(name == null || path == null) return false;
    try{
      File rawfile = new File(path, name);
      try{
        RandomAccessFile file = new RandomAccessFile(rawfile,"rw");
        file.writeUTF("3LNW V1.0");
        file.writeInt(Ninp);
        file.writeInt(Nhid);
        file.writeInt(Nout);
        file.writeDouble(eida);
        file.writeDouble(theta);
        file.writeDouble(elast);
        file.writeDouble(momentum);
        for(i=0;i < Ninp; i++)
          for(j=0;j < Nhid; j++) file.writeDouble(hidW[j][i]);
        for(i=0;i < Nhid; i++)
          for(j=0;j < Nout; j++) file.writeDouble(outW[j][i]);
        file.close();
      }
      catch(IllegalArgumentException iae){/*I'M A GOOD PROGRAMMER*/
        ;
      }
    }	
    catch(IOException ioe){
      return false;
    }
    catch(SecurityException se){
      return false;
    }
    return true;
  }
  public boolean loadNeuro(String path, String name){
    int i,j;
    if(name == null || path == null) return false;
    try{
      File rawfile = new File(path, name);
      try{
        RandomAccessFile file = new RandomAccessFile(rawfile,"r");
        if(file.readUTF().compareTo("3LNW V1.0") != 0){
          file.close();
          return false;
        }
        Ninp = file.readInt();
        Nhid = file.readInt();
        Nout = file.readInt();
        eida = file.readDouble();
        theta = file.readDouble();
        elast = file.readDouble();
        momentum = file.readDouble();
        //this(Ninp, Nhid, Nout, eida, theta, elast, momentum);
        this.inpA = new double[Ninp];
        this.hidW = new double[Nhid][Ninp];
        this.hidA = new double[Nhid];
        this.hidN = new double[Nhid];
        this.hidD = new double[Nhid];
        this.outW = new double[Nout][Nhid];
        this.outA = new double[Nout];
        this.outN = new double[Nout];
        this.outD = new double[Nout];
        this.oldD = new double[Nout];
        for(i=0;i < Ninp; i++)
          for(j=0;j < Nhid; j++) hidW[j][i] = file.readDouble();
        for(i=0;i < Nhid; i++)
          for(j=0;j < Nout; j++) outW[j][i] = file.readDouble();
        file.close();
      }
      catch(IllegalArgumentException iae){/*I'M A GOOD PROGRAMMER*/
        ;
      }
    }
    catch(IOException ioe){
      return false;
    }
    catch(SecurityException se){
      return false;
    }		
    return true;
  }
}
//Gesture recognition using angles between vectors
//Structure guidelines taken from
//<http://www.generation5.org/content/2004/aiTabletOcr.asp>
BPN net;
PFont font;
int pathLength = 20;
int sampleNum = 5;
double [][] outs;
double [][] thetas;
Tracer tracer = new Tracer(pathLength);
Vec2 [] input;
Vec2 [][] sample;
Vec2 [][] miniSample;
Buttons [] button;
int state = 0;
int epochs = 100;
String id = "Press train network";
void setup(){
  size(500,400);
  sample = new Vec2[sampleNum][pathLength];
  miniSample = new Vec2[sampleNum][pathLength];
  thetas = new double[sampleNum][pathLength-1];
  font = loadFont("Kartika-48.vlw");
  textFont(font, 24);
  //load training set
  Vec2 [] temp = loadVec2("data.txt");
  for(int i = 0; i < sampleNum; i++){
    sample[i] = subsetVec2(temp,i*pathLength,pathLength);
    thetas[i] = atan2Vec2(sample[i]);
    shrinkSample(i);
  }
  outs = new double[sampleNum][sampleNum];
  for(int i = 0; i < outs.length; i++)
    for(int j = 0; j < outs[i].length; j++)
      if(i == j) outs[i][j] = 0.99; 
      else outs[i][j] = 0.0;
  //inputs, hidden, outputs, learning, sigmoid threshold, sigmoid elasticity, momentum
  net = new BPN(pathLength-1, (pathLength + sampleNum) / 2, sampleNum, 0.05, 0.5, 0.5, 0.999);
  //buttons
  button = new Buttons[8];
  for(int i = 0; i < 5; i++)
    button[i] = new Buttons(width-200, 40 + i * 20, 200, 20, color(240), "save as training set "+i, null);
  button[5] = new Buttons(width-200, 140, 200, 20, color(240), "save training vectors file", null);
  button[6] = new Buttons(width-200, 160, 200, 20, color(240), "train network", null);
  button[7] = new Buttons(width-200, 180, 200, 20, color(240), "classify drawing", null);
}
void draw(){
  if(!mousePressed)
    background(255);
  tracer.draw();
  drawSamples();
  text(id, 20, height-20);
  for(int i = 0; i < button.length; i++)
    button[i].draw();
}
void mousePressed(){
  int choice = -1;
  for(int i = 0; i < button.length; i++)
    if (button[i].over()) choice = i;
  switch(choice){
  case 0:
  case 1:
  case 2:
  case 3:
  case 4:
    sample[choice] = copyVec2(tracer.vectors);
    thetas[choice] = atan2Vec2(sample[choice]);
    shrinkSample(choice);
    break;
  case 5:
    Vec2 [] stemp = new Vec2[pathLength * sampleNum];
    stemp = sample[0];
    for(int i = 1; i < sample.length; i++)
      stemp = concatVec2(stemp, sample[i]);
    saveVec2("data.txt", stemp);
    println("saved");
    break;
  case 6:
    net = new BPN(pathLength-1, (pathLength + sampleNum) / 2, sampleNum, 0.1, 0.5, 0.5, 0.999);
    trainNet();
    id = "network trained";
    break;
  case 7:
    double [] temp2;
    temp2 = atan2Vec2(tracer.vectors);
    net.propagate(temp2);
    int bestMatch = -1;
    double bestMatchScore = -1.0;
    for(int i = 0; i < net.outA.length; i++){
      print(net.outA[i]+" ");
      if(net.outA[i] > bestMatchScore){
        bestMatch = i;
        bestMatchScore = net.outA[i];
      }
    }
    print(" best match:"+bestMatch+"\n");
    id = "best match:"+bestMatch;
    break;
  default:
    input = new Vec2[1];
    input[0] = new Vec2(mouseX,mouseY);
    point(mouseX,mouseY);
    break;
  }
}
void mouseDragged(){
  Vec2 temp = new Vec2(mouseX,mouseY);
  input = addVec2(input, temp);
  point(mouseX,mouseY);
}
void mouseReleased(){
  if(!over(width-200,40,200,160))
    tracer.initVectors(input);
}
void keyPressed(){
  switch(key){
  case 't':
    double [] temp;
    for(int i = 0; i < sample.length; i++){
      temp = atan2Vec2(sample[i]);
      net.learnVector(temp,outs[i]);
      println("learnt "+i+" error:"+net.absoluteError);
    }
    break;
  }
}
void trainNet(){
  boolean [] picked = new boolean[sampleNum];
  //first pass
  for(int i = 0; i < epochs; i++){
  for(int j = 0; j < sampleNum; j++){
      net.learnVector(thetas[j],outs[j]);
    }
  }
  /*
  //second pass - randomise sets
  for(int i = 0; i < sample.length; i++){
    int k = -1;
    while(true){
      k = int(random(sampleNum));
      if(!picked[k]){
        picked[k] = true;
        break;
      }
    }
    temp = atan2Vec2(sample[k]);
    for(int j = 0; j < learningIterations; j++){
      net.learnVector(temp,outs[k]);
      //println("learnt "+i+" error:"+net.absoluteError);
      if(net.absoluteError <= 0.1) break;
    }
  }
  */
}
void shrinkSample(int num){
  miniSample[num][0] = new Vec2(0,0);
  for(int i = 1; i < miniSample[num].length; i++){
    float x = miniSample[num][i-1].x + cos((float)thetas[num][i-1] * TWO_PI) * 2.0;
    float y = miniSample[num][i-1].y + sin((float)thetas[num][i-1] * TWO_PI) * 2.0;
    miniSample[num][i] = new Vec2(x,y);
  }
}
void drawSamples(){
  for(int i = 0; i < miniSample.length; i++){
    pushMatrix();
    translate(20+i*40,30);
    fill(130);
    text(str(i),0,0);
    if(miniSample[i][0] != null){
      beginShape(LINE_STRIP);
      for(int j = 0; j < miniSample[i].length; j++)
        vertex(miniSample[i][j].x, miniSample[i][j].y);
      endShape();
    }
    popMatrix();
  }
}
class Buttons{
  int x,y,w,h,col;
  String label;
  PImage pic;
  Buttons(int x, int y, int w, int h, int col, String label, PImage pic){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.col = col;
    this.label = label;
    this.pic = pic;
  }
  void draw(){
    stroke(0);
    fill(0);
    int xup,yup;
    if(over()){
      if(mousePressed){
        xup = x-1;
        yup = y-1;
      }
      else{
        xup = x-4;
        yup = y-4;
      }
    }
    else{
      xup = x;
      yup = y;
    }
    rect(x,y,w,h);
    if(pic == null){
      fill(col);
      rect(xup,yup,w,h);
    }
    else{
      image(pic,xup,yup,w,h);
    }
    if (label.length() > 0){
      if (pic == null) fill(0);
      else fill(col);
      text(label,xup+2,yup+18);
    }
  }
  boolean over(){
    if (mouseX <= x+w && mouseX >= x && mouseY <= y+h && mouseY >= y){
      return true;
    }
    else{
      return false;
    }
  }
}
boolean over(int x, int y, int w, int h){
    if (mouseX <= x+w && mouseX >= x && mouseY <= y+h && mouseY >= y){
      return true;
    }
    else{
      return false;
    }
  }
//Line drawing class
class Tracer{
  Vec2 [] vectors;
  Tracer(){
  }
  Tracer(int len){
    vectors = new Vec2[len];
  }
  void initVectors(Vec2 [] input){
    //if the path is too short, double its length and interpolate vectors
    while(input.length < vectors.length){
      Vec2 [] temp = copyVec2(input);
      input = new Vec2[(temp.length*2)-1];
      for(int i = 0; i < temp.length-1; i++){
        input[i*2] = temp[i];
        input[i*2+1] = temp[i].midPoint(temp[i+1]);
      }
      input[input.length-1] = temp[temp.length-1];
    }
    //take points along the input as our path
    if (input.length > vectors.length){
      float step = (float)input.length/vectors.length;
      float j = 0.0;
      for(int i = 0; i < vectors.length; i++){
        vectors[i] = input[(int)j];
        j += step;
      }
    }
  }
  void draw(){
    if(tracer.vectors[0] != null){
      beginShape(LINE_STRIP);
      for(int i = 0; i < vectors.length; i++)
        vertex(vectors[i].x,vectors[i].y);
      endShape();
    }
  }
}
//2D vector class and methods
class Vec2{
  float x,y;
  Vec2(){
    x = -1;
    y = -1;
  }
  Vec2(float x, float y){
    this.x = x;
    this.y = y;
  }
  float arcTan2(Vec2 other){
    float dx = other.x - this.x;
    float dy = other.y - this.y;
    return atan2(dy,dx);
  }
  float dist(Vec2 other){
    float dx = this.x - other.x;
    float dy = this.y - other.y;
    return sqrt(dx*dx + dy*dy);
  }
  Vec2 midPoint(Vec2 other){
  Vec2 temp = new Vec2(lerp(this.x, other.x, 0.5), lerp(this.y, other.y, 0.5));
  return temp;
  }
}
//save and load
void saveVec2(String filename, Vec2 [] data){
  String [] file = new String [data.length];
  for(int i = 0; i < data.length; i++){
  if (data[i] == null) println("bad"); else println ("good");
    file[i] = data[i].x+" "+data[i].y;
  }
  saveStrings(filename, file);
}
Vec2 [] loadVec2(String filename){
  String [] file = loadStrings(filename);
  Vec2 [] data = new Vec2[file.length];
  for(int i = 0; i < file.length; i++){
    String [] temp = split(file[i]);
    data[i] = new Vec2(float(temp[0]),float(temp[1]));
  }
  return data;
}
//array functions
Vec2 [] addVec2(Vec2 [] vectors, Vec2 newVector) {  
  Vec2 [] temp = new Vec2[vectors.length + 1];  
  System.arraycopy(vectors, 0, temp, 0, vectors.length);  
  temp[vectors.length] = newVector;   
  return temp;
}
Vec2 [] concatVec2(Vec2 [] vectors, Vec2 [] addVectors) {  
  Vec2 [] temp = new Vec2[vectors.length + addVectors.length];  
  System.arraycopy(vectors, 0, temp, 0, vectors.length);  
  System.arraycopy(addVectors, 0, temp, vectors.length, addVectors.length);   
  return temp;
}
Vec2 [] subsetVec2(Vec2 [] vectors, int offset, int len) {  
  Vec2 [] temp = new Vec2[len];  
  System.arraycopy(vectors, offset, temp, 0, len);    
  return temp;
}
Vec2 [] copyVec2(Vec2 [] vectors){
  Vec2 [] temp = new Vec2[vectors.length];
    System.arraycopy(vectors, 0, temp, 0, vectors.length);
  return temp;
}
/*
float [] atan2Vec2(Vec2 [] vectors){
    float [] atan2Return = new float[vectors.length-1];
    for(int i = 1; i < vectors.length; i++)
      atan2Return[i-1] = vectors[i-1].arcTan2(vectors[i]);
    return atan2Return;
}
*/
double [] atan2Vec2(Vec2 [] vectors){
    double [] atan2Return = new double[vectors.length-1];
    for(int i = 1; i < vectors.length; i++)
      atan2Return[i-1] = (1.0 / TWO_PI) * (vectors[i-1].arcTan2(vectors[i]));
    return atan2Return;
}

class Mozek{
	Keuron k[][];
	int[] layers = LAYERS;

	Mozek(){

		k = new Keuron[layers.length][0];

		// create keurons
		for(int i = 0;i < layers.length;i++){
			GRAPY+=GRAPSTEP;
			GRAPX=0;



			for(int t = 0;t < layers[i];t++){
				
				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this);
				GRAPX+=GRAPSTEP;
			}

			if(i==0){

				
				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this,0);

				GRAPX+=GRAPSTEP;
				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this,1);
				GRAPX+=GRAPSTEP;

			}



		}

		// fill keurons with connexions
		for(int i = 0;i < layers.length;i++){
			for(int t = 0;t < layers[i];t++){
				fillIns(i,t);
			}
		}

	}

	void act(){
		for(int i = 0;i < layers.length;i++){
			for(int t = 0;t < layers[i];t++){
				k[i][t].act();
			}
		}

	}

	int[] getIns(int lay,int kolik){

		int temp[] = new int[kolik];
		int vse[] = new int[LAYERS[lay]];
		int zbytek[] = new int[0];


		for(int i =0;i<vse.length;i++){
			vse[i] = k[lay][i].id;
		}

		for(int i =0;i<kolik;i++){

			int rand = (int)random(vse.length);
			temp[i] = rand;

			zbytek = new int[0];
			for(int t = 0;t<vse.length;t++){
				if(vse[t]!=rand){
					zbytek = (int[])expand(zbytek,zbytek.length+1);
					zbytek[zbytek.length-1] = vse[t];
				}
			}

			vse = new int[zbytek.length];
			for(int r = 0;r<zbytek.length;r++){
				vse[r] = zbytek[r];
			}

		}

		return temp;

	}

	int[] getIns2(int lay){
		
		int vse[] = new int[k[lay].length];
		for(int i =0;i<vse.length;i++){
			vse[i] = i;
		}
		return vse;

	}

	void fillIns(int l,int n){

		if(l!=0){
			k[l][n].ins = getIns2(l-1);
			k[l][n].initW();
		}
	}

}

class Keuron{

	float x,y;

	float val;
	int id;
	int[] ins;
	float w[];
	boolean active;
	int layer;
	Mozek parent;

	Keuron(int _layer,Mozek _parent){
		id = register;
		register++;
		parent = _parent;

		// prvni / posledni / jine?
		layer = _layer;

		ins = new int[0];
		if(random(101)>50){
		val = 1.0;
		}else{
		val = 0.0;
		}
		active = true;

		x = GRAPX;
		y = GRAPY;

		if(layer==0){
			val = IN[id];
		}

	}
	
	void initW(){
	w = new float[ins.length];
	for(int i =0;i<w.length;i++){
		w[i] = random(0,100)*0.01;
	
	}
	
	}

	Keuron(int _layer,Mozek _parent,float _val){
		id = register;
		register++;
		parent = _parent;

		// prvni / posledni / jine?
		layer = _layer;

		ins = new int[0];
		val = _val;
			x = GRAPX;
		y = GRAPY;

	}

	void act(){
		refresh();
		
		if(STOCHAIST){
		
		if(layer!=0)
		stochaist(NOISEAMOUNT);
		}

	}

	void refresh(){
		if(layer==LAYERS.length-1){
			float soucet = 0;

			for(int i = 0;i<ins.length;i++){
				//if(parent.k[layer-1][ins[i]].active)
				soucet += parent.k[layer-1][ins[i]].val*w[i];
			}

			val += (sigmoid2(soucet,(float)ins.length,SLOPE) - val)*SPEED;

		}else if(layer>0){
			float soucet = 0;

			for(int i = 0;i<ins.length;i++){
				//if(parent.k[layer-1][ins[i]].active)
				soucet += parent.k[layer-1][ins[i]].val*w[i];
			}

			val += (derivative(soucet,(float)ins.length,SLOPE) - val)*SPEED;
			
		}else{
			val = IN[id];
		}
	}
	
	void stochaist(float kolik){
	
				val += random(-100,100)/kolik;
				val = constrain(val,0.0,1.0);
			
	}

}
// layer set
int[] LAYERS = {2,4,16,32,4,1};

// sigmoidal slope
float SLOPE = 2.0;

//learning constant 0.296875 : 1.0
float SPEED = 1/(64.0*64.0);;
float TEACHSPEED = 1/(64.0*64.0*10);//0.0296875;//0.64;

int TEACHROUNDS = 64;

// noise ?
boolean STOCHAIST = true;
// so how much (1/x) ?
float NOISEAMOUNT = 10000.0;

//inputs
float IN[] = new float[LAYERS[0]];

int CURRENT = 0;

float tarvals[];

// brain class
Mozek m;

// x,y
float GRAPX = 0;
float GRAPY = 0;
float GRAPSTEP = 10;

// global id register
int register = 0;


float result[];
float smoothing[];

PImage in;
int SCALE = 1;

Recorder r;
boolean rec = true;

void setup(){
	in = loadImage("input.png");

	size(SCALE*in.width,SCALE*in.height,OPENGL);
	background(255);
	stroke(0);



	tarvals =new float[in.pixels.length];
	smoothing =new float[in.pixels.length];

	result = new float[in.pixels.length];

	IN[0] = 0.5;
	IN[1] = 0.5;


	tarvals[0] = 0.5;//random(0,100)*0.01;
	for(int i = 1 ;i<tarvals.length;i++){
		tarvals[i] = tarvals[i-1]+random(-100,100)*0.0005;
		tarvals[i] = constrain(tarvals[i],0.1,0.9);
		smoothing[i] = 0;
	}

	m = new Mozek();

	if(rec)
		r = new Recorder("out","brainEye2.mp4");
}

void draw(){
	fill(255,15);
	noStroke();
	rect(0,0,width,height);
	noFill();
	//noStroke(0);

/*
	for(int y =0;y<in.height;y++){

		for(int x =0;x<in.width;x++){
			int i = y*in.width+x;
			IN[0] = norm(x,0,in.width);
			IN[1] = norm(y,0,in.height);

			result[i] = m.k[LAYERS.length-1][0].val;
			smoothing[i] += (result[i]-smoothing[i])/4.0;


			if(frameCount<TEACHROUNDS)
				teach(brightness(in.pixels[i]),255,TEACHSPEED);
			m.act();



		}

	}



	for(int x =0;x<in.width;x++){
		for(int y =0;y<in.height;y++){
			int i = y*in.width+x;
			IN[0] = norm(x,0,in.width);
			IN[1] = norm(y,0,in.height);

			result[i] = m.k[LAYERS.length-1][0].val;
			smoothing[i] += (result[i]-smoothing[i])/4.0;


			if(frameCount<TEACHROUNDS)
				teach(brightness(in.pixels[i]),255,TEACHSPEED);
			m.act();



		}

	}


	for(int y =in.height-1;y>=0;y--){

		for(int x = in.width-1;x>=0;x--){
			int i = y*in.width+x;
			IN[0] = norm(x,0,in.width);
			IN[1] = norm(y,0,in.height);

			result[i] = m.k[LAYERS.length-1][0].val;
			smoothing[i] += (result[i]-smoothing[i])/4.0;

			fill(smoothing[i]*255);
			rect(x*SCALE,y*SCALE,SCALE,SCALE);

			if(frameCount<TEACHROUNDS)
				teach(brightness(in.pixels[i]),255,TEACHSPEED);
			m.act();
		}

	}

*/

	for(int x = in.width-1;x>=0;x--){
		for(int y =in.height-1;y>=0;y--){
			int i = y*in.width+x;
			IN[0] = norm(x,0,in.width);
			IN[1] = norm(y,0,in.height);

			result[i] = m.k[LAYERS.length-1][0].val;
			smoothing[i] += (result[i]-smoothing[i])/2.0;

			fill(smoothing[i]*255);
			rect(x*SCALE,y*SCALE,SCALE,SCALE);

			if(frameCount<TEACHROUNDS)
				teach2(brightness(in.pixels[i]),255,TEACHSPEED);
			m.act();
		}
	}

	if(rec)
		r.add();
	//interact();

	//illustrate(10,10);
}

void keyPressed(){

	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}

}

void mousePressed(){
	tarvals[0] = 0.5;//random(0,100)*0.01;
	for(int i = 1 ;i<tarvals.length;i++){
		tarvals[i] = tarvals[i-1]+random(-100,100)*0.0005;
		tarvals[i] = constrain(tarvals[i],0.1,0.9);
	}
}

void interact(){
	mapping();
}

void mapping(){

	float spmin = 0.18;

	float spmax = 0.22;

	float tmin = 0.6;
	float tmax = 0.7;

	SPEED = map(mouseX,0,width,spmin,spmax);
	TEACHSPEED = map(height-mouseY,0,height,tmin,tmax);

	if(mousePressed){
		println("X:"+map(mouseX,0,width,spmin,spmax));

		println("Y:"+map(height-mouseY,0,height,tmin,tmax)+"\n");

	}
}

void illustrate(float x,float y){

	pushMatrix();
	translate(x,y);
	for(int i =0;i<m.k.length;i++){

		for(int t =0;t<m.k[i].length;t++){

			Keuron tmp = m.k[i][t];
			stroke(map(tmp.val,0,1,255,0));
			rect(tmp.x,tmp.y,2,2);

			if(i!=0){
				for(int q = 0;q<m.k[i][t].ins.length;q++){
					Keuron kdo = m.k[tmp.layer-1][tmp.ins[q]];
					stroke(0,15);
					line(tmp.x,tmp.y,kdo.x,kdo.y);
				}
			}
		}
	}
	popMatrix();

}

void teach(float target,float top,float rate){

	target = norm(target,0,top);

	Keuron temp;

	for(int i = LAYERS.length-1;i>0;i--){
		for(int t = 0;t<LAYERS[i];t++){


			temp = m.k[i][t];

			int closest = 0;
			float less = 10.;

			for(int q = 0;q<LAYERS[temp.layer-1];q++){
				if(abs(m.k[i-1][q].val-target)<less){
					less = abs(m.k[i-1][q].val-target);
					closest = q;
				}
				//m.k[i-1][q].val -= (target-m.k[i-1][q].val)*(rate/m.k[i-1].length);
				m.k[i-1][q].val += TEACHSPEED*((derivative(map(m.k[i-1][q].val-target,-1,1,0,1),1,SLOPE))-m.k[i-1][q].val);
			}

			//m.k[i-1][closest].val += (1.0-m.k[i-1][closest].val)*rate;


		}
	}
}


void teach2(float target,float top,float rate){

	target = norm(target,0,top);

	Keuron temp;

	for(int i = LAYERS.length-1;i>0;i--){
		for(int t = 0;t<LAYERS[i];t++){

			temp = m.k[i][t];

			for(int q = 0;q<LAYERS[temp.layer-1];q++){				
				//m.k[i-1][q].val -= (target-m.k[i-1][q].val)*(rate/m.k[i-1].length);
				temp.w[q] += TEACHSPEED * ( abs(m.k[i-1][q].val-target ) - (temp.w[q]) );
			}

			//m.k[i-1][closest].val += (1.0-m.k[i-1][closest].val)*rate;
		}
	}
}



// toxi's

public float sigmoid(float x, float normV, float sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0f / (1.0f + (float)Math.exp(-x));
}


public double sigmoid(double x, double normV, double sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0 / (1.0 + Math.exp(-x));
}

// kof mod

float sigmoid2(float x, float norm, float slope) {
	x = (x / norm * 2 - 1) * 5 * slope;
	return (float) (1.0/( 1.0 + Math.pow( Math.E ,(-1.0 * x ))));
}


float derivative(float input,float norm,float slope){
	input = sigmoid2(input,norm,slope);
	return(float)(1.0-(input*(1.0-input))*4.0);
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

class Mozek{
	Keuron k[][];
	int[] layers = LAYERS;

	Mozek(){

		k = new Keuron[layers.length][0];

		// create keurons
		for(int i = 0;i < layers.length;i++){
			GRAPY+=GRAPSTEP;
			GRAPX=0;



			for(int t = 0;t < layers[i];t++){
				
				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this);
				GRAPX+=GRAPSTEP;
			}

			if(i==0){

				
				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this,0);

				GRAPX+=GRAPSTEP;
				k[i] = (Keuron[])expand(k[i],k[i].length+1);
				k[i][k[i].length-1] = new Keuron(i,this,1);
				GRAPX+=GRAPSTEP;

			}



		}

		// fill keurons with connexions
		for(int i = 0;i < layers.length;i++){
			for(int t = 0;t < layers[i];t++){
				fillIns(i,t);
				
			}
		}

	}

	void act(){
		for(int i = 0;i < layers.length;i++){
			for(int t = 0;t < layers[i];t++){
				k[i][t].act();
			}
		}

	}

	int[] getIns(int lay,int kolik){

		int temp[] = new int[kolik];
		int vse[] = new int[LAYERS[lay]];
		int zbytek[] = new int[0];


		for(int i =0;i<vse.length;i++){
			vse[i] = k[lay][i].id;
		}

		for(int i =0;i<kolik;i++){

			int rand = (int)random(vse.length);
			temp[i] = rand;

			zbytek = new int[0];
			for(int t = 0;t<vse.length;t++){
				if(vse[t]!=rand){
					zbytek = (int[])expand(zbytek,zbytek.length+1);
					zbytek[zbytek.length-1] = vse[t];
				}
			}

			vse = new int[zbytek.length];
			for(int r = 0;r<zbytek.length;r++){
				vse[r] = zbytek[r];
			}

		}

		return temp;

	}

	int[] getIns2(int lay){
		
		int vse[] = new int[k[lay].length];
		for(int i =0;i<vse.length;i++){
			vse[i] = i;
		}
		return vse;

	}

	void fillIns(int l,int n){

		if(l!=0){
			k[l][n].ins = getIns2(l-1);
			k[l][n].initW();
		}
	}

}

class Keuron{

	float x,y;

	float val;
	int id;
	int[] ins;
	float w[];
	boolean active;
	int layer;
	Mozek parent;

	Keuron(int _layer,Mozek _parent){
		id = register;
		register++;
		parent = _parent;

		// prvni / posledni / jine?
		layer = _layer;

		ins = new int[0];
		val = random(0,100)*0.01;
		
		active = true;

		x = GRAPX;
		y = GRAPY;
		
		

		if(layer==0){
			val = IN[id];
		}

	}

	Keuron(int _layer,Mozek _parent,float _val){
		id = register;
		register++;
		parent = _parent;

		// prvni / posledni / jine?
		layer = _layer;

		ins = new int[0];
		val = _val;
		
		x = GRAPX;
		y = GRAPY;

	}
	void initW(){
		w = new float[ins.length];
		for(int i =0;i<w.length;i++){
			w[i] = random(0,100)*0.01;
		}
	
	
	}

	void act(){
		refresh();
		
		if(STOCHAIST){
		
		if(layer!=0)
		stochaist(NOISEAMOUNT);
		}

	}

	void refresh(){
		if(layer!=0){
			float soucet = 0;

			int g = 0;
			for(int i = 0;i<ins.length;i++){
				//if(parent.k[layer-1][ins[i]].active)
				soucet += w[i]*parent.k[layer-1][ins[i]].val;
				g++;
			}

			val += (sigmoid2(soucet,g,SLOPE) - val)*SPEED;

		}else{
			val = IN[id];
		}
	}
	
	void stochaist(float kolik){
	
				val += random(-100,100)/kolik;
				val = constrain(val,0.0,1.0);
			
	}

}
// layer set
int[] LAYERS = {2,16,16,1};

// sigmoidal slope
float SLOPE = 2.0;

//learning constant 0.296875 : 1.0
float SPEED = 0.19;//0.19;
float TEACHSPEED = SPEED/0.296875;//SPEED/0.296875;//0.64;

int TEACHROUNDS = 50;

// noise ?
boolean STOCHAIST = true;
// so how much (1/x) ?
float NOISEAMOUNT = 100000.0;

//inputs
float IN[] = new float[LAYERS[0]];

int CURRENT = 0;

float tarvals[];

// brain class
Mozek m[];

// x,y
float GRAPX = 0;
float GRAPY = 0;
float GRAPSTEP = 10;

// global id register
int register = 0;


float result[];
float smoothing[];

PImage in;
int SCALE = 1;

Recorder r;
boolean rec = true;

void setup(){
	in = loadImage("input.png");

	size(SCALE*in.width,SCALE*in.height,P3D);
	background(255);
	stroke(0);



	tarvals =new float[in.pixels.length];
	smoothing =new float[in.pixels.length];

	result = new float[in.pixels.length];

	IN[0] = 0.5;
	IN[1] = 0.5;


	tarvals[0] = 0.5;//random(0,100)*0.01;
	for(int i = 1 ;i<tarvals.length;i++){
		tarvals[i] = tarvals[i-1]+random(-100,100)*0.0005;
		tarvals[i] = constrain(tarvals[i],0.1,0.9);
		smoothing[i] = 0;
	}

	m = new Mozek[in.width];
	
	for(int i = 0;i<m.length;i++){
		register = 0;
		m[i] = new Mozek();
	}

	if(rec)
		r = new Recorder("out","brainEye2.mp4");

}




void draw(){
	fill(255,15);
	noStroke();
	rect(0,0,width,height);
	noFill();
	//noStroke(0);
/*

	for(int y =0;y<in.height;y++){

		for(int x =0;x<in.width;x++){
			int i = y*in.width+x;
			IN[0] = norm(x,0,in.width);
			IN[1] = norm(y,0,in.height);

			result[i] = m.k[LAYERS.length-1][0].val;
			smoothing[i] += (result[i]-smoothing[i])/4.0;


			if(frameCount<TEACHROUNDS)
				teach(brightness(in.pixels[i]),255,TEACHSPEED);
			m.act();



		}

	}



	for(int x =0;x<in.width;x++){
		for(int y =0;y<in.height;y++){
			int i = y*in.width+x;
			IN[0] = norm(x,0,in.width);
			IN[1] = norm(y,0,in.height);

			result[i] = m.k[LAYERS.length-1][0].val;
			smoothing[i] += (result[i]-smoothing[i])/4.0;


			if(frameCount<TEACHROUNDS)
				teach(brightness(in.pixels[i]),255,TEACHSPEED);
			m.act();



		}

	}


	for(int y =in.height-1;y>=0;y--){

		for(int x = in.width-1;x>=0;x--){
			int i = y*in.width+x;
			IN[0] = norm(x,0,in.width);
			IN[1] = norm(y,0,in.height);

			result[i] = m.k[LAYERS.length-1][0].val;
			smoothing[i] += (result[i]-smoothing[i])/4.0;

			fill(smoothing[i]*255);
			rect(x*SCALE,y*SCALE,SCALE,SCALE);

			if(frameCount<TEACHROUNDS)
				teach(brightness(in.pixels[i]),255,TEACHSPEED);
			m.act();



		}

	}

*/

	for(int x = in.width-1;x>=0;x--){
		
		for(int y =in.height-1;y>=0;y--){
			int i = y*in.width+x;
			IN[0] = norm(x,0,in.width);
			IN[1] = norm(y,0,in.height);

			result[i] = m[x].k[LAYERS.length-1][0].val;
			smoothing[i] += (result[i]-smoothing[i])*1.0;

			fill(smoothing[i]*255);
			rect(x*SCALE,y*SCALE,SCALE,SCALE);

			if(frameCount<TEACHROUNDS)
			teach2(brightness(in.pixels[i]),255,TEACHSPEED,x);
			m[x].act();



		}

	}


	if(rec)
		r.add();
	//interact();

	//illustrate(10,10);

}

void keyPressed(){

	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}

}

void mousePressed(){

	tarvals[0] = 0.5;//random(0,100)*0.01;
	for(int i = 1 ;i<tarvals.length;i++){
		tarvals[i] = tarvals[i-1]+random(-100,100)*0.0005;
		tarvals[i] = constrain(tarvals[i],0.1,0.9);
	}


}

void interact(){
	mapping();
}

void mapping(){

	float spmin = 0.18;

	float spmax = 0.22;

	float tmin = 0.6;
	float tmax = 0.7;

	SPEED = map(mouseX,0,width,spmin,spmax);
	TEACHSPEED = map(height-mouseY,0,height,tmin,tmax);

	if(mousePressed){
		println("X:"+map(mouseX,0,width,spmin,spmax));

		println("Y:"+map(height-mouseY,0,height,tmin,tmax)+"\n");

	}
}

/*
void teach(float target,float top,float rate,int which){

	target = norm(target,0,top);

	Keuron temp;

	for(int i = LAYERS.length-1;i>0;i--){
		for(int t = 0;t<LAYERS[i];t++){


			temp = m[which].k[i][t];

			int closest = 0;
			float less = 10.;

			for(int q = 0;q<LAYERS[temp.layer-1];q++){
				if(abs(m.k[i-1][q].val-target)<less){
					less = abs(m.k[i-1][q].val-target);
					closest = q;
				}
				//m.k[i-1][q].val -= (target-m.k[i-1][q].val)*(rate/m.k[i-1].length);
				m.k[i-1][q].val += TEACHSPEED*((derivative(map(m.k[i-1][q].val-target,-1,1,0,1),1,SLOPE))-m.k[i-1][q].val);
			}

			//m.k[i-1][closest].val += (1.0-m.k[i-1][closest].val)*rate;


		}
	}
}*/


void teach2(float target,float top,float rate,int which){

	target = norm(target,0,top);

	Keuron temp;

	for(int i = LAYERS.length-1;i>0;i--){
		for(int t = 0;t<LAYERS[i];t++){


			temp = m[which].k[i][t];

			for(int q = 0;q<LAYERS[temp.layer-1];q++){
				
				//m.k[i-1][q].val -= (target-m.k[i-1][q].val)*(rate/m.k[i-1].length);
				m[which].k[i][t].w[q] += TEACHSPEED*((derivative(map(m[which].k[i-1][q].val-(target),-1,1,0,1)*255,255,SLOPE))-temp.w[q]);
			}

			//m.k[i-1][closest].val += (1.0-m.k[i-1][closest].val)*rate;


		}
	}
}



// toxi's

public float sigmoid(float x, float normV, float sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0f / (1.0f + (float)Math.exp(-x));
}


public double sigmoid(double x, double normV, double sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0 / (1.0 + Math.exp(-x));
}

// kof mod

float sigmoid2(float x, float norm, float slope) {
	x = (x / norm * 2 - 1) * 5 * slope;
	return (float) (1.0/( 1.0 + Math.pow( Math.E ,(-1.0 * x ))));
}


float derivative(float input,float norm,float slope){

	return(float)(1.0-(sigmoid2(input,norm,slope)*(1.0-sigmoid2(input,norm,slope)))*4.0);
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
//Gesture recognition using angles between vectors
//Structure guidelines taken from
//<http://www.generation5.org/content/2004/aiTabletOcr.asp>
BPN net;
PFont font;
int pathLength = 20;
int sampleNum = 5;
double [][] outs;
double [][] thetas;
Tracer tracer = new Tracer(pathLength);
Vec2 [] input;
Vec2 [][] sample;
Vec2 [][] miniSample;
Buttons [] button;
int state = 0;
int epochs = 100;
String id = "Press train network";
void setup(){
  size(500,400);
  sample = new Vec2[sampleNum][pathLength];
  miniSample = new Vec2[sampleNum][pathLength];
  thetas = new double[sampleNum][pathLength-1];
  font = loadFont("Kartika-48.vlw");
  textFont(font, 24);
  //load training set
  Vec2 [] temp = loadVec2("data.txt");
  for(int i = 0; i < sampleNum; i++){
    sample[i] = subsetVec2(temp,i*pathLength,pathLength);
    thetas[i] = atan2Vec2(sample[i]);
    shrinkSample(i);
  }
  outs = new double[sampleNum][sampleNum];
  for(int i = 0; i < outs.length; i++)
    for(int j = 0; j < outs[i].length; j++)
      if(i == j) outs[i][j] = 0.99; 
      else outs[i][j] = 0.0;
  //inputs, hidden, outputs, learning, sigmoid threshold, sigmoid elasticity, momentum
  net = new BPN(pathLength-1, (pathLength + sampleNum) / 2, sampleNum, 0.05, 0.5, 0.5, 0.999);
  //buttons
  button = new Buttons[8];
  for(int i = 0; i < 5; i++)
    button[i] = new Buttons(width-200, 40 + i * 20, 200, 20, color(240), "save as training set "+i, null);
  button[5] = new Buttons(width-200, 140, 200, 20, color(240), "save training vectors file", null);
  button[6] = new Buttons(width-200, 160, 200, 20, color(240), "train network", null);
  button[7] = new Buttons(width-200, 180, 200, 20, color(240), "classify drawing", null);
}
void draw(){
  if(!mousePressed)
    background(255);
  tracer.draw();
  drawSamples();
  text(id, 20, height-20);
  for(int i = 0; i < button.length; i++)
    button[i].draw();
}
void mousePressed(){
  int choice = -1;
  for(int i = 0; i < button.length; i++)
    if (button[i].over()) choice = i;
  switch(choice){
  case 0:
  case 1:
  case 2:
  case 3:
  case 4:
    sample[choice] = copyVec2(tracer.vectors);
    thetas[choice] = atan2Vec2(sample[choice]);
    shrinkSample(choice);
    break;
  case 5:
    Vec2 [] stemp = new Vec2[pathLength * sampleNum];
    stemp = sample[0];
    for(int i = 1; i < sample.length; i++)
      stemp = concatVec2(stemp, sample[i]);
    saveVec2("data.txt", stemp);
    println("saved");
    break;
  case 6:
    net = new BPN(pathLength-1, (pathLength + sampleNum) / 2, sampleNum, 0.1, 0.5, 0.5, 0.999);
    trainNet();
    id = "network trained";
    break;
  case 7:
    double [] temp2;
    temp2 = atan2Vec2(tracer.vectors);
    net.propagate(temp2);
    int bestMatch = -1;
    double bestMatchScore = -1.0;
    for(int i = 0; i < net.outA.length; i++){
      print(net.outA[i]+" ");
      if(net.outA[i] > bestMatchScore){
        bestMatch = i;
        bestMatchScore = net.outA[i];
      }
    }
    print(" best match:"+bestMatch+"\n");
    id = "best match:"+bestMatch;
    break;
  default:
    input = new Vec2[1];
    input[0] = new Vec2(mouseX,mouseY);
    point(mouseX,mouseY);
    break;
  }
}
void mouseDragged(){
  Vec2 temp = new Vec2(mouseX,mouseY);
  input = addVec2(input, temp);
  point(mouseX,mouseY);
}
void mouseReleased(){
  if(!over(width-200,40,200,160))
    tracer.initVectors(input);
}
void keyPressed(){
  switch(key){
  case 't':
    double [] temp;
    for(int i = 0; i < sample.length; i++){
      temp = atan2Vec2(sample[i]);
      net.learnVector(temp,outs[i]);
      println("learnt "+i+" error:"+net.absoluteError);
    }
    break;
  }
}
void trainNet(){
  boolean [] picked = new boolean[sampleNum];
  //first pass
  for(int i = 0; i < epochs; i++){
  for(int j = 0; j < sampleNum; j++){
      net.learnVector(thetas[j],outs[j]);
    }
  }
  /*
  //second pass - randomise sets
  for(int i = 0; i < sample.length; i++){
    int k = -1;
    while(true){
      k = int(random(sampleNum));
      if(!picked[k]){
        picked[k] = true;
        break;
      }
    }
    temp = atan2Vec2(sample[k]);
    for(int j = 0; j < learningIterations; j++){
      net.learnVector(temp,outs[k]);
      //println("learnt "+i+" error:"+net.absoluteError);
      if(net.absoluteError <= 0.1) break;
    }
  }
  */
}
void shrinkSample(int num){
  miniSample[num][0] = new Vec2(0,0);
  for(int i = 1; i < miniSample[num].length; i++){
    float x = miniSample[num][i-1].x + cos((float)thetas[num][i-1] * TWO_PI) * 2.0;
    float y = miniSample[num][i-1].y + sin((float)thetas[num][i-1] * TWO_PI) * 2.0;
    miniSample[num][i] = new Vec2(x,y);
  }
}
void drawSamples(){
  for(int i = 0; i < miniSample.length; i++){
    pushMatrix();
    translate(20+i*40,30);
    fill(130);
    text(str(i),0,0);
    if(miniSample[i][0] != null){
      beginShape(LINE_STRIP);
      for(int j = 0; j < miniSample[i].length; j++)
        vertex(miniSample[i][j].x, miniSample[i][j].y);
      endShape();
    }
    popMatrix();
  }
}
void setup(){


	size(1680,1050,OPENGL);

	background(0);

	loadPixels();

	for(int x = 0;x<width;x++){

		for(int y = 0;y<width;y++){
			stroke(random(255));
			line(x,y,x+1,y);

		}
	}


}



/**noise gen
*/

Recorder r;
boolean rec = true;
int cntr = 0;

void setup(){

	size(720,576,OPENGL);
	background(0);
	loadPixels();
	noFill();
	noSmooth();

	r = new Recorder("out","noise.mp4");

}


void draw(){

	for(int x = 160;x<560;x+=1){

		for(int y = 88;y<488;y+=1){
			stroke(random(255));
			line(x,y,x+1,y);
		}
	}
	
	if(frameCount%25==0){
		cntr++;
		println(cntr);
		}

	if(rec){
		r.add();
	}
}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

import oscP5.*;
import netP5.*;

class OscSender{

	OscP5 oscP5;
	NetAddress myRemoteLocation;
	String address;
	int port;
	
	OscSender(String _address,int _port){
		
		address = _address;
		port = _port;
		
		oscP5 = new OscP5(this,port);
		myRemoteLocation = new NetAddress(address,port);
		
		/* start oscP5, listening for incoming messages at port 12000 */


		/* myRemoteLocation is a NetAddress. a NetAddress takes 2 parameters,
		 * an ip address and a port number. myRemoteLocation is used as parameter in
		 * oscP5.send() when sending osc packets to another computer, device, 
		 * application. usage see below. for testing purposes the listening port
		 * and the port of the remote location address are the same, hence you will
		 * send messages back to this sketch.
		 */
	}

	void send(String header, float what){


		OscMessage myMessage = new OscMessage(header);

		//myMessage.add(123); /* add an int to the osc message */
		myMessage.add(what); /* add a float to the osc message */
		//myMessage.add("some text"); /* add a string to the osc message */
		//myMessage.add(new byte[] {0x00, 0x01, 0x10, 0x20}); /* add a byte blob to the osc message */
		//myMessage.add(new int[] {1,2,3,4}); /* add an int array to the osc message */

		/* send the message */
		oscP5.send(myMessage, myRemoteLocation);
	}
	
void send(String header, float[] what){


		OscMessage myMessage = new OscMessage(header);

		//myMessage.add(123); /* add an int to the osc message */
		for(int i =0;i<what.length;i++)
		myMessage.add(what[i]); /* add a float to the osc message */
		//myMessage.add("some text"); /* add a string to the osc message */
		//myMessage.add(new byte[] {0x00, 0x01, 0x10, 0x20}); /* add a byte blob to the osc message */
		//myMessage.add(new int[] {1,2,3,4}); /* add an int array to the osc message */

		/* send the message */
		oscP5.send(myMessage, myRemoteLocation);
	}
	
	void send(String header, int[] what){


		OscMessage myMessage = new OscMessage(header);

		//myMessage.add(123); /* add an int to the osc message */
		for(int i =0;i<what.length;i++)
		myMessage.add(what[i]); /* add a float to the osc message */
		//myMessage.add("some text"); /* add a string to the osc message */
		//myMessage.add(new byte[] {0x00, 0x01, 0x10, 0x20}); /* add a byte blob to the osc message */
		//myMessage.add(new int[] {1,2,3,4}); /* add an int array to the osc message */

		/* send the message */
		oscP5.send(myMessage, myRemoteLocation);
	}


	/*
	void oscEvent(OscMessage theOscMessage) {
		
		print("### received an osc message.");
		print(" addrpattern: "+theOscMessage.addrPattern());
		println(" typetag: "+theOscMessage.typetag());
	} incoming osc message are forwarded to the oscEvent method. */


}



OscSender s;

float x,y,vel;

void setup() {
	size(320,240,P2D);
	frameRate(30);
	s = new OscSender("127.0.0.1",12000);

}



                                                                           
void draw() {
	background(0);
	x = map(mouseX,0,width,220,240);
	y = map(mouseY,0,height,10,25);
	
	
	stroke(255,100);
	line(mouseX,0,mouseX,height);
	line(0,mouseY,width,mouseY);
	
	float[] tst = {x,y};
	s.send("/test", tst);
}


import ddf.minim.*;


Minim minim;
AudioPlayer sam[];
String files[] = {"understandingRepeating.mp3","clock.mp3","clockSmall.mp3","porcelan.mp3"};



void setup(){


	size(320,240,OPENGL);

	background(0);
	frameRate(25);

	sam = new AudioPlayer[files.length];
	minim = new Minim(this);

	for(int i =0;i<sam.length;i++){
		sam[i] = minim.loadFile(files[i], 2048);

	}

	syncstart();
}

void syncstart(){

	for(int i =0;i<sam.length;i++)
		sam[i].loop();

}

void draw(){
	background(0);

}

void stop(){


	// always close Minim audio classes when you are done with them
	for(int i =0;i<sam.length;i++)
		sam[i].close();
	// always stop Minim before exiting.
	minim.stop();

	super.stop();


}



import promidi.*;
import codeanticode.gsvideo.*;

import ddf.minim.*;
 
Minim minim;
AudioPlayer sam[];
String files[] = {"understandingRepeating.mp3","clock.mp3","clockSmall.mp3","porcelan.mp3"};


MidiIO midiIO;
MidiOut midiOut;
Note note;

int notes[] = {30,30,34,36,39,90,94,97};
//{0,32,37,43,51,64,85,127};//new int[0];//{0, 8, 16, , 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 30, 20};//new int[0];
char ch[] = {'a','s','d','f','g','h','j','k','l',';','z','x','c','v','b','n','m',',','.','/'};
ImgPlr one;
int lastPlayed = 0;

GSCapture cam;
int step = 32;

boolean doublesize = true;
boolean bw = true;

boolean auto = true;
boolean helper =true;

PImage msk;

/*

 midiOut.sendController(

      new promidi.Controller(myNumber,int(xPos/6)+2)

    );
 midiOut.sendProgramChange(

        new ProgramChange(myNumber)

      );

*/

void setup(){


	size(480,480,OPENGL);
 
	background(0);
	frameRate(25);
	noSmooth();

	//smooth();
	/*
	int g = 0;
	for(int i = width/2;i<width;i+=step){
			notes = (int[])expand(notes,notes.length+1);
			notes[notes.length-1] = constrain(g*8,0,127);//(int)map(i,width/2,width,20,100);
			print(notes[notes.length-1]+", ");
			g++;
}
	println("");
	println("created "+g+" of senzors");
	*/
	msk = loadImage("mask.png");
	
	
	midiIO = MidiIO.getInstance(this);

	midiOut = midiIO.getMidiOut(0,64);

	if(doublesize){
		cam = new GSCapture(this,320,240);
	}else{
		cam = new GSCapture(this,640,480);

	}

	//print a list with all available devices

	midiIO.printDevices();


	sam = new AudioPlayer[files.length];
	minim = new Minim(this);

	for(int i =0;i<sam.length;i++){
		sam[i] = minim.loadFile(files[i], 2048);

	}

	syncstart();
 




	one = new ImgPlr(loadImage("title.png"));

	noStroke();
	rectMode(CENTER);

}


void syncstart(){

	for(int i =0;i<sam.length;i++)
		sam[i].loop();

}

void draw(){


	background(255);
	noFill();
	stroke(0);
	

	one.act();

	image(msk,-1,-1,width+2,height+2);
	
	noFill();
	stroke(0);
	
	if(helper)
		for(int i =width/2 ;i<width*2;i+=step*2){
			ellipse(width/2,height/2,i-width/2,i-width/2);
		
		}
}

void stop(){


	// always close Minim audio classes when you are done with them
	for(int i =0;i<sam.length;i++)
		sam[i].close();
	// always stop Minim before exiting.
	minim.stop();

	super.stop();


}



void keyPressed(){

	if(key=='q'){
		try{
			exit();
		}catch(NullPointerException e){
			println("buckEnd!");
		}
	}else if(key==' '){

		one.refresh();


	}else if(keyCode==UP){
		one.speed+=0.1;
		println(one.speed);
	}else if(keyCode==DOWN){
		one.speed-=0.1;
		println(one.speed);
	}else if(key== ' '){
		one.refresh();
	}else if(key==ch[0]){
		one.playNote(0);	
	}else if(key==ch[1]){
		one.playNote(1);	
	}else if(key==ch[2]){
		one.playNote(2);	
	}else if(key==ch[3]){
		one.playNote(3);	
	}else if(key==ch[4]){
		one.playNote(4);	
	}else if(key==ch[5]){
		one.playNote(5);	
	}else if(key==ch[6]){
		one.playNote(6);	
	}else if(key==ch[7]){
		one.playNote(7);	
	}else if(key==ch[8]){
		one.playNote(8);	
	}else if(key==ch[9]){
		one.playNote(9);	
	}else if(key==ch[10]){
		one.playNote(10);	
	}else if(key==ch[11]){
		one.playNote(11);	
	}else if(key==ch[12]){
		one.playNote(12);	
	}else if(key==ch[13]){
		one.playNote(13);	
	}else if(key==ch[14]){
		one.playNote(14);	
	}else if(key==ch[15]){
		one.playNote(15);	
	}else if(key==ch[16]){
		one.playNote(16);	
	}else if(key==ch[17]){
		one.playNote(17);	
	}else if(key==ch[18]){
		one.playNote(18);	
	}else if(key==ch[19]){
		one.playNote(19);	
	}else if(keyCode==LEFT){
		
		notes[lastPlayed] --;
		one.rebuild();
		println(notes[lastPlayed]);
	}else if(keyCode==RIGHT){
		notes[lastPlayed] ++;
		one.rebuild();
		println(notes[lastPlayed]);
	}
	

	one.speed=constrain(one.speed,-12,12);
}





class ImgPlr{

	PImage store;
	float rot = 0;
	float speed = 0.3;

	Note[] note = new Note[0];
	int mem[] = new int[0];
	int mem2[] = new int[0];

	int waits[] = new int[0];
	boolean ons[] = new boolean[0];

	int w = 3;
	float tresh = 6;


	ImgPlr(PImage _src){
		store = _src;

		rebuild();

	}
	
	void rebuild(){
	
	int g = 0;
		note = new Note[0];
		mem = new int[0];
		mem2 = new int[0];
		waits = new int[0];
		ons = new boolean[0];
		
		for(int i = width/2;i<width;i+=step){

			note = (Note[])expand(note,note.length+1);
			note[note.length-1] = new Note(notes[g],100,1000);

			mem = (int[])expand(mem,mem.length+1);
			mem[mem.length-1] = 0;

			mem2 = (int[])expand(mem2,mem2.length+1);
			mem2[mem2.length-1] = 0;

			waits = (int[])expand(waits,waits.length+1);
			waits[waits.length-1] = w;

			ons = (boolean[])expand(ons,ons.length+1);
			ons[ons.length-1] = true;


			g++;
		}
		
	}

	void act(){
		rot+=speed;



		pushMatrix();
		translate(width/2,height/2);
		rotate(radians(rot));

		if(doublesize){
			image(store,-store.width,-store.height,store.width*2,store.height*2);

		}else{
			image(store,-store.width/2,-store.height/2);


		}
		popMatrix();

		int g = 0;

		for(int i = width/2;i<width;i+=step){
			mem[g] = (int)brightness(get(i,height/2));
			
			if(ons[g]){
			fill(#FF0000);
			}else{
			fill(0);
			}
			rect(i,height/2,4,4);


			if((mem[g])<(mem2[g]-tresh-map(i,width/2,width,0,tresh*PI))){
				if(rot>2)
					if(!ons[g]){
						playNote( g ); //notes[g] , (int)constrain((abs(mem2[g]-mem[g])-tresh)*300,5,1000)
						ons[g] = true;
						waits[g] = w;
					}
			}

			mem2[g] = mem[g];



			if(waits[g]<=0){
				ons[g] = false;
			}else{
				waits[g]--;
			}
			
			g++;
		}

		if(auto)
		if(rot>360){
			rot=0;
			refresh();
		}

	}

	void refresh(){
		if (cam.available() == true) {
			try{
				cam.read();
				store=cam;
				
				if(bw)store.filter(GRAY);
				//cam.resize(0,320);
				
				//for(int i =0;i<ons.length;i++){
				//	ons[i] = true;
					//waits[i] = w;
				//
				//}


			}catch(java.lang.NullPointerException e){
				println("weird error! @ "+frameCount);
			}
		}

		int g = 0;

	}

	void playNote(int id){

		//Note tmp = ;
		midiOut.sendNote( note[id] );
		lastPlayed = id;

	}



}





int ID;
float X,Y;
float STEP = 10;


Ci c[] = new Ci[300];
Signal s;

void setup(){
	size(300,300,OPENGL);
	background(0);


	for(int i =0;i<c.length;i++)
		c[i] = new Ci();
	stroke(255);

	
	s = new Signal();
}


void draw(){

	background(0);

	for(int i =0;i<c.length;i++)
		c[i].display();

	s.display();

}

void mousePressed(){

	s.nextStep();
}

class Signal{

	int pos;
	int level = 0;

	Signal(){

		pos = (int)random(width/STEP);

	}

	void nextStep(){

		level+=1;
		pos = (int)random(width/STEP);
		println(pos+"::"+level+"::"+level*(int)(width/STEP)+pos);

	}

	void display(){

		//noStroke();
		pushStyle();
		fill(255,0,0);
		rect(c[level*(int)(width/STEP)+pos].x,c[level*(int)(width/STEP)+pos].y,2,2);
		popStyle();
	}



}

class Ci{

	float decision = 0.5;
	int nexts[] = new int[2];
	boolean deciding = false;
	float x,y;


	Ci(){
		int id = ID;
		ID++;

		x=X;
		X+=STEP;
		y=Y;

		if(X>=width){
			Y+=STEP;
			X=0;
		}

		nexts[0] = id+(int)(width/STEP);
		nexts[1] = id+(int)(width/STEP)+1;
		decision = random(1000)*0.001;

	}

	void display(){
		if(deciding){
			fill(255);
		}else{
			noFill();
		}
		rect(x,y,2,2);
	}


	boolean decide(){
		if(decision >0.5){
			return true;
		}else{
			return false;
		}

	}



}

float [][] matice;
Determinant d[];

void setup(){
	size(200,200,OPENGL);
	background(0);

	matice = new float[width][height];

	for(int y = 0;y<height;y++){
		for(int x = 0;x<width;x++){
			matice[x][y] = random(1000)*0.001;

		}
	}
	
	noSmooth();

	d = new Determinant[width];

	for(int i =0;i<d.length;i++)
		d[i] = new Determinant(i);


}


void draw(){
	fill(0,10);
	rect(0,0,width,height);
	
	
	for(int c = 0;c<height;c++)
		for(int i =0;i<d.length;i++){
		d[i].display();
		d[i].nextStep();
	}


}

void redistribute(){
for(int y = 0;y<height;y++){
		for(int x = 0;x<width;x++){
			matice[x][y] += random(-100,100)*0.01;
			matice[x][y] = constrain(matice[x][y],0,1);

		}
	}

}

void keyPressed(){

	if(key == ' '){
		//d = null;
		//	d = new Determinant();

	}

}

class Determinant{
	int x,y;
	int id;
	//float mem = 0;
	color c;

	Determinant(int _id){
		id = _id;
		c = color(255);
		reset();
		

	}

	void reset(){
		
		x = id;//(int)random(width);
		y = 0;
		

	}

	void nextStep(){
		/*
		if((matice[x][y])<0.001){
			// matice[(x+1)%(width-1)][y] = 0.09;//random(1000.0)*0.001;
			x-=1;
			
			
		}else if((matice[x][y])>0.999){
			//matice[x][y] = matice[(x+1)%(width-1)][y];
			//matice[(x+width-2)%(width-1)][y] = 0.91;//random(1000.0)*0.001;
			
			x+=1;
			
			
			
		}*/
		x+=(int)(random(-20,20)/18.0);
		
		
		
		if(x<0)x=width-1;
		if(x>width-1)x=0;
		
		
		matice[(x+1)%(width-1)][y]+=random(-100,100)*0.0001;
		matice[(x+width-2)%(width-1)][y]+=random(-100,100)*0.0001;
		matice[x][y]=constrain(matice[x][y],0,1);

		if(y<height-1){
			
				
			y+=1;
			
		}else{
			reset();
			//if(id==0)
				//redistribute();
		}


	}

	void display(){
		stroke(c,10);
		line(x,y,x,y+1);

	}


}
/**
 * oscP5parsing by andreas schlegel
 * example shows how to parse incoming osc messages "by hand".
 * it is recommended to take a look at oscP5plug for an
 * alternative and more convenient way to parse messages.
 * oscP5 website at http://www.sojamo.de/oscP5
 */

import oscP5.*;
import netP5.*;

OscP5 oscP5;
NetAddress myRemoteLocation;

int id;
float x,y,z;

Pt[] a = new Pt[0];

void setup() {
	size(400,400,P3D);
	frameRate(25);
	/* start oscP5, listening for incoming messages at port 12000 */
	oscP5 = new OscP5(this,12000);

	/* myRemoteLocation is a NetAddress. a NetAddress takes 2 parameters,
	 * an ip address and a port number. myRemoteLocation is used as parameter in
	 * oscP5.send() when sending osc packets to another computer, device, 
	 * application. usage see below. for testing purposes the listening port
	 * and the port of the remote location address are the same, hence you will
	 * send messages back to this sketch.
	 */
	//myRemoteLocation = new NetAddress("127.0.0.1",12000);
}

void draw() {
	background(0);

	pushMatrix();
	translate(0,0,-mouseY*1000);
	
	for(int i =0;i<a.length;i++){
	if(a[i]!=null)
		a[i].act();
	}
	popMatrix();
}


void oscEvent(OscMessage theOscMessage) {
	/* check if theOscMessage has the address pattern we are looking for. */
	//println(theOscMessage.typetag());
	x = (float)theOscMessage.get(0).doubleValue();
	y = (float)theOscMessage.get(1).doubleValue();
	z = (float)theOscMessage.get(2).doubleValue();
	id = theOscMessage.get(3).intValue();
	int corp = theOscMessage.get(3).intValue();

	if(a.length>corp){
		a = new Pt[0];
	}

	if(existujeBod(id)){
		a[id].sedCoords(x,y,z);
	}else{
		a = (Pt[])expand(a,a.length+1);
		a[a.length-1] = new Pt(x,y,z,id);
	}
}

boolean existujeBod(int _id){
	boolean answr = false;
	int ids = _id;
	for(int i = 0;i<a.length;i++){
		if(a[i].id==ids){
			ids = a[i].id;
			answr = true;
		}
		
	}
	return answr;
}

class Pt{
	float x,y,z;
	int id;

	Pt(float _x,float _y,float _z,int _id){
		x = _x;
		y = _y;
		z = _z;
		id = _id;
	}

	void sedCoords(float _x,float _y,float _z){
		x=_x;
		y=_y;
		z=_z;
	}

	void act(){
		stroke(255);
		line(x-100,y,z,x+1000,y,z);
		line(x,y-100,z,x,y+100,z);
		line(x,y,z-100,x,y,z+100);
	}

}


float x,y;
float count = 0;
float r = 80.0;

float step = 0.0133;

int len = 5000;

int rozestup = 402;

color c[] = {#ffffff,#ffffFF};

void setup(){
	size(800,400,P3D);
	background(0);


}


void draw(){

	noStroke();
	fill(0,15);
	rect(0,0,width,height);


	step = map(sin(frameCount/3000.0),-1,1,0.25,0.5);
	float speed = 200.01;
	rozestup = (int)map(mouseX,0,width,0,500);

	if(count>6500000)
		count = 0;

	for(int stereo = 0;stereo<=1;stereo++){
		stroke(c[stereo],70);
		for(int i = 0;i<len;i++){

			count += step;
			r = sin(i/speed)*80.0;

			x = width/2.0+cos(count)*r*2.0-(rozestup/2.0)+(rozestup*stereo);
			if(stereo==0){
				y = height/2.0+(sin(count)*r*2.0);
			}else{
				y = height/2.0-(sin(count)*r*2.0);
				//+step*3.333*stereo

			}

			point(x,y);

		}
	}
}
import codeanticode.gsvideo.*;


GSMovieMaker mm;

boolean rec = false;

boolean disp = true;

float x,y;
float count = 0;
float r = 80.0;
float r2 = 80.0;

float step = 0.0133;

int len = 5000;

int rozestup = 350;

color c[] = {#ffffff,#ffffFF};

void setup(){
	size(720,400,P3D);
	background(0);
	
	frameRate(3);

	mm = new GSMovieMaker(this,width,height,"out/out.avi",GSMovieMaker.X264,GSMovieMaker.BEST,25);
	mm.start();
	
	textFont(createFont("Veranda",11));
	textMode(SCREEN);


}


void draw(){

	noStroke();
	fill(0,35);
	rect(0,0,width,height);


	step = map(sin(frameCount/3000.0),-1,1,0.25,0.5);
	float speed = 200.01;
	//rozestup = (int)map(mouseX,0,width,0,500);

	if(count>6500000)
		count = 0;

	if(disp){
		for(int stereo = 0;stereo<=1;stereo++){
			stroke(c[stereo],100);
			for(int i = 0;i<len;i++){

				count += step;
				r = sin(i/speed)*r2;

				x = width/2.0+cos(count)*r*2.0-(rozestup/2.0)+(rozestup*stereo);
				if(stereo==0){
					y = height/2.0+(sin(count)*r*2.0);
				}else{
					y = height/2.0-(sin(count)*r*2.0);
					//+step*3.333*stereo

				}

				point(x,y);

			}
		}
	}else{
		fill(255,30);
		textAlign(CENTER);
		
		text("try to skew until you can see three white crosses",width/2.0,height/2.0+5);
	pushStyle();
	stroke(255);
	strokeWeight(3);
	line(width/2.0-(rozestup/2.0)-10,height/2.0,width/2.0-(rozestup/2.0)+10,height/2.0);
	line(width/2.0-(rozestup/2.0),height/2.0-10,width/2.0-(rozestup/2.0),height/2.0+10);
	
	
	line(width/2.0+(rozestup/2.0)-10,height/2.0,width/2.0+(rozestup/2.0)+10,height/2.0);
	line(width/2.0+(rozestup/2.0),height/2.0-10,width/2.0+(rozestup/2.0),height/2.0+10);

	popStyle();
	
	}
	if(rec){
		loadPixels();
		mm.addFrame(pixels);
	}
}


void keyPressed(){
	if(key == 'q'){

		if(rec){
			mm.finish();
		}
		mm.dispose();
		exit();

	}else if(key == 'a'){
		rec=!rec;

	}else if(key == 'd'){
		disp=!disp;
	}

}

Structure s;
int compose[] = {2,2,2};

void setup(){

	size(200,200);
	background(0);

	s = new Structure(compose);


}

class Structure{

	int id,layer;
	int[] outs;
	float[] w;
	boolean active = true;
	int globid = 0;


	Neuron n[] = new Neuron[0];
	int[] model;

	Structure(int[] _model){
		model = _model;

		for(int i =0;i<model.length;i++){
			for(int q =0;q<model[i];q++){
				n = (Neuron[])expand(n,n.length+1);
				n[n.length-1] = new Neuron(i,this);
			}

		}

	}


	int act(int[] args){
		if(args.length==model[0]){
			for(int i =0;i<args.length;i++){
				n[i].val = args[i];
			}
		}else{
			print("incorrect no. of ins: "+args.length);
		}

	}


}

class Neuron{

	
	float x,y;
	int id,layer;
	int[] ins;
	float[] w;
	float val;
	boolean active = true;
	Structure parent;

	Neuron(int _layer, Structure _parent){
		layer = _layer;
		
		parent = _parent;
		
		id = parent.globid;
		parent.globid++;
		
		if(layer==0){
			// input lay creation
			w = new float[1];
			w[0] = 1.0;


		}else if(layer<parent.model.length-1){
			//hidden lay creation

			ins = new int[parent.model[layer-1]];
			w = new float[ins.length];

			for(int i = 0;i<ins.length;i++){
				ins[i] = n[parent.model[layer-1]].id;
				w[i] = random(-2.0,2.0);
			}


		}else{
			//output lay creation

			ins = new int[parent.model[layer-1]];
			w = new float[ins.length];

			for(int i = 0;i<ins.length;i++){
				ins[i] = i;
				w[i] = random(-2.0,2.0);
			}
		}

		//println("neuron no."+id+" created");


	}
	
	

	void compute(){
		val = 0;
		for(int i =0;i<parent.model[layer-1];i++){
			val += parent.n[ins[i]].val*w[i];
		}

	}
}


// toxi's

public float sigmoid(float x, float normV, float sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0f / (1.0f + (float)Math.exp(-x));
}


public double sigmoid(double x, double normV, double sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0 / (1.0 + Math.exp(-x));
}

// kof mod

float sigmoid2(float x, float norm, float slope) {
	x = (x / norm * 2 - 1) * 5 * slope;
	return (float) (1.0/( 1.0 + Math.pow( Math.E ,(-1.0 * x ))));
}


float derivative(float input,float norm,float slope){

	return(float)(1.0-(sigmoid2(input,norm,slope)*(1.0-sigmoid2(input,norm,slope)))*4.0);
}


int LAYERS[] = {8,8,16,3,16,8,8};
Neuron n[][];

float TEACHSPEED = 255.0*50.0*8.0;
float SPEED = 2.0;

float GRAPY = 0;
float GRAPX = 0;
float GRAPSTEP = 10;

float IN[];

int graph[];
int graph2[];

int register = 0;

int q = 0;

PGraphics gr;

void setup(){
	size(255,255,OPENGL);
	background(0);
	stroke(255);


	//init neurons

	n = new Neuron[LAYERS.length][0];
	IN = new float[LAYERS[0]];

	gr = createGraphics(width,32,JAVA2D);

	for(int i = 0;i < LAYERS.length;i++){

		for(int t = 0;t < LAYERS[i];t++){

			n[i] = (Neuron[])expand(n[i],n[i].length+1);
			n[i][n[i].length-1] = new Neuron(i);
			GRAPX+=GRAPSTEP;
		}

		if(i==0){


			n[i] = (Neuron[])expand(n[i],n[i].length+1);
			n[i][n[i].length-1] = new Neuron(i,0);

			GRAPX+=GRAPSTEP;
			n[i] = (Neuron[])expand(n[i],n[i].length+1);
			n[i][n[i].length-1] = new Neuron(i,1);
			GRAPX+=GRAPSTEP;

		}

		GRAPY+=GRAPSTEP;
		GRAPX=0;

	}

	for(int i = 0;i < LAYERS.length;i++){
		for(int t = 0;t < LAYERS[i];t++){
			fillIns(i,t);
		}
	}




	//graphing
	graph = new int[width];
	graph[0] = 127;

	for(int i =1;i<width;i++){
		graph[i] = graph[i-1]+(int)random(-6,6);
		graph[i] = constrain(graph[i],0,height);

	}

	textFont(createFont("Veranda",9));
	fill(255);
}


//functions


void inputting(){

	String pos = nf(parseInt(binary(q)),8)+"";


	for(int i = 0;i<IN.length;i++){
		int w = parseInt(pos.charAt(i))-48;
		IN[i] = w;


	}



}

void act(){
	for(int i = 0;i < LAYERS.length;i++){
		for(int t = 0;t < LAYERS[i];t++){
			n[i][t].act();
		}
	}

}

void fillIns(int l,int _n){

	if(l!=0){
		n[l][_n].ins = getIns2(l-1);
		n[l][_n].initW();
	}
}

int[] getIns2(int lay){

	int vse[] = new int[n[lay].length];
	for(int i =0;i<vse.length;i++){
		vse[i] = i;
	}
	return vse;

}


void illustrate(float x,float y){

	pushMatrix();
	translate(x,y);
	for(int i =0;i<n.length;i++){

		for(int t =0;t<n[i].length;t++){

			Neuron tmp = n[i][t];
			noFill();
			stroke(tmp.val*255);
			rect(tmp.x,tmp.y,2,2);

			if(i!=0){
				//for(int q = 0;q<n[i][t].ins.length;q++){
				//	Neuron kdo = n[tmp.layer-1][tmp.ins[q]];
				//	stroke(255,50);
				//	line(tmp.x,tmp.y,kdo.x,kdo.y);
				//}
			}
		}
	}
	popMatrix();

}

//////////////////////////

void draw(){

	background(0);

	float y = map(mouseY,0,height,0,2);

	stroke(255);
	if(frameCount%100==0)q++;
	if(q>=width)q=0;
	if(q==0){
		resetGr();
	}

	for(int i =1;i<width;i++){

	}


	line(q,0,q,height);

	inputting();
	act();

	for(int i =0;i<LAYERS[LAYERS.length-1];i++){
		String pos = nf(parseInt(binary(graph[q])),8)+"";
		float w = parseInt(pos.charAt(i))-48;
		backProp(w,1.0,i,1);

	}



	drawGr();
	illustrate(10,10);
	image(gr,0,height-32);

	fill(255);
	text(nf(parseInt(binary(graph[q])),8),q+2,10);
	text(nf(parseInt(binary(q)),8),q+2,20);



	for(int i =1;i<width;i++){

		stroke(255);
		line(i,graph[i],i,graph[i]+1);
	}



}

void backProp(float target,float top,int iid,float rate){
	target = norm(target,0,top);

	Neuron temp = n[LAYERS.length-1][iid];// = n[i][idd];

	for(int p = LAYERS.length-2;p>0;p--){

		int next= 0;
		float topp = 0.0;

		for(int q = 0;q<temp.w.length;q++){
			//m.k[i-1][q].val -= (target-m.k[i-1][q].val)*(rate/m.k[i-1].length);
			//m.k[i-1][t].w[q] += TEACHSPEED*((derivative(map(m.k[i-1][q].val-target,-1,1,0,1),1,SLOPE))-m.k[i-1][q].val);
			if(topp<(derivative(map(n[temp.layer-1][temp.ins[q]].val-temp.val,-1,1,0,width),width,4.0))){
				topp = (derivative(map(n[temp.layer-1][temp.ins[q]].val-temp.val,-1,1,0,width),width,4.0));
				next = q;
			}

			temp.w[q] += ((derivative(map(n[temp.layer-1][temp.ins[q]].val-target,-1,1,0,width),width,4.0))-temp.w[q])/TEACHSPEED;
		}

		temp = n[p][next];
	}

	/*

	for(int i = LAYERS.length-2;i>0;i--){
	for(int t = 0;t<LAYERS[i];t++){


	temp = n[i][t];

	for(int q = 0;q<temp.w.length;q++){
		//m.k[i-1][q].val -= (target-m.k[i-1][q].val)*(rate/m.k[i-1].length);
		//m.k[i-1][t].w[q] += TEACHSPEED*((derivative(map(m.k[i-1][q].val-target,-1,1,0,1),1,SLOPE))-m.k[i-1][q].val);
		temp.w[q] += ((derivative(target-map(n[i-1][temp.ins[q]].val,-1,1,0,1),1.0,4.0))-temp.w[q])/TEACHSPEED;
}

	//m.k[i-1][closest].val += (1.0-m.k[i-1][closest].val)*rate;


}
}*/

}

void drawGr(){
	gr.beginDraw();
	//gr.background(0);

	for(int i =0;i<IN.length;i++){

		if((nf(parseInt(binary(graph[q])),8).charAt(i)+"").equals("1")){
			gr.stroke(#ff0000);

		}else{
			gr.stroke(0);


		}
		gr.line(q,i*2,q,i*2+1);

		if((nf(parseInt(binary(q)),8).charAt(i)+"").equals("1")){
			gr.stroke(#ffcc00);
		}else{
			gr.stroke(0);


		}
		gr.line(q,i*2+16,q,i*2+17);

	}
	gr.endDraw();

}

void resetGr(){
	//	gr.beginDraw();
	//	gr.background(0);
	//	gr.endDraw();
	//gr = createGraphics(width,32,JAVA2D);
}


void mousePressed(){

	for(int i =1;i<width;i++){
		graph[i] = graph[i-1]+(int)random(-4,4);
		graph[i] = constrain(graph[i],0,height);
	}
}

class Neuron{

	float x,y;

	float val;
	int id;
	int[] ins;
	float[] w;
	boolean active;
	int layer;
	//Mozek parent;

	Neuron(int _layer){
		id = register;
		register++;
		//parent = _parent;

		// prvni / posledni / jine?
		layer = _layer;

		ins = new int[0];
		val = 0;//random(0,100)*0.01;
		active = true;

		x = GRAPX;
		y = GRAPY;

		if(layer==0){
			val = IN[id];
		}

	}

	Neuron(int _layer,float _val){
		id = register;
		register++;
		//parent = _parent;

		// prvni / posledni / jine?
		layer = _layer;

		ins = new int[0];
		val = _val;
		x = GRAPX;
		y = GRAPY;

	}

	void initW(){
		w = new float[ins.length];
		for(int i =0;i<w.length;i++){
			w[i] = random(0,100)*0.01;
		}

	}

	void act(){
		//if(!learning)
		refresh();


	}

	void refresh(){
		if(layer>0){
			//if(learning){
			float soucet = 0;

			for(int i = 0;i<ins.length;i++){
				w[i] = constrain(w[i],0,1);
				//if(parent.k[layer-1][ins[i]].active)
				soucet += n[layer-1][ins[i]].val*w[i];
			}


			val += (sigmoid2(soucet,ins.length/2.0,2.0)-val)/SPEED;
			val = constrain(val,0,1);
			//}

		}else{
			val = IN[id];
		}

	}

	void stochaist(float kolik){

		val += random(-100,100)/kolik;
		val = constrain(val,0.0,1.0);

	}

}

// toxi's

public float sigmoid(float x, float normV, float sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0f / (1.0f + (float)Math.exp(-x));
}


public double sigmoid(double x, double normV, double sharpness) {
	x=(x/normV*2-1)*5*sharpness;
	return 1.0 / (1.0 + Math.exp(-x));
}

// kof mod

float sigmoid2(float x, float norm, float slope) {
	x = (x / norm * 2 - 1) * 5 * slope;
	return (float) (1.0/( 1.0 + Math.pow( Math.E ,(-1.0 * x ))));
}


float derivative(float input,float norm,float slope){

	return(float)(1.0-(sigmoid2(input,norm,slope)*(1.0-sigmoid2(input,norm,slope)))*4.0);
}

int GLOBX = 0;
int GLOBID = 0;
int GLOBSTEP = 3;

NP[] neurons;

int W = 16;
int H = 40;

float IN[] = new float[W];

int counter =1;
String tmp = "";
int imgNo = 0;

PGraphics graphing;
float graph[] = new float [480];
float graph2[] = new float [480];

color globcol = #FFCC00;

void setup(){
	size(480,240,OPENGL);
	background(0);


	//imageMode(CENTER);
	neurons = new NP[W*H];


	recycle();

	for(int i = 0 ; i<graph.length ; i++){
		graph[i] = 0;
		graph2[i] = 0;

	}

	for(int metalay = 0;metalay < H;metalay++){
		for(int metamember = 0;metamember < W;metamember++){
			//println("neuron no. "+GLOBID+" created");
			neurons[GLOBID] = new NP(metalay);

		}
	}

	for(int i = 0 ; i<neurons.length ; i++){
		neurons[i].postSet();
	}

	for(int i =0;i<IN.length;i++)
		IN[i] = random(1,1001)*0.001;

	for(int i = 0 ; i<neurons.length ; i++){
		neurons[i].refresh();
		fill(map(neurons[i].val,0,1,0,255));
		neurons[i].disp();

	}

	for(int i = 0 ; i<neurons.length ; i++){
		neurons[i].compute();
	}

	stroke(255);
	noFill();

	noSmooth();
	textFont(createFont("Veranda",9));

}

void recycle(){



	graphing = createGraphics(width,height,P2D);
	//graphing.colorMode(ARGB);
	graphing.beginDraw();
	graphing.noStroke();
	graphing.noSmooth();
	graphing.endDraw();

}

void drawTo(){

	graphing.beginDraw();
	graphing.stroke(0,20);
	graphing.line(counter,0,counter,height);
	graphing.endDraw();

	
	

	graphing.beginDraw();
	graphing.pushMatrix();
	//graphing.translate(0,graph[graph.length-1]-50);
	for(int i =0;i<graph.length;i++){
		graph[i] += (map(unbinary(tmp),0,65536,0,255)-graph[i])/(i*2.0);
		globcol = lerpColor(#ff0000,#00ff00,norm(graph2[i]-graph[i],-4,4));
		graphing.stroke(255,40);
		
		if(i%20==0){
			graphing.line(counter-1,map(graph2[i],255,0,10,height-10),counter,map(graph[i],255,0,10,height-10));
		//
	}
		pushMatrix();
		
		if(i%20==0){
		stroke(255,50);
		}else{
		stroke(255,10);
		
		}
		translate(counter,map(graph[i],255,0,10,height-10));
		rotate(atan2(graph2[i]-graph[i],1));
		line(-20,0,-40,0);
		line(20,0,40,0);
		popMatrix();
	
		graphing.stroke(globcol,20);
		graphing.point(counter,map(graph[i],255,0,10,height-10));

		graph2[i]=graph[i];
	}
	
	graphing.popMatrix();
	graphing.endDraw();

	graphing.beginDraw();

	for(int i =0;i<W;i++){
		if(parseInt(tmp.charAt(i)-48)==1){
			graphing.stroke(#FF0000,100);
		}else{
			graphing.stroke(0,20);


		}
		graphing.line(counter,height-i*2,counter,height-i*2-1);

	}
	graphing.endDraw();


	/*

	for(int i =0;i<graph.length;i++){
		graph[i] += (unbinary(tmp)-graph[i])/(i*2.0);

		graphing[in].beginDraw();
		graphing[in].stroke(255,100);
		if(i%20==0)
			graphing[in].line(counter-1,map(graph2[i],255,0,10,height-10),counter,map(graph[i],255,0,10,height-10));
		//

		graphing[in].stroke(255,10);
		graphing[in].point(counter,map(graph[i],255,0,10,height-10));
		graphing[in].endDraw();
		graph2[i]=graph[i];
}*/
}

void draw(){
	background(0);



	image(graphing,0,0);


	for(int i =0;i<IN.length;i++)
		IN[i] = random(500,1000)*0.001;

	pushMatrix();
	translate(5,5);
	for(int i = 0 ; i<neurons.length ; i++){
		neurons[i].refresh();
		stroke(map(neurons[i].val,0.5,1,0,255));
		neurons[i].disp();

	}
	popMatrix();




	for(int i = 0 ; i<neurons.length ; i++){
		neurons[i].compute();
	}

	tmp = "";

	NP[] last = getLayerMembers(H-1);

	for(int i = 0 ; i<last.length ; i++){
		if(last[i].val>0.5){
			tmp+="1";
		}else{
			tmp+="0";
		}
	}


	drawTo();




	stroke(255);

	counter ++;
	if(counter>width){
		counter=1;
	}



	pushStyle();
	fill(255);
	text(tmp+" = "+unbinary(tmp),330,10);
	popStyle();



}

class NP{

	int x,y;
	int layer,id;
	int ins[] = new int[0];
	float w[] = new float[0];
	float val = 0;
	float nextval;
	float speeds[] = new float[0];

	NP(int _layer){
		layer = _layer;
		id = GLOBID;
		GLOBID++;


		y = GLOBSTEP*layer;


		if(id!=0){
			if(layer==neurons[id-1].layer){
				GLOBX+=GLOBSTEP;
			}else{
				GLOBX=0;
			}
		}
		x = GLOBX;
	}

	void postSet(){
		if(layer>0){
			NP[] tmp = getLayerMembers(layer-1);

			for(int i =0;i<tmp.length;i++){
				ins = (int[])expand(ins,ins.length+1);
				ins[ins.length-1] = tmp[i].id;
				w = (float[])expand(w,w.length+1);
				w[w.length-1] = random(1,1001)*0.001;
				speeds = (float[])expand(speeds,speeds.length+1);
				speeds[speeds.length-1] = random(1.1,width/10.0);

			}
		}
	}

	void sum(){
		float soucet = 0.0;


		for(int i =0;i<ins.length;i++){
			soucet += sigmoidal(neurons[ins[i]].val * w[i],0.4,1.3);
		}

		soucet/=(W+0.0);
		nextval = soucet;
	}

	void refresh(){
		if(layer == 0){
			val = IN[id];
		}else{
			sum();
		}

	}

	void compute(){
		val = nextval;//(nextval-val)/2.0;
		for(int i =0;i<w.length;i++)
			w[i] = 0.5*(sin(frameCount/speeds[i])+1.0);
	}

	void disp(){
		rect(x,y,2,2);
	}

}

void mousePressed(){
	
	//graphing.save("cosi.png");

}

void keyPressed(){
	if(key==' '){
		globcol = color(random(255),random(255),11);
	}

}

NP[] getLayerMembers(int _lay){
	//println("getting members of"+ _lay);
	NP[] temp = new NP[0];

	for(int i = 0;i < neurons.length;i++){
		if(neurons[i].layer==_lay){
			temp = (NP[])expand(temp,temp.length+1);
			temp[temp.length-1] = neurons[i];
		}

	}
	return temp;
}


float sigmoidal(float x, float norm, float slope) {
	x = (x / norm * 2 - 1) * 5 * slope;
	return (float) (1.0/( 1.0 + Math.pow( Math.E ,(-1.0 * x ))));
}


float derivative(float input,float norm,float slope){

	return(float)(1.0-(sigmoidal(input,norm,slope)*(1.0-sigmoidal(input,norm,slope)))*4.0);
}
import com.hardcorepawn.*;
import processing.opengl.*;

SuperPoint p;

void setup()
{
	size(400,400,OPENGL);
	p=new SuperPoint(this);
	for(int i=0;i<100000;i++)
	{
		float ina = random(0.5);
		float x = random(-100,100);
		float y = random(-100,100);
		float z = random(-100,100);

		p.addPoint(x,y,z,1,1,1,0.5 );
	}
}

void draw()
{

	background(0);
	translate(width/2,height/2);
	rotateY(frameCount/300.0);

	pushMatrix();
	p.draw(13);
	popMatrix();
}
import codeanticode.gsvideo.*;

GSMovieMaker mm;

int X, Y;

//Recorder r;

boolean rec = true;

int top = 4;
int numx = 320/top,numy = 240/top;

Cell c[][] = new Cell[numx*top][numy*top];
color col[] = {color(0),color(50),color(120),color(255)};

int shiftx=0,shifty=0;

int scaler = 4;
String filename;

void setup(){
	size(320,240,OPENGL);
	background(0);

	noCursor();

	filename =  "machines/test1_"+c.length+"x"+c[0].length;

	frameRate(25);

	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			c[x][y] = new Cell(x,y);
		}
	}

	//if(rec){
		mm = new GSMovieMaker(this,width,height,"out/out.avi",GSMovieMaker.X264,GSMovieMaker.BEST,25);
		mm.start();
	//}


	//for(int x=0;x<c.length;x++){
	//	c[x][30].state=1;
	//}

	noStroke();


}

void loadState(){
	try{
		String temp[] = loadStrings(filename+".txt");

		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].state = parseInt(temp[y].charAt(x))-48;
			}
		}

	}catch(NullPointerException e){
		println("no such a file, please save before");
	}
	println("machine loaded: "+filename+".txt");
}

void saveState(){

	String data[] = new String[0];

	for(int y=0;y<c[0].length;y++){
		data = (String[])expand(data,data.length+1);
		data[data.length-1] = "";
		for(int x=0;x<c.length;x++){
			data[data.length-1]+=c[x][y].state!=0?"1":"0";
		}
	}

	saveStrings(filename,data);
	println("saved as: "+filename+".txt");


}


void loadStateFromImage(){
	try{
		PImage temp = loadImage(filename+".png");


		if(temp.width==c.length&&temp.height==c[0].length){

			c = new Cell[numx*top][numy*top];

			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y] = new Cell(x,y);
					if((brightness(color(temp.pixels[y*temp.width+x]))) != 0.0){
						c[x][y].state=1;
					}else{
						c[x][y].state=0;
					}
				}
			}

			println("state loaded sucessfully from: "+filename+".bmp");



		}else{
			println("error: stored values does not correpondent to dimensions");

		}

	}catch(NullPointerException e){
		println("error: saved record does not found " +e);
	}


}



void saveStateToImage(){
	PImage temp = createImage(c.length,c[0].length,RGB);


	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			if(c[x][y].state>0){temp.pixels[y*temp.width+x]=color(255);}else{temp.pixels[y*temp.width+x]=color(0);}
		}
	}

	temp.save(filename+".bmp");
	println("state saved as image: "+filename+".bmp");


}

void draw(){

	background(0);

	step(1);


	pushMatrix();
	translate(-shiftx,-shifty);


	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			c[x][y].draw();
		}
	}

	noFill();
	stroke(255);
	rect(-1,-1,1,1);
	rect(c.length*scaler+1,-1,1,1);
	rect(-1,c[0].length*scaler+1,1,1);
	rect(c.length*scaler-1,c[0].length*scaler+1,1,1);
	noStroke();

	popMatrix();



	X = constrain((int)((mouseX/scaler)+shiftx/scaler),0,c.length-1);
	Y = constrain((int)((mouseY/scaler)+shifty/scaler),0,c[0].length-1);

	c[X][Y].sel=true;

	if(mousePressed){
		if(mouseButton==LEFT)
			c[X][Y].state=1;
		if(mouseButton==RIGHT)
			c[X][Y].state=0;
		if(mouseButton==3){
			c[X][Y].state=3;
			mousePressed=false;
		}
	}


	if(rec){
		loadPixels();
		mm.addFrame(pixels);
	}
}

void keyPressed(){
	if(key==' '){
		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].calm();
			}

		}
	}else if(key=='='){
		scaler++;
	}else if(key=='-'){
		scaler--;
	}else if(key =='s'){
		saveState();
	}else if(key =='l'){
		loadState();
	}else if(keyCode==LEFT){
		shiftx-=3;
	}else if(keyCode==RIGHT){
		shiftx+=3;
	}else if(keyCode==UP){
		shifty-=3;
	}else if(keyCode==DOWN){
		shifty+=3;
	}else if(keyCode==DELETE){
		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].state=c[x][y].nextState=0;
			}
		}
	}else if(keyCode==ENTER){
		c[X][Y].state=3;


	}else if(keyCode == 155){
		saveStateToImage();

	}else if(keyCode==36){
		loadStateFromImage();
	}else if(key == 'q'){

		if(rec){
			mm.finish();
		}
		mm.dispose();
		exit();
	}else if(key == 'a'){
		rec=!rec;
	}


	scaler=constrain(scaler,1,top);
	keyPressed=false;
}

void step(int n){
	boolean anim = false;
	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			if(c[x][y].state>1){
				anim=true;
				break;
			}
		}
	}

	if(anim){
		if(frameCount%n==0){
			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y].act();
				}
			}

			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y].update();
				}
			}
		}
	}

}

class Cell{
	//state 0=black, 1=wire, 2= tail, 3=head
	int state = 0;
	int nextState = 0;
	int x,y;
	boolean sel = false;

	Cell(int _x,int _y){
		x=_x;
		y=_y;
	}

	void act(){
		compute();


	}

	void draw(){



		if(state>0){

			noStroke();
			fill(col[state]);
			rect(x*scaler,y*scaler,scaler,scaler);
		}

		if(sel){
			stroke(255);
			fill(col[state]);
			rect(x*scaler,y*scaler,scaler,scaler);
		}
		sel=false;



	}

	void compute(){

		//is wire?
		if(state>0){

			if(state==3){
				nextState = 2;
			}else if(state==2){
				nextState=	1;
			}else if(state==1){
				nextState=1;

				int q = getStates(3);
				if(q==1||q==2){
					nextState=3;
				}
			}

		}else{
			nextState=0;
		}

	}

	void update(){
		state=nextState;
	}

	int getStates(int wh){
		int cnt = 0;

		if(c[(x+c.length-1)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length-1)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length-1)%c.length][(y+c[0].length)%c[0].length].state==wh)cnt++;

		return cnt;

	}

	void calm(){

		if(state>0){
			nextState=1;
			update();
		}

	}
}
import processing.serial.*;
import cc.arduino.*;

Arduino arduino;
int ledPin = 11;

import javax.swing.*;


void init(){
	frame.setLocation(1680,10);
	super.init();

}

void setup(){
	size(200,200);
	//frame.setLocation(50,10);
	
	JFrame f = new JFrame("ciao");
		f.pack();
		f.setSize(100,100);
		f.setLocation(1680,20);
		f.show();
		f.background(0);
		
	
	//println(Arduino.list());
	arduino = new Arduino(this, Arduino.list()[0]); // v2
	// arduino = new Arduino(this, Arduino.list()[0], 57600); // v1
	arduino.pinMode(ledPin, Arduino.OUTPUT);
	frameRate(30);
}

void draw()
{
	
	background(0);
	arduino.analogWrite(ledPin, (int)map(mouseX,0,width,0,255));

}

PImage zdroj;
PImage trace;

void setup(){
	zdroj = loadImage("sample.jpg");
	//zdroj.filter(THRESHOLD,0.4);
	size(zdroj.width,zdroj.height,P2D);

	trace = edgeDetect(zdroj,3.0);




}


void draw(){
	
	image(trace,0,0);


}


PImage edgeDetect(PImage in,float kolik){

	PImage cpy = createImage(in.width,in.height,RGB);
	in.loadPixels();
	
	for(int i = 0;i<in.pixels.length;i++)
		cpy.pixels[i] = in.pixels[i];
	
	PGraphics src = createGraphics(in.width,in.height,P2D);
	
	src.beginDraw();
	
	//in.filter(THRESHOLD,.4);
	//in.filter(INVERT);
	//src.image(in,0,0);

	src.background(255);
	
	
	cpy.filter(THRESHOLD,.25);
	//cpy.filter(BLUR,15.0);
	src.image(cpy,0,0);
	
	
	
	int coordX[] = {-1,0,1,1,1,0,-1,-1}; //,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2
	int coordY[] = {-1,-1,-1,0,1,1,1,0}; //,-2,-2,-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1
	
	float neighs[] = new float[coordX.length];
	float sims[] = new float[coordX.length];

	for(int y =0;y<in.height;y++){
		for(int x =0;x<in.width;x++){

			for(int i =0;i<coordX.length;i++)
				neighs[i] = brightness(in.pixels[((y+in.height+coordX[i])%in.height)*in.width+((x+in.width+coordY[i])%in.width)]);

			for(int i =0;i<neighs.length;i++){
				sims[i] = abs( neighs[(i+1)%(coordX.length)] - neighs[i]);
				if(sims[i]>kolik){
					src.stroke(0,map(sims[i],kolik,30,0,170));
					src.point(x+coordX[i],y+coordY[i]);
				}
			}

		}
	}
	
	
	//src.tint(255,50);
	//in.filter(THRESHOLD,.3);
	src.endDraw();

	PImage out = createImage(src.width,src.height,RGB);
	src.filter(THRESHOLD,0.5);
	
	
	
	src.loadPixels();
	
	for(int i = 0;i<src.pixels.length;i++)
		out.pixels[i] = src.pixels[i];
	
	return out;





}
import codeanticode.gsvideo.*;

GSCapture cam;

GSMovieMaker mm;


boolean rec = true;

PImage zdroj;
PImage trace;

void setup(){
	
	size(640,480);


	cam = new GSCapture(this,640,480);
	background(0);
	
	mm = new GSMovieMaker(this,width,height,"out/out.avi",GSMovieMaker.X264,GSMovieMaker.BEST,25);
		mm.start();

}


void draw(){

	if (cam.available() == true) {
		try{
			cam.read();
		}catch(java.lang.NullPointerException e){
			println("weird error! @ "+frameCount);
		}

		if(cam!=null)
		
			cam.loadPixels();
			
			PImage tmp1 = createImage(cam.width,cam.height,RGB);
			
			for(int i =0;i<cam.pixels.length;i+=1)
			tmp1.pixels[i]=cam.pixels[i];
		
			//tmp1.filter(THRESHOLD,0.999);
			tmp1 = edgeDetect(tmp1,20);
			image(tmp1, 0, 0);
			
			
	}

	if(rec){
		loadPixels();
		mm.addFrame(pixels);
	}


}

void keyPressed(){

if(key == 'q'){

		if(rec){
			mm.finish();
		}
		mm.dispose();
		exit();
	}

}


PImage edgeDetect(PImage in,float kolik){

	PImage cpy = createImage(in.width,in.height,RGB);
	in.loadPixels();

	for(int i = 0;i<in.pixels.length;i++)
		cpy.pixels[i] = in.pixels[i];

	PGraphics src = createGraphics(in.width,in.height,P2D);

	src.beginDraw();

	//in.filter(THRESHOLD,.4);
	//in.filter(INVERT);
	//src.image(in,0,0);

	src.background(255);


	cpy.filter(THRESHOLD,.55);
	//cpy.filter(BLUR,15.0);
	src.image(cpy,0,0);



	int coordX[] = {-1,0,1,1,1,0,-1,-1}; //,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2
	int coordY[] = {-1,-1,-1,0,1,1,1,0}; //,-2,-2,-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1

	float neighs[] = new float[coordX.length];
	float sims[] = new float[coordX.length];

	for(int y =0;y<in.height;y++){
		for(int x =0;x<in.width;x++){

			for(int i =0;i<coordX.length;i++)
				neighs[i] = brightness(in.pixels[((y+in.height+coordX[i])%in.height)*in.width+((x+in.width+coordY[i])%in.width)]);

			for(int i =0;i<neighs.length;i++){
				sims[i] = abs( neighs[(i+1)%(coordX.length)] - neighs[i]);
				if(sims[i]>kolik){
					src.stroke(0,map(sims[i],kolik,30,0,170));
					src.point(x+coordX[i],y+coordY[i]);
				}
			}

		}
	}


	//src.tint(255,50);
	//in.filter(THRESHOLD,.3);
	src.endDraw();

	PImage out = createImage(src.width,src.height,RGB);
	//src.filter(THRESHOLD,0.5);



	src.loadPixels();

	for(int i = 0;i<src.pixels.length;i++)
		out.pixels[i] = src.pixels[i];

	return out;





}

Pnt [][][] pnt = new Pnt[5][30][5];
float siz = 30.0;
float X,Y,Z;
float rspeed = 150.0;
float zoom = 0;
float zoomS = 0;
float highS = 0;
float rotS;

void setup(){
	size(640,400,OPENGL);
	X = Y = Z = 0;


	//textFont(createFont(PFont.list()[0],8));
	//textMode(SCREEN);

	////////////////////////////////////////////////////////////
	addMouseWheelListener(new java.awt.event.MouseWheelListener() {
		                      public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
			                      int notches = evt.getWheelRotation();
			                      if(notches!=0){
				                      zoom+=notches*40;}}});
	////////////////////////////////////////////////////////////

	int g = 0;
	for(int i = 0;i<pnt.length;i++){
		for(int ii = 0;ii<pnt[i].length;ii++){
			for(int iii = 0;iii<pnt[i][ii].length;iii++){
				pnt[i][ii][iii] = new Pnt(g);
				g++;
			}
		}
	}

	stroke(255,60);
	noFill();
}


void draw(){


	background(0);


	zoomS += (zoom-zoomS)/20.0;
	highS += ( (map(mouseY,0,height,-1000,1000) )-highS)/10.0;
	rotS += (map(mouseX,0,width,360,-360)-rotS)/10.0;





	camera(
	        (pnt.length-1)*siz/2.0+cos(rotS/rspeed)*(200+zoomS), (pnt[0].length-1)*siz/2.0 + highS, (pnt[0][0].length-1)*siz/2.0+sin(rotS/rspeed)*(200+zoomS),
	        (pnt.length-1)*siz/2.0, (pnt[0].length-1)*siz/2.0, (pnt[0][0].length-1)*siz/2.0,
	        0, 1, 0);




	//pushMatrix();

	//translate(width/2-(pnt.length-1)*siz/2,height/2-(pnt[0].length-1)*siz/2,-mouseY);


	int g = 0;
	for(int i = 0;i<pnt.length;i++){
		for(int ii = 0;ii<pnt[i].length;ii++){
			for(int iii = 0;iii<pnt[i][ii].length;iii++){
				pnt[i][ii][iii].draw();
				g++;

			}
		}
	}

	

}


class Pnt{
	float w;
	int id;
	float x,y,z;
	float bx,by,bz;

	Pnt(int _id){
		id = _id;
		w = 1.0;// random(100)/100.0;

		bx = x = X;
		by = y = Y;
		bz = z = Z;

		X+=siz;

		if(X>=pnt.length*siz){
			X=0;
			Y+=siz;
		}

		if(Y>=pnt[0].length*siz){
			Y=0;
			Z+=siz;
		}
	}

	void draw(){
		w = (0.5*(sin(frameCount/(id+10.0))+1.0));
		x = bx + (((cos(frameCount/(id+10.0))+1.0)))*100.0;
		z = bz + (((sin(frameCount/(id+10.0))+1.0)))*100.0;
		
		pushMatrix();
		translate(x,y,z);
		line(-5,0,0,5,0,0);
		line(0,-5,0,0,5,0);
		line(0,0,-5,0,0,5);
		box(w*siz);
		popMatrix();
	}
	
	Pnt [] getNeighs(){
		Pnt[] tmp= new Pnt[0];
		
		//int[] matix = new int[26];
		//matix[0] = pnt[];
		
		return tmp;
	
	
	
	}
}
import codeanticode.gsvideo.*;
GSMovieMaker mm;
boolean rec = true;


PImage kriz[] = new PImage[9];
int next = 5,current = 0;

void setup(){


	for(int i =0;i<kriz.length;i++){
		kriz[i] = loadImage(i+"b.png");
	}

	size(kriz[0].width,kriz[0].height,OPENGL);
	frameRate(3);
	/*
	for(int i =0;i<kriz.length;i++){
		PImage temp = loadImage(i+".jpg");
		PGraphics pt = createGraphics(temp.width/3,temp.height/3,P2D);
		pt.beginDraw();
		pt.image(temp,0,0,pt.width,pt.height);
		pt.endDraw();
		
		pt.save(i+"b.png");
}*/
	println("loaded!");
	
	mm = new GSMovieMaker(this,width,height,"out/out.avi",GSMovieMaker.X264,GSMovieMaker.BEST,25);
	mm.start();
}

void draw(){

	image(kriz[current],0,0);

	if(frameCount%next==0){
		current = (int)random(kriz.length);
		next = (int)random(1,25);

	}
	
	if(rec){
		loadPixels();
		mm.addFrame(pixels);
	}

}

void keyPressed(){
	if(key == 'q'){

		if(rec){
			mm.finish();
		}
		mm.dispose();
		exit();
	}
}


import point2line.*;

Car bug;
PGraphics pneus;


void setup(){

	size(640,480,P2D);


	pneus=createGraphics(width,height,P2D);

	pneus.beginDraw();
	pneus.background(#cccccc);
	pneus.endDraw();

	bug = new Car();
	//noSmooth();

}


void draw(){


	background(pneus);

	bug.draw();




}


class Car{


	PImage skin;
	PGraphics model;
	Vect2 loc,vel,acc,setrv,mom,bok;

	float posXm,posYm;
	float mass = 10.0;

	float heading;
	float speed = 0;
	float theta;

	float r;
	float maxforce = 10.0;    // Maximum steering force
	float maxSpeed = 3.0;    // Maximum speed

	float stress1,stress2;
	boolean stressed = false;

	boolean accelerating,breaking,steeringL,steeringR;

	Car(){

		skin = loadImage("bug.png");

		model = createGraphics(skin.width,skin.height,P2D);

		model.loadPixels();
		skin.loadPixels();

		for(int i =0;i<model.pixels.length;i++){
			if(skin.pixels[i]!=-240388)
				model.pixels[i] = skin.pixels[i];
		}


		imageMode(CENTER);

		acc = new Vect2(0,0);
		vel = new Vect2(0,0);
		setrv = new Vect2(0,0);
		bok = new Vect2(0,0);
		mom = new Vect2(0,0);
		loc = new Vect2(width/2,height/2);


	}

	void update() {
		borders();

		posXm = loc.x;
		posYm = loc.y;






		mom = new Vect2((posXm-loc.x-vel.x)/2.0,(posYm-loc.y-vel.y)/2.0);
		//mom.rotate(vel.angle());
		//println(mom.angle());
		//if(mom.angle()<PI){
		bok = new Vect2(0,(mom.magnitude()*heading*pow(vel.magnitude(),1.5)));
		//}else{
		//bok = new Vect2(0,(mom.magnitude()*-heading));

		//}
		bok.rotate(mom.angle());


		vel.add(acc);
		mom.add(bok.scaled(1));
		loc.add(vel);

		setrv = bok;
		//	setrv.rotate(mom.scaled(-mass).angle());






		// Reset accelertion to 0 each cycle
		acc = new Vect2(0,0);
	}



	void draw(){

		stress1 = vel.magnitude();

		if(bok.magnitude()>5){
			stressed = true;
		}else{
			stressed = false;
		}

		update();

		theta = vel.angle() + PI/2;
		
		
		
		vel.rotate(radians(heading*(vel.magnitude()/2.0)* pow(bok.scaled(0.5).magnitude()*mom.magnitude(),0.1) ));
		
		//acc.rotate(radians(theta));
		heading=constrain(heading,-10,10);
		heading+=(0-heading)/(20);
		vel.scale(0.99);

		if(vel.magnitude()>maxSpeed){
			vel.setMagnitude(maxSpeed);
		}

		if(setrv.magnitude()>100.0){
			setrv.setMagnitude(maxSpeed);
		}

		if(breaking){
			stressed = true;
		}

		pushMatrix();
		translate(loc.x,loc.y);
		rotate(theta);
		if(stressed){
			
			doSmyk();
		}
		image(model,0,0);
		popMatrix();

		if(accelerating)doAccelerate();
		if(breaking)doBrake();
		if(steeringL)steerL();
		if(steeringR)steerR();

		//acc.rotateZ(theta);

		stress2 = stress1;
		

		stroke(0);
		line(loc.x,loc.y,loc.x+setrv.x,loc.y+setrv.y);


	}
	void borders() {
		if (loc.x < -r) loc.x = width+r;
		if (loc.y < -r) loc.y = height+r;
		if (loc.x > width+r) loc.x = -r;
		if (loc.y > height+r) loc.y = -r;
	}
	void doAccelerate(){
		Vect2 tmp = new Vect2(0.1,0);
		tmp.rotate(vel.angle());
		acc.add(tmp);

	}

	void doBrake(){
		bug.vel.scale(0.97);
	}

	void steerL(){
		bug.heading+=.13;

	}

	void steerR(){
		bug.heading-=.13;

	}

	void doSmyk(){
		pneus.beginDraw();
		pneus.pushMatrix();
		pneus.translate(loc.x,loc.y);
		pneus.rotate(theta);
		
		pneus.strokeWeight(1.5);
		pneus.stroke(0,20);
		
		pneus.line(-5,-5,-5,-2);
		pneus.line(5,-5,5,-2);
		pneus.line(-5,5,-5,2);
		pneus.line(5,5,5,2);
		
		pneus.popMatrix();
		pneus.endDraw();


	}

}

void keyPressed(){
	if(keyCode==UP){
		bug.accelerating=true;
	}

	if(keyCode==DOWN){
		bug.breaking=true;

	}

	if(keyCode==RIGHT){
		bug.steeringL=true;

	}

	if(keyCode==LEFT){
		bug.steeringR=true;

	}


}


void keyReleased(){
	if(keyCode==UP){
		bug.accelerating=false;
	}

	if(keyCode==DOWN){
		bug.breaking=false;

	}

	if(keyCode==RIGHT){
		bug.steeringL=false;

	}

	if(keyCode==LEFT){
		bug.steeringR=false;

	}


}
import net.sf.fann.swig.*;
import net.sf.fann.*;


import java.io.File;

import net.sf.fann.swig.fann;
import net.sf.fann.swig.fann_activationfunc_enum;
import net.sf.fann.swig.fann_connection;
import net.sf.fann.swig.fann_nettype_enum;
import net.sf.fann.swig.libfann;


XorTest nn;


	public static int CONNECTION_RATE = 1;
	public static float LEARNING_RATE = 0.7f;
	public static int NUM_INPUT = 2;
	public static int NUM_NEURONS_HIDDEN = 4;
	public static int NUM_OUTPUT = 1;

	public static float DESIRED_ERROR = 0.0001f;
	public static int MAX_ITERATIONS = 100000;
	public static int ITERATIONS_BETWEEN_REPORTS = 1000;

void setup(){
	size(300,300);

	nn = new XorTest();



}

class XorTest {	

	//@Test
	public void testXor() {
		NeuralNet ann = new NeuralNet(CONNECTION_RATE, new long[] {NUM_INPUT, NUM_NEURONS_HIDDEN, NUM_OUTPUT});
		ann.setActivationFunctionForOutput(NeuralNet.ActivationFunction.SIGMOID_SYMMETRIC_STEPWISE);
		Training training = new Training(ann);
		training.setLearningRate(LEARNING_RATE);
		training.train("examples/xor.data", MAX_ITERATIONS, ITERATIONS_BETWEEN_REPORTS, DESIRED_ERROR);
		ann.save("java/src/data/xor_float.net");
	}

	//@Test
	public void testXor1() {
		NeuralNet ann = new NeuralNet(false, new long[] {NUM_INPUT, NUM_NEURONS_HIDDEN, NUM_OUTPUT});
		ann.setActivationFunctionForOutput(NeuralNet.ActivationFunction.SIGMOID_SYMMETRIC_STEPWISE);
		Training training = new Training(ann);
		training.setLearningRate(LEARNING_RATE);
		training.train("examples/xor.data", MAX_ITERATIONS, ITERATIONS_BETWEEN_REPORTS, DESIRED_ERROR);
	}

	//@Test
	public void testXor15() {
		NeuralNet ann = new NeuralNet(false, new long[] {NUM_INPUT, NUM_NEURONS_HIDDEN, NUM_OUTPUT});
		ann.setActivationFunctionForOutput(NeuralNet.ActivationFunction.SIGMOID_SYMMETRIC_STEPWISE);
		Training training = new Training(ann);
		training.setLearningRate(LEARNING_RATE);
		TrainingData data = new TrainingData("examples/xor.data");
		training.train(data, MAX_ITERATIONS, ITERATIONS_BETWEEN_REPORTS, DESIRED_ERROR);
	}

	//@Test
	public void testXor2() throws InterruptedException {
		NeuralNet ann = new NeuralNet(true, new long[] {NUM_INPUT, NUM_NEURONS_HIDDEN, NUM_OUTPUT});
		ann.setActivationFunctionForOutput(NeuralNet.ActivationFunction.SIGMOID_SYMMETRIC_STEPWISE);
		Training training = new Training(ann);
		training.setLearningRate(LEARNING_RATE);
		training.train("examples/xor.data", MAX_ITERATIONS, ITERATIONS_BETWEEN_REPORTS, DESIRED_ERROR);

		training.train(new double[] {1, 1}, new double[] {0});
		double[] result = training.test(new double[] {1, 1}, new double[] {0});
		assertEquals(1, result.length);
		assertEquals(-1, result[0], 0.2);
	}

	//@Test
	public void testCallback() {
		NeuralNet ann = new NeuralNet(false, new long[] {NUM_INPUT, NUM_NEURONS_HIDDEN, NUM_OUTPUT});
		ann.setActivationFunctionForOutput(NeuralNet.ActivationFunction.SIGMOID_SYMMETRIC_STEPWISE);
		Training training = new Training(ann);
		training.setLearningRate(LEARNING_RATE);
		training.setCallback(this);
		System.out.println("Starting training");
		training.train("examples/xor.data", MAX_ITERATIONS, 1, DESIRED_ERROR);
		System.out.println("Training ended");
	}

	//@Test
	public void testCallbackAnonymous() {
		NeuralNet ann = new NeuralNet(false, new long[] {NUM_INPUT, NUM_NEURONS_HIDDEN, NUM_OUTPUT});
		ann.setActivationFunctionForOutput(NeuralNet.ActivationFunction.SIGMOID_SYMMETRIC_STEPWISE);
		Training training = new Training(ann);
		training.setLearningRate(LEARNING_RATE);
		training.setCallback(new TrainingReportCallback() {
			                     public void report(Training training, long maxEpochs,
			                                        long epochsBetweenReports, double desiredError, long epochs) {
				                     System.out.println("Report from anonymous: epochs="+epochs);
			                     }
		                     });
		System.out.println("Starting training");
		training.train("examples/xor.data", MAX_ITERATIONS, 1, DESIRED_ERROR);
		System.out.println("Training ended");
	}


	public void report(Training training, long maxEpochs,
	                   long epochsBetweenReports, double desiredError, long epochs) {
		System.out.printf("JavaReport: Epochs=%d. Current error=%f. Bit fail %d\n",
		                  epochs, training.getMSE(), training.getBitFail());
	}

	//@Test
	public void testErrors() {
		try {
			NeuralNet ann = new NeuralNet("bad/file.name");
			fail("Excepted an exception");
		} catch (FannException e) {
			// this is excepted
			assertTrue(e.getMessage().contains("bad/file.name"));
			e.printStackTrace();
		}
	}

	//	@Test
	public void testNullArgument() {
		try {
			libfann.fann_get_bit_fail(null);
			fail("Excepted an exception");
		} catch (RuntimeException e) {
			// this is excepted
			assertTrue(e.getMessage().contains("is null"));
			assertTrue(e instanceof NullPointerException);
		}
	}



}

/* 
 * The following are not available since we are using floating points
 * fann_get_decimal_point
 * fann_get_multiplier
 */
class NeuralNet extends ErrorHandling {
	
	
	/**
	 * Enums: fann_activationfunc_enum
	 * 
	 * The activation functions used for the neurons during training. The activation functions
	 * can either be defined for a group of neurons by <fann_set_activation_function_hidden> and
	 * <fann_set_activation_function_output> or it can be defined for a single neuron by <fann_set_activation_function>.
	 * 
	 * The steepness of an activation function is defined in the same way by
	 * <fann_set_activation_steepness_hidden>, <fann_set_activation_steepness_output> and <fann_set_activation_steepness>.
	 *
	 */
	public enum ActivationFunction {
		  LINEAR, // 0
		  THRESHOLD,
		  THRESHOLD_SYMMETRIC,
		  SIGMOID,
		  SIGMOID_STEPWISE,
		  SIGMOID_SYMMETRIC,
		  SIGMOID_SYMMETRIC_STEPWISE,
		  GAUSSIAN,
		  GAUSSIAN_SYMMETRIC,
		  GAUSSIAN_STEPWISE,
		  ELLIOT,
		  ELLIOT_SYMMETRIC,
		  LINEAR_PIECE,
		  LINEAR_PIECE_SYMMETRIC,
		  SIN_SYMMETRIC,
		  COS_SYMMETRIC,
		  SIN,
		  COS
	};

	
	/* Enum: fann_network_type_enum
	 * 
	 * Definition of network types used by <fann_get_network_type>
	 * 
	 * FANN_NETTYPE_LAYER - Each layer only has connections to the next layer
	 * FANN_NETTYPE_SHORTCUT - Each layer has connections to all following layers
	 *  
     */
	public enum NeuralNetType {
		  LAYER, // 0
		  SHORTCUT
	};
	
	private fann ann;
	private Object userdata;
	
	public NeuralNet(boolean shortcut, long numLayers) {
		if (shortcut) {
			ann = libfann.fann_create_shortcut(numLayers);
		} else {
			ann = libfann.fann_create_standard(numLayers);
		}
		checkError();
	}

	public NeuralNet(boolean shortcut, long[] noNodesInEachLayer) {
		if (shortcut) {
			ann = libfann.fann_create_shortcut_array(noNodesInEachLayer.length, noNodesInEachLayer);
		} else {
			ann = libfann.fann_create_standard_array(noNodesInEachLayer.length, noNodesInEachLayer);
		}
		checkError();
	}

	/**
	 * Creates a standard backpropagation neural network, which is not fully connected.
	 * @param connectionRate The connection rate controls how many connections there will
	 *  be in the network.  If the connection rate is set to 1, the network will be fully
	 *  connected, but if it is set to 0.5 only half of the connections will be set.
	 *  A connection rate of 1 will yield the same result as fann_create_standard
	 * @param numLayers The total number of layers including the input and the output layer.
	 */
	public NeuralNet(float connectionRate, long numLayers) {
		ann = libfann.fann_create_sparse(connectionRate, numLayers);
		checkError();
	}

	/**
	 * Creates a standard backpropagation neural network, which is not fully connected.
	 * @param connectionRate The connection rate controls how many connections there will
	 *  be in the network.  If the connection rate is set to 1, the network will be fully
	 *  connected, but if it is set to 0.5 only half of the connections will be set.
	 *  A connection rate of 1 will yield the same result as fann_create_standard
	 * @param noNodesInEachLayer an array of layer sizes.
	 */
	public NeuralNet(float connectionRate, long[] noNodesInEachLayer) {
		ann = libfann.fann_create_sparse_array(connectionRate, noNodesInEachLayer.length, noNodesInEachLayer);
		checkError();
	}

	
	/**
	 * Create a new Neural Network based on a copy from another Neural Network.
	 * Creates a copy of a fann structure.
	 * Data in the user data fann_set_user_data is not copied, but the user data
	 * pointer is copied.
	 * @param nn the nn to copy
	 */
	public NeuralNet(NeuralNet nn) {
		// TODO: Only in 2.2
//		ann = libfann.fann_copy(nn.ann);
		// for now the only way to copy it, is saving and reloading.
		String tempFilename = "NeuralNet.copy.tmp";
		nn.save(tempFilename);
		load(tempFilename);
		
		// delete the file again
		new File(tempFilename).delete();
		
		userdata = nn.userdata;
		checkError();
	}

	/**
	 * Constructs a backpropagation neural network from a configuration file, 
	 * which have been saved by fann_save.
	 */
	public NeuralNet(String filename) {
		ann = libfann.fann_create_from_file(filename);
		if (ann==null) {
			throw new FannException("Unable to open configuration file for reading: "+filename);
		}
		checkError();
	}
	
	
	/**
	 * Destroys the entire network and properly freeing all the associated memmory.
	 */
	public void destroy() {
		libfann.fann_destroy(ann);
		checkError();
	}
	
	/**
	 * Will run input through the neural network, returning an array of outputs,
	 * the number of which being equal to the number of neurons in the output layer.
	 * @param inputs
	 */
	public double[] run(double[] inputs) {
		double[] result = new double[(int) getNumOutput()];
		libfann.fann_run_wrap(ann, inputs, result, result.length);
		checkError();
		return result;
	}
	
	/***************************************************************************
	 *                              PARAMETERS
	 ***************************************************************************/
	
	/**
	 * Prints all of the parameters and options of the ANN
	 */
	public void printParameters() {
		libfann.fann_print_parameters(ann);
		checkError();
	}
	
	/**
	 * Will print the connections of the ann in a compact matrix, for easy viewing of
	 * the internals of the ann.
	 * 
	 * The output from fann_print_connections on a small (2 2 1) network trained on
	 * the xor problem
	 * 
	 *     Layer / Neuron 012345
	 *         L   1 / N    3 BBa...
	 *         L   1 / N    4 BBA...
	 *         L   1 / N    5 ......
	 *         L   2 / N    6 ...BBA
	 *         L   2 / N    7 ......
	 *         
	 * This network have five real neurons and two bias neurons.  This gives a
	 * total of seven neurons named from 0 to 6.  The connections between these neurons
	 * can be seen in the matrix.  �.� is a place where there is no connection, while a
	 * character tells how strong the connection is on a scale from a-z.  The two real
	 * neurons in the hidden layer (neuron 3 and 4 in layer 1) has connection from the
	 * three neurons in the previous layer as is visible in the first two lines.  The
	 * output neuron (6) has connections form the three neurons in the hidden
	 * layer 3 - 5 as is visible in the fourth line.
	 * 
	 * To simplify the matrix output neurons is not visible as neurons that connections
	 * can come from, and input and bias neurons are not visible as neurons that
	 * connections can go to.
	 */
	public void printConnections() {
		libfann.fann_print_connections(ann);
		checkError();
	}

	/**
	 * @return the number of input neurons.
	 */
	public long getNumInput() {
		long result = libfann.fann_get_num_input(ann);
		checkError();
		return result;
	}
	
	/**
	 * @return the number of output neurons.
	 */
	public long getNumOutput() {
		long result = libfann.fann_get_num_output(ann);
		checkError();
		return result;
	}
	
	/**
	 * @return the total number of neurons in the entire network.  This number does also
	 *  include the bias neurons, so a 2-4-2 network has 2+4+2 +2(bias) = 10 neurons.
	 */
	public long getTotalNeurons() {
		long result = libfann.fann_get_total_neurons(ann);
		checkError();
		return result;
	}

	/**
	 * @return the total number of connections in the entire network.
	 */
	public long getTotalConnections() {
		long result = libfann.fann_get_total_connections(ann);
		checkError();
		return result;
	}

	public long getNumLayers() {
		long result = libfann.fann_get_num_layers(ann);
		checkError();
		return result;
	}
	
	
	public NeuralNetType getNetworkType() {
		fann_nettype_enum x = libfann.fann_get_network_type(ann);
		checkError();
		for(NeuralNetType f : NeuralNetType.values()) {
			if (f.ordinal() == x.ordinal()) {
				return f;
			}
		}
		throw new FannException("Could not find a NeuralNetType with ordinal="+x.ordinal());
	}
	
	public float getConnectionRate() {
		float result = libfann.fann_get_connection_rate(ann);
		checkError();
		return result;
	}
	
	public long[] getLayerArray() {
		long[] numNeurons = new long[(int)getNumLayers()];
		libfann.fann_get_layer_array(ann, numNeurons);
		checkError();
		return numNeurons;
	}
	
	/**
	 * @return the number of bias in each layer in the network.
	 */
	public long[] getBiasArray() {
		long[] numBias = new long[(int)getNumLayers()];
		libfann.fann_get_bias_array(ann, numBias);
		checkError();
		return numBias;
	}

	public fann_connection[] getConnectionArray() {
		fann_connection[] connections = new fann_connection[(int)getTotalConnections()];
		// TODO
		// libfann.fann_get_connection_array(ann, connections);
		checkError();
		return connections;
	}
	
	/**
	 * Set a connection in the network.
	 * Only the weights can be changed.  The connection/weight is ignored if it does 
	 * not already exist in the network.
	 * 
	 * @param fromNeuron starting neuron number
	 * @param toNeuron ending neuron number
	 * @param weight the connection weight
	 */
	public void setWeight(long fromNeuron, long toNeuron, double weight) {
		libfann.fann_set_weight(ann, fromNeuron, toNeuron, weight);
		checkError();
	}
	
	/**
	 * Set connections in the network.
	 * Only the weights can be changed, connections and weights are ignored
	 * if they do not already exist in the network.
	 * 
	 * @param connections the definition of the connections
	 */
	public void setWeightArray(fann_connection[] connections) {
		// TODO:
		//libfann.fann_set_weight_array(ann, connections, (int) connections.length);
		checkError();
	}
	
	/**
	 * Initialize the weights using Widrow + Nguyen�s algorithm.
	 * 
	 * This function behaves similarly to fann_randomize_weights.  It will use
	 * the algorithm developed by Derrick Nguyen and Bernard Widrow to set the 
	 * weights in such a way as to speed up training.  This technique is not always 
	 * successful, and in some cases can be less efficient than a purely random 
	 * initialization.
	 * 
	 * The algorithm requires access to the range of the input data (ie, largest
	 * and smallest input), and therefore accepts a second argument, data, which 
	 * is the training data that will be used to train the network.
	 * 
	 */
	public void weightsInit(TrainingData data) {
		libfann.fann_init_weights(ann, data.getData());
		checkError();
	}
	
	/**
	 * Give each connection a random weight between min_weight and max_weight
	 * From the beginning the weights are random between -0.1 and 0.1.
	 * 
	 * @param minWeight
	 * @param maxWeight
	 */
	public void weightsRandomize(double minWeight, double maxWeight) {
		libfann.fann_randomize_weights(ann, minWeight, maxWeight);
		checkError();
	}
	
	public void setUserData(Object userdata) {
		this.userdata = userdata;
	}
	
	public Object getUserData() {
		return this.userdata;
	}
	
	
	/***************************************************************************
	 *                              FILE
	 ***************************************************************************/
	
	/**
	 * Constructs a backpropagation neural network from a configuration file, 
	 * which have been saved by fann_save.
	 * @param filename The filename
	 */
	public void load(String filename) {
		ann = libfann.fann_create_from_file(filename);
		checkError();
	}
	
	/**
	 * Save the entire network to a configuration file.
	 * The configuration file contains all information about the neural network
	 * and enables fann_create_from_file to create an exact copy of the neural 
	 * network and all of the parameters associated with the neural network.
	 * 
	 * These three parameters (fann_set_callback, fann_set_error_log, fann_set_user_data) 
	 * are NOT saved to the file because they cannot safely be ported to a different 
	 * location.  Also temporary parameters generated during training like fann_get_MSE
	 * is not saved.
	 * 
	 * @param filename The filename
	 */
	public void save(String filename) {
		int err = libfann.fann_save(ann, filename);
		if (err == -1) {
			throw new FannException("Could not save data to the file:"+filename);
		}
		checkError();
	}

	/**
	 * Saves the entire network to a configuration file.  But it is saved in fixed 
	 * point format no matter which format it is currently in.
	 * 
	 * This is usefull for training a network in floating points, and then later 
	 * executing it in fixed point.
	 * 
	 * The function returns the bit position of the fix point, which can be used to 
	 * find out how accurate the fixed point network will be.  A high value indicates 
	 * high precision, and a low value indicates low precision.
	 * 
	 * A negative value indicates very low precision, and a very strong possibility 
	 * for overflow.  (the actual fix point will be set to 0, since a negative fix 
	 * point does not make sence).
	 * 
	 * Generally, a fix point lower than 6 is bad, and should be avoided.  The best 
	 * way to avoid this, is to have less connections to each neuron, or just less 
	 * neurons in each layer.
	 * 
	 * The fixed point use of this network is only intended for use on machines that 
	 * have no floating point processor, like an iPAQ.  On normal computers the 
	 * floating point version is actually faster.
	 * 
	 * @param filename The filename
	 */
	public void saveToFixed(String filename) {
		int err = libfann.fann_save_to_fixed(ann, filename);
		if (err == -1) {
			throw new FannException("Could not save data to the file:"+filename);
		}
		checkError();
	}

	/***************************************************************************
	 *                              ERROR
	 ***************************************************************************/
	
	
	public void setErrorLog() {
	// TODO:		
	//			libfann.fann_set_error_log(errdat, log_file);
	}	
		
	/**
	 * @return Returns the last error number.
	 */
	public Error getLastError() {
		return convert(libfann.fann_get_errno_fann(ann)); 
	}

	/**
	 * Resets the last error number.
	 */
	public void resetLastError() {
		libfann.fann_reset_errno_fann(ann);
	}

	/**
	 * @return the last errstr.
	 */
	public String getErrorString() {
		return libfann.fann_get_errstr_fann(ann);
	}

	/**
	 * Resets the last error string.
	 */
	public void resetErrorString() {
		libfann.fann_reset_errstr_fann(ann);
	}

	/**
	 * Prints the last error to stderr. 
	 */
	public void printError() {
		libfann.fann_print_error_fann(ann);
	}

	/**
	 * @return the ann
	 */
	public fann getFann() {
		return ann;
	}

	/**
	 * @param ann the ann to set
	 */
	public void setFann(fann ann) {
		this.ann = ann;
	}
	
	public ActivationFunction getActivationFunction(int layer, int neuron) {
		fann_activationfunc_enum x = libfann.fann_get_activation_function(ann, layer, neuron);
		checkError();
		for(ActivationFunction f : ActivationFunction.values()) {
			if (f.ordinal() == x.ordinal()) {
				return f;
			}
		}
		throw new FannException("Could not find a ActivationFunction with ordinal="+x.ordinal());
	}

	/**
	 * Set the activation function for neuron number neuron in layer number layer, 
	 * counting the input layer as layer 0.
	 * 
	 * It is not possible to set activation functions for the neurons in the input layer.
	 * 
	 * When choosing an activation function it is important to note that 
	 * the activation functions have different range.  FANN_SIGMOID is e.g. in 
	 * the 0 - 1 range while FANN_SIGMOID_SYMMETRIC is in the -1 - 1 range and 
	 * FANN_LINEAR is unbound.
	 * 
	 * Information about the individual activation functions is available at 
	 * fann_activationfunc_enum.
	 * 
	 * The default activation function is FANN_SIGMOID_STEPWISE.
	 * 
	 * @param activationFunction the activation function to be used
	 * @param layer the layer number
	 * @param neuron the neuron number in the given layer
	 */
	public void setActivationFunction(ActivationFunction activationFunction, int layer, int neuron) {
		for(fann_activationfunc_enum f : fann_activationfunc_enum.values()) {
			if (f.ordinal() == activationFunction.ordinal()) {
				libfann.fann_set_activation_function(ann, f, layer, neuron);
				checkError();
				return;
			}
		}
		throw new FannException("Could not find a fann_activationfunc_enum matching the ActivationFunction="+activationFunction.toString());
	}
	
	/**
	 * Set the activation function for the whole layer with number layer, 
	 * counting the input layer as layer 0.
	 * 
	 * @param activationFunction the activation function to be used
	 * @param layer the layer number
	 */
	public void setActivationFunction(ActivationFunction activationFunction, int layer) {
		for(fann_activationfunc_enum f : fann_activationfunc_enum.values()) {
			if (f.ordinal() == activationFunction.ordinal()) {
				libfann.fann_set_activation_function_layer(ann, f, layer);
				checkError();
				return;
			}
		}
		throw new FannException("Could not find a fann_activationfunc_enum matching the ActivationFunction="+activationFunction.toString());
		
	}

	/**
	 * Set the activation function for the all hidden layers. 
	 * 
	 * @param activationFunction the activation function to be used
	 */
	public void setActivationFunctionForAllHidden(ActivationFunction activationFunction) {
		for(fann_activationfunc_enum f : fann_activationfunc_enum.values()) {
			if (f.ordinal() == activationFunction.ordinal()) {
				libfann.fann_set_activation_function_hidden(ann, f);
				checkError();
				return;
			}
		}
		throw new FannException("Could not find a fann_activationfunc_enum matching the ActivationFunction="+activationFunction.toString());
	}

	/**
	 * Set the activation function for the output layer. 
	 * 
	 * @param activationFunction the activation function to be used
	 */
	public void setActivationFunctionForOutput(ActivationFunction activationFunction) {
		for(fann_activationfunc_enum f : fann_activationfunc_enum.values()) {
			if (f.ordinal() == activationFunction.ordinal()) {
				libfann.fann_set_activation_function_output(ann, f);
				checkError();
				return;
			}
		}
		throw new FannException("Could not find a fann_activationfunc_enum matching the ActivationFunction="+activationFunction.toString());
	}
	
	/**
	 * Set the activation steepness all of the neurons in layer number layer, 
	 * counting the input layer as layer 0.
	 * 
	 * It is not possible to set activation steepness for the neurons in the input layer.
	 * 
	 * @param layer The layer number (input=0)
	 * @param steepness the steepness for that neuron
	 */
	public void setActivationSteepness(int layer, double steepness) {
		libfann.fann_set_activation_steepness_layer(ann, steepness, layer);
		checkError();
	}
	
	public void setActivationSteepnessForAllHidden(double steepness) {
		libfann.fann_set_activation_steepness_hidden(ann, steepness);
		checkError();
	}
	
	public void setActivationSteepnessForOutput(double steepness) {
		libfann.fann_set_activation_steepness_output(ann, steepness);
		checkError();
	}
	
	
}
import saito.objloader.*;
import processing.opengl.*;
//import processing.opengl.*;
//import com.bulletphysics.dynamics.*;

boolean up,down,left,right;

Letadlo spitfire;

void setup(){
	size(640,480,OPENGL);
	spitfire = new Letadlo(this);
}

void draw(){
	background(0);
	
	pushMatrix();
	translate(width/2,height/2,-mouseY);
	pushMatrix();
	translate(spitfire.loc.x,spitfire.loc.y,spitfire.loc.z);
	rotateY(radians(mouseX));
	spitfire.draw();
	popMatrix();
	
	popMatrix();
}


class Letadlo{

	OBJModel model;

	PVector vel;
	PVector loc;
	PVector acc;
	PVector head;

	float mass = 10.0;
	float maxspeed = 3.0;
	float maxforce = 1.0;

	PApplet parent;

	Letadlo(PApplet _parent){
		parent = _parent;
		model = new OBJModel(parent);
		model.load("spitfire2.obj");
		model.drawMode(POLYGON);
		//model.enableTexture();

		loc = new PVector(0,0,0);
		vel = new PVector(0,0,0);
		acc = new PVector(0,0,0);
		head = new PVector(0,1,0);

	}

	void update() {
		
		if(up){
		head.add(0,-0.10,0);
		
		}
		
		if(down){
		head.add(0,0.1,0);
		}
		
		// Update velocity
		vel.add(acc);
		// Limit speed
		vel.limit(maxspeed);
		loc.add(vel);
		// Reset accelertion to 0 each cycle
		acc.mult(0);
	}

	// A method that calculates a steering vector towards a target
	// Takes a second argument, if true, it slows down as it approaches the target
	PVector steer(PVector target, boolean slowdown) {
		PVector steer;  // The steering vector
		PVector desired = PVector.sub(target,loc);  // A vector pointing from the location to the target
		float d = desired.mag(); // Distance from the target is the magnitude of the vector
		// If the distance is greater than 0, calc steering (otherwise return zero vector)
		if (d > 0) {
			// Normalize desired
			desired.normalize();
			// Two options for desired vector magnitude (1 -- based on distance, 2 -- maxspeed)
			if ((slowdown) && (d < 100.0f)) desired.mult(maxspeed*(d/100.0f)); // This damping is somewhat arbitrary
			else desired.mult(maxspeed);
			// Steering = Desired minus Velocity
			steer = PVector.sub(desired,vel);
			steer.limit(maxforce);  // Limit to maximum steering force
		} else {
			steer = new PVector(0,0, -100);
		}
		return steer;
	}

	void draw(){
		update();
		noStroke();
		
		pushMatrix();

		rotateX(atan2(head.z-loc.z,head.x-loc.x));	
		rotateY(atan2(head.y-loc.y,head.x-loc.x));

		model.draw();
		
		popMatrix();
		


	}






}


void keyPressed(){

	if(keyCode==LEFT){
		left = true;
	}
	if(keyCode==RIGHT){
		right = true;
	}
	if(keyCode==UP){
		up = true;
	}
	if(keyCode==DOWN){
		down = true;
	}


}

void keyReleased(){

	if(keyCode==LEFT){
		left = false;
	}
	if(keyCode==RIGHT){
		right = false;
	}
	if(keyCode==UP){
		up = false;
	}
	if(keyCode==DOWN){
		down = false;
	}


}
import eu.fluidforms.utils.*;
import eu.fluidforms.processing.*;
import eu.fluidforms.geom.*;
import eu.fluidforms.io.*;
import eu.fluidforms.parser.*;




void setup(){
  size(500, 800, P3D);
  background(255);
  String format = "stl";  
  FGraphics gExport = (FGraphics)beginRecord(FluidForms.RECORDER, "UVExample." + format);  
  gExport.setApplyTransformMatrix(false);
  //gExport.setAscii(true);
  smooth();
  lights();
  fill(200);
  noStroke();
  translate(width/2, height/2);
  rotateX(PI/2);
  rotateZ(PI/2);
  int scale = 170;
  int resolution = 50;
  float inc = (TWO_PI)/resolution;
  for(float v=-PI/2; v<PI/2; v+=inc){ // creates a half circle
    beginShape(TRIANGLE_STRIP);
    for(float u=0; u<=TWO_PI+inc; u+=inc){  // rotates the half circle
      float x1 = getX(u, v);
      float y1 = getY(u, v);
      float z1 = getZ(u, v);

      float x2 = getX(u, v+inc);
      float y2 = getY(u, v+inc);
      float z2 = getZ(u, v+inc);

          vertex(x1*scale,y1*scale,z1*scale);
          vertex(x2*scale,y2*scale,z2*scale);
    }
    endShape();
  }

  endRecord();
}


float getX(float u, float v){
  return cos(u) * cos(v);
}
float getY(float u, float v){
  return sin(u) * cos(v);
}
float getZ(float u, float v){
  return sin(v) + cos(u);
}


import fullscreen.*; 

FullScreen fs; 

void setup(){
  // set size to 640x480
  size(640,480,P3D);
  
  // 5 fps
  frameRate(40);

  // Create the fullscreen object
  fs = new FullScreen(this); 
  
  // enter fullscreen mode
 // fs.enter(); 
}


void draw(){
  background(0);
  
  // Do your fancy drawing here...
  for(int i = 0; i < 10; i++){
    fill(
      random(255),
      random(255),
      random(255)
    );

    rect(
      i*10, i*10,
      width - i*20, height - i*20
    ); 
  }
}


// to run command:
// rm out.txt && pp 2> out.txt

PImage a,b;
Recorder r;
byte[] data;
boolean rec = false;
PGraphics ram;
String txt[];
PGraphics ou;
void setup()
{
	a = loadImage("bratri2.jpg");
	//a.save("data/bratriMod.jpg");
	//b = loadImage("bratriMod.jpg");
	txt = loadStrings("out.txt");

	size(a.width,a.height,OPENGL);
	r = new Recorder("out","glitch3.mp4");
	background(0);
	//data=loadBytes("bratri2.jpg");
	
	image(a,0,0);

	textFont(createFont(PFont.list()[0],8));
	textAlign(RIGHT);

	ou = createGraphics(width,height,JAVA2D);
	ram = createGraphics(width,height,P2D);
	
	kurv();
	
	ram.beginDraw();
	ram.noFill();
	ram.stroke(0,150);
	ram.strokeWeight(10);
	ram.rect(0,0,width,height);
	ram.endDraw();
	ram.filter(BLUR,2.5);
}


void draw(){
	kurv();

	noTint();
	image(ou,0,0);

	fill(255,120);
	
	for(int i = 0;i<txt.length;i++){
		int pos = txt.length*6;
		if(pos>height-10)
			text(txt[i],width-10,i*6-pos+height-10);
		else
			text(txt[i],width-10,i*6);

	}

	noTint();
	image(ram,0,0);

	if(rec)
		r.add();


}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}else if(key=='r'){
		rec=true;
	}
	keyPressed = false;
}

void kurv(){
	data =loadBytes("bratri2.jpg");
	for(int i=0;i<4;i++) // 100 changes
	{
		int loc=(int)random(256,data.length);//(int)constrain(map(mouseY*width+mouseX,0,height*width+width,1024,data.length),1024,data.length);//(int)random(1024,data.length);//guess at header being 128 bytes at most..
		data[loc]+=(byte)((byte)random(120,125)-data[loc])/20.0;
	}
	saveBytes("data/bratriMod.jpg",data);
	b = loadImage("bratriMod.jpg");
	txt = loadStrings("out.txt");
	
	ou.beginDraw();
	if(frameCount%25==0){
		ou.noTint();
	}else{
		ou.tint(random(128,255),random(128,255),12,100);
	}

	ou.image(b,0,random(-10,10));
	ou.endDraw();


}



class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

int X = 128;
int Y =  X;

int cycle = 0;

boolean textual = false;

boolean pattern[] = new boolean[X];
int wt[][] = new int[X][Y];

float cerror;
float crr[];

float inm[];
float outm[];

boolean learning = false;
boolean doLearn = true;

int [][] lcyc;
int lc = 0;

int[][] matrix = new int[X][Y];
int input[] = new int[X];
int output[] = new int[X];
int error[] = new int[X];


void setup(){

	size(1000,240,P2D);
	background(0);

	cerror = .5;
	crr = new float[width];
	outm = new float[width];
	inm = new float[width];
	for(int i=0;i<width;i++){
		crr[i] = 0;
		inm[i] = 0;
		outm[i] = 0;
	}

	reborn(width);


	//rndIn();
	initNet();
	runNetwork();




	textFont(createFont("04b03b",8));
	textMode(SCREEN);
	textAlign(RIGHT);
	noStroke();


}

void reborn(int lin){
	createPattern(lin);
	lcyc = loadPattern();

}

void createPattern(int len){
	String s[] = new String[len];


	int vala = 200;

	for(int q = 0 ;q<len;q++){
		String temp = "";
		vala += random(-2,3);
		vala = constrain(vala,0,255);
		
		for(int i = 0 ;i<16;i++){
			temp+=nf(parseInt(binary(vala)),8)+"";
		}
		s[q] = temp+"";
	}

/*
	for(int i = 0 ;i<len;i++){
		String temp = "";
		rndIn();
		for(int z =0; z<X;z++){
			temp+=input[z]+"";
		}
		s[i] = temp+"";
	}
*/
	saveStrings("data/set.txt",s);
}

int[][] loadPattern(){
	String s[] = loadStrings("set.txt");
	int[][] ans = new int[s.length][X];

	for(int i = 0 ;i<s.length;i++){
		String temp = s[i]+"";
		for(int z =0; z<X;z++){
			ans[i][z] = parseInt(s[i].charAt(z)+"");
		}

	}

	return ans;
}

void draw(){
	background(0);


	int val = funpack(input);
	inm[frameCount%width]=map(val,0,255,height-10,10);

	val = funpack(output);
	outm[frameCount%width]=map(val,0,255,height-10,10);


	noFill();

	if(doLearn){
		fill(255);
		text("L",width-2,height-10);
		learnCyc(1);

	}

	if(!learning)
		test();

	fill(255);
	for(int x = 0;x<matrix.length;x++){
		if(input[x]==1)
			fill(#FF0000);
		else
			fill(255);

		if(textual)
			text(input[x],x*10+20,10);
		else
			rect(x+20,10,1,1);
	}

	for(int x = 0;x<matrix.length;x++){
		if(error[x]==1)
			fill(#FF0000);
		else
			fill(255);

		if(textual)
			text(output[x],x*10+20,height-20);
		else
			rect(x+20,height-20,1,1);
	}

	fill(255);
	text(cycle,width-2,10);



	stroke(255,50);
	line(0,height/2,width,height/2);




	for(int i=0;i<width;i++){
		stroke(255);
		point(i,map(crr[i],0,1,height-10,10));
		stroke(#00FF00);
		point(i,inm[i]);
		stroke(#FFCC00);
		point(i,outm[i]);

	}
	noStroke();


}

void learnCyc(int kolik){
	for(int i =0;i<kolik;i++)
		drill();

}

void keyPressed(){
	if(key == ' '){
		drill();
		learning = true;
	}else if(key=='l'){
		doLearn = !doLearn;
	}
}


void keyReleased(){
	if(key == ' '){

		learning = false;
	}else if(keyCode == ENTER){
		reborn(width);
	}
}

void drill(){


	train();
	//runNetwork();
	//initNet();



}

void test(){
	lc++;
	if(lc>(lcyc.length-1)) lc=0;
	input = lcyc[lc];

	initNet();

	runNetwork();

	float q = 0;
	for(int i =0;i<X;i++){
		q += error[i];
	}
	q = (q/(X+0.0));

	cerror += (q-cerror)/10.0;

	crr[frameCount%(width-1)] = cerror;

}

void rndIn(){


	input = new int[X];
	for(int i =0;i<input.length;i++)
		if(random(100)>50)
			input[i] = 1;
		else
			input[i] = 0;

}


void initNet(){

	for ( int row=0;row<X;row++ )
		for ( int col=0;col<Y;col++ )
			wt[row][col]=matrix[row][col];
	for ( int row=0;row<X;row++ ) {
		int i = input[row];
		if ( i==0 )
			pattern[row] = false;
		else
			pattern[row] = true;
	}

}

void runNetwork() {




	Network net = new Network(wt);
	net.activation(pattern);

	for ( int row=0;row<X;row++ ) {
		if ( net.output[row] )
			output[row] = 1;
		else
			output[row] = 0;
		if ( net.output[row]==pattern[row] )
			error[row] = 0;
		else
			error[row] = 1;
	}
}


void clear(){
	for ( int row=0;row<X;row++ )
		for ( int col=0;col<Y;col++ )
			matrix[row][col] = 0;
}

int[] unpack(int[] in,int num){
	int[] answ = new int[num];

	int tc = 0;
	for(int i =0;i<num;i++){
		String tmp = "";

		for(int q =0;q<8;q++){
			if(in[q+tc]==1)
				tmp+=1+"";
			else
				tmp+=0+"";

		}

		answ[i] = unbinary(tmp);
		tc+=8;
	}

	return answ;
}

int funpack(int[] a){
	int res = 0;
	for(int i =0;i<16;i++)
		res+=unpack(a,16)[i];

	res = (int)(res/16.0);

	return (res);

}

void train(){
	cycle ++;
	int work[][] = new int[X][Y];
	int bi[] = new int[X];

	for ( int x=0;x<X;x++ ) {
		if ( input[x]==0 )
			bi[x] = -1;
		else
			bi[x] = 1;
	}

	for ( int row=0;row<X;row++ )
		for ( int col=0;col<Y;col++ ) {
			work[row][col] = bi[row]*bi[col];
		}

	for ( int x=0;x<X;x++ )
		work[x][x] -=1;

	for ( int row=0;row<X;row++ )
		for ( int col=0;col<Y;col++ ) {
			int i = matrix[row][col];
			matrix[row][col] = i+work[row][col];
		}

}



class Network {
  Neuron neuron[] = new Neuron[X];
  boolean output[] = new boolean[X];
  

  Network(int in[][]){
	  for(int i =0;i<in.length;i++)
		  neuron[i] = new Neuron(in[i]);
  }

  boolean threshold(int k){
    return(k>=0);
  }

  void activation(boolean pattern[]) {
	  //cycle++;
    int i,j;
    for ( i=0;i<X;i++ ) {
      neuron[i].activation = neuron[i].act(pattern);
      output[i] = threshold(neuron[i].activation);
    }
  }
}

public class Neuron{
  int activation;
  int weightv[] = new int[Y];

  Neuron(int in[]){
    int i;
    for (i = 0; i < Y; i++)
      weightv[i] = in[i];
  }

  int act(boolean x[]) {
    int i;
    int a = 0;

    for (i = 0; i < x.length; i++)
      if (x[i])
        a += weightv[i];
    return a;
  }

}
int num = 300;
float tresh = 0.0;
Node[] n;

void setup(){
	size(300,300,P2D);
	background(0);
	rectMode(CENTER);

	n = new Node[num];

	for(int i =0;i<num;i++){
		n[i] = new Node(i,2);
	}

	noFill();
	stroke(255);
}

void draw(){

	background(0);

	for(int i =0;i<num;i++){
		n[i].calc();
		n[i].update();
	}


	for(int i =0;i<num;i++){
		n[i].draw();
	}



}

class Node{
	float x,y;
	int id,inum;
	int ins[];
	float w[];
	boolean active = true;
	float sum = 0,sum2;

	Node(int _id,int _inum){
		id = _id;
		inum = _inum;
		ins = new int[inum];
		w = new float[inum];
		sum2 = 2;
		x = random(width);

		y = random(height);



		for(int i = 0;i<inum;i++){
			
			
				ins[i] = (int)random(num);
				if(ins[i]==id)			
			while(ins[i]==id){
				ins[i] = (int)random(num);
			}
			w[i] = random(-100,100)/100.0;
			
		}


	}

	void calc(){
		if(id<5){
			sum = random(-100,100)/100.0;
		
		}else{
		float sum = 0;
		
		int cnt = 0;
		for(int i = 0;i<inum;i++){
			if(n[i].active){
				sum += n[i].sum2*w[i];
				cnt++;	
			}
		}
		sum = (sum/(cnt+0.0));
		}

	}

	void update(){
		sum2 += (sum-sum2)/3.0;
		x = map(sum2,-1,1,0,width);
		
		if(sum>=tresh){
			active = true;
		}else{
			active = false;
		}
	}

	void draw(){
		stroke(255,map(sum2,-1,1,0,255));
		rect(x,y,3,3);

		for(int i =0;i<inum;i++){
			stroke(255,map(sum2,-1,1,0,255));
			line(n[ins[i]].x,n[ins[i]].y,x,y);
		}


	}



}
class Cortex{
	
  KCell [] layer;
  int bestCell = -1;
  float mapUnit,mapWidth,mapArea,mapRadius,learningRate;
  float startLearningRate = 0.1;
  float iterations = 1.0;
  float sumIterations = 1000.0;
  String mode = "brightness";
  
  Cortex(){
	  
    layer = new KCell[pic.pixels.length];
    mapArea = float(pic.pixels.length);
    mapWidth = sqrt(mapArea);
    mapUnit = width/mapWidth;
    for(int i = 0; i < layer.length; i++){
      layer[i] = new KCell(i,i%int(mapWidth),i/int(mapWidth),mapUnit);
    }
    //calculate radius (max (width, height)/2) or ->
    mapRadius = sqrt(mapArea)/2;
  }
  void draw(){
    //render an image of the weight values of the net and
    //highlight where the best cell is picked
    noStroke();
    for(int i = 0; i < layer.length; i++){
      fill(255,255,0);
      if(i == bestCell){
        ellipse(layer[i].x*mapUnit,layer[i].y*mapUnit,20,20);
      }
      //layer[i].draw();
    }
    for(int i = 0; i < layer.length; i++){
      stroke(layer[i].weight[0]*255.0,layer[i].weight[1]*255.0,layer[i].weight[2]*255.0);
      point(layer[i].x,layer[i].y); 
    }
  }
  void train(){
    //calculate best matching unit
    float bestInputVectorDelta = 100000.0;
    bestCell = -1;
    int pick = int(random(layer.length));
    float [] inputVector = new float[3];
    inputVector[0] = (1.0/255.0) * red(pic.pixels[pick]);
    inputVector[1] = (1.0/255.0) * green(pic.pixels[pick]);
    inputVector[2] = (1.0/255.0) * blue(pic.pixels[pick]);
    for(int i = 0; i < layer.length; i++){
      float vectorDelta = 0.0;
      //normally iterate through sum of weights
      for (int j = 0; j < layer[i].weight.length; j++){
        vectorDelta += sq(inputVector[j] - layer[i].weight[j]);
      }
      vectorDelta = sqrt(vectorDelta);
      if (vectorDelta < bestInputVectorDelta){
        bestCell = i;
        bestInputVectorDelta = vectorDelta;
      }
    }
    //calc time constant
    float timeConstant = sumIterations/log(mapRadius);
    //calc neighbourhood
    float neighbourhood = mapRadius * exp(-iterations/timeConstant);
    for (int i = 0; i < layer.length; i++){
      //calculate the Euclidean distance (squared) to this node from the
      //Best Matching Unit
      float distToNodeSq = sq(layer[bestCell].x-layer[i].x) + sq(layer[bestCell].y-layer[i].y);
      float widthSq = sq(neighbourhood);
      //if within the neighbourhood adjust its weights
      if (distToNodeSq < widthSq){
        //calculate by how much its weights are adjusted
        float influence = exp(-(distToNodeSq) / (2*widthSq));
        layer[i].educate(learningRate,influence,inputVector);
      }
    }//next node
    //set new learning rate
    learningRate = startLearningRate * exp(-iterations/sumIterations);
    iterations++;
  }
}

class KCell{
  //a Kohonen neural net component
  int id;
  float x,y,mapUnit;
  float [] weight;
  KCell(int id, float x, float y, float mapUnit){
    this.id = id;
    weight = new float[3];
    for (int i = 0; i < weight.length; i++){
      weight[i] = random(0.1,0.5);
    }
    this.x = x;
    this.y = y;
    this.mapUnit = mapUnit;
  }
  void educate(float learningRate, float influence, float [] targetVector){
    //alters weight on dendrites based on desired input
    for (int i = 0; i < targetVector.length; i++){
      weight[i] += learningRate * influence * (targetVector[i] - weight[i]);
    }
  }
  void draw(){
    //put rectangular pixels representing the net over their source pixels
    fill(weight[0]*255.0,weight[1]*255.0,weight[2]*255.0);
    rect(x*mapUnit,y*mapUnit,5,5);
  }
}

class Buttons{
  int x,y,w,h,col;
  String label;
  PImage pic;
  Buttons(int x, int y, int w, int h, int col, String label, PImage pic){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.col = col;
    this.label = label;
    this.pic = pic;
  }
  void draw(){
    stroke(0);
    fill(0);
    int xup,yup;
    if(over()){
      if(mousePressed){
        xup = x-1;
        yup = y-1;
      }
      else{
        xup = x-4;
        yup = y-4;
      }
    }
    else{
      xup = x;
      yup = y;
    }
    rect(x,y,w,h);
    if(pic == null){
      fill(col);
      rect(xup,yup,w,h);
    }
    else{
      image(pic,xup,yup,w,h);
    }
    if (label.length() > 0){
      fill(0);
      text(label,xup+2,yup+18);
    }
  }
  boolean over(){
    if (mouseX <= x+w && mouseX >= x && mouseY <= y+h && mouseY >= y){
      return true;
    }
    else{
      return false;
    }
  }
}

/*
Kohonen Neural net demo.
 
 Sorts an image into it's constituent colours.
 
 This example can be adapted to sort all sorts of data
 into groups.
 
 Adapted from tutorial at:
 http://www.ai-junkie.com/ann/som/som1.html
*/

PFont font;
PImage pic;
Cortex cortex;
Buttons [] button;
int choice = -1;
boolean go = false;

void setup(){
  size(123*2,123*2,P2D);
  pic = loadImage("1.gif");
  cortex = new Cortex();
  int col = #EEEEEE;
  button = new Buttons[2];
  button[0] = new Buttons(128,0,64,20,col,"train",null);
  button[1] = new Buttons(192,0,64,20,col,"reset",null);
  font = createFont("04b03b",8);
  textMode(SCREEN);
  textFont(font,8);
  noStroke();
  noSmooth();
}

void draw(){
  image(pic,0,0,width,height);
  cortex.draw();
  if (go) cortex.train();
  for (int i = 0; i < button.length; i++){
    button[i].draw();
  }
}

void mousePressed(){
  for(int i = 0; i < button.length; i++){
    if(button[i].over()){
      choice = i;
    }
  }
  switch(choice){
  case 0:
    go = !go;
    break;
  case 1:
    cortex = new Cortex();
    break;
  }
}




Node[] n = new Node[250];
PImage shape1 ;

void setup()
{

	size(1024,768,OPENGL);
	background(0);

	
	shape1 = loadImage("shape1.png");
	
	for(int i =0;i<n.length;i++)
	{
		n[i] = new Node(i);
	}



}


void draw()
{
	//background(0);
	fill(0,2);
	rect(0,0,width,height);
	
	for(int i =0;i<n.length;i++)
	{
		n[i].live();
	}	
}

void BBox(){

	//pushMatrix();
	
	
	pushMatrix();
	translate(width/2.0,height/2.0);
	rotateY(radians(frameCount/3.0));
	noFill();
	noTint();
	stroke(0,10);
	box(400);

	
	popMatrix();


	
	//popMatrix();

}

class Node
{
	float x,y,sx,sy,speed = 60.0;
	float pulsar = 0;
	float pulseSpeed;
	int id;
	float area,areaB = 40.0;
	color c;

	Node(int _id)
	{
		id = _id;
		sx = x = random(width);
		sy = y = random(height);
		
		areaB = random(5,200);
		area = areaB;
		
		pulsar = random(1000)/100.0;
		pulseSpeed = random(2,30);

		c = color(random(255));
	}

	void seek()
	{

		area = 1+areaB*(sin(pulsar/pulseSpeed)+1.0)/2.0;
		pulsar ++;
		
		Node tmp = getNearest();

		if(dist(sx,sy,tmp.sx,tmp.sy)>=area+1){

			x += (tmp.x-x)/speed;
			y += (tmp.y-y)/speed;
		}else if(dist(sx,sy,tmp.sx,tmp.sy)<=area){

			x -= (tmp.x-x)/(speed*0.033);
			y -= (tmp.y-y)/(speed*0.033);

		}

		//stroke(255,40);
		//line(tmp.sx,tmp.sy,sx,sy);

	}
	
	void bordr()
	{
	
		if(x>width-area/2.0)x=width-area/2.0;
		if(x<area/2.0)x=area/2.0;
		
		
		if(y>height-area/2.0)y=height-area/2.0;
		if(y<area/2.0)y=area/2.0;
		
	
	}

	Node getNearest()
	{
		float lenn = width * height;
		Node a = this;

		for(int i = 0;i<n.length;i++)
		{

			float temp = dist(x,y,n[i].x,n[i].y);
			if(lenn>temp && i != id)
			{
				lenn = temp;
				a = null;
				a = n[i];
			}

		}

		return a;

	}


	void connect()
	{




	}

	void pulse()
	{


	}

	void live()
	{

		seek();
		bordr();
		
		//x+=(mouseX-x)/(abs(x-mouseX)+1);
		//y+=(mouseY-y)/(abs(y-mouseY)+1);
		
		sx += (x-sx)/10.0;
		
		sy += (y-sy)/10.0;
		
		pushStyle();
		noFill();
		stroke(255,80);
		rectMode(CENTER);
		imageMode(CENTER);
		
		tint(c,90);
		image(shape1,sx,sy,area*2,area*2);
		
		//ellipse(sx,sy,area,area);

		//rect(sx,sy,3,3);
		popStyle();

	}



}


PGraphics anim;

int cntr = 0;

void setup(){

	size(176,220);
	background(0);
	frameRate(3);
	textFont(createFont("04b08",8));
	fill(255);
	animate();
	
}

void animate(){

	
	anim = createGraphics(width,height,P3D);
	anim.beginDraw();
	//anim.textFont(createFont("04b08",64));
	anim.fill(255,85);
	anim.pushMatrix();
	anim.translate(0,0,100);
	anim.rect(-width,-height,3*width,3*height);
	anim.popMatrix();
	
	anim.strokeWeight(5);
	anim.fill(#999999,160);
	anim.stroke(0);
	
	anim.pushMatrix();
	anim.translate(width/2.0,height/2.0);
	anim.rotateX(radians(-45));
	anim.rotate(radians(cntr));
	anim.box(70);
	
	anim.popMatrix();
	//anim.text("kof",20,height-30);
	anim.endDraw();

}



void draw(){

	
	background(0);
	//image(anim,0,0);
	
	anim.loadPixels();
	for(int y = 2;y<height-2;y+=6){
		for(int x = 2;x<width-2;x+=6){
			fill(anim.pixels[y*width+x]);
			text((char)((int)(random(0,27)+65)),x,y);
		}

	}
	
	saveFrame("fr####.png");
	println(cntr);

	animate();
	cntr+=5;
}

import javax.media.opengl.*;
import processing.opengl.*;
import java.nio.*;

void setup(){


	size(200,200,OPENGL);
	fill(255);
	textFont(createFont("04B_21__",16));
	background(255);



	//set everything up as usual
	PGraphicsOpenGL pgl = ((PGraphicsOpenGL)g);
	GL gl = pgl.beginGL();

	// GLFont (opengl Context, font name, size (in pixels), smooth)
	GLFont gltext = new GLFont(gl, "Arial",26, true);
	gltext.setcolor( 1.0, 0.0, 0.0, 1.0);
	pgl.endGL();

	//....
	//somewhere in your render
	gl = pgl.beginGL();
	gltext.write(gl, "Joey Joe-Joe Junior Shabadoo" ,  20, 20);
	pgl.endGL();

	//....
	//when you dont need text any longer
	gltext.deallocate(gl);



}

class GLFont{
	int _texsize, _tex[], _list[];
	float _size, _charwidth[], _color[];
	String _name;
	Hashtable _charmap;

	GLFont(GL gl, String fontName, float fontSize, boolean smoothFont){
		PFont font = createFont(fontName, fontSize, smoothFont);
		textFont(font);
		textMode(MODEL);

		_name = fontName;
		_size = fontSize;
		_texsize = font.images[0].width;
		_tex = new int[280];
		_list = new int[280];
		_charwidth = new float[280];
		_charmap = new Hashtable();
		setcolor(1,1,1,1);

		ByteBuffer tempBuf;
		boolean noImage;
		_charwidth[32] = textWidth( " " );
		for(int index=0; index<279; index++){
			_charmap.put( new Character( char(font.value[index]) ), new Integer(index) );
			_charwidth[index]= textWidth(char(font.value[index]));

			noImage = true;
			
			tempBuf = ByteBuffer.allocate( 4 * font.images[index].pixels.length );
			for(int t=0; t< font.images[index].pixels.length; t++){
				tempBuf.putInt(  t*4, (255<<24)+(255<<16)+(255<<8)+(font.images[index].pixels[t]) );
				if( font.images[index].pixels[t] >0 ) noImage = false;
			}
			tempBuf.rewind();
			if( noImage ) continue;

			_tex[index] = glNewTex(gl, GL.GL_TEXTURE_2D, _texsize, _texsize, GL.GL_RGBA, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE,  GL.GL_NEAREST, GL.GL_NEAREST,  tempBuf);

			//generate and build the display list
			_list[index] = gl.glGenLists(1);
			gl.glNewList( _list[index] ,GL.GL_COMPILE);
			gl.glActiveTexture( GL.GL_TEXTURE0);
			gl.glEnable( GL.GL_TEXTURE_2D );
			gl.glBindTexture( GL.GL_TEXTURE_2D, _tex[index] );

			gl.glPushMatrix();
			gl.glBegin(GL.GL_POINTS);
			//i shift the pixel to the char's correct distance from the baseline
			gl.glVertex2f( _texsize/2 +font.leftExtent[index] , _size + _texsize/2 -font.topExtent[index] );
			gl.glEnd();
			gl.glPopMatrix();
			gl.glEndList();
		}
		gl.glActiveTexture( GL.GL_TEXTURE0);
		gl.glEnable( GL.GL_TEXTURE_2D );
		gl.glBindTexture( GL.GL_TEXTURE_2D, 0 );
	}

	void deallocate(GL gl){
		gl.glDeleteTextures(128, _tex, 0);
		gl.glDeleteLists(128, _list[0] );
	}

	void setcolor(float r, float g, float b, float a){
		_color = new float[]{r,g,b,a};
	}

	void write(GL gl, String l_text, float x, float y){
		gl.glPushAttrib( GL.GL_ALL_ATTRIB_BITS );
		gl.glPushMatrix();
		gl.glColor4f( _color[0], _color[1], _color[2], _color[3] );
		gl.glTranslatef(x,y,0);
		gl.glDepthMask(false);
		gl.glDisable(GL.GL_DEPTH_TEST);
		gl.glEnable(GL.GL_BLEND);  //blending is important for alpha

		//set up point sprites
		gl.glEnable(GL.GL_POINT_SPRITE);
		gl.glPointSize(_texsize);
		gl.glTexEnvi(GL.GL_POINT_SPRITE, GL.GL_COORD_REPLACE, GL.GL_TRUE);
		int len = l_text.length();
		int t;
		for(int i=0; i<len; i++){
			if( _charmap.containsKey( new Character( l_text.charAt(i) ) ) ){
				t = ( (Integer)_charmap.get( new Character( l_text.charAt(i) ) ) ).intValue();
				gl.glCallList( _list[t] );
				gl.glTranslatef( _charwidth[t], 0, 0 );
			}else if( l_text.charAt(i) == char(32) )
				gl.glTranslatef( _charwidth[32], 0, 0 );
		}
		gl.glPopMatrix();
		gl.glPopAttrib();
	}
}

//Create a new texture of any type and pass back it's ID
int glNewTex(GL gl, int texType, int w, int h,  int internalFormat, int l_format, int dataType, int minFilter, int magFilter, Buffer data){
	gl.glActiveTexture( GL.GL_TEXTURE0 );
	gl.glEnable(texType);
	int[] temp = new int[1];
	gl.glGenTextures( 1, temp, 0 );

	gl.glBindTexture( texType, temp[0] );
	gl.glTexParameteri( texType, GL.GL_TEXTURE_MIN_FILTER, minFilter );
	gl.glTexParameteri( texType, GL.GL_TEXTURE_MAG_FILTER, magFilter );
	gl.glTexParameteri( texType, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE );
	gl.glTexParameteri( texType, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE );
	gl.glTexImage2D( texType, 0, internalFormat, w, h, 0, l_format, dataType, data );
	gl.glActiveTexture( GL.GL_TEXTURE0);
	gl.glEnable( GL.GL_TEXTURE_2D );
	gl.glBindTexture( GL.GL_TEXTURE_2D, 0 );
	return temp[0];
}




PFont[] fonts = new PFont[12];

void setup(){

	size(800,600);


	//PFont font = ;
	//println(PFont.list());
	fill(255);
	



	for(int q = 0;q<100;q++){
		background(0);
		for(int i = 4;i<25;i++){
			textFont(createFont(PFont.list()[q],i));

			text(PFont.list()[q]+" abcd0128 " + (i)+ "px.",10,24*(i - 3));

		}
		
		save(PFont.list()[q]+".png");


	}

}
class Node{
   int mutaton = 2;
  float echo = 0.5f;
  
  int mat = 3;
  float[][] matix = new float[mat][mat];
  float w,h;
  float x,y,tx,ty;
  float speed = 30.0f;
  float wid,heig;
  float r = 15.0f;
  int tim = 0,lim;
  float t;
  color c[] = new color[3];
  int id;
  int which; 

  float ler = 0.0f;
  boolean sending;


  Node(int _id){
    id = _id;
    which = constrain(id-1,0,node.length-1);
    lim = (int)random(5,42);
    w=h=5;
    x=y=tx=ty=width/2.0f;
    wid = w*mat;
    heig=h*mat;
    sending = false;
    this.reset();
  }

  void run(){
    tim++;

    if(tim%lim==0&&id==node.length-1){
      lim = (int)random(50,420);      
      reset();
      sending = true;
    }

    

    compute();
    draw();
    
    if(sending){
      ler+=echo;
      fill(#FFCC00,85);
      ellipse(lerp(x+1.5f*w,node[which].x+1.5f*w,ler),lerp(y+1.5f*w,node[which].y+1.5f*w,ler),
      3*w-((ler)*3*w),3*w-((ler)*3*w));
      
      if(ler>=1){
        sendGen(which);
        sending = false;
        if(which!=0)node[which].sending = true;
        ler = 0.0f;
      }      
    }
  }

  void compute(){
    move();    
  }

  void draw(){



    fill(255,85);              


    triangle(x,y,x+3*w,y,(node[which].x+(1.5f*w)),(node[which].y+(1.5*w)));
    
    if(sending){
       fill(#FFCC00,85);
    triangle(x,y,x,y+3*w,(int)(node[which].x+(1.5f*w)),(int)(node[which].y+(1.5f*w)));

   
    triangle( x, y+3*w, x+3*w, y+3*w,(int)(node[which].x+(1.5f*w)),(int)(node[which].y+(1.5f*w)));

                   
    triangle(x+3*w,y,x+3*w,y+3*w,(int)(node[which].x+(1.5f*w)),(int)(node[which].y+(1.5*w)));    
    
    }else{
    
    fill(hue(c[0]),85);
    triangle(x,y,x,y+3*w,(int)(node[which].x+(1.5*w)),(int)(node[which].y+(1.5*w)));

    fill(hue(c[1]),85);
    triangle( x, y+3*w, x+3*w, y+3*w,(int)(node[which].x+(1.5f*w)),(int)(node[which].y+(1.5f*w)));

    fill(hue( c[2]),85);                 
    triangle(x+3*w,y,x+3*w,y+3*w,(int)(node[which].x+(1.5f*w)),(int)(node[which].y+(1.5f*w)));    
    }

    pushMatrix();
    fill(lerpColor(#FFFFFF,#FFCC00,ler),125);
    translate(x,y);
    ellipse((int)(w*1.5f),(int)(h*1.5f),r*2,r*2);
    image(shade,-41,-41);
    for(int i = 0;i < matix.length;i++){
      for(int q = 0;q < matix[i].length;q++){

        fill(matix[i][q]); 

        rect((int)i*w,(int)q*h,w,h);
      }
    }
    //colors();

    c[0] = color(matix[0][0],matix[1][0],matix[2][0]);
    c[1] =  color(matix[0][1],matix[1][1],matix[2][1]);
    c[2] = color(matix[0][2],matix[1][2],matix[2][2]);
    sipka();
    popMatrix();
    //rect(tx,ty,w,h);

  }

  void sendGen(int r){
    node[r].matix = new float[mat][mat];
    node[r].matix = (float[][])mutate(this.matix);  
    //println("sendingGen from "+id+" >> "+r);
  }

  void receiveGen(int q){
    this.matix = (mutate(node[q].matix));  
  }

  float[][] mutate(float[][] _matix){
    float [][] mut = new float[mat][mat];
    for(int i = 0;i<mut.length;i++){
      for(int q = 0;q<mut[0].length;q++){
        mut[i][q] = _matix[i][q]; 
      }      
    }

    for(int i=0;i<mutaton;i++){
      int XR = (int)random(mut.length);
      int YR = (int)random(mut[0].length);
      mut[XR][YR]+=(random(0,255)-mut[XR][YR])/2.0;
    }
    return mut;
  }

  void reset(){
    matix = new float[mat][mat];
    for(int i = 0;i < matix.length;i++){
      for(int q = 0;q < matix[i].length;q++){
        this.matix[i][q] = random(0,255);
      }
    }
        
  }

  void move(){
    float up = (matix[0][0]+matix[1][0]+matix[2][0])/3.0f;
    float left = (matix[0][0]+matix[0][1]+matix[0][2])/3.0f;
    float down= (matix[0][2]+matix[1][2]+matix[2][2])/3.0f;
    float right = (matix[2][0]+matix[2][1]+matix[2][2])/3.0f;

    up = norm(up,0,255);
    left = norm(left,0,255);
    down = norm(down,0,255);
    right = norm(right,0,255);

    tx += ((norm(right-left,-0.5f,0.5f)*width)-tx)/speed;
    ty += ((norm(down-up,-0.5f,0.5f)*height)-ty)/speed;

    x+=(tx-x)/speed;
    y+=(ty-y)/speed;

    //bordrs();
  }

  void sipka(){
    t = atan2(ty-y,tx-x);

    pushMatrix();
    translate(1.5f*w,1.5f*w);
    rotate(t);
    pushMatrix();
    fill(255,map(dist(tx,ty,x,y),0,90,0,255));
    stroke(0,map(dist(tx,ty,x,y),0,90,90,255));

    triangle(r+2,-5,r+2,5,1.5f*r+2,0);
    popMatrix();
    popMatrix(); 
  }

  void bordrs(){
    if(x>width-r-1.5f*w){
      x=tx=width-r-1.5f*w;
    }
    if(y>height-r-1.5f*w){
      y=ty=height-r-1.5f*w;
    }
    if(x+1.5f*w<r){
      x=tx=r-1.5f*w;
    }
    if(y+1.5f*w<r){
      y=ty=r-1.5f*w;
    }
  }

  void colors(){
    color c2[] = {
      color(matix[0][0],matix[0][1],matix[0][2]),
      color(matix[1][0],matix[1][1],matix[1][2]),
      color(matix[2][0],matix[2][1],matix[2][2])
      };

      for(int i = 0;i < mat;i++){        
       
	if(!over()){
          fill(c2[i]);
        }
        else{
          fill(hue(c2[i])); 
        }
        rect((int)(i*w),(int)(mat*h+h),w,height-y);
      }
  }

  boolean over(){
    boolean answ = false;
    if((mouseX>x)&& (mouseX<x+w*matix.length)&& (mouseY>y)&& (mouseY<y+h*matix[0].length)){
      answ = true;      
    }
    return answ;
  }
}
import codeanticode.gsvideo.*;



GSMovieMaker mm;

boolean rec = false;

int num = 50;
Node node[];

int op = 60;

PImage shade,high;

void setup(){
  size(7*op,5*op,OPENGL);
  background(0);
  node = new Node[num];
  frame.setTitle("QadGenz 8");
  for(int i = 0;i < node.length;i++){
    node[i] = new Node(i);
  }
  smooth();
frameRate(3);

 // textFont(createFont("Tahoma",9));
  shade = loadImage("shade3.png");
  high = loadImage("high.png");
  //smooth();
  //frame.setLocation(0,screen.height-height); //works 
mm = new GSMovieMaker(this,width,height,"out/out.avi",GSMovieMaker.X264,GSMovieMaker.BEST,25);
if(rec)
	mm.start();
}


void draw(){
  float w = node[0].w;
  background(15); //#5a6a7a
  
   pushMatrix();
    translate(-((node[node.length-1].x+node[node.length-1].tx)/2.0f)+width/2,
    -((node[node.length-1].y+node[node.length-1].ty)/2.0f)+height/2);
  for(int i = 0;i < node.length;i++){
      
      
    /*image(shade,node[which].x-shade.width/4+(1.5*w),node[which].y-shade.height/4+(1.5*w),
     shade.width/2,shade.height/2);
     */
   
     node[i].run();
     
    
   // fill(255,155);
   // text("#"+(node.length-i),(int)node[i].x+3*w,(int)node[i].y);

    if(mousePressed&&node[i].over()){
      node[i].sendGen(node[i].which);
      mousePressed=false;
    }
  }
   popMatrix();

if(rec){
		loadPixels();
		mm.addFrame(pixels);
if(frameCount>25*60*5){
mm.dispose();
		exit();
}
	}

}

void keyPressed(){
	if(key == 'q'){

		if(rec){
			mm.finish();
		}
		mm.dispose();
		exit();

	}
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
// Learning Processing
// Daniel Shiffman
// http://www.learningprocessing.com

// Example 15-13: Sharpen with convolution
/*
 int xstart = constrain(mouseX-w/2,0,img.width); 
  int ystart = constrain(mouseY-w/2,0,img.height);
  int xend = constrain(mouseX + w/2,0,img.width);
  int yend = constrain(mouseY + w/2,0,img.height);
  */

boolean rec = true;
Recorder r;

int xstart = 0;
int ystart = 0;
int xend;
int yend;

PImage img;
PGraphics g;
int w = 80;
// The convolution matrix for a "sharpen" effect stored as a 3 x 3 two-dimensional array.
float[][] matrix = { { -.01, -.1, -.01 } ,
                     { -.1, 1.44, -.1 } ,
                     { -.01, -.1, -.01 } } ;
float calib = 0;
float[][] matrix2 = { { -.01+calib, -.1+calib, -.01+calib } ,
                      { -.1+calib, 1.44+calib, -.1+calib } ,
                      { -.01+calib, -.1+calib, -.01+calib } } ;

int matrixsize = 3;

void setup() {
	img = loadImage( "bratri.png" );
	xend = img.width;
	yend = img.height;
	g = createGraphics(img.width,img.height,JAVA2D);
	g.beginDraw();
	g.image(img,0,0);
	g.endDraw();

	r = new Recorder("out","convlutionOne.mp4");

	size(img.width,img.height);
}

void draw() {

	// We're only going to process a portion of the image
	// so let's set the whole image as the background first
	//image(img,0,0);

	// In this example we are only processing a section of the image-an 80 x 80 rectangle around the mouse location.




	if(frameCount%10==0){
		if(rec){
			r.add();

		}
		//g.filter(INVERT);
		g.filter(BLUR,4);

	}
	
	for
	
	g.loadPixels();
	g.beginDraw();
	PImage tmp = (PImage)g;
	// Begin our loop for every pixel
	for (int x = xstart; x < xend; x++ ) {
		for (int y = ystart; y < yend; y++ ) {
			// Each pixel location (x,y) gets passed into a function called convolution()
			// The convolution() function returns a new color to be displayed.
			color c = convolution2(x,y,matrix2,matrixsize,tmp);
			int loc = x + y*img.width;
			g.pixels[loc] = c;
		}
	}
	g.updatePixels();
	g.endDraw();

	image(g,0,0);




	// rect(xstart,ystart,w,w);
}

void keyReleased(){
	if(key=='q'){
		if(rec){
			r.finish();

		}
		exit();
	}

}

void mousePressed(){



	// loadPixels();
	if(frameCount%10==0)
		g.filter(BLUR,2.0);

	g.loadPixels();
	g.beginDraw();
	// Begin our loop for every pixel
	for (int x = xstart; x < xend; x++ ) {
		for (int y = ystart; y < yend; y++ ) {
			// Each pixel location (x,y) gets passed into a function called convolution()
			// The convolution() function returns a new color to be displayed.
			color c = convolution(x,y,matrix,matrixsize,(PImage)g);
			int loc = x + y*img.width;
			g.pixels[loc] = c;
		}
	}
	g.updatePixels();
	g.endDraw();



	stroke(0);
	noFill();

}

color convolution(int x, int y, float[][] matrix, int matrixsize, PImage img) {
	float rtotal = 0.0;
	float gtotal = 0.0;
	float btotal = 0.0;
	int offset = matrixsize / 2;

	// Loop through convolution matrix
	for (int i = 0; i < matrixsize; i++ ) {
		for (int j = 0; j < matrixsize; j++ ) {

			// What pixel are we testing
			int xloc = x + i-offset;
			int yloc = y + j-offset;
			int loc = xloc + img.width*yloc;

			// Make sure we haven't walked off the edge of the pixel array
			// It is often good when looking at neighboring pixels to make sure we have not gone off the edge of the pixel array by accident.
			loc = constrain(loc,0,img.pixels.length-1);

			// Calculate the convolution
			// We sum all the neighboring pixels multiplied by the values in the convolution matrix.
			rtotal += (red(img.pixels[loc]) * matrix[i][j]);
			gtotal += (green(img.pixels[loc]) * matrix[i][j]);
			btotal += (blue(img.pixels[loc]) * matrix[i][j]);
		}
	}

	// Make sure RGB is within range
	rtotal = constrain(rtotal,0,255);
	gtotal = constrain(gtotal,0,255);
	btotal = constrain(btotal,0,255);

	// Return the resulting color
	return color(rtotal,gtotal,btotal);
}

color convolution2(int x, int y, float[][] matrix, int matrixsize, PImage img) {
	float rtotal = 0.0;
	float gtotal = 0.0;
	float btotal = 0.0;
	int offset = matrixsize / 2;

	// Loop through convolution matrix
	for (int i = 0; i < matrixsize; i++ ) {
		for (int j = 0; j < matrixsize; j++ ) {

			// What pixel are we testing
			int xloc = x + i-offset;
			int yloc = y + j-offset;
			int loc = xloc + img.width*yloc;

			// Make sure we haven't walked off the edge of the pixel array
			// It is often good when looking at neighboring pixels to make sure we have not gone off the edge of the pixel array by accident.
			loc = constrain(loc,0,img.pixels.length-1);

			// Calculate the convolution
			// We sum all the neighboring pixels multiplied by the values in the convolution matrix.
			rtotal += (red(img.pixels[loc]) * matrix2[i][j]);
			gtotal += (green(img.pixels[loc]) * matrix2[i][j]);
			btotal += (blue(img.pixels[loc]) * matrix2[i][j]);
		}
	}

	// Make sure RGB is within range
	rtotal = constrain(rtotal,0,255);
	gtotal = constrain(gtotal,0,255);
	btotal = constrain(btotal,0,255);

	// Return the resulting color
	return color(rtotal,gtotal,btotal);
}

import codeanticode.gsvideo.*;
import imageadjuster.*;

//Translator tr;
GSPipeline cam;
ImageAdjuster adjust;
Recorder r;

//PImage store;
//Deconstructor a;
PGraphics result;
int W = 320;
int H = 240;
int matrix[];

PImage temp;


void init() {
	/// to make a frame not displayable, you can
	// use frame.removeNotify()
	frame.removeNotify();

	frame.setUndecorated(true);

	// addNotify, here i am not sure if you have
	// to add notify again.
	frame.addNotify();
	super.init();
}



void setup(){

	//store = loadImage("screen.png");
	//a = new Deconstructor(store);
	size(W,H,P2D);
	adjust = new ImageAdjuster(this);
	//cam = new GSCapture(this,720,576,"v4lsrc");
	//result = createGraphics(width,height,P2D);
	//aspectratiocrop aspect-ratio=16/9
	//aspectratiocrop aspect-ratio=5/4 !
	cam = new GSPipeline(this,"v4l2src ! ffmpegcolorspace ! videoscale ! video/x-raw-rgb ,width = "+ W +",height = "+ H +", bpp=32, depth=24");
	r = new Recorder("out","movingSomething.mp4");
	frameRate(15);
	noStroke();
	stroke(255,25);
	noSmooth();

	readCam();
}

void draw(){


}

void keyPressed(){

	if(key==' '){
		readCam();
		r.add();
	}else if(key =='q'){
		r.finish();
		exit();

	}

}

void readCam(){
	if (cam.available() == true) {
		try{
			cam.read();
			//temp = cam;

			//temp.filter(GRAY);
			cam.filter(GRAY);

			adjust.brightness(cam,0, 0, width,height, 0.1);
			adjust.contrast(cam,0, 0, width,height, 2);
			//temp.filter(BLUR,5);
			//adjust.contrast(cam,0,0,width,height,3);
			//adjust.contrast(temp,0,0,width,height,3);

			//temp.filter(BLUR,3);

			//temp.filter(GRAY);

			//cam.filter(GRAY);


			image(cam,0,0);
			cam.filter(BLUR,2);
			blend(cam, 0, 0, width, height, 0, 0, width, height, OVERLAY);




		}catch(java.lang.NullPointerException e){
			println("weird error! @ "+frameCount);
		}
	}
}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import codeanticode.gsvideo.*;

//Translator tr;
GSPipeline cam;
//PImage store;
//Deconstructor a;
PGraphics result;
int W = 360;
int H = 288;
int matrix[];

boolean check = true;

import codeanticode.gsvideo.*;



void init() {
  /// to make a frame not displayable, you can 
  // use frame.removeNotify() 
  frame.removeNotify(); 
 
  frame.setUndecorated(true); 
 
  // addNotify, here i am not sure if you have  
  // to add notify again.                                                  
  frame.addNotify(); 
  super.init();
}

void setup(){

	//store = loadImage("screen.png");
	//a = new Deconstructor(store);
	size(W,H,P2D);
	//cam = new GSCapture(this,720,576,"v4lsrc");
	//result = createGraphics(width,height,P2D);
	//aspectratiocrop aspect-ratio=16/9
	cam = new GSPipeline(this,"dv1394src ! dvdemux ! ffdec_dvvideo ! ffmpegcolorspace ! aspectratiocrop aspect-ratio=5/4 ! ffvideoscale, method=6 ! video/x-raw-rgb ,width = "+ W +",height = "+ H +", bpp=32, depth=24");
	
	frameRate(15);
	noStroke();
	stroke(255,25);
	noSmooth();
}

void draw(){
	readCam();
}

void readCam(){
	if (cam.available() == true) {
		try{
			cam.read();
			image(cam,0,0);
		}catch(java.lang.NullPointerException e){
			println("weird error! @ "+frameCount);
		}
	}
}

void keyPressed(){
	if(key == ' '){
		check=!check;
	}

}



PImage in;
PGraphics prep;
PGraphics result;
int W = 15;
int H = 12;
int rW = 360;
int rH = 288;
int matrix[];

void setup(){


	size(rW,rH);
	loadMatrix();

	println(matrix);

	in = loadImage("../noisePdf/out.png");

	prep = createGraphics(rW,rH,JAVA2D);
	prep.beginDraw();
	prep.image(in,0,0,rW,rH);
	prep.endDraw();

	process();



}

void process(){


	int aspect = rW/W;
	int area  =5;
	int pseudoImg[][] = new int[W][H];

	for(int y =0;y<rH;y+=aspect){
		for(int x =0;x<rW;x+=aspect){
			float soucet = brightness(prep.pixels[(y+3)*rW+(x+3)]);
			int count = 1;

			for(int yy = 0;yy<=area;yy++){
				for(int xx = 0;xx<=area;xx++){
					soucet += (brightness(prep.pixels[(y+yy+3)*rW+(x+xx+3)]));
					count ++;
				}
			}
			soucet /= (count+0.0);

			pseudoImg[x/aspect][y/aspect] = (int)soucet;

		}
	}

	PGraphics pima = createGraphics(W,H,P2D);
	pima.beginDraw();
	for(int y =0;y<H;y++){
		for(int x =0;x<W;x++){
			pima.pixels[matrix[y*W+x]] = color(pseudoImg[x][y]);
		}
	}

	pima.endDraw();


	image(pima,0,0,width,height);

	stroke(#FF0000);
	noFill();
	for(int y =0;y<rH;y+=aspect){
		for(int x =0;x<rW;x+=aspect){
fill(pseudoImg[x/aspect][y/aspect]);
			rect(x+3,y+3,area,area);

		}
	}

}


void loadMatrix(){
	String[] tmp = loadStrings("../noisePdf/data/matix"+W+"x"+H+".txt");
	matrix = new int[tmp.length];

	for(int y = 0;y<H;y++){
		for(int x = 0;x<W;x++){
			matrix[y*W+x] = parseInt(tmp[y*W+x]);
		}
	}

}

PImage tex;

Corner c[] = new Corner[4];

void setup(){

	size(640,480,P2D);
	tex = loadImage("screen.png");

	c[0] = new Corner(10.0,10.0,0.0,0.0);
	c[1] = new Corner(width-10.0,10.0,1.0,0.0);
	c[2] = new Corner(width-10.0,height-10.0,1.0,1.0);
	c[3] = new Corner(10.0,height-10.0,0.0,1.0);


	frameRate(25);
	textureMode(NORMALIZED);
	ellipseMode(CENTER);
	stroke(#FFCC00);
	//noFill();


}


void draw(){
	background(0);

	beginShape();
	texture(tex);
	for(int i =0 ;i<c.length;i++){
		c[i].draw();
	}
	endShape();




}
void mouseReleased(){
	for(int i =0 ;i<c.length;i++){
		c[i].over = false;
	}
}


class Corner{
	boolean over;
	float x,y,u,v;

	Corner(float _x,float _y,float _u, float _v){
		x=_x;
		y=_y;
		u=_u;
		v=_v;
	}

	void draw(){
		if(abs(mouseX-x)<10&&abs(mouseY-y)<10&&mousePressed)
			over = true;


		vertex(x,y,u,v);

		if(over){
			x = mouseX;
			y = mouseY;
			ellipse(x,y,10,10);
		}
	}


}
import processing.pdf.*;
PImage store;
PGraphics resiz;

int matrix[];
int W = 360;
int H = 288;


void setup(){


	//store = loadImage("320x240.png");
	size(W,H,P3D);
	makeMatrix2();


	PImage store = loadImage("bratri.png");
	resiz = createGraphics(W,H,JAVA2D);
	resiz.beginDraw();
	resiz.image(store,0,0,W,H);
	resiz.noStroke();
	
	resiz.save("not.png");
	
	resiz.loadPixels();
	for(int y = 0;y<H;y++){
		for(int x = 0;x<W;x++){
			resiz.fill(resiz.pixels[matrix[y*W+x]]);
			resiz.rect(x,y,1,1);
		}
	}
	
	resiz.endDraw();


	resiz.save("out.png");
	
	/*
	store = loadImage("screen60x48.png");

	PGraphics pdf = createGraphics(width,height, PDF, "noise.pdf");
	pdf.beginDraw();
	pdf.background(255);
	pdf.fill(0);
	pdf.noStroke();
	for(int y = 0;y<pdf.height;y++){
		for(int x = 0;x<pdf.width;x++){
			pdf.fill(brightness(store.pixels[matrix[y*pdf.width+x]]));
			pdf.rect(x,y,1,1);
		}
}
	pdf.dispose();
	pdf.endDraw();
	*/

	/*
	loadPixels();
	store.loadPixels();
	for(int y = 0;y<height;y++){
		for(int x = 0;x<width;x++){
			pixels[matrix[y*width+x]] = store.pixels[y*width+x];
		}
}


	PGraphics pdf = createGraphics(width,height, PDF, "noise.pdf");
	pdf.beginDraw();
	pdf.background(255);
	pdf.fill(0);
	pdf.noStroke();
	for(int y = 0;y<pdf.height;y++){
		for(int x = 0;x<pdf.width;x++){
			pdf.fill(brightness(store.pixels[matrix[y*pdf.width+x]]));
			pdf.rect(x,y,1,1);
		}
}
	pdf.dispose();
	pdf.endDraw();
	save("screen.png");
	*/
	exit();



}

void loadMatrix(){
	String[] tmp = loadStrings("matix"+W+"x"+H+".txt");
	matrix = new int[tmp.length];

	for(int y = 0;y<height;y++){
		for(int x = 0;x<width;x++){
			matrix[y*width+x] = parseInt(tmp[y*width+x]);
		}
	}

}
void makeMatrix(){

	String[] newMatrix = new String[width*height];
	int g = 0;


	// Random rgen = new Random();  // Random number generator
	//int[] cards = new int[store.width*store.height];

	int[] novaMatice = new int[0];

	/*  for (int i=0; i<cards.length; i++) {
	    cards[i] = i;
	  }

	  --- Shuffle by exchanging each element randomly
	  for (int i=0; i<cards.length; i++) {
	    int randomPosition = rgen.nextInt(cards.length);
	    int temp = cards[i];
	    cards[i] = cards[randomPosition];
	    cards[randomPosition] = temp;
	  }*/

	for (int i=0; i<width*height; i++) {
		novaMatice = (int[])expand(novaMatice,novaMatice.length+1);

		int newRndm = (int)random(width*height);

		if(i>=width*height-10){
			novaMatice[novaMatice.length-1] = (int)random(5);

		}else{

			boolean isInList = false;
			for(int q = 0;q< novaMatice.length;q++){
				if(novaMatice[q]==newRndm)
					isInList = true;
			}

			if(isInList){
				while(isInList){
					newRndm = (int)random(width*height);

					isInList = false;
					for(int q = 0;q< novaMatice.length;q++){
						if(novaMatice[q]==newRndm)
							isInList = true;
					}
				}
			}

			novaMatice[novaMatice.length-1] = newRndm;
		}
		if(i%1000==0)
			println(i);

	}


	for (int i=0; i<width*height; i++) {
		newMatrix[i] = novaMatice[i]+"";
	}

	matrix = novaMatice;
	saveStrings("data/matix"+W+"x"+H+".txt",newMatrix);
	saveStrings("../translator/data/matix"+W+"x"+H+".txt",newMatrix);

}


void makeMatrix2(){

	Random rgen = new Random();
	int[] novaMatice = new int[W*H];
	matrix = new int[W*H];

	for (int i=0; i<novaMatice.length; i++) {
		novaMatice[i] = i;
	}

	//--- Shuffle by exchanging each element randomly
	for (int i=0; i<novaMatice.length; i++) {
		int randomPosition = rgen.nextInt(novaMatice.length);
		int temp = novaMatice[i];
		novaMatice[i] = novaMatice[randomPosition];
		novaMatice[randomPosition] = temp;
	}
	
	String newMatrix[] = new String[W*H];
	for(int i =0;i<newMatrix.length;i++){
		newMatrix[i] = novaMatice[i]+"";
		matrix[i] = novaMatice[i];
	}

	saveStrings("data/matix"+W+"x"+H+".txt",newMatrix);
	saveStrings("../translator/data/matix"+W+"x"+H+".txt",newMatrix);


}

Recorder r;

void setup(){
	size(360,288,P2D);
	r = new Recorder("out","pureNoise.mp4");
}


void draw(){

	loadPixels();
	for(int i =0;i<pixels.length;i++){
	pixels[i] = color(random(255));
	}
	r.add();
	
	if(frameCount>(25*60)){
	r.finish();
	exit();
		
	}



}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

Recorder r;

void setup(){
	size(360,288,OPENGL);
	r = new Recorder("out","test.mp4");
	noStroke();
	fill(0);
}

void draw(){

	background(255);
	
	
	translate(width/2,height/2);
	rotate(radians(frameCount));
	rect(-width,0,width*2,height*2);

	r.add();
	
	if(frameCount>300){
	
		r.finish();
		exit();
	}

}

void keyPressed(){
	if(key == ' '){
	save("screen.png");
	}

}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}


//make imports

import codeanticode.gsvideo.*;

//init cam instance

GSPipeline cam;
PGraphics result;

// some vars
int W = 360;
int H = 288;
int rW = 360;
int rH = 288;
//aspect ratio
String pomer = "500/403";
//matrixes for translation
int matrix[];
int korekce[];
//manipulation
int res = 1;
int bor = 5;

int aspect = 1;
int area  = 1;

int check = 0;

import codeanticode.gsvideo.*;



void init() {
	frame.removeNotify();

	frame.setUndecorated(true);

	// addNotify, here i am not sure if you have
	// to add notify again.
	frame.addNotify();
	super.init();
}

void setup(){

	//store = loadImage("screen.png");
	//a = new Deconstructor(store);
	size(rW,rH);
	//cam = new GSCapture(this,720,576,"v4lsrc");
	result = createGraphics(W,H,P2D);

	loadMatrix("matix"+W+"x"+H+".txt");
	// ! ffdeinterlace
	//cam = new GSPipeline(this,"v4l2src ! ffmpegcolorspace ! videoscale ! video/x-raw-rgb ,width = "+ W +",height = "+ H +", bpp=32, depth=24 ");

	/*
	cam = new GSPipeline(this,"v4l2src ! ffmpegcolorspace ! videoscale ! video/x-raw-rgb ,width = "+ W +",height = "+ H +", bpp=32, depth=24 "");
	*/

	cam = new GSPipeline(this,"dv1394src ! dvdemux ! ffdec_dvvideo ! queue ! ffmpegcolorspace ! aspectratiocrop aspect-ratio="+pomer+" ! ffvideoscale method=0 ! video/x-raw-rgb ,width = "+ rW +",height = "+ rH +", bpp=32, depth=24");
	/*
	cam = new GSPipeline(this,"dv1394src ! dvdemux ! ffdec_dvvideo !  ffmpegcolorspace ! video/x-raw-rgb ,width = "+ W +",height = "+ H +", bpp=32, depth=24 ");

	*/

	//tr = new Translator(10);
	frameRate(15);
	noStroke();
	stroke(255,25);
	noSmooth();
}


void loadMatrix(String _which){
	String[] tmp = loadStrings(_which);
	matrix = new int[tmp.length];

	for(int i =0;i<W*H;i++){
		matrix[i] = parseInt(tmp[i]);
	}

}


void draw(){
	//background(0);
	fill(0,25);
	rect(0,0,width,height);

	readCam();


	//stroke(random(255),random(255),random(255),60);
	//a.draw();
	//tr.draw();


}

void readCam(){
	if (cam.available() == true) {
		try{
			cam.read();


			if(check ==1){
				int pseudoImg[][] = new int[W+1][H+1];

				for(int y =0;y<rH;y+=aspect){
					for(int x =0;x<rW;x+=aspect){
						float soucet = brightness(cam.pixels[(y)*rW+(x)]);
						
						//sizing here
						/*
						int count = 1;

						for(int yy = 0;yy<=area;yy++){
							for(int xx = 0;xx<=area;xx++){
								soucet += (brightness(cam.pixels[(y+yy)*rW+(x+xx)]));
								count ++;
							}
						}
						soucet /= (count+0.0);
						*/

						pseudoImg[x/aspect][y/aspect] = (int)soucet;

					}
				}

				PGraphics pima = createGraphics(W,H,P2D);
				pima.beginDraw();
				for(int y =0;y<H;y++){
					for(int x =0;x<W;x++){
						pima.pixels[matrix[y*W+x]] = color(pseudoImg[x][y]);
					}
				}

				pima.endDraw();

				image(pima,0,0,width,height);


			}else if(check == 0){

				image(cam,0,0);

				/*stroke(#FF0000);
				noFill();
				for(int y =0;y<rH;y+=aspect){
					for(int x =0;x<rW;x+=aspect){
						
						rect(x+3,y+3,area,area);
					}
					}*/
			}
			/*result.beginDraw();
						int g = 0;

						for(int y =0;y<H;y+=res){
							for(int x =0;x<W;x+=res){

								for(int a =0;a<res;a++){
									for(int b =0;b<res;b++){
										int pix = cam.pixels[y*W+x];
										int pixCoded = cam.pixels[matrix[y*W+x]];
										
										if((x<bor||x>W-bor||y<bor||y>H-bor)&&check==0)
											result.pixels[(y+a)*W+(x+b)]=pix;
										else if(check == 0 || check == 1)
											result.pixels[(y+a)*W+(x+b)]=pixCoded;

										if(check==2)
											result.pixels[(y+a)*W+(x+b)]=pix;
										g++;
									}
								}
							}
						}
						result.endDraw();
			*/


		}catch(java.lang.NullPointerException e){
			println("weird error! @ "+frameCount);
		}
	}
}

void keyPressed(){
	if(key == ' '){
		check++;
		check = check%2;

	}if (keyCode == UP){
		res++;

	}else if(keyCode == DOWN){
		res --;
	}

	res = constrain(res,1,100);

}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
/**
 * Loop. 
 * Built-in video library replaced with gsvideo by Andres Colubri
 * 
 * Move the cursor across the screen to draw. 
 * Shows how to load and play a QuickTime movie file.  
 */

import codeanticode.gsvideo.*;

GSMovie myMovie;

int matrix[];
PGraphics temp;

Recorder r;
boolean rec = true;

int W = 360;
int H = 288;
Corner c[] = new Corner[4];

boolean gotImage = false;

void setup() {
	size(W, H, P2D);
	background(0);
	// Load and play the video in a loop
	temp = createGraphics(W,H,P2D);
	//che = loadImage("screen.png");
	loadMatrix();
	frameRate(15);

	//makeCheckImage();
	/*
		textureMode(NORMALIZED);
		ellipseMode(CENTER);
		noStroke();

		c[0] = new Corner(10.0,10.0,0.0,0.0);
		c[1] = new Corner(width-10.0,10.0,1.0,0.0);
		c[2] = new Corner(width-10.0,height-10.0,1.0,1.0);
		c[3] = new Corner(10.0,height-10.0,0.0,1.0);
	*/
	myMovie = new GSMovie(this, "order.mp4");
	myMovie.loop();

	if(rec)
		r = new Recorder("out","disorder.mp4");

	println("setup done, matrix got len.: "+matrix.length);
}

void movieEvent(GSMovie myMovie) {
	myMovie.read();
	gotImage = true;
}

/*
void makeCheckImage(){

	che.loadPixels();
	for(int y = 0;y<H;y++){
		for(int x = 0;x<W;x++){
			che.pixels[matrix[y*W+x]] = che.pixels[y*W+x];

		}
	}

	temp.save("checker.png");


}*/

void loadMatrix(){
	String[] tmp = loadStrings("matix"+W+"x"+H+".txt");
	matrix = new int[tmp.length];

	for(int y = 0;y<H;y++){
		for(int x = 0;x<W;x++){
			matrix[y*W+x] = parseInt(tmp[y*W+x]);
		}
	}

}

void draw() {

	//background(0);

	if(gotImage){

		temp.beginDraw();
		temp.image(myMovie,0,0);
		temp.endDraw();


		temp.loadPixels();
		for(int y = 0;y<H;y++){
			for(int x = 0;x<W;x++){
				temp.pixels[y*W+x] = myMovie.pixels[matrix[y*W+x]];

			}
		}


		image(temp,0,0,width,height);


		if(rec)
			r.add();
	}
	gotImage = false;


	/*
		beginShape();
		texture(temp);
		for(int i =0 ;i<c.length;i++){
			c[i].draw();
		}
		endShape();
		*/
}

void mouseReleased(){
	for(int i =0 ;i<c.length;i++){
		c[i].over = false;
	}
}

void keyPressed(){
	if(key == 'q'){
		r.finish();
		exit();

	}

}


class Corner{
	boolean over;
	float x,y,u,v;

	Corner(float _x,float _y,float _u, float _v){
		x=_x;
		y=_y;
		u=_u;
		v=_v;
	}

	void draw(){
		if(abs(mouseX-x)<15&&abs(mouseY-y)<15&&mousePressed)
			over = true;


		vertex(x,y,u,v);

		if(over){
			x = mouseX;
			y = mouseY;
			ellipse(x,y,15,15);
		}
	}


}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

Recorder r;

int matrix[];
int W = 360;
int H = 288;

int sel = 0;
int X=0,Y=0;

PGraphics marks;

void init() {
  /// to make a frame not displayable, you can 
  // use frame.removeNotify() 
  frame.removeNotify(); 
 
  frame.setUndecorated(true); 
 
  // addNotify, here i am not sure if you have  
  // to add notify again.   
  frame.addNotify(); 
  super.init();
}

void setup(){

	size(W,H,OPENGL);
	loadMatrix();
	
	r = new Recorder("out","order.mp4");

	marks = createGraphics(W,H,P2D);
	marks.beginDraw();
	marks.background(0);
	marks.stroke(255);
	marks.point(getPosition(matrix[sel])[0],getPosition(matrix[sel])[1]);
	marks.endDraw();



}


void draw(){
	image(marks,0,0);
	for(int i =1;i<20;i++){
		arrow(X+i,Y,getPosition(matrix[sel+i])[0],getPosition(matrix[sel+i])[1],(int)(255-(i*10)));

	}
	if(frameCount%3==0){
		
		
		marks.beginDraw();
		//marks.stroke(255);
		//marks.point(getPosition(matrix[sel])[0],getPosition(matrix[sel])[1]);
		marks.stroke(255,20);

		marks.line(X,Y,getPosition(matrix[sel])[0],getPosition(matrix[sel])[1]);
		marks.noStroke();
		marks.fill(255,20);

		marks.pushMatrix();
		marks.translate(getPosition(matrix[sel])[0],getPosition(matrix[sel])[1]);
		marks.rotate(atan2(getPosition(matrix[sel])[1]-Y,getPosition(matrix[sel])[0]-X)+HALF_PI);
		marks.triangle(0,0,-3,8,3,8);
		marks.popMatrix();
		marks.endDraw();
		

		X+=10;
		sel+=10;
	}

	if(X>=width){
		X=0;
		Y+=10;
	}

	if(Y >= height){
		r.finish();
		exit();
	}
	
	r.add();

}

void keyPressed(){
	if(key == 'q'){
		r.finish();
		exit();
	
	
	}

}

int[] getPosition(int pos){
	int[] res = {(pos%width),(int)(pos/(width+0.0))};
	return res;

}

void arrow(int x,int y, int x2, int y2,int alp){
	stroke(255,alp);

	line(x,y,x2,y2);
	noStroke();
	fill(255,alp);

	pushMatrix();
	translate(x2,y2);
	rotate(atan2(y2-y,x2-x)+HALF_PI);
	triangle(0,0,-2,9,2,9);
	popMatrix();



}


void loadMatrix(){
	String[] tmp = loadStrings("../translator/data/matix"+W+"x"+H+".txt");
	matrix = new int[tmp.length];

	for(int y = 0;y<tmp.length;y++){

		matrix[y] = parseInt(tmp[y]);

	}
	println("matrix.loaded");

}

int num = 550;
Kriz k[];

void setup(){

	size(320,240,OPENGL);

	k = new Kriz[num];
	for(int i =0;i<k.length;i++)
		k[i] = new Kriz();

	background(0);
	stroke(255,20);
	smooth();
}

void draw(){
	background(0);

	for(int i =0;i<k.length;i++)
		k[i].draw();

}


class Kriz{

	float theta = 0;
	float speed = 0;
	float x,y,w,l;

	Kriz(){
		speed = random(115,120);
		w = 3;
		l = 20;
		x = random(w,width-w);
		y=  random(w,height-w);
	}

	void draw(){
		theta += sin(frameCount/speed);

		//pushMatrix();
		//translate(random(-2,2),random(-2,2));
		cross(x,y,w,l,theta);
		//popMatrix();

	}

	void cross(float x,float y,float b,float vel,float t){
		pushMatrix();
		translate(x,y);
		rotate(radians(t));
		strokeWeight(b);
		line(-vel,0,vel,0);
		line(0,-vel,0,vel);
		popMatrix();
	}



}
import codeanticode.gsvideo.*;

GSPipeline pipe;

void setup()
{
	size(320, 240,P2D);


	pipe = new GSPipeline(this,"dv1394src ! dvdemux ! ffdec_dvvideo ! ffdeinterlace ! ffmpegcolorspace ! videoscale  ! video/x-raw-rgb ,width = 100, bpp=32, depth=24 ");

	frameRate(25);
	println("pipe created!");

	background(255);
}

void draw() {
	if (pipe.available() == true) {
		// println("got frame!");
		pipe.read();
		image(pipe, 0, 0);
	}


}

Agent a[];
float sila = 1.0;
float sila2 = 10.0;

float prostredi = 0.98;
float hmotnost = 1000.0;

void setup(){
	size(400,400,OPENGL);

	a = new Agent[150];

	reset();
	noSmooth();
	background(0);
}

void mousePressed(){
	reset();

}

void reset(){

	for(int i = 0;i<a.length;i++)
		a[i] = new Agent(random(width),random(height),0,i);
}


void draw(){

	background(0);


	for(int i = 0;i<a.length;i++)
		a[i].act();

	for(int i = 0;i<a.length;i++)
		a[i].apply();

}


class Agent{

	int id;
	float x,y,z;
	float radius = 120;//.0;
	float radius2 = 80.0;
	PVector move;
	boolean pN[],oN[];
	


	Agent(float _x,float _y,float _z,int _id){
		move = new PVector( 0,0,0 );
		x = _x;
		y = _y;
		z = _z;
		id = _id;
		oN = new boolean[a.length];
		pN = new boolean[a.length];
		//hmotnost = random(10,100.0);
	}

	void act(){

		radius2 = map(mouseY,0,height,3,radius);

		int p = 0;
		int o = 0;

		for(int i =0;i<a.length;i++){
			if(i!=id){
				
				pN[i] = false;
				oN[i] = false;
				if(dist(x,y,z,a[i].x,a[i].y,a[i].z)<radius2){
					
					pN[i] = true;
					p++;
					
				}
				
				if(dist(x,y,z,a[i].x,a[i].y,a[i].z)<radius){
					
					oN[i] = true;
					o++;
				}


			}
		}




		float len = radius2;
		PVector pritazl[] = new PVector[p];
		PVector odpuzl[] = new PVector[o];
		o = p = 0;
		for(int i = 0;i<a.length;i++){
			if(pN[i]){
				len = dist(a[i].x,a[i].y,a[i].z,x,y,z);
				pritazl[p] = new PVector(a[i].x-x,a[i].y-y,a[i].z-z);
				pritazl[p].normalize();
				pritazl[p].mult( sila * (radius-len)/radius/hmotnost );
				move.add(pritazl[p]);
				p++;
			}

			if(oN[i]){
				len = dist(a[i].x,a[i].y,a[i].z,x,y,z);
				odpuzl[o] = new PVector(x-a[i].x,y-a[i].y,z-a[i].z);
				odpuzl[o].normalize();
				odpuzl[o].mult( sila2 * (radius2-len)/radius2/hmotnost );
				move.add(odpuzl[o]);
				o++;
				
				//line(a[i].x,a[i].y,a[i].z,x,y,z);
			}
		}
	}

	void apply(){
		move.mult(prostredi);
		x += move.x;
		y += move.y;
		z += move.z;

		bordr();
		
		draw();

	}

	void draw(){


		noFill();
		stroke(255,40);

		pushMatrix();
		translate(x,y,z);
		box(2);

		popMatrix();


	}
	
	void bordr(){
	
	
		x=constrain(x,0,width);
		y=constrain(y,0,width);
		z=constrain(z,0,width);
	
	
	
	}






}
import net.sf.fann.*;
import net.sf.fann.swig.*;


static {
	    System.loadLibrary("fann");
	}	
	
	public static final long numNeuronsHidden = 4;
	public static final long numOutput = 1;
	public static final float desiredError = 0.0001f;
	public static final long maxNeurons = 40;
	public static final long neuronsBetweenReports = 1;
	public static double[] steepness = new double[] {0.1,0.2,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1};


void setup(){


}

public void testCascadingTrainging() {
		// load and scale the training and test data
		TrainingData trainData = new TrainingData("two-spiral.train");
		TrainingData testData = new TrainingData("two-spiral.test");
		trainData.scale(0, 1);
		testData.scale(0, 1);
		
		// configure the network
		NeuralNet ann = new NeuralNet(true, new long[] {trainData.getNumInput(), trainData.getNumOutput()});
		ann.setActivationFunctionForAllHidden(ActivationFunction.SIGMOID_SYMMETRIC);
		ann.setActivationFunctionForOutput(ActivationFunction.SIGMOID_SYMMETRIC);
		ann.setActivationSteepnessForAllHidden(0.5);
		ann.setActivationSteepnessForOutput(0.5);
		
		// configure the training
		CascadeTraining training = new CascadeTraining(ann);
		training.setTrainingAlgorithm(TrainingAlgorithm.RPROP);
		training.setTrainingErrorFunction(ErrorFunction.LINEAR);
		training.setRPropIncreaseFactor(1.2f);
		training.setRPropDecreaseFactor(0.5f);
		training.setRPropDeltaMin(0.0f);
		training.setRPropDeltaMax(50.0f);

		// configure the cascading training
		training.setOutputChangeFraction(0.01f);
		training.setOutputStagnationEpochs(12);
		training.setCandidateChangeFraction(0.01f);
		training.setCandidateStagnationEpochs(12);
		training.setCandidateLimit(1000.0f);
		training.setWeightMultiplier(0.4);
		training.setMaxOutEpochs(150);
		training.setMaxCandEpochs(150);
		training.setActivationSteepnesses(steepness);
		training.setNumCandidateGroups(1);

		// print the config
		ann.printParameters();
		
		training.train(trainData, maxNeurons, neuronsBetweenReports, desiredError);
		
		ann.printConnections();

		System.out.printf("\nTrain error: %f, Test error: %f\n\n", training.test(trainData), training.test(testData));

		ann.save("java/src/data/two-spiral.net");
	}
Recorder r;
boolean rec  = false;
float hust = 0.0;

PGraphics one,two;

void setup(){

	size(320,320,OPENGL);
	noStroke();
	frameRate(25);

	//one = createGraphics(width,height,P2D);
	//two = createGraphics(width,height,P2D);
	smooth();

	r = new Recorder("out","haluz2.mp4");

}


void draw(){

	background(255);

	haluz(frameCount);
	//haluz(-frameCount*6.28,two);

	//image(one,0,0);
	//blend(two,0,0,width,height,0,0,width,height,ADD);

	hust = (sin(frameCount/130.0)+2.5)*3.14;


	if(rec)
		r.add();

}

void keyPressed(){
	if(key == 'q'){

		if(rec)
			r.finish();
		exit();

	}

}

void haluz(float theta){
	int g = 0;
	int lasti = 0;
	pushMatrix();
	translate(width/2.0,height/2.0);
	rotate(radians(theta));

	
	for(int i =0;i<width*2;i+=5){
		if(g%2==0)
			fill(255);
		else
			fill(0);
		
		ellipse(cos(g/hust)*(2*width-i)/10.0,sin(g/hust)*(2*width-i)/10.0,2*width-i,2*width-i);
		g++;
		lasti=i;

	}	
	popMatrix();
	

}

void haluz(float theta,PGraphics a){

	a.beginDraw();
	a.background(255);
	a.smooth();
	a.noStroke();
	a.pushMatrix();
	a.translate(width/2.0,height/2.0);
	a.rotate(radians(theta));

	int g = 0;
	for(int i =0;i<width;i+=10){
		if(g%2==0)
			a.fill(255);
		else
			a.fill(0);

		a.ellipse(cos(g/hust)*20.0,sin(g/hust)*20.0,width-i,width-i);
		g++;

	}

	a.popMatrix();
	a.endDraw();


}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="40000K";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
String path = "Okabu.txt";//"/mnt/lan/PESEK/PublicFolder/Okabu.txt";
String Input[] = new String[0];
String Output[];

BB[] bb = new BB[0];
int GLOB_ID = 0;

float Gcx,Gcy,Gcz;

int zoom = 100;

boolean debug = true;
boolean show = true;

float scalar = 0.1;

PVector camPos;

PMatrix3D cam2;
int R = 100;

void setup(){

	size(320,240,OPENGL);
	background(0);

	//println(PFont.list());

	textFont(createFont("Pixel Classic",8));
	fill(255);
	stroke(255);
	cam2 = new PMatrix3D();

	////////////////////////////////////////////////////////////
	addMouseWheelListener(new java.awt.event.MouseWheelListener() {
	                      public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
		                      int notches = evt.getWheelRotation();
		                      if(notches!=0){
			                      zoom+=(int)(notches*10);}}});
	////////////////////////////////////////////////////////////

}




void draw(){
	background(0);


	if(bb.length>0&&show){


		if((abs(pmouseX-mouseX)/100.0)<0.5&&(abs(pmouseY-mouseY)/100.0)<0.5){
			cam2.rotateX( (mouseY-pmouseY)/100.0 );
			cam2.rotateZ( (pmouseX-mouseX)/100.0 );
		}

		PVector x = cam2.mult(new PVector(1, 0, 0), new PVector(0, 0, 0));
		PVector y = cam2.mult(new PVector(0, 0, 1), new PVector(0, 0, 0));
		PVector d = x.cross(y); d.normalize(); d.mult(zoom);

		camera(d.x+Gcx, d.y+Gcy, d.z+Gcz,0+Gcx, 0+Gcy, 0+Gcz, 0, 0 ,1 );

		/*
		// camera !!
		camera(
		        //(sin(mouseX/(100.0))*zoom+Gcx) + (sin(mouseY/(100.0))*zoom) , (cos(mouseX/(100.0))*zoom+Gcy) + (cos(mouseY/(100.0))*zoom), sin(mouseY/(100.0))*zoom+Gcz,
		        camPos.x,camPos.y,camPos.z,
		        Gcx,Gcy,Gcz,
		        0.0,0.0,1.0);

		*/
		noFill();
		stroke(255,120);
		for(int i = 0;i<bb.length;i++)
			bb[i].draw();


		camera();

		//camPos = rotateAxis(camPos, new PVector(0,1,0), mouseX);


	}

	if(Input.length>0&&debug){
		fill(255,120);
		for(int i = 0;i<Input.length;i++)
			text(Input[i],10,i*9+10);

	}

}

void keyPressed(){

	if(key == ' '){
		loadInput();
	}else if(key =='d'){
		debug = !debug;
	}else if(key =='s'){
		show = !show;
	}

}

void loadInput(){

	Input = new String[0];
	Input = loadStrings(path);

	if(Input.length>0){

		resetBB();

		for(int i = 0;i<Input.length;i++){
			float parser[] = new float[7];
			String[] temp = splitTokens(Input[i]," ,");
			parser[0] = parseFloat(temp[0])*scalar;
			parser[1] = parseFloat(temp[1])*scalar;
			parser[2] = parseFloat(temp[2])*scalar;
			parser[3] = parseFloat(temp[3])*scalar;
			parser[4] = parseFloat(temp[4])*scalar;
			parser[5] = parseFloat(temp[5])*scalar;
			parser[6] = parseFloat(temp[6])*scalar;
			bb = (BB[])expand(bb,bb.length+1);
			bb[bb.length-1] = new BB(parser[0],parser[1],parser[2],parser[3],parser[4],parser[5],parser[6]);

		}

		float[] centers = getCenterOfObjects();
		Gcx = centers[0];
		Gcy = centers[1];
		Gcz = centers[2];

		camPos = new PVector(0,-10,0);

		println("Gcx = "+Gcx+",Gcy = "+Gcy+",Gcz = "+Gcz);

	}

	//println(Input);

}

void resetBB(){
	bb = new BB[0];
	GLOB_ID = 0;
}

float[] getCenterOfObjects(){

	float x,y,z;

	if(bb.length>0){
		x = bb[0].cx;
		y = bb[0].cy;
		z = bb[0].cz;

		for(int i = 1;i<bb.length;i++){
			x += bb[i].cx;
			y += bb[i].cy;
			z += bb[i].cz;
		}

		x /= (bb.length+0.0);
		y /= (bb.length+0.0);
		z /= (bb.length+0.0);

		return new float[]{x,y,z};
	}else{
		return null;
	}


}

class BB{
	float x,y,z,x2,y2,z2,cx,cy,cz;
	float val;
	int id;

	BB(float _x,float _y,float _z,float _x2,float _y2,float _z2,float _val){
		id = GLOB_ID;
		GLOB_ID ++;

		x = _x;
		y = _y;
		z = _z;
		x2 = _x2;
		y2 = _y2;
		z2 = _z2;
		val = _val;

		cx = (x+x2)/2.0;
		cy = (y+y2)/2.0;
		cz = (z+z2)/2.0;

		println(id+" comes alive!");

	}

	void draw(){

		pushMatrix();
		translate(cx,cy,cz);
		box(abs(x-x2),abs(y-y2),abs(z-z2));

		popMatrix();
	}




}

PVector rotateAxis(PVector v, PVector _axis,float ang)
{
	PVector axis=new PVector(_axis.x,_axis.y,_axis.z);
	PVector vnorm=new PVector(v.x,v.y,v.z);
	float _parallel= axis.dot(v);
	axis.mult(_parallel);
	PVector parallel= axis;
	parallel.sub(v);
	PVector perp= parallel;
	PVector Cross= v.cross(axis);
	Cross.mult(sin(-ang));
	perp.mult(cos(-ang));
	PVector result = new PVector(0,0,0);
	result.add(parallel);
	result.add(Cross);
	result.add(perp);
	return result;
}
import netP5.*;
import oscP5.*;

  
oscP5.OscP5 oscP5;
netP5.NetAddress myRemoteLocation;

void setup() {
  size(400,400);
  frameRate(25);
  
  oscP5 = new oscP5.OscP5(this,111);
  
}


void draw() {
  background(0);  
}

void mousePressed() {
 
  OscMessage myMessage = new OscMessage("/test");
  
  myMessage.add(123);

}



void oscEvent(OscMessage theOscMessage) {
 
  print("### received an osc message.");
  print(" addrpattern: "+theOscMessage.addrPattern());
  println(" typetag: "+theOscMessage.typetag());
}
import supercollider.*;

Synth synth;

void setup ()
{
    size(800, 200);

    // uses default sc server at 127.0.0.1:57110    
    // does NOT create synth!
    synth = new Synth("sine");
    
    // set initial arguments
    synth.set("amp", 0.5);
    synth.set("freq", 80);
    
    // create synth
    synth.create();
}

void draw ()
{
    background(0);
    stroke(255);
    line(mouseX, 0, mouseX, height);
}

void mouseMoved ()
{
    synth.set("freq", 40 + (mouseX * 3)); 
}

void stop ()
{
    synth.free();
}


void setup(){


   List<String> lista = new ArrayList();
    
    // Add elements to list
    
    // Shuffle the elements in the list
    Collections.shuffle(lista);
    
    // Create an array
    String[] array = new String[]{"a", "b", "c"};
    
    // Shuffle the elements in the array
    Collections.shuffle(Arrays.asList(array));

    println(array);

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

Recorder r;
boolean rec = false;

boolean enough = false;
float speed = 220.0;
float GX = 0;
float GY = 0;
float step = 30;

Bod b[] = new Bod[0];



void setup(){

	size(400,300,OPENGL);

	if(rec){
		r = new Recorder("out","stredobod.mp4");

	}

	int g = 0;
	while(!enough){
		b = (Bod[])expand(b,b.length+1);
		b[b.length-1] = new Bod(g);
		g++;
	}

	fill(255,35);
	noStroke();
	rectMode(CENTER);

	background(0);
}


void draw(){
	background(0);

	stepper(200);

	

	if(rec)
		r.add();
	
	reset();


}

void reset(){
	for(int i =0;i<b.length;i++){
			b[i].redef(random(-10,100));
		}
	
	
}

void stepper(int st){

	for(int e = 0;e<st;e++){

		for(int i =0;i<b.length;i++){
			b[i].compute();
		}



		for(int i =0;i<b.length;i++){
			b[i].update();
			b[i].draw();
		}

	}

}

void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();

		exit();

	}


}

class Bod{

	float x,y,tx,ty,bx,by;
	float r = 5.0;
	int id;

	Bod(int _id){
		id = _id;
		bx = tx = x = GX;
		by = ty = y = GY;

		GX+=step;

		if(GX>width){
			GY +=step;
			GX = 0;
		}

		if(GY>height){
			enough = true;
		}
	}
	
	
	Bod(int _id,float _r){
		r = _r;
		id = _id;
		bx = tx = x = GX;
		by = ty = y = GY;

		GX+=step;

		if(GX>width){
			GY +=step;
			GX = 0;
		}

		if(GY>height){
			enough = true;
		}
	}
	
	void redef(float _r){
	
		r += _r/200.0;
		tx = x = bx;
		ty = y = by;
		
	
	}

	void draw(){
		rect(x,y,2,2);
		
		/*
		pushStyle();
		stroke(255,1);
		noFill();
		ellipse(x,y,r*2,r*2);
		popStyle();

		*/
	}

	void compute(){

		int react = 0;
		for(int i =0;i < b.length;i++){
			if(id!=i){
				if(react>7){
					break;
				}
				if(dist(b[i].tx,b[i].ty,tx,ty)<r){
					tx += ( b[i].x - x ) / speed;
					ty += ( b[i].y - y ) / speed;
					react++;
				}
			}
		}

	}

	void update(){

		x=tx;
		y=ty;

	}



}
class OSC{
  OscP5 osc;
  NetAddress addr;
  int port;

//////////////////////////////////////////////////////////

  OSC(String _addr,int _port){
    port=_port;
    osc = new OscP5(this,_port-1);
    addr = new NetAddress(_addr,port);
  }
  
  //////////////////////////////////////////////////////////


  void send(float _whatX,float _whatY,float _whatZ){
    OscMessage message = new OscMessage("/msg");
    //message.add("x ");
    message.add(_whatX);
    //message.add("y ");
    message.add(_whatY);
   
    message.add(_whatZ);
    osc.send(message, addr);
    
    
  }
  
  //////////////////////////////////////////////////////////

  void send(int _ident,float _what){
    OscMessage message = new OscMessage("/msg");
    String ident = (char)(_ident+65)+"";
    message.add(ident);
    message.add(_what);
    osc.send(message, addr);
  }
  
  //////////////////////////////////////////////////////////
  
   void send(String _ident,float _what){
    OscMessage message = new OscMessage("/msg");
    String ident = _ident+"";
    message.add(ident);
    message.add(_what);
    osc.send(message, addr);
  }
  
  //////////////////////////////////////////////////////////

}

import oscP5.*;
import netP5.*;
import processing.serial.*;
import cc.arduino.*;


String data;
String serialString;
String[] vals = new String[3];


boolean listen = true;
boolean emit = false;

int sel = 1;
float posX[],posY[],posZ[];


Arduino arduino;
OSC osc;
Cube cub;

void setup() {

	size(1000, 600,P3D);
	frameRate(25);
	//osc = new OSC("127.0.0.1",12000);
	//osc.send("on",1);

	data = "";

	textFont(createFont("Veranda",9));
	textMode(SCREEN);

	fill(255);
	stroke(0,100);

	println("pahse0");

	cub = new Cube();
	noCursor();
	smooth();
	println("pahse1");


	posX= new float[10];
	posY= new float[10];
	posZ= new float[10];

	println("pahse2");

	//	osc = new OSCm("127.0.0.1",12000);

	println("pahse3");

	println(Arduino.list());
	arduino = new Arduino(this, Arduino.list()[0], 57600);

	/* start oscP5, listening for incoming messages at port 12000 */






}

void draw() {
	background(0);
	if(listen){
		serialInput();
	}

	cub.draw(listen);


}

/*
void stop(){
	osc.osc.stop();
	super.stop();


}*/




void serialInput() {

	vals[0] =""+arduino.analogRead(0);
	vals[1] =""+arduino.analogRead(1);
	vals[2] =""+arduino.analogRead(2);

	//println(vals);

}



void writePos(int q){
	listen = true;
	posX[q] = cub.p.x;
	posY[q] = cub.p.y;
	posZ[q] = cub.p.z;
}

void jdi(int q){
	//if(posX[q]!=null){
	sel = q;
	listen = false;
	//}

}


void keyPressed(){
	if(key == 'q'){
		writePos(1);
	}else if (key=='1'){
		jdi(1);
	}else if(keyCode==BACKSPACE){
	osc = new OSC("127.0.0.1",12000);
	emit = true;
	
	}

}



class Cube{
	float x,y;
	String a;
	float speed = 0.01;
	Drawer p;
	Follower ff;
	float velikost = 300;

	Cube(){
		x=width/2.0;
		y=height/2.0;
		textFont(createFont("Veranda",9));
		textMode(SCREEN);

		p = new Drawer(data,0,0,0);
		ff = new Follower(100.0);
	}

	void draw(boolean driven){
		pushMatrix();
		translate(x,y);
		pushMatrix();

		rotateY(frameCount*speed);
		noFill();
		stroke(255,200);
		//box(velikost);
		p.draw(driven);
		ff.draw();
		popMatrix();
		popMatrix();
	}

}

class Follower{
	float x,y,z;
	float speed;
	float X[],Y[],Z[];
	float xx,yy,zz;
	int num = 4000;
	int cntr = 0;
	boolean first = true;


	Follower(float _speed){
		speed=_speed;
		X = new float[num];
		Y = new float[num];
		Z = new float[num];
	}

	void draw(){
		x+=(cub.p.x-x)/speed;
		y+=(cub.p.y-y)/speed;
		z+=(cub.p.z-z)/speed;


		pushMatrix();
		translate(x,y,z);
		noFill();
		box(4);


		popMatrix();
		for(int i  =1;i<num;i++){
			if(i!=cntr&&i!=cntr+1){
				stroke(#FFCC00,150);
				line(X[i],Y[i],Z[i],X[i-1],Y[i-1],Z[i-1]);
			}
		}
		if(first){
			for(int i =0;i<num;i++){

				X[i] = x;
				Y[i] = y;
				Z[i] = z;
				first = false;
			}
		}
		X[cntr] = x;
		Y[cntr] = y;
		Z[cntr] = z;
		if(farL(0.01))
			cntr++;
		cntr = cntr % num;
	}

	boolean farL(float tresh){
		boolean answ = false;
		if(dist(xx,yy,zz,x,y,z)>tresh){
			answ = true;

		}
		xx=x;
		yy=y;
		zz=z;

		return answ;
	}

}

class Drawer{
	int num = 4000;
	float X[],Y[],Z[];
	float xx,yy,zz;
	float x,y,z;
	String s;
	int cntr = 0;
	boolean first = true;

	Drawer(String content,float _x,float _y,float _z){
		x=_x;
		y=_y;
		z=_z;
		s = content+"";

		X = new float[num];
		Y = new float[num];
		Z = new float[num];

		for(int i =0;i<num;i++){
			X[i] = Y[i] = Z[i] = 0;
		}


	}

	void draw(boolean driven){
		if(driven){
			getCoord();
		}else{
			getSoftCoord();
		}
		fill(255);
		stroke(255,100);
		line(x+10,y-10,z,x,y,z);
		line(x+10,y-10,z,x+100,y-10,z);
		for(int i =1;i<num;i++){
			if(i!=cntr&&i!=cntr+1){
				stroke(255,60);
				/*

				map(X[i],-cub.velikost/2,cub.velikost/2,0,255),
				map(Y[i],-cub.velikost/2,cub.velikost/2,0,255),
				map(Z[i],-cub.velikost/2,cub.velikost/2,0,255),

				*/
				line(X[i],Y[i],Z[i],X[i-1],Y[i-1],Z[i-1]);
			}
		}
		text(s,(int)screenX(x+100,y-10,z),(int)screenY(x+100,y-10,z));

	}

	void getCoord(){
		s = vals[2]+" : "+vals[1]+" : "+vals[0];
		if(vals[0]!=null){
			if(first){
				for(int i =0;i<num;i++){
					X[i] = map(parseFloat(vals[1]),98,1024,-cub.velikost/2,cub.velikost/2);
					Y[i] = map(parseFloat(vals[0]),98,1024,cub.velikost/2,-cub.velikost/2);
					Z[i] = map(parseFloat(vals[2]),98,1024,cub.velikost/2,-cub.velikost/2);
					first=false;
				}
			}

			X[cntr] = map(parseFloat(vals[1]),98,1024,-cub.velikost/2,cub.velikost/2);
			Y[cntr] = map(parseFloat(vals[0]),98,1024,cub.velikost/2,-cub.velikost/2);
			Z[cntr] = map(parseFloat(vals[2]),98,1024,cub.velikost/2,-cub.velikost/2);
		}
		x=X[cntr];
		y=Y[cntr];
		z=Z[cntr];

		if(emit)
		osc.send(x,-y,-z);
		if(farL(1))
			cntr++;
		cntr = cntr % num;
	}


	void getSoftCoord(){
		s = x+" : "+y+" : "+z;
		X[cntr] += (posX[sel]-X[cntr])/10.0;
		Y[cntr] += (posY[sel]-Y[cntr])/10.0;
		Z[cntr] += (posZ[sel]-Z[cntr])/10.0;

		x=X[cntr];
		y=Y[cntr];
		z=Z[cntr];

		//osc.send(0,x,cub.velikost-y,cub.velikost-z);
		if(farL(1))
			cntr++;
		cntr = cntr % num;
	}

	boolean farL(int tresh){
		boolean answ = false;
		if(dist(xx,yy,zz,x,y,z)>tresh){
			answ = true;

		}
		xx=x;
		yy=y;
		zz=z;

		return answ;
	}

}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}

float R = 65.0;
float G = 51.0;
float B = 47.5;

Recorder r;
boolean rec = true;
PImage pani;

PGraphics rr,gg,bb;

void setup(){
	size(416,320);
	frameRate(25);
	noStroke();
	background(0);
	fill(255);

	pani = loadImage("pani.png");
	rr = createGraphics(width,height,P3D);
	gg = createGraphics(width,height,P3D);
	bb = createGraphics(width,height,P3D);


	drawGrph2(rr,R,#ff0000);
	drawGrph2(gg,G,#00ff00);
	drawGrph2(bb,B,#0000ff);


	if(rec)
		r = new Recorder("out","color.mp4");
}



void draw(){

	background(0);
	
	if(frameCount<= 1500){
	
	drawGrph(rr,R,#ff0000);
	drawGrph(gg,G,#00ff00);
	drawGrph(bb,B,#0000ff);
	
		
	}else{
	
	drawGrph2(rr,R,#ff0000);
	drawGrph2(gg,G,#00ff00);
	drawGrph2(bb,B,#0000ff);

	}
	image(rr,0,0);
	blend(gg, 0, 0, width, height, 0, 0, width, height, ADD);
	blend(bb, 0, 0, width, height, 0, 0, width, height, ADD);

	if(rec&&frameCount >= 3000){
		r.finish();
		exit();
	}else if(rec){
		r.add();
	}

}

void drawGrph(PGraphics which,float speed,color c){
	which.beginDraw();
	which.background(0);
	which.noStroke();
	which.fill(c);
	which.ellipse(width/2,height/2+sin(frameCount/speed)*50.0,50,50);
	which.endDraw();

}

void drawGrph2(PGraphics which,float speed,color c){
	which.beginDraw();
	which.background(0);
	//which.noStroke();
	which.tint(c);
	which.image(pani,0,sin(frameCount/speed)*50.0);//ellipse(width/2,height/2+sin(frameCount/speed)*50.0,50,50);
	which.endDraw();

}

void keyPressed(){
	if(key=='q'){
		r.finish();
		exit();

	}

}
// Example by Krister Olsson

import krister.Ess.*;

AudioStream myStream;
SineWave myWave;

void setup() {
  size(256,200,P2D);
  background(0,0,255);

  // start up Ess
  Ess.start(this);

  // create a new AudioStream
  myStream=new AudioStream();

  // our wave
  myWave=new SineWave(90,.33);
  
  // start
  myStream.start();
}

void draw() {
  stroke(255,10);

  // overlay an average of the samples in the buffer being played
  float inc=myStream.buffer.length/256.0f;
  for (int i=0;i<256;i++) {
    int y=(int)(100+myStream.buffer[(int)(i*inc)]*100);
    
    line(i-200,y-200,i+200,y+200);
  }
}

void audioStreamWrite(AudioStream theStream) {
  // next wave
  myWave.generate(myStream);

  // adjust our phase
  myWave.phase+=myStream.size;
  myWave.phase%=myStream.sampleRate;
}

// we are done, clean up Ess

public void stop() {
  Ess.stop();
  super.stop();
}
import hardcorepawn.fog.*;


int num = 60;
int vlak =  60;


fog myFog;
float nearDist = 0;
float farDist = 350;
color fogColor;


PImage texmap;
PGraphics earth;

Recorder r;
boolean rec = false;
int DUR = 2182;//2*60*25;

boolean drawEarth = false;
boolean drawEllipses = false;
boolean drawIds = false;
boolean drawLines = true;
boolean drawBox = false;
boolean glowing = true;

Vlakno v[];

void setup(){
	size(720,480,OPENGL);
	frameRate(25);

	myFog=new fog(this);

	myFog.setupFog(nearDist,farDist);
	fogColor=color(0,0,0);
	myFog.setColor(fogColor);


	v = new Vlakno[num];

	for(int i = 0;i<num;i++){
		v[i] = new Vlakno(i,vlak);

	}

	if(drawEarth){
		earth = createGraphics(width,height,P3D);
		texmap = loadImage("earthWhit.png");
		initializeSphere(sDetail);
	}
	//println(PFont.list());

	if(drawIds){
		textFont(createFont("Pixel",8));
	}

	r = new Recorder("earthOut","dratysolo.mp4");

	smooth();
	//textMode(SCREEN);

	background(0);

}


void draw(){
	background(0);

	//fill(0,5);
	//rect(0,0,width,height);



	if(drawEarth){
		earth.beginDraw();
		earth.background(0);
		rotationY = -(frameCount/3.0);
		noStroke();

		renderGlobe();

		//earth.myFog.doFog();
		earth.endDraw();
		//earth.filter(BLUR,2);
	}




	//tint(255,50);

	//image(earth,0,0);



	pushMatrix();
	translate(width/2,height/2);
	rotateY(radians(frameCount/3.0));

	noFill();
	//sphere(200);
	if(drawBox){
		noFill();
		box(width/2.0);
	}
	for(int i = 0;i<num;i++){
		v[i].compute();
		v[i].draw();//= new Vlakno(i,100);

	}
	//println(v[0].rx+" "+v[0].ry+" "+v[0].rz);



	popMatrix();


	myFog.doFog();


	if(glowing){
		for(int i = 0;i<num;i++){
			v[i].glow(v[i].rx,v[i].ry,map(v[i].rz,50,200,0,25),map(v[i].rz,50,200,0,70),6);

		}
	}

	//	glow(x[10],y[10],5.0,6);

	if(drawEarth)
		image(earth,0,0);
	//blend(earth, 0, 0, width, height, 0, 0, width, height, MULTIPLY);


	if(rec){
		r.add();
		if (frameCount>=DUR)
			exit();
	}


}

void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();
		exit();

	}


}

class Vlakno{
	float x[],y[],z[];
	float X,Y,Z,rx,ry,rz;
	int id,len;
	float radi = 100;
	int glowRef = 8;

	Vlakno(int _id,int _len){
		id =_id;
		len = _len;

		x = new float[len];
		y = new float[len];
		z = new float[len];

		x[0] = random(-20,20);
		y[0] = random(-20,20);
		z[0] = random(-20,20);
		for(int i = 1;i<len;i++){
			x[i] = x[0];
			y[i] = y[0];
			z[i] = z[0];
		}

	}


	void compute(){
		x[0] += random(-10,10);
		y[0] += random(-10,10);
		z[0] += random(-10,10);

		for(int i = 1;i<len;i++){
			x[i] += (x[i-1]-x[i])/3.0;
			y[i] += (y[i-1]-y[i])/3.0;
			z[i] += (z[i-1]-z[i])/3.0;
		}

		//interact();
		bordrs();
	}

	void interact(){



		for(int i = 0;i<v.length;i++){

			if(id!=i){
				float dd = dist(x[10],y[10],z[10],v[i].x[10],v[i].y[10],v[i].z[10]);
				//dd = constrain(dd,0.01,width*2);
				if(dd<radi/2.0){
					x[0]-=(v[i].x[0]-x[0])/300.0;
					y[0]-=(v[i].y[0]-y[0])/300.0;
					z[0]-=(v[i].z[0]-z[0])/300.0;

				}else if(dd<radi){
					x[0]+=(v[i].x[0]-x[0])/300.0;
					y[0]+=(v[i].y[0]-y[0])/300.0;
					z[0]+=(v[i].z[0]-z[0])/300.0;


				}

			}

		}

	}


	void draw(){

		X = screenX(x[10],y[10],z[10])-width/2.0;
		Y = screenY(x[10],y[10],z[10])-height/2.0;
		Z = map(z[10],-width,width,20,2);

		stroke(255,80);


		if(drawLines){
			rx = screenX(x[glowRef],y[glowRef],z[glowRef]);
			ry = screenY(x[glowRef],y[glowRef],z[glowRef]);
			rz = modelZ(x[glowRef],y[glowRef],z[glowRef]);

			for(int i = 10;i<len;i++){
				if(i==10)
					stroke(255,200);
				else
					stroke(255,80);

				//strokeWeight(map(i,0,len,1,5));
				line(x[i],y[i],z[i],x[i-1],y[i-1],z[i-1]);
			}

		}



	}

	void glow(float x,float y,float dia,float top,int steps){
		pushStyle();
		for(int i =0;i<steps;i++){
			noStroke();
			float tmp = map(i,0,steps,0,dia);
			fill(random(255),map(i,0,steps,top,0));
			ellipse(x,y,tmp,tmp);
		}
		popStyle();
	}

	void draw2(){

		pushStyle();
		if(drawEllipses){
			fill(255,50);
			noStroke();
			ellipse( X , Y , Z , Z );
		}
		if(drawIds){

			fill(255,120);
			text(id,(int)(X+width/2.0)-3,(int)(Y+height/2.0)+3);
		}
		popStyle();

	}

	void bordrs(){

		/*
		x[0] = constrain(x[0],-width/2.0,width/2.0);
		y[0] = constrain(y[0],-width/2.0,width/2.0);
		z[0] = constrain(z[0],-width/2.0,width/2.0);
		*/

		if(dist(x[0],y[0],z[0],0,0,0)>200){
			x[0]+=(0-x[0])/20.0;
			y[0]+=(0-y[0])/20.0;
			z[0]+=(0-z[0])/20.0;
		}


	}



}
PImage bg;


int sDetail = 35;  //Sphere detail setting
float rotationX = 0;
float rotationY = 0;
float velocityX = 0;
float velocityY = 0;
float globeRadius = 300;
float pushBack = 0;

float[] cx,cz,sphereX,sphereY,sphereZ;
float sinLUT[];
float cosLUT[];
float SINCOS_PRECISION = 0.5f;
int SINCOS_LENGTH = int(360.0 / SINCOS_PRECISION);


void renderGlobe(){
	//earth.beginDraw();
	earth.pushMatrix();
	earth.translate(width/2.0, height/2.0, pushBack);
	earth.pushMatrix();
	earth.noFill();
	earth.stroke(0);
	earth.strokeWeight(4);
	earth.smooth();
	earth.popMatrix();
	//earth.lights();
	earth.pushMatrix();
	earth.rotateX( radians(-rotationX) );
	earth.rotateY( radians(270 - rotationY) );
	earth.fill(200);
	earth.noStroke();
	earth.textureMode(IMAGE);
	texturedSphere(globeRadius, texmap);
	earth.popMatrix();
	earth.popMatrix();
	//earth.endDraw();
	rotationX += velocityX;
	rotationY += velocityY;
	velocityX *= 0.95;
	velocityY *= 0.95;

	// Implements mouse control (interaction will be inverse when sphere is  upside down)
	//if(mousePressed){
	//	velocityX += (mouseY-pmouseY) * 0.01;
	//	velocityY -= (mouseX-pmouseX) * 0.01;
	//}
}

void initializeSphere(int res){
	sinLUT = new float[SINCOS_LENGTH];
	cosLUT = new float[SINCOS_LENGTH];

	for (int i = 0; i < SINCOS_LENGTH; i++) {
		sinLUT[i] = (float) Math.sin(i * DEG_TO_RAD * SINCOS_PRECISION);
		cosLUT[i] = (float) Math.cos(i * DEG_TO_RAD * SINCOS_PRECISION);
	}

	float delta = (float)SINCOS_LENGTH/res;
	float[] cx = new float[res];
	float[] cz = new float[res];

	// Calc unit circle in XZ plane
	for (int i = 0; i < res; i++) {
		cx[i] = -cosLUT[(int) (i*delta) % SINCOS_LENGTH];
		cz[i] = sinLUT[(int) (i*delta) % SINCOS_LENGTH];
	}

	// Computing vertexlist vertexlist starts at south pole
	int vertCount = res * (res-1) + 2;
	int currVert = 0;

	// Re-init arrays to store vertices
	sphereX = new float[vertCount];
	sphereY = new float[vertCount];
	sphereZ = new float[vertCount];
	float angle_step = (SINCOS_LENGTH*0.5f)/res;
	float angle = angle_step;

	// Step along Y axis
	for (int i = 1; i < res; i++) {
		float curradius = sinLUT[(int) angle % SINCOS_LENGTH];
		float currY = -cosLUT[(int) angle % SINCOS_LENGTH];
		for (int j = 0; j < res; j++) {
			sphereX[currVert] = cx[j] * curradius;
			sphereY[currVert] = currY;
			sphereZ[currVert++] = cz[j] * curradius;
		}
		angle += angle_step;
	}
	sDetail = res;
}

// Generic routine to draw textured sphere
void texturedSphere(float r, PImage t){
	int v1,v11,v2;
	r = (r + 240 ) * 0.33;
	//earth.beginDraw();
	earth.beginShape(TRIANGLE_STRIP);
	earth.texture(t);
	float iu=(float)(t.width-1)/(sDetail);
	float iv=(float)(t.height-1)/(sDetail);
	float u=0,v=iv;
	for (int i = 0; i < sDetail; i++) {
		earth.vertex(0, -r, 0,u,0);
		earth.vertex(sphereX[i]*r, sphereY[i]*r, sphereZ[i]*r, u, v);
		u+=iu;
	}
	earth.vertex(0, -r, 0,u,0);
	earth.vertex(sphereX[0]*r, sphereY[0]*r, sphereZ[0]*r, u, v);
	endShape();

	// Middle rings
	int voff = 0;
	for(int i = 2; i < sDetail; i++) {
		v1=v11=voff;
		voff += sDetail;
		v2=voff;
		u=0;
		earth.beginShape(TRIANGLE_STRIP);
		earth.texture(t);
		for (int j = 0; j < sDetail; j++) {
			earth.vertex(sphereX[v1]*r, sphereY[v1]*r, sphereZ[v1++]*r, u, v);
			earth.vertex(sphereX[v2]*r, sphereY[v2]*r, sphereZ[v2++]*r, u, v+iv);
			u+=iu;
		}

		// Close each ring
		v1=v11;
		v2=voff;
		earth.vertex(sphereX[v1]*r, sphereY[v1]*r, sphereZ[v1]*r, u, v);
		earth.vertex(sphereX[v2]*r, sphereY[v2]*r, sphereZ[v2]*r, u, v+iv);
		earth.endShape();
		v+=iv;
	}
	u=0;

	// Add the northern cap
	earth.beginShape(TRIANGLE_STRIP);
	earth.texture(t);
	for (int i = 0; i < sDetail; i++) {
		v2 = voff + i;
		earth.vertex(sphereX[v2]*r, sphereY[v2]*r, sphereZ[v2]*r, u, v);
		earth.vertex(0, r, 0,u,v+iv);
		u+=iu;
	}
	earth.vertex(0, r, 0,u, v+iv);
	earth.vertex(sphereX[voff]*r, sphereY[voff]*r, sphereZ[voff]*r, u, v);
	earth.endShape();
	
	//earth.endDraw();

}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="80000K";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import java.util.Collections;  
import java.util.ArrayList;  
import java.util.Comparator; 


class CylinderRoll
{
  CylinderRoll()
  {
    minNoise = 0.499;
    maxNoise = 0.501;
    
    _doRenderHead = true;
    _doUpdate = true;

    _tailSize = 100;
    _tailRenderSegments = 0;
    _tailWidth = 11.0;

    _initPos = new Vector3();
    
    _headSize = 8*3;
    _head = new Vector3();
    _target = new Vector3();
    _right = new Vector3();

    _usePerlin = false;
    _perlin = new Vector3();
    
    _add = new Vector3();
    
    _damp = 0.95;

    _age = 0;
    _agePer = 0;
    _timeToLive = 100;
    _invTimeToLive = 1.0 / _timeToLive;
    
    _facets = 5;
    
    _colour = new Vector4( 1, 1, 1, 1 );
    
    _flowerCount = 0;
    _numFlowers = 20;
    _flowers = new ArrayList();
    _flowersSizeValue = new ArrayList();
    _flowersDir = new ArrayList();

    _dispoffset = 0;
    _displaces = 0;
    _dispscale = 9;
  }

  CylinderRoll( int tailSize, float tailWidth, float headSize, boolean renderHead )
  {

    _doRenderHead = renderHead;
    _doUpdate = true;

    _tailSize = tailSize;
    _tailRenderSegments = 0;
    _tailWidth = tailWidth;

    _initPos = new Vector3();

    _headSize = headSize;
    _head = new Vector3();
    _target = new Vector3();
    _right = new Vector3();

    _usePerlin = false;
    _perlin = new Vector3();
    
    _add = new Vector3();    

    _damp = 0.95;

    _age = 0;
    _agePer = 0;
    _timeToLive = 100;
    _invTimeToLive = 1.0 / _timeToLive;

    _colour = new Vector4( 1, 1, 1, 1 );

    _facets = 8;
    
    _dispoffset = 0;
    _displaces = 0;
    _dispscale = 9;
  }
  
  float getRads(float val1, float val2, float mult, float div)
  {
    float rads = noise(val1/div, val2/div, frameCount/div );
    
    if (rads < minNoise) minNoise = rads;
    if (rads > maxNoise) maxNoise = rads;
    
    rads -= minNoise;
    rads *= 1.0/(maxNoise - minNoise);
  
    return rads * mult;
  }


  void setCylinderDetail( int d )
  {
    _facets = d;
  }
  
  void setCylinderRadius( int r )
  {
    _tailWidth = r;
  }   

/*  void loadHeadTexture( String file )
  {
    _headTex = new XTexture( file );
  }*/

  void findPerlin()
  {
    float xyRads = getRads( _head.x, _head.z, 5.0, 15.0 );
    float yRads = getRads( _head.x, _head.y, 5.0, 15.0 );
//    _perlin.set( cos(xyRads), sin(yRads), sin(xyRads) );

//    _perlin.set( cos(1.2*xyRads), sin(4*yRads), sin(1.2*xyRads) );
//    _perlin.mul( 2.85 );

    _perlin.set( cos(5.2*xyRads), sin(4*yRads), sin(5.2*xyRads) );
    _perlin.mul( 2.85 );

//    _perlin.set( cos(10.2*xyRads), sin(4*yRads), sin(10.2*xyRads) );
//    _perlin.mul( 2.85 );
  }

  void computeTail()
  {
    if( _tail == null )
    {
      _tail = new Vector3[_tailSize];
    }

    for( int i=0; i<_tailSize; i++ )
    {
      _tail[i] = new Vector3();
      _tail[i] = _head.copy();
    }

    yTable = new int[_tailSize];
    for( int i=0; i<_tailSize; i++ )
      yTable[i] = i * (_facets+1);
    _vertices = new Vector3[ ((_tailSize)*(_facets+1)) ];
    _normals = new Vector3[ ((_tailSize)*(_facets+1)) ];
    _texcoords = new Vector3[ ((_tailSize)*(_facets+1)) ]; 
    for( int i=0; i<((_tailSize)*(_facets+1)); i++ )
    {
      _vertices[i] = new Vector3();
      _normals[i] = new Vector3();
      _texcoords[i] = new Vector3(); 
    }
  }
  

  boolean isDead()
  {
    if( _age >= _timeToLive )
      return true;

    return false;
  }

  void setTailSize( int t )
  {
    _tailSize = t;
    computeTail();
  }

  void setTimeToLive( float t )
  {
    _timeToLive = t;
    _invTimeToLive = 1.0 / _timeToLive;
  }

  void setHeadY( float y )
  {
    _head.y = y;
    _initPos = _head.copy();
  }

  void setHead( float x, float y )
  {
    _head.set( x, y, 0 );
    _initPos = _head.copy();
    _target = _head.copy();
  }

  void setHead( float x, float y, float z )
  {
    _head.set( x, y, z );
    _initPos = _head.copy();
  }

  void setHead( Vector3 h )
  {
    _head = h;
    _initPos = _head.copy();
  }

  void addHead( float x, float y )
  {
    //if( _doUpdate )
    if( !_usePerlin )
    {
      _head.add( x, y, 0 );
    }
  }

  void addHead( float x, float y, float z )
  {
    //if( _doUpdate )
    if( !_usePerlin )
    {
      _head.x += x;
      _head.y += y;
      _head.z += z;
    }
  }

  void addHead( Vector3 a )
  {
    //if( _doUpdate )
    if( !_usePerlin )
    {
      _head.add( a );
    }
  }

  void renderHead( boolean f )
  {
    _doRenderHead = f;
  }


  void update( float time )
  {
    if( _age < _timeToLive )
    {
      if( _tailRenderSegments < _tailSize )
      {        
//        for( int i=_tailSize-1; i>0; i-- )
        for( int i=_tailRenderSegments; i>0; i-- )
        {
          _tail[i] = _tail[i-1];
        }
        _tail[0] = _head.copy();
        _tailRenderSegments++;
      }
      else
      {
        _doUpdate = false;
      }
    }

    if( _usePerlin )
    {
/*      findPerlin();
      _add.add( _perlin );
      _head.add( _add );
      _add.mul( _damp );*/
      
      float target_distance = 200.0;
      float redirect_distance = 60.0;
      float d = Vector3.distance( _head, _target );//dist( _head.x, _head.y, _head.z, tx, ty, tz );
      if( d < target_distance )
      {
        _target.x += random(-redirect_distance, redirect_distance);
        _target.y += random(-redirect_distance, redirect_distance);
        _target.z += random(-redirect_distance, redirect_distance);
        //tx = global.constrainX(tx);
        //ty = global.constrainY(ty);
        //tz = 0;
      }
      _add.x += (_target.x-_head.x) * 0.002;
      _add.y += (_target.y-_head.y) * 0.002;
      _add.z += (_target.z-_head.z) * 0.002;
      _add.mul( 0.97 );
      _head.add( _add );      
    }
    else
    {
      if( _doUpdate) 
        _head.add( _add );
    }
    
    _age ++;
    _agePer = _age * _invTimeToLive;
  }


  void draw( float time )
  {
    if( _age < _timeToLive )
    {
/*      if( _doRenderHead )
      {
        _headTex.enable();
        renderHead();
        _headTex.disable();
      }*/

/*      vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.setDepthWrite( true );
//      vgl.setDepthMask( false );
      vgl.setAlphaBlend();*/

//      renderTail();      
      renderTailCylinder();


      // Stop head motion once it completes its growth      
      if( !_doUpdate )
        _head = _tail[0].copy();


      // Render base of each tail (not needed for most cases)
//      renderBase();
    }
  }

  void drawCylinder( float time )
  {
    if( _age < _timeToLive )
    {
      vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.setDepthWrite( true );
//      vgl.setDepthMask( false );
      vgl.setAlphaBlend();
      
      renderTailCylinder();
    }
  }

  void renderBase()
  {
/*    activeNoteTex.enable();

    // Draw activator center 
    vgl.setAlphaBlend();
    vgl.fill( 1, 1.0-_agePer );
    vgl.pushMatrix();
    vgl.translate( _initPos );
    vgl.rotateX( 90 );
    vgl.quad( 20 );
    vgl.popMatrix();

    activeNoteTex.disable();*/
  }


  void renderHead()
  {
    // Draw activator center 
    vgl.setDepthWrite( false );
    vgl.setAlphaBlend();
    //activeNoteTex.enable();
    vgl.fill( 1, 1.0-_agePer );
    vgl.pushMatrix();
    vgl.translate( _head.x, _head.y, _head.z );
    vgl.rotateX( 90 );
    vgl.quad( _headSize );
    vgl.popMatrix();

    vgl.setDepthWrite( true );
  }


  void renderTail( float time )
  {
    float per;
    float xp, yp, zp;
    float xOff, yOff, zOff;

    ///////////////////////////////////////
    ///////////////////////////////////////
    vgl.gl().glBegin( GL.GL_QUAD_STRIP );
    for ( int i=0; i<_tailSize-1; i++ )
    {
      per           = (((float)i/(float)(_tailSize))); // ratio
//      per           = 1.0-(((float)i/(float)(_tailSize)));

      per *= 1.5;

      {
        Vector3 dir = Vector3.sub( _tail[i+1], _tail[i] );
        dir.normalize();
        Vector3 V = dir.cross( new Vector3( 0, 1, 0 ) );
        V.normalize();
        Vector3 U = dir.cross( V );
        U.normalize();
        V = U.cross( dir );
        V.normalize();
        
        _right = V.copy();

//        xp = _tail[i].x;
//        yp = _tail[i].y;
//        zp = _tail[i].z;
        xp = _tail[i].x + _right.x*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
        yp = _tail[i].y - 30;// + _right.y*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
        zp = _tail[i].z + _right.z*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
        

        xOff = V.x * _tailWidth * per;
        yOff = V.y * _tailWidth * per;
        zOff = V.z * _tailWidth * per;

        vgl.gl().glColor4f( 0, 0, 0, 1-_agePer );
        vgl.gl().glVertex3f( xp - xOff, yp - yOff, zp - zOff );
        vgl.gl().glVertex3f( xp + xOff, yp + yOff, zp + zOff );
      }
    }
    vgl.gl().glEnd();
  }


  void transformRect( Vector3 up, Vector3 V, Vector3 offset, Vector3[] rect ) 
  {
	for( int i=0; i<4; i++ )
	{
		Vector3 v = rect[i];
		Vector3 P = new Vector3( v.x, v.y, v.z );

		Vector3 NY = up.copy();
		NY.normalize();
		Vector3 NV = V.copy();
		NV.normalize();

		Vector3 N = NY.cross( NV );	// axis of rotation
		N.normalize();

		float dot = NY.dot( NV );	// cos angle
		float rad = ( acos(dot) );	// angle of rotation (radians)

		// quat from an angle and a rotation axis
		Quaternion quat = new Quaternion();

		quat.rotateAxis( N, rad );
//                Vector3 axis = Vector3.sub( N, NY );
//		quat.rotateAxis( axis, rad );

		// transform vertex
		Vector3 dv = quat.mul( P );

		v.set( dv );
                // translate to right position
                
//                Vector3 disp = N.copy();
//                disp.mul( _tailWidth*0.125 );
//                offset.add( disp );
                
		v.add( offset );
	}
  }

  void renderTailCylinder()
  {
    float invsteps = 1.0 / (float)(_tailSize-1);
    float invfacets = 1.0 / (float)(_facets);

    float pi2OverSteps = TWO_PI / (_tailSize-1);
    float pi2OverFacets = TWO_PI / _facets;
    float pi2MulInvsteps = TWO_PI * invsteps;
    float pi2MulInvfacets = TWO_PI * invfacets;

//    float _p = 5;
//    float _q = 5;
//    float _scale = 20;
//    float _thickness = 10;


    ///////////////////////////////////////////////////////////
    // Draw vine mesh
    ///////////////////////////////////////////////////////////

//    int hlen = (int)((_tailSize-1)*0.5);
//    for( int jj=-hlen; jj<hlen; jj++ )    
//    for ( int j=0; j<_tailSize-1; j++ )
    for ( int j=0; j<_tailRenderSegments-1; j++ )
    {
//      int j = jj+hlen;

/*      // draw textured quads along the path
      activeNoteTex.enable();
      // Draw activator center 
      vgl.setAlphaBlend();
      vgl.setDepthWrite( false );
      vgl.fill( .3 );//, 1.0-_agePer );
      vgl.pushMatrix();
      vgl.translate( _tail[j].x, _tail[j].y, _tail[j].z );
//      vgl.rotateX( 90 );
      vgl.quad( 15 );
      vgl.popMatrix();
      activeNoteTex.disable();*/

      float per = 0.0;
//      per = 1.0 - (((float)(abs(jj))/(float)(hlen)));
//      per = 1.0-(((float)(j)/(float)(_tailSize)));
//      per = j / (float)_tailRenderSegments; //_tailSize;
  
    
      float dthd1 = 10;
      float th = _tailWidth;
      float dthd2 = _tailSize;
      float dthm = 1 * _tailWidth;
      
/*      if( j < 10 )
      {
        per = 1.0-(dthm-min(dthm*(j)/dthd1,dthm)); //(dthm-min(dthm*(min(_tailSize,_tailRenderSegments)-(j))/dthd2,dthm));
        per = max( per, 0 );
      }
      else    */  
      {
        per = (dthm-min(dthm*(min(_tailSize,_tailRenderSegments)-(j))/dthd2,dthm));
        //per = max( per, 0 );
      }


      // first point
      Vector3 center = new Vector3();
      center = _tail[j];//.copy();

      // next point
      Vector3 nextPoint = new Vector3();
      nextPoint = _tail[j+1];//.copy();

      // get TBN matrix for transformation
      Vector3 T = new Vector3();
      T.x = nextPoint.x - center.x;
      T.y = nextPoint.y - center.y;
      T.z = nextPoint.z - center.z;
      T.normalize();

      Vector3 N = new Vector3(0,1,0); // use vector on y axis. it should work just fine here

      Vector3 B = T.cross( N );
      B.normalize();
      N = B.cross( T );

      // normalize vectors
      B.normalize();
      N.normalize();

      if( j == 0 )
      {
        _right = N.copy();
      }

      // go through facets and tweak a bit with some distortions
      for( int i=0; i<_facets+1; i++ )
      {
        float x = (sin(i * pi2OverFacets) * per);
        float y = (cos(i * pi2OverFacets) * per);        
//        float x = (sin(i * pi2OverFacets) * _tailWidth * per);
//        float y = (cos(i * pi2OverFacets) * _tailWidth * per);
        // distort knot along the curve
        if( _displaces != 0.0 )
        {
          x *= (1 + (sin(_dispoffset + _displaces * j * pi2OverSteps) * _dispscale));
          y *= (1 + (cos(_dispoffset + _displaces * j * pi2OverSteps) * _dispscale));
        }

        int idx = yTable[j] + i;
        _vertices[ idx ].x = N.x * x + B.x * y + center.x;
        _vertices[ idx ].y = N.y * x + B.y * y + center.y;
        _vertices[ idx ].z = N.z * x + B.z * y + center.z;

        _texcoords[ idx ].x = ((float)i / (float)_facets) * 1;
        _texcoords[ idx ].y = ((float)(j) / (float)_tailRenderSegments) * 10; 
//        _texcoords[ idx ].y = ((float)(j-_tailSize) / (float)_tailSize) * 10; 
//        _texcoords[ idx ].y = ((float)j / (float)_tailSize-1) * 10; 
        
        // get vertex normal
        _normals[ idx ].x = _vertices[ idx ].x - center.x;
        _normals[ idx ].y = _vertices[ idx ].y - center.y;
        _normals[ idx ].z = _vertices[ idx ].z - center.z;
        // normalize
        _normals[ idx ].normalize();
      }

      // duplicate sideways vertices/normals
      int idxSrc = yTable[j] + 0;
      int idxDest = yTable[j] + _facets;

      _vertices[ idxDest ].x = _vertices[ idxSrc ].x;
      _vertices[ idxDest ].y = _vertices[ idxSrc  ].y;
      _vertices[ idxDest ].z = _vertices[ idxSrc ].z;
      _texcoords[ idxDest ].x = _texcoords[ idxSrc ].x;
      _texcoords[ idxDest ].y = _texcoords[ idxSrc ].y;
      _normals[ idxDest ].x = _normals[ idxSrc ].x;
      _normals[ idxDest].y = _normals[ idxSrc ].y;
      _normals[ idxDest ].z = _normals[ idxSrc ].z;
    }


    // Increase color as it grows
//    _colour.x += 0.01;
//    _colour.y += 0.01;
//    _colour.z += 0.01;

    vgl.enableLighting( false );
    vgl.enableTexture( false );
/*    CGpass pass = diffuseSpecularCG.getTechniqueFirstPass( "Technique_Diffuse" );
    while( pass != null ) 
    {
      CgGL.cgSetPassState( pass );     

      diffuseSpecularCG.setTextureParameter( "ColorSampler", hll4.getId() );
      diffuseSpecularCG.setParameter3f( "lightPos", lightPos );
      diffuseSpecularCG.setParameter3f( "cameraPos", eye );
      diffuseSpecularCG.setParameter4x4f( "WorldViewProjection", CgGL.CG_GL_MODELVIEW_PROJECTION_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
      diffuseSpecularCG.setParameter4x4f( "World", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_INVERSE_TRANSPOSE );
*/

      int j = 0;
      float umul= 1;
      float vmul = 10;
      float u, v1, v2;
      v1 = vmul*j * invsteps;
      v2 = vmul*(j+1) * invsteps;

/*      vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
      for( int i=0; i<_facets+1; i+=1 )
      {
        u = umul*i * invfacets; 

        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z, 1.0 );//-_agePer );
//        vgl.gl().glColor4f( _colour.x-_agePer, _colour.y-_agePer, _colour.z-_agePer, 1 );//-_agePer );

        vgl.gl().glNormal3f( _normals[yTable[j]+i].x, _normals[yTable[j]+i].y, _normals[yTable[j]+i].z );
        vgl.gl().glTexCoord2f( u, v1 ); 
        vgl.gl().glVertex3f( _vertices[yTable[j]+i].x, _vertices[yTable[j]+i].y, _vertices[yTable[j]+i].z );

        vgl.gl().glNormal3f( _normals[yTable[j+1]+i].x, _normals[yTable[j+1]+i].y, _normals[yTable[j+1]+i].z );
        vgl.gl().glTexCoord2f( u, v2 );         
        vgl.gl().glVertex3f( _vertices[yTable[j+1]+i].x, _vertices[yTable[j+1]+i].y, _vertices[yTable[j+1]+i].z );
      }      
      vgl.gl().glEnd();*/

//    for ( j=0; j<_tailSize-2; j++ )
    for ( j=0; j<_tailRenderSegments-2; j++ )
    {
//      v1 = vmul*j / (float)_tailRenderSegments;//* invsteps;
//      v2 = vmul*(j+1) / (float)_tailRenderSegments;// * invsteps; 

      vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
      for( int i=0; i<_facets+1; i++ )
      {
//        u = umul*i * invfacets; 

        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z, 1 );//1-noiseAmp );
//        vgl.gl().glColor4f( _colour.x-_agePer, _colour.y-_agePer, _colour.z-_agePer, 1 );//-_agePer );

        vgl.gl().glNormal3f( _normals[yTable[j]+i].x, _normals[yTable[j]+i].y, _normals[yTable[j]+i].z );
//        vgl.gl().glTexCoord2f( u, v1 ); 
        vgl.gl().glTexCoord2f( _texcoords[yTable[j]+i].x, _texcoords[yTable[j]+i].y ); 
        vgl.gl().glVertex3f( _vertices[yTable[j]+i].x, _vertices[yTable[j]+i].y, _vertices[yTable[j]+i].z );

        vgl.gl().glNormal3f( _normals[yTable[j+1]+i].x, _normals[yTable[j+1]+i].y, _normals[yTable[j+1]+i].z );
//        vgl.gl().glTexCoord2f( u, v2 );         
        vgl.gl().glTexCoord2f( _texcoords[yTable[j+1]+i].x, _texcoords[yTable[j+1]+i].y ); 
        vgl.gl().glVertex3f( _vertices[yTable[j+1]+i].x, _vertices[yTable[j+1]+i].y, _vertices[yTable[j+1]+i].z );
      }      
      vgl.gl().glEnd();
    }

//      CgGL.cgResetPassState( pass );
//      pass = CgGL.cgGetNextPass( pass );
//    }     

  }


  void reset( Vector3 newPos, float ttl )
  {
    setHead( newPos );
    computeTail();
    setTimeToLive( ttl );
    _tailRenderSegments = 0;
    _age = 0;
    _doUpdate = true;  
    
    if( random(100) > 50 )
      _colour.set( 1, 1, 1, 1 );
    else
      _colour.set( 0, 0, 0, 1 );

  }

  float minNoise, maxNoise;
 
  int _facets;
  int[] yTable;
  Vector3[] _vertices;
  Vector3[] _texcoords; 
  Vector3[] _normals;
  
//  XTexture _headTex;
  
  Vector4  _colour;

  boolean _doRenderHead;
  boolean _doUpdate;

  float _age;
  float _agePer;
  float _timeToLive;
  float _invTimeToLive;

  Vector3 _initPos;
  
  float _headSize;
  Vector3 _head;
  Vector3 _right;
  Vector3 _target;

  Vector3  _add;
  
  float _damp;
  
  boolean _usePerlin;
  Vector3 _perlin;
  
  float _dispoffset;
  float _displaces;
  float _dispscale;
  

  float _tailWidth;
  int  _tailRenderSegments;    // counts number of tail segments to render  
  int  _tailSize;
  Vector3[] _tail;

  int _flowerCount;
  int _numFlowers;
  ArrayList _flowers;
  ArrayList _flowersSizeValue;
  ArrayList _flowersDir;
}

/*
  this code is a mess. things were mixed with one eye closed so it was ready to deploy. 
  things are seperate by scenes, so if you like something specific look into its scene.
  
  it depends on vitamin and jogl, so its not a good idea to come here to learn processing
  no good coding practices, errors i know, errors i dont know, oh well
  
  if you still want to go on, please do, afterall the piece came out nicely =)
  
  v*, 2009
*/

import java.awt.event.*;
import javax.swing.*;
import javax.media.opengl.glu.*; 
import com.sun.opengl.util.*;
import com.sun.opengl.util.FPSAnimator;   

import ddf.minim.*;
//import ddf.minim.signals.*;
//import ddf.minim.spi.*;
//import ddf.minim.effects.*; 
//import pitaru.sonia_v2_9.*;  
import penner.easing.*;
import vitamin.*;
import vitamin.math.*;

//import controlP5.*; 

Frame deepFrame;
GLCapabilities deepCaps;
GLCanvas deepCanvas;
GLRenderer deepListener;
FPSAnimator animator;

boolean isFullScreen = true;
int WIDTH = 1280;
int HEIGHT = 720;
int NUM_SAMPLES = 4;
float gamma = 0.9;

final boolean useMinim = true;
final boolean useESS = false;
final boolean saveFrameSequence = false;
final float frequencyScale = 400.0;

float addTime = 0.0;
final float addTimeStep = 5.0;

Minim minim;
ddf.minim.AudioOutput out;
AudioPlayer track;
AudioPlayer credits;
AudioSample outsphere;
boolean playedOutsphere = false;
javax.sound.sampled.FloatControl ourcontrol1;
javax.sound.sampled.FloatControl ourcontrol2;

float time;
float startTime;
VTimer timer;

//VTextRenderer textRender;
//PFont guiFont;


//
// demo timeline
//
float backgroundTime = 0.0;
float fadeBGOutTime = 334.0;
float bgEndTime = 337.0;
float logoTime = 20.0;
float landTime = 0.0;  
float candlesTime = 15.0;
float spikeyTime = 5.0;
float planktonTime = 5.0;
float jellyTime = 73.0;
float tactuTime = 337.0;
float endFadeOutTime = 380.0;
boolean isEndOfDemo = false;


VGL vgl;
float aspectRatio;
Vector3 eye, target, up;

float[] fogColorArray = { 0, 0, 0, 0 };
Vector4 fogColor = new Vector4( 0, 0.0, 0.0, 1.0 );    // darker blue
//Vector4 fogColor = new Vector4( 0, 1/255.0, 8/255.0, 0.0 );    // darker green-blue
//Vector4 fogColor = new Vector4( 0, 0, 10/255.0, 0.0 );    // darker green-blue
//Vector4 fogColor = new Vector4( 0.0+(2.0/255.0), 0.0+(6.0/255.0), 0.0+(17/255.0), 0.0 );    // dark green-blue
//Vector4 fogColor = new Vector4( (1/255.0)*1.1, (3.0/255.0)*1.1, (36/255.0)*1.1, 0.0 );
//Vector4 fogColor = new Vector4( 0.0, 0.0, 0.1, 0.0 );
float fogConstant = 0.0007f; //7f;
float fogDensity = 0.0008f; //7f;

Vector4 lightPos;
float kC = 0.0;
float kL = 0.0008;
float kQ = 0.000008;

Vector3 jeye, jtarget;
Vector3 jellyEye, jellyTarget;

JellyScene jellys;
GrassScene grassScene;
SpikeyScene spikey;
Landscape land;
TactuScene tactu;

vitamin.math.Matrix camMatrix;
vitamin.math.Matrix invCamMatrix;

XTexture backG;
XTexture deepTex;

/*ControlP5 gui;
controlP5.Button okButton;
controlP5.MultiList resList;
Textlabel textLabel;*/
boolean isDemoRunning = false;

void writelog( String s )
{
  //VLogger.getSingleton().log( s );
}

/*
void LAUNCH(float theValue) 
{
  if( !isDemoRunning )
    initDemo();
}

void FULLSCREEN( float theValue )
{
  isFullScreen = !isFullScreen;
}

void QUIT(float theValue) 
{
  System.exit( 0 );
}

void controlEvent(ControlEvent theEvent) 
{
  if( isDemoRunning ) return;
  
  if( theEvent.controller().name().equals("FULLSCREEN") )
    return;
  
  //println( theEvent.controller().name() +" = " + theEvent.value() );
  textLabel.setValue( "RESOLUTION: " + theEvent.controller().name() );

  switch( (int)theEvent.value() )
  {
    case 1:
      WIDTH = 640;
      HEIGHT = 400;
      break;
    case 2:
      WIDTH = 720;
      HEIGHT = 576;
      break;
    case 3:
      WIDTH = 800;
      HEIGHT = 600;
      break;
    case 4:
      WIDTH = 1024;
      HEIGHT = 768;
      break;
    case 5:
      WIDTH = 1280;
      HEIGHT = 720;
      break;
    case 6:
      WIDTH = 1280;
      HEIGHT = 768;
      break;
    case 7:
      WIDTH = 1280;
      HEIGHT = 960;
      break;
    default:
      WIDTH = 800;
      HEIGHT = 600;
  }    
}*/

void setup()
{
  if( saveFrameSequence )
  {
    size( WIDTH, HEIGHT, OPENGL );
    hint( ENABLE_OPENGL_4X_SMOOTH ); 
  }
  
/*  gui = new ControlP5( this ); 
  gui.setAutoDraw( false );
  gui.addButton( "LAUNCH", 0, 20, 40, 50, 20 );
  gui.addButton( "QUIT", 0, 20, 70, 50, 20 );
  resList = gui.addMultiList( "resList", 80, 40, 100, 12 );
  textLabel = gui.addTextlabel( "label", new String("RESOLUTION: " + WIDTH + "_" + HEIGHT), 40, 20 );
  gui.addToggle( "FULLSCREEN", false, 20, 108, 10, 10 );

  resList.add( "640_400", 1 );
  resList.add( "720_576", 2 );
  resList.add( "800_600", 3 );
  resList.add( "1024_768", 4 );
  resList.add( "1280_720", 5 );
  resList.add( "1280_768", 6 );
  resList.add( "1280_960", 7 );*/
//  textRender = new VTextRenderer( "Arial", 12, true, true ); 

//  guiFont = loadFont( "Tahoma-12.vlw" ); //createFont( "Arial", 10 );
//  textFont( guiFont, 12 ); 
//  textAlign( CENTER );

  String res[] = loadStrings( dataPath("res.txt") );
  if( res.length == 5 )
  {
    WIDTH = Integer.parseInt( res[0] );
    HEIGHT = Integer.parseInt( res[1] );
    if( Integer.parseInt(res[2]) == 0 )
      isFullScreen = false;
    else
      isFullScreen = true;
    NUM_SAMPLES = Integer.parseInt( res[3] );
    gamma = Float.parseFloat( res[4] );
  }

  isDemoRunning = false;

  ///////////////////////////////////////////////////////////
  // Start sound system
  ///////////////////////////////////////////////////////////

//  logger.log( "init minim" );
  if( useMinim )
  {
    //
    // MINIM
    //
    // always start Minim before you do anything with it
    minim = new Minim( this );
    // get a line out from Minim, default bufferSize is 1024, 
    // default sample rate is 44100, bit depth is 16
    out = minim.getLineOut( Minim.STEREO, 2048 );
    track = minim.loadFile( dataPath("deep_mixdown3.mp3"), 2048 ); 
    ourcontrol1 = track.gain(); //use to fadeout in the end
    outsphere = minim.loadSample( dataPath("outsphere.mp3"), 2048 );
    credits = minim.loadFile( dataPath("clicking.mp3"), 2048 ); //dataPath("ps-350_090318.wav"), 1024 ); 
    ourcontrol2 = credits.gain(); //use to fadeout in the end
  }
  if( useESS )
  {
    init_sound( 2048, dataPath("deep_mixdown3.mp3") );
    println( "*** mp3 loaded" ); 
  }

  //
  //
  //
  if( saveFrameSequence )
  {
    vgl = new VGL( this ); // use processing mode
    vgl.setVSync( true );     
    
    setupJOGL();
  
/*    int buf[] = new int[1];
    int sbuf[] = new int[1];
    vgl.gl().glGetIntegerv( GL.GL_SAMPLE_BUFFERS, buf, 0 );
    System.out.println( "number of sample buffers is " + buf[0] );
    vgl.gl().glGetIntegerv( GL.GL_SAMPLES, sbuf, 0 );
    System.out.println( "number of samples is " + sbuf[0] );*/
  
    vgl.gl().glEnable( GL.GL_MULTISAMPLE );
    vgl.gl().glEnable( GL.GL_NORMALIZE );
    vgl.gl().glEnable( GL.GL_BLEND );
    
    vgl.gl().glHint( GL.GL_PERSPECTIVE_CORRECTION_HINT, GL.GL_NICEST ); 
    vgl.gl().glHint( GL.GL_FOG_HINT, GL.GL_NICEST ); 
  }
  else
    initDemo();  
}

void initDemo()
{
  isDemoRunning = true;
  
  GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
/*GraphicsDevice[] displayDevices = ge.getScreenDevices();
  for( int i=0; i<displayDevices.length; i++ )
  {
    //println( "device '" + i + "' supports fullscreen? " + displayDevices[i].isFullScreenSupported() );
    //if( displayDevices[i].isFullScreenSupported() )
      //displayDevices[i].setFullScreenWindow( f );
    // Get display modes for current device
    DisplayMode[] dm = displayDevices[i].getDisplayModes();
    //for( int j=0; j<dm.length; j++ )
      //println( "display mode: " + dm[j].getWidth() + "x" + dm[j].getHeight() + "x" + dm[j].getBitDepth() + "x" + dm[j].getRefreshRate() + "hz" );
    
    // Get device configurations
    GraphicsConfiguration[] gc = displayDevices[i].getConfigurations();
    for( int j=0; j<gc.length; j++ )
    {
      Rectangle rect = gc[j].getBounds();
      //println( rect.toString() );

      ImageCapabilities ic = gc[j].getImageCapabilities();
      //println( "display device '" + i + "' is accelerated? " + ic.isAccelerated() );
    }
  }*/

  deepListener = new GLRenderer();
  deepFrame = new Frame( "Deep" );
  deepCaps = new GLCapabilities();
  deepCaps.setHardwareAccelerated( true );
  deepCaps.setDoubleBuffered( true );
  if( NUM_SAMPLES > 0 )
  {
    deepCaps.setSampleBuffers( true );
    deepCaps.setNumSamples( NUM_SAMPLES );
  }
  else
  {
    deepCaps.setSampleBuffers( false );
  }
  deepCanvas = new GLCanvas( deepCaps );
  deepCanvas.addGLEventListener( deepListener );
  deepCanvas.addKeyListener( deepListener );
  deepFrame.add( deepCanvas );
  deepFrame.setSize( WIDTH, HEIGHT );
  deepFrame.setResizable( false );
  deepFrame.setAlwaysOnTop( true );
  deepFrame.setUndecorated( true );
//  deepFrame.setFocusable( true );
//  deepFrame.setBackground( Color.BLACK );

  GraphicsDevice displayDevice = ge.getDefaultScreenDevice();
  Point pp = ge.getCenterPoint();
  deepFrame.setLocation( pp.x-WIDTH/2, pp.y-HEIGHT/2 );
  //deepFrame.requestFocus();

  if( isFullScreen )
  {    
    displayDevice.setFullScreenWindow( deepFrame );

    // Create transparent cursor and set it to our canvas  
    int[] pixels = new int[16*16];
    Image image = Toolkit.getDefaultToolkit().createImage( new MemoryImageSource(16, 16, pixels, 0, 16) );
    Cursor transparentCursor = Toolkit.getDefaultToolkit().createCustomCursor( image, new Point(0, 0), "invisibleCursor" );
    deepCanvas.setCursor( transparentCursor );
  }

  deepFrame.addWindowListener( new WindowAdapter()
  {
    public void windowClosing( WindowEvent e )
    {
      stopDemo();
      System.exit( 0 );
    }
  } );
/* deepFrame.addWindowListener(new WindowAdapter() 
 {
             public void windowClosing(WindowEvent e) 
             {
               new Thread(new Runnable() 
               {
                   public void run() 
                   {
                     stopDemo();
                     System.exit( 0 );
                   }
                 }).start();
             }
         });*/


  deepFrame.show();
  deepCanvas.requestFocusInWindow();  
  animator = new FPSAnimator( deepCanvas, 60 );
  animator.setRunAsFastAsPossible( true );
  writelog( "animator start" );
  animator.start();  
}

void stopDemo()
{
  deepCanvas.removeGLEventListener( deepListener );

  vgl = null;

  animator.stop();
  deepFrame.setVisible( false );
  deepFrame.dispose();
  deepFrame = null;
}


void setupJOGL()
{
  writelog( "setupJOGL - start" );

  aspectRatio = WIDTH / (float)HEIGHT;

  eye = new Vector3();
  target = new Vector3();
  up = new Vector3( 0, 1, 0 );

  //  lightPos = new Vector4( 600, 300, 500, 1.0f );
  lightPos = new Vector4( 100, 300, 500, 1.0f );

  jeye = new Vector3();
  jtarget = new Vector3();
  jellyEye = new Vector3();
  jellyTarget = new Vector3();

  writelog( "setupJOGL - jellys init" );
  jellys = new JellyScene();
  jellys.init();

  writelog( "setupJOGL - grass init" );
  grassScene = new GrassScene();
  grassScene.init( 250 );
//  grassScene.init( 125 );

  writelog( "setupJOGL - landscape init" );
  land = new Landscape( vgl.gl(), 75, 75, 180, 64 );
//  land = new Landscape( vgl.gl(), 65, 65, 180, 64 );

  writelog( "setupJOGL - spikey init" );
  spikey = new SpikeyScene();
  spikey.init();  
  for( int i=0; i<spikey._ballPos.size(); i++ )
  {
    Vector3Order v = (Vector3Order)spikey._ballPos.get(i);
    v.y = land.InterpolatedValue( v.x, v.z ) + 100;
    //v.y = land.getHeight( v.x, v.z );/// - 100;
  }

  writelog( "setupJOGL - tactu init" );
  tactu = new TactuScene();
  tactu.init();

  writelog( "setupJOGL - backG init" );
  //backG = new XTexture( "Comp1.png" ); //4_blur_800.png" );
  //backG.setClamp();
  backG = new XTexture( GL.GL_TEXTURE_RECTANGLE_ARB );
  backG.loadPImage( "Comp1280.png" ); //"Comp1.png" );

  writelog( "setupJOGL - deep2 init" );
  deepTex = new XTexture( "deep2.png" ); //4_blur_800.png" );
  deepTex.setClampToEdge();

  if( useMinim )
  {
    writelog( "setupJOGL - track play" );
    //track.play( int(addTime*1000) );
    //track.loop();  
    track.play();
  }
  if( useESS && !saveFrameSequence )
  {
    play_sound();
  }

  writelog( "setupJOGL - timer start" );
  timer = new VTimer();
  timer.start();
  //startTime = (millis() * 0.001);
  //time = 0.0;
  
  writelog( "setupJOGL - end" );
  
}


void draw()
{
  if( useESS && saveFrameSequence )
  {
    drawJOGL();
  }
  
/*  if( !isDemoRunning )
  {
    background( 0 );    

/*    fill( 0, 64, 128 );
    // Launch
    rect( 20, 40, 60, 20 );
  
    // Quit
    rect( 20, 60, 60, 20 );
    
    // Fullscreen
    rect( 20, 100, 60, 20 );
    
    // Resolutions
    rect( 80, 40, 100, 20 );
    rect( 80, 60, 100, 20 );
    rect( 80, 80, 100, 20 );
    rect( 80, 100, 100, 20 );
    rect( 80, 120, 100, 20 );
    rect( 80, 140, 100, 20 );
    rect( 80, 160, 100, 20 );
  
    // Text  
    fill( 255 );
    text("launch", 50, 55 );
    text("quit", 50, 75 );
    text("fullscreen", 50, 115 );
  
    text("640x400", 130, 55 );
    text("720x576", 130, 75 );
    text("800x600", 130, 95 );
    text("1024x768", 130, 115 );
    text("1280x720", 130, 135 );
    text("1280x768", 130, 155 );
    text("1280x960", 130, 175 );*/
//  }
}

/*
void mousePressed()
{
  if( mousePressed && mouseX >= 20 && mouseX <= 20+60 && mouseY >= 40 && mouseY <= 40+20 )
    initDemo();

  if( mousePressed && mouseX >= 20 && mouseX <= 20+60 && mouseY >= 60 && mouseY <= 60+20 )
    System.exit( 0 );  
        
  if( mousePressed && mouseX >= 20 && mouseX <= 20+60 && mouseY >= 100 && mouseY <= 100+20 )
    isFullScreen = !isFullScreen;

  if( mousePressed && mouseX >= 80 && mouseX <= 80+100 && mouseY >= 40 && mouseY <= 40+20 )
  {
    WIDTH = 640;
    HEIGHT = 400;
  }
  if( mousePressed && mouseX >= 80 && mouseX <= 80+100 && mouseY >= 60 && mouseY <= 60+20 )
  {
    WIDTH = 720;
    HEIGHT = 576;
  }
  if( mousePressed && mouseX >= 80 && mouseX <= 80+100 && mouseY >= 80 && mouseY <= 80+20 )
  {
    WIDTH = 800;
    HEIGHT = 600;
  }
  if( mousePressed && mouseX >= 80 && mouseX <= 80+100 && mouseY >= 100 && mouseY <= 100+20 )
  {
    WIDTH = 1024;
    HEIGHT = 768;
  }
  if( mousePressed && mouseX >= 80 && mouseX <= 80+100 && mouseY >= 120 && mouseY <= 120+20 )
  {
    WIDTH = 1280;
    HEIGHT = 720;
  }
  if( mousePressed && mouseX >= 80 && mouseX <= 80+100 && mouseY >= 140 && mouseY <= 140+20 )
  {
    WIDTH = 1280;
    HEIGHT = 768;
  }
  if( mousePressed && mouseX >= 80 && mouseX <= 80+100 && mouseY >= 160 && mouseY <= 160+20 )
  {
    WIDTH = 1280;
    HEIGHT = 960;
  }
}*/

void drawJOGL()
{
  //writelog( "drawJOGL - start" );
  
  if( saveFrameSequence )
  {
    time += (1.0 / (float)framesPerSecond) + addTime;
  }
  else
  {
    //time = ((millis() * 0.001) - startTime) + addTime;
    time = timer.getCurrTime() + addTime; 
    timer.update();
    //writelog( time + " : " + timer.getFrameRate() + ", " + timer.getFrameTime() + " | eye.z: " + land.eye.z );
  }
  
  
/*  if( keyPressed && key == ' ' )
  {
    //println( time + " : " + frameRate + " | eye.z: " + land.eye.z );
    println( time + " : " + timer.getFrameRate() + ", " + timer.getFrameTime() + " | eye.z: " + land.eye.z );
  }*/

  if( useESS )
  {
    analyze( frequencyScale );
    renderDeep();
    advance(); 
  }

  if( useMinim )
    renderDeep();

  if( saveFrameSequence )
    store( "deep", "f:\\_deep", "png" );
    
  //writelog( "drawJOGL - end" );    
}

void renderDeep()
{
  /*  if( time < 10.0 )
   {
   fogColor.x = Linear.easeOut( time, 0.0, 1/255.0, 10.0 );
   fogColor.y = Linear.easeOut( time, 0.0, 3/255.0, 10.0 );
   fogColor.z = Linear.easeOut( time, 0.0, 36/255.0, 10.0 );
   }*/
   
  fogDensity = fogConstant + ((0.5-(noise(land.eye.z*0.2, time*0.01)))*0.0001f);

  // Update lightpos  
  lightPos.x = -400;
  lightPos.y = 400;
  lightPos.z = 2100-(time*0.9);

  vgl.begin();
//  vgl.background( 0.0, 0.0, 0.0 );
  vgl.background( 0.0, 0.0, 0.0 ); //fogColor.x, fogColor.y, fogColor.z ); //0.0, 0.0, 0.0 );
  

  //
  // Draw background
  //
  if( time >= backgroundTime && time < bgEndTime )
  {
    vgl.ortho();
    //vgl.ortho( 0, width, 0, height );
    vgl.pushMatrix();
    //vgl.gl().glBlendFunc( GL.GL_DST_COLOR, GL.GL_ZERO );
    float bgColor = 1;//time * 0.1;
    float bgDestColor = 1 - (noise(land.eye.z*0.05, time*0.01)*0.3); //.3;
    if( bgColor > bgDestColor ) bgColor = bgDestColor * gamma;
    if( time < fadeBGOutTime )
    {
      vgl.translate( 0, -0.2, 0 );
      vgl.fill( 1*gamma, 1 );
      //vgl.fill( bgColor, 1 );
    }
    else
    {
      vgl.translate( 0, -0.2-((time-fadeBGOutTime)*.25), 0 );    // translate bg up. simulate camera sinking 
      vgl.fill( bgColor, 1-((time-fadeBGOutTime)*.25) );
    }

    vgl.setDepthWrite( false );
    vgl.setDepthMask( false );
//    vgl.setAdditiveBlend();
    vgl.setAlphaBlend();
    vgl.texCoordScale( WIDTH, HEIGHT );
    backG.enable();
    //vgl.rect( width, height );
    vgl.rect( 1, 1 );
    backG.disable();
    vgl.texCoordScale( 1, 1 );
    vgl.popMatrix();
    
    if( time >= logoTime && time < logoTime+20 )
    {
      vgl.pushMatrix();
      vgl.translate( .6+(time-logoTime)*0.01, -0, 0 );
//      vgl.translate( .7-(time-logoTime)*0.01, .1, 0 );
      vgl.setAdditiveBlend();
      if( (time-logoTime)<10 ) vgl.fill( ((time-logoTime)*0.1) );
      else vgl.fill( 1.0-((time-(logoTime+10))*0.1) );
      deepTex.enable();
      vgl.rect( 0.15, 0.125 );
      deepTex.disable();
      vgl.popMatrix();
    }
    
//    backG.enable();    
//    vgl.setAlphaBlend();
//    vgl.enableLighting( false );
//    vgl.gl().glDisable( GL.GL_FOG );
//    vgl.pushMatrix();
////    vgl.scale( 1, -1, 1 );
//
//    float posx = 0;
//    float posy = 0;
//    float z = 0;
//    float sx = 1;
//    float sy = 1;
//    float tsx = width;
//    float tsy = height;
//    vgl.gl().glBegin( GL.GL_QUADS );
//    vgl.gl().glColor4f( bgColor, bgColor, bgColor, 1 );    
//
////    vgl.gl().glColor4f( 64/255.0, 93/255.0, 143.0/255.0, 1 );    
//    vgl.gl().glTexCoord2f( 0*tsx, 0*tsy ); 
//    vgl.gl().glVertex3f( posx+(-1*sx), posy+(-1*sy), z );
//
////    vgl.gl().glColor4f( 64/255.0, 93/255.0, 143.0/255.0, 1 );    
////    vgl.gl().glColor4f( 9/255.0, 51/255.0, 95.0/255.0, 1 );    
//    vgl.gl().glTexCoord2f( 1*tsx, 0*tsy ); 
//    vgl.gl().glVertex3f( posx+(1*sx), posy+(-1*sy), z );
//
////    vgl.gl().glColor4f( 6/255.0, 12/255.0, 46.0/255.0, 1 );    
//    vgl.gl().glTexCoord2f( 1*tsx, 1*tsy ); 
//    vgl.gl().glVertex3f( posx+(1*sx), posy+(1*sy), z );
//
////    vgl.gl().glColor4f( 6/255.0, 12/255.0, 46.0/255.0, 1 );    
//    vgl.gl().glTexCoord2f( 0*tsx, 1*tsy ); 
//    vgl.gl().glVertex3f( posx+(-1*sx), posy+(1*sy), z );
//    vgl.gl().glEnd();   
//
//    vgl.popMatrix();
//    backG.disable();

    vgl.setDepthMask( true );
    vgl.setDepthWrite( true );
  }



  // Set perspective for the world
  vgl.perspective( 45.0, aspectRatio, 1, 6000 );

  //
  // draw landscape
  //
  if( time >= landTime && time < 337.0 )
  {
    vgl.setDepthWrite( true );
    vgl.setDepthMask( false );
    vgl.enableTexture( false );
    vgl.setAlphaBlend();
//    vgl.gl().glBlendFunc( GL.GL_SRC_COLOR, GL.GL_ONE_MINUS_SRC_COLOR );

    float moveLand = (time-landTime) * .9;

    land.eye.set( -400, 300, 2100-moveLand*10 );
    land.target.set( -400, 350, 0-moveLand*10 );
//    land.eye.set( -400, 400, 2100-moveLand*10 );
//    land.target.set( -400, 550, 0-moveLand*10 );
    vgl.camera( land.eye, land.target, up );
    land.invCamMatrix = (vitamin.math.Matrix)vgl.getTransposeViewMatrix();

    //land.setAlpha( (time-landTime)*0.1 );
    land.draw();
  }


  //
  // draw candles
  //
  float move = 0;
  if( time >= candlesTime && time < 337.0 )
  {
    eye = land.eye.copy();
    target = land.target.copy();    // get camera points from the landscape (unify everything)
    grassScene.eye = land.eye.copy();
    grassScene.target = land.target.copy();
    vgl.camera( eye.x, eye.y, eye.z, target.x, target.y, target.z, up.x, up.y, up.z );
    grassScene.camMatrix = vgl.getViewMatrix();

    // Setup fog
    vgl.gl().glEnable( GL.GL_FOG );
    //gl._gl.glFogi( GL.GL_FOG_MODE, GL.GL_LINEAR );
    vgl.gl().glFogi( GL.GL_FOG_MODE, GL.GL_EXP2 );
    vgl.gl().glFogfv( GL.GL_FOG_COLOR, fogColorArray, 0 );
    vgl.gl().glFogf( GL.GL_FOG_DENSITY, fogDensity );
//    vgl.gl().glHint( GL.GL_FOG_HINT, GL.GL_NICEST ); 

    grassScene.draw( (time-candlesTime) );
  }


  //
  // draw spikeys
  //
  if( time > spikeyTime && time < 337.0 )
  {
     float moveSpikey = (time-spikeyTime) * .9;

     vgl.enableLighting( false );
     vgl.setDepthMask( false );
     vgl.setDepthWrite( true );
     vgl.setAlphaBlend();

     //land.eye.set( -500, 400, 2100-moveLand*10 );
     //land.target.set( -500, 450, 0-moveLand*10 );    
     spikey.eye = land.eye.copy(); //.set( -400, 400-moveSpikey*2, 2100-moveSpikey*10 );
     spikey.target = land.target.copy(); //.set( -400, 550-moveSpikey*2, 0-moveSpikey*10 );
     vgl.camera( spikey.eye, spikey.target, up );
     camMatrix = vgl.getViewMatrix();
     invCamMatrix = vgl.getTransposeViewMatrix();
     spikey.draw( time );
  }



  //
  // draw plankton
  //
  if( time >= planktonTime && time < 240.0 )
  {
    float timedif1 = (time-planktonTime)*.1;
    float timedif2 = timedif1 * 2;
    eye.set( 50+cos(timedif1)*100, -20+sin(timedif2)*120, 350 );
    target.set( 50, -20, 0 );
    //eye.set( 0, -300, 400 );
    //target.set( 0, -300, 0 );
    vgl.camera( eye, target, up );

    // Setup fog
    vgl.gl().glEnable( GL.GL_FOG );
    //gl._gl.glFogi( GL.GL_FOG_MODE, GL.GL_LINEAR );
    vgl.gl().glFogi( GL.GL_FOG_MODE, GL.GL_EXP2 );
    vgl.gl().glFogfv( GL.GL_FOG_COLOR, fogColorArray, 0 );
    vgl.gl().glFogf( GL.GL_FOG_DENSITY, fogDensity );
//    vgl.gl().glHint( GL.GL_FOG_HINT, GL.GL_NICEST ); 

    jellys.drawPlankton( (time-planktonTime) );
    jellys.updatePlankton( (time-planktonTime) );
  }



  //
  // Draw jellys
  //
  if( time >= jellyTime  && time < 310.0 )
  {
//    float moveJellys = 0;//(time-jellyTime) * .9;
    jellys.eye = land.eye.copy();
    jellys.target = land.target.copy();
//    jellys.eye.set( -400, 700-moveJellys*.2, 2100-moveJellys*10 );
//    jellys.target.set( -400, 650-moveJellys*.2, 0-moveJellys*10 );
    jeye = jellys.eye.copy();
    jtarget = jellys.target.copy();
    vgl.camera( jeye, jtarget, up );
    jellys.camMatrix = vgl.getViewMatrix();

    // Setup fog
    vgl.gl().glEnable( GL.GL_FOG );
    //gl._gl.glFogi( GL.GL_FOG_MODE, GL.GL_LINEAR );
    vgl.gl().glFogi( GL.GL_FOG_MODE, GL.GL_EXP2 );
    vgl.gl().glFogfv( GL.GL_FOG_COLOR, fogColorArray, 0 );
    vgl.gl().glFogf( GL.GL_FOG_DENSITY, fogDensity );
//    vgl.gl().glHint( GL.GL_FOG_HINT, GL.GL_NICEST );

    //    eyeAngle += ( radians(eye3Angle-eyeAngle)*0.5 );
    //    eyeAngleY += ( radians(eye3AngleY-eyeAngleY)*0.5 );
    //    eye.x = sin( eyeAngle ) * 400;
    //    eye.y = sin( eyeAngleY ) * 400;
    //    eye.z = cos( eyeAngle ) * 400;

    jellys.drawJelly( time-jellyTime );
    jellys.updateJelly( time-jellyTime );
  }


  /*
   * Draw credits scene
   *
  */
  if( time >= tactuTime )
  {
    if( useMinim && !playedOutsphere) {
      outsphere.trigger();
      playedOutsphere = true;
    }
    tactu.draw( time-tactuTime );
  }


  // 
  // Begin of demo.. fade in
  //
  float fadeInTime = 10.0;
  if (time >= 0.0 && time < fadeInTime )
  {
     float beginAlpha = 0.0;
     beginAlpha = 1.0 - (time * 0.1);
     if( beginAlpha <= 0.0 ) beginAlpha = 0.0;
     if( beginAlpha >= 1.0 ) beginAlpha = 1.0;
     vgl.ortho();
     vgl.gl().glDisable( GL.GL_FOG );
     vgl.enableLighting( false );
     vgl.setDepthWrite( false );
     vgl.setDepthMask( false );
     vgl.setAlphaBlend();
     vgl.enableTexture( false );
     vgl.fill( 0, beginAlpha );
     vgl.rect( 1, 1 );
     vgl.setDepthWrite( true );
     vgl.setDepthMask( true );
   }
  
  //
  // End of the demo. fade out
  //
  if (time >= endFadeOutTime)
  {
     float endAlpha = 0.0;
     endAlpha = ( time - endFadeOutTime ) * 0.1; // 10 seconds to fade completely
     if( endAlpha <= 0.0 ) endAlpha = 0.0;
     if( endAlpha >= 1.0 ) 
     {
       endAlpha = 1.0;
       isEndOfDemo = true;
     }
     vgl.ortho();
     vgl.gl().glDisable( GL.GL_FOG );
     vgl.enableLighting( false );
     vgl.setDepthWrite( false );
     vgl.setAlphaBlend();
     vgl.enableTexture( false );
     vgl.fill( 0, endAlpha );
     vgl.rect( 1, 1 );
     vgl.setDepthWrite( true );
     
     if ( useMinim ) {
       ourcontrol1.setValue( endFadeOutTime - time );
       ourcontrol2.setValue( endFadeOutTime - time );
     }
     if ( useESS ) volume( endAlpha );     
   }


  vgl.end();

  if (isEndOfDemo)
  {
    if( !saveFrameSequence ) stopDemo();
    System.exit( 0 );
  }
}



/*
void keyPressed()
{
  if( key == 's' )
  {
    saveFrame( "shot"+frameCount+".png" );
  }  
  if( keyCode == UP )
  {
    addTime += addTimeStep;
    if( useMinim ) track.play( int(time*1000) );
    println( "skiptime: " + time + " camZ: " + land.eye.z );
  }
  if( keyCode == DOWN )
  {
    addTime -= addTimeStep;
    if( useMinim ) track.play( int(time*1000) );
    println( "skiptime: " + time + " camZ: " + land.eye.z );
  }

  if( key == 'q' )
  {
    fogConstant += 0.00001f;
    println( fogDensity );
  }
  if( key == 'a' )
  {
    fogConstant -= 0.00001f;
    println( fogDensity );
  }


//  if( key == 'w' )
//   spikey.uvFurScale += 0.1;
//   if( key == 's' )
//   spikey.uvFurScale -= 0.1;
//   if( key == 'e' )
//   spikey.uvTexScale += 0.1;
//   if( key == 'd' )
//   spikey.uvTexScale -= 0.1;
//   if( key == 'q' )
//   spikey.furLength += 1;
//   if( key == 'a' )
//   spikey.furLength -= 1;
//   println( "uvFurScale = " + spikey.uvFurScale );
//   println( "uvTexScale = " + spikey.uvTexScale );
//   println( "furLength = " + spikey.furLength );
   
   if( key == 't' )
     fogColor.x += 1.0 / 255.0;
   if( key == 'y' )
     fogColor.y += 1.0 / 255.0;
   if( key == 'u' )
     fogColor.z += 1.0 / 255.0;
   if( key == 'g' )
     fogColor.x -= 1.0 / 255.0;
   if( key == 'h' )
     fogColor.y -= 1.0 / 255.0;
   if( key == 'j' )
     fogColor.z -= 1.0 / 255.0;
}

void keyReleased()
{
  //addTime = 0.0;
}
*/

void stop()
{
/*  deepCanvas.removeGLEventListener( deepListener );
  
  if( useMinim )
  {
    track.pause();
    track.close();
    outsphere.close();
    credits.pause();
    credits.close();
    minim.stop();
  }
  
  if( useESS )
  {
    stop_sound(); 
  }

  super.stop();*/
}


class GLRenderer implements GLEventListener, KeyListener
{
  GL _gl;

  public void init( GLAutoDrawable drawable ) 
  {
    this._gl = drawable.getGL();
    _gl.glClearColor( 0, 0, 0, 1 );

    vgl = new VGL( drawable.getGL(), new GLU() );  // dont use processing, and set debug mode on

    setupJOGL();

    int buf[] = new int[1];
    int sbuf[] = new int[1];
    _gl.glGetIntegerv( GL.GL_SAMPLE_BUFFERS, buf, 0 );
    System.out.println( "number of sample buffers is " + buf[0] );
    _gl.glGetIntegerv( GL.GL_SAMPLES, sbuf, 0 );
    System.out.println( "number of samples is " + sbuf[0] );

    if( NUM_SAMPLES > 0 )
      _gl.glEnable( GL.GL_MULTISAMPLE );

    _gl.glEnable( GL.GL_NORMALIZE );
    _gl.glEnable( GL.GL_BLEND );

    _gl.glHint( GL.GL_PERSPECTIVE_CORRECTION_HINT, GL.GL_NICEST ); 
    _gl.glHint( GL.GL_FOG_HINT, GL.GL_NICEST ); 
        
    println( "init finished" );
  }

  public void display( GLAutoDrawable drawable )
  {
    //vgl.setGL( drawable.getGL() );
    drawJOGL();
  }

  public void reshape( GLAutoDrawable drawable, int x, int y, int width, int height ) 
  {
  }

  public void displayChanged( GLAutoDrawable drawable, boolean modeChanged, boolean deviceChanged )
  {
  }
  
  public void keyPressed( KeyEvent e ) 
  {
    if( e.getKeyCode() == KeyEvent.VK_ESCAPE )
    {
      System.exit( 0 );
    }
  }
  
  public void keyReleased( KeyEvent e ) 
  {
  }
 
  public void keyTyped( KeyEvent e ) 
  {
  }
  
/*  final void setRunAsFastAsPossible( boolean flag )
  {
    flag = true;
  }*/
}

  class JellyComparator implements Comparator
  {
    public final int compare( Object a, Object b )
    {
       float z1 = ((ParticleJelly)a).pos.z;
       float z2 = ((ParticleJelly)b).pos.z;
//      float z1 = ((Vector3)a).z;
//      float z2 = ((Vector3)b).z;
  
      if( z1 > z2 )  return 1;
      else return -1;
    }
  }

/*
  // Vector class used for ordering
  class Vector3Order extends Vector3
  {
    Vector3Order()
    {
      super();
      idx = 0;
    }
  
    Vector3Order( float x, float y, float z, int i )
    {
      super( x, y, z);
      idx = i;
    }
  
    Vector3Order( Vector3 v, int i )
    {
      super( v.x, v.y, v.z );
      idx = i;
    }
    
    int idx;
  }*/


class EmitterJelly
{
  Vector3 loc;
  Vector3 vel;
  Vector3 accel;

  float radius;

  Vector3 myColor;

  JellyComparator comparator;
  ArrayList particles;
//  ArrayList particlesViewSpace;
  int maxParticles;
  
  int particleCount;

  int _nebulaTexID;
  //int _particleTexID;  
  int _tailTexID;
  
  EmitterJelly( Vector3 pos, int maxPoints )
  {
    loc        = pos;
    vel        = new Vector3();
    accel      = new Vector3();

    maxParticles = maxPoints;

    radius     = 30;

    myColor    = new Vector3( 1, 1, 1 );

    comparator = new JellyComparator();
    particles  = new ArrayList();
//    particlesViewSpace  = new ArrayList();
    particleCount = 0;
    
    _nebulaTexID = -1;
    //_particleTexID = -1;
    _tailTexID = -1;
    
  }

  /*void exist( float time )
  {
    //render();
    iterateListExist( time );
    //update( time );
  }*/
  
  void update( float time )
  {
    findAccel( time );
    vel.add( accel );
    accel.mul( 0 ); 
    vel.mul( 0.75 );
  }

  void findAccel( float time )
  {
    Vector3 noi = new Vector3();
    noi.x = (noise( time*0.1, cos(time*.25)*1, time*0.2 ) - 0.5) * .2;
    noi.y = (noise( time*0.1, sin(time*.25)*1, time*0.2 ) - 0.5) * .2;
    accel.add( noi );
  }

/*   void setPosition(){
   loc.addSelf( vel );
   
   if( ALLOWFLOOR ){
   if( loc.y > floorLevel ){
   loc.y = floorLevel;
   vel.y = 0;
   }
   }
   }*/
   
   
  void draw( int texID, float time )
  {
/*    // Sort jellyfishes in eye-space and save index for render
    particlesViewSpace.clear();
    for( int i=0; i<particles.size(); i++ )
    {
      Vector3 v0 = ((ParticleJelly)particles.get(i)).pos;
      Vector3 v1 = Vector3.transform( v0, jellys.camMatrix );
      particlesViewSpace.add( new Vector3Order(v1, i) );
    }
    Collections.sort( particlesViewSpace, comparator ); */
    Collections.sort( particles, comparator ); 
    
    /*
    // Debug
    for( int io=0; io<particlesViewSpace.size(); io++ )
    {
      Vector3Order vv = (Vector3Order)particlesViewSpace.get(io);
      println( vv.idx + "= " + vv.z );
    }*/


    //for( int i=particles.size()-1; i>=0; i-- )
    for( int i=0; i<particles.size(); i++ )
    { 
      //int idx = ((Vector3Order)particlesViewSpace.get(i)).idx;
      //ParticleJelly p = ( ParticleJelly )particles.get( idx );
      ParticleJelly p = ( ParticleJelly )particles.get( i );

      if ( !p._isDead )
      {
        //p._nebulaTexID = _nebulaTexID;
        p._tailTexID = _tailTexID;
        //p._particleTexID = texID;
        p.setTexture( texID );

        p.draw( time );
        p.update( time );
        //p.exist( time );
      }
      /*else 
      {
        particles.set( idx, particles.get( particles.size() - 1 ) ); 
        particles.remove( particles.size() - 1 ); 
      }*/
    }

//    particle.disable();
  }

/*
  void addParticles( int _amt )
  {
    //Vector3 v = new Vector3(random(-.52, .52), random(-.2, .2), 0);

    for( int i=0; i<_amt; i++ )
    {
      particles.add( new ParticleJelly( particleCount+1, 1, loc, vel ) );
      
      particleCount ++;
    }

    //    if( ALLOWNEBULA ){
    //      nebulae.add( new Nebula( loc, 40.0, false ) );
    //      nebulae.add( new Nebula( loc, 100.0, false ) );
    //    }
  }
*/
  void addParticle( Vector3 pos )
  {
    particles.add( new ParticleJelly( particleCount+1, 1, pos, vel ) );
    particleCount ++;
    //    if( ALLOWNEBULA ){
    //      nebulae.add( new Nebula( loc, 40.0, false ) );
    //      nebulae.add( new Nebula( loc, 100.0, false ) );
    //    }
  }
/*
  void addParticles( int _amt, Vector3 pos )
  {
    for( int i=0; i<_amt; i++ )
    {
      particles.add( new ParticleJelly( particleCount+1, 1, pos, vel ) );
      
      particleCount ++;
    }

    //    if( ALLOWNEBULA ){
    //      nebulae.add( new Nebula( loc, 40.0, false ) );
    //      nebulae.add( new Nebula( loc, 100.0, false ) );
    //    }
  }

  void addParticles( ParticleJelly _p )
  {
    // play with amt if you want to control how many particles spawn when splitting
    int amt = (int)( _p.radius * .15 );
    for( int i=0; i<amt; i++ )
    {
      particles.add( new ParticleJelly( particleCount+1, _p.gen + 1, _p.pos, _p._vel ) );

      //      particles.add( new Particle( _p.gen + 1, _p.loc[0], _p.vel ) );
      //      if( ALLOWNEBULA )
      //        nebulae.add( new Nebula( _p.loc[0], random( 5.0, 50.0 ), true ) );
      
      particleCount ++;
    }
  }*/
}
class EmitterPlankton
{
  Vector3 loc;
  Vector3 vel;
  Vector3 accel;

  float radius;

  Vector3 myColor;

  ArrayList particles;
  int maxParticles;

  int _particleTexID;  

  FloatBuffer _planktonPos;
  FloatBuffer _planktonTexCoords;


  EmitterPlankton( Vector3 pos, int maxPoints )
  {
    loc        = pos;
    vel        = new Vector3();
    accel      = new Vector3();

    maxParticles = maxPoints;

    radius     = 30;

    myColor    = new Vector3( 1, 1, 1 );

    particles  = new ArrayList();

    int numberElements = 300 * 18;
    _planktonPos = BufferUtil.newFloatBuffer(numberElements);
//    _planktonPos.limit( numberElements );
    _planktonPos.rewind();
//    _planktonPos.flip();

    _planktonTexCoords = BufferUtil.newFloatBuffer(numberElements);
//    _planktonTexCoord.limit( numberElements );
    _planktonTexCoords.rewind();
  }

/*  void update( float time )
  {
    findAccel( time );
    vel.add( accel );
    accel.mul( 0 ); 
    vel.mul( 0.75 );
  }

  void findAccel( float time )
  {
    Vector3 noi = new Vector3();
    noi.x = (noise( time*0.1, cos(time*.25)*1, time*0.2 ) - 0.5) * 2;
    noi.y = (noise( time*0.1, sin(time*.25)*1, time*0.2 ) - 0.5) * 2;
    accel.add( noi );
  }*/
   
/*   void setPosition(){
   loc.addSelf( vel );
   
   if( ALLOWFLOOR ){
   if( loc.y > floorLevel ){
   loc.y = floorLevel;
   vel.y = 0;
   }
   }
   }*/

  void draw( float time )
  {
    int mylength = particles.size(); 

    // Set texture for all textures
    if( _particleTexID > 0 )
    {
      //vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _particleTexID );
    }

    for( int i=mylength-1; i>=0; i-- )
    { 
      ParticlePlankton p = ( ParticlePlankton )particles.get(i); 

      if ( !p._isDead )
      {
        p._particleTexID = _particleTexID;
        p.exist( time );
      }
      else
      {
        particles.set( i, particles.get( particles.size() - 1 ) );
        particles.remove( particles.size() - 1 );
      }
    }
  }


  void drawUsingVertexArray( float time )
  {
    if( _particleTexID > 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _particleTexID );
    }
//    vgl.gl().glDisable( GL.GL_FOG );
//    vgl.enableLighting( false );
//    vgl.enableTexture( false );
//    vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, 0 );

    int index = 0;
    int indextc = 0;
    boolean anyParticleDead = false;
    for( int i=0; i<particles.size(); i++ )
    {
      ParticlePlankton p = ( ParticlePlankton )particles.get( i ); 

      if( !p._isDead )
      {
        p._particleTexID = _particleTexID;
        //p.render( time );
        p.update( time );

          // create the particles shape
          float xs = p.radius*0.5;
          float ys = p.radius*0.5; //.25;
          
          // TRI 1
          _planktonPos.put( index+0, p.pos.x-xs );
          _planktonPos.put( index+1, p.pos.y+ys );
          _planktonPos.put( index+2, p.pos.z );
          _planktonPos.put( index+3, p.pos.x+xs );
          _planktonPos.put( index+4, p.pos.y+ys );
          _planktonPos.put( index+5, p.pos.z );
          _planktonPos.put( index+6, p.pos.x-xs );
          _planktonPos.put( index+7, p.pos.y-ys );
          _planktonPos.put( index+8, p.pos.z );
          _planktonTexCoords.put( indextc+0, 0 );
          _planktonTexCoords.put( indextc+1, 0 );
          _planktonTexCoords.put( indextc+2, 1 );
          _planktonTexCoords.put( indextc+3, 0 );
          _planktonTexCoords.put( indextc+4, 0 );
          _planktonTexCoords.put( indextc+5, 1 );
  
          // TRI 2
          _planktonPos.put( index+9, p.pos.x+xs );
          _planktonPos.put( index+10, p.pos.y+ys );
          _planktonPos.put( index+11, p.pos.z );
          _planktonPos.put( index+12, p.pos.x+xs );
          _planktonPos.put( index+13, p.pos.y-ys );
          _planktonPos.put( index+14, p.pos.z );
          _planktonPos.put( index+15, p.pos.x-xs );
          _planktonPos.put( index+16, p.pos.y-ys );
          _planktonPos.put( index+17, p.pos.z );
          _planktonTexCoords.put( indextc+6, 1 );
          _planktonTexCoords.put( indextc+7, 0 );
          _planktonTexCoords.put( indextc+8, 1 );
          _planktonTexCoords.put( indextc+9, 1 );
          _planktonTexCoords.put( indextc+10, 0 );
          _planktonTexCoords.put( indextc+11, 1 );
  
          index += 18; // 6 vertices of 3 components = 18      
          indextc += 12;   // 6 vertices of 2 components = 12
        
      }
      else
      {
        //particles.set( i, particles.get( particles.size() - 1 ) );
        //particles.remove( particles.size() - 1 );
        //anyParticleDead = true;
        p.reset( random(250, 380), random(-200, -300), random(0, 200) );
      }
    }

    _planktonPos.rewind();
    _planktonTexCoords.rewind();
    vgl.gl().glEnableClientState( GL.GL_VERTEX_ARRAY );
    vgl.gl().glEnableClientState( GL.GL_TEXTURE_COORD_ARRAY ); 
    vgl.gl().glVertexPointer( 3, GL.GL_FLOAT, 0, _planktonPos );
    vgl.gl().glTexCoordPointer( 2, GL.GL_FLOAT, 0, _planktonTexCoords );
    vgl.gl().glDrawArrays( GL.GL_TRIANGLES, 0, particles.size()*2*3 );
    vgl.gl().glDisableClientState( GL.GL_VERTEX_ARRAY );
    vgl.gl().glDisableClientState( GL.GL_TEXTURE_COORD_ARRAY ); 
  }

/*  void render()
  {
    flare3.enable();
    
    gl.pushMatrix();
    gl.translate( loc );
    glReverseCamera( eye, target );
    gl.fill( 1 ); //myColor.x, myColor.y, myColor.z, 1 );
    gl.quad( radius );
    gl.popMatrix();    

    flare3.disable();
  }*/

  /*  void renderReflection(){
   float altitude           = floorLevel - loc.y;
   float reflectMaxAltitude = 300.0;
   float yPer               = 1.0 - altitude/reflectMaxAltitude;
   
   if( yPer > .05 )
   renderImageOnFloor( new Vec3D( loc.x, floorLevel, loc.z ), radius * 10.0, color( 0.5, 1.0, yPer*.25 ), yPer );
   
   if( mousePressed )
   renderImageOnFloor( new Vec3D( loc.x, floorLevel, loc.z ), radius + ( yPer + 1.0 ) * radius * random( 2.0, 3.5 ), color( 1.0, 0, 0 ), yPer );
   }
   
   void iterateListRenderTrails()
   {
   for( Iterator it = particles.iterator(); it.hasNext(); )
   {
   Particle p = (Particle) it.next();
   p.renderTrails();
   }
   }*/

/*
  void addParticles( int _amt )
  {
    //Vector3 v = new Vector3(random(-.52, .52), random(-.2, .2), 0);

    for( int i=0; i<_amt; i++ )
    {
      particles.add( new ParticlePlankton( 1, loc, vel ) );
    }

    //    if( ALLOWNEBULA ){
    //      nebulae.add( new Nebula( loc, 40.0, false ) );
    //      nebulae.add( new Nebula( loc, 100.0, false ) );
    //    }
  }
*/
  void addParticle( Vector3 pos )
  {
    particles.add( new ParticlePlankton( 1, pos, vel ) );
  }

/*
  void addParticles( ParticlePlankton _p )
  {
    // play with amt if you want to control how many particles spawn when splitting
    int amt = (int)( _p.radius * .15 );
    for( int i=0; i<amt; i++ )
    {
      particles.add( new ParticlePlankton( _p.gen + 1, _p.pos, _p._vel ) );

      //      particles.add( new Particle( _p.gen + 1, _p.loc[0], _p.vel ) );
      //      if( ALLOWNEBULA )
      //        nebulae.add( new Nebula( _p.loc[0], random( 5.0, 50.0 ), true ) );
    }
  }*/
}
import java.nio.*;
import javax.media.opengl.*;
//import com.sun.opengl.util.*;
import processing.opengl.*;


//
// based on article: http://ogltotd.blogspot.com/2006/12/render-to-texture.html
//

class FBO
{
  FBO( int width, int height, boolean depthOnly )
  {
    _gl = vgl.gl();

/*    int[] maxAttach = new int[1];
    maxAttach[0] = 0;
    _gl.glGetIntegerv( GL.GL_MAX_RENDERBUFFER_SIZE_EXT, maxAttach, 0 );
    println( "maxattach: " + maxAttach[0] );
    int[] colorBufferCount = new int[1];
    colorBufferCount[0] = 0;
    _gl.glGetIntegerv( GL.GL_MAX_COLOR_ATTACHMENTS_EXT, colorBufferCount, 0 );
    println( "max colorbuffers attachments: " + colorBufferCount[0] );*/

    // Creating arrays for FBO and depth&stencil buffer.
    FBO = new int[1];
    FBO[0] = 0;
    depthStencilBuffer = new int[1];
    depthStencilBuffer[0] = 0; 
    
    _width = width;
    _height = height;
    _depthOnly = depthOnly;
  }

  void init()
  {
    _gl.glGenFramebuffersEXT( 1, FBO, 0 );   
    errcheck();
    println( "FBO id: " + FBO[0] );
    //bind();
    //errcheck();
  }

  void attachTexture( int attachment, int texTarget, int texId )
  {
    _gl.glFramebufferTexture2DEXT( GL.GL_FRAMEBUFFER_EXT, attachment, texTarget, texId, 0 ); 
    errcheck();
    
    if( _depthOnly )
    {
      // No color buffer to draw to or read from
      println( "depth only texture!" );
      _gl.glDrawBuffer( GL.GL_NONE );
      _gl.glReadBuffer( GL.GL_NONE );
    }
  }

  void attachRenderBuffer( int w, int h )
  {
//    if( depthStencilBuffer[0] > 0 ) return;   

    // initialize depth+stencil renderbuffer
    _gl.glGenRenderbuffersEXT( 1, depthStencilBuffer, 0 );    
    errcheck();
    println( "RenderBuffer id: " + depthStencilBuffer[0] );
    
    _gl.glBindRenderbufferEXT( GL.GL_RENDERBUFFER_EXT, depthStencilBuffer[0] );
    errcheck();
    _gl.glRenderbufferStorageEXT( GL.GL_RENDERBUFFER_EXT, GL.GL_DEPTH_COMPONENT24, w, h );
    errcheck();
    _gl.glFramebufferRenderbufferEXT( GL.GL_FRAMEBUFFER_EXT, GL.GL_DEPTH_ATTACHMENT_EXT, GL.GL_RENDERBUFFER_EXT, depthStencilBuffer[0] );
    errcheck();
    _gl.glBindRenderbufferEXT( GL.GL_RENDERBUFFER_EXT, depthStencilBuffer[0] );
    _gl.glFramebufferRenderbufferEXT( GL.GL_FRAMEBUFFER_EXT, GL.GL_STENCIL_ATTACHMENT_EXT, GL.GL_RENDERBUFFER_EXT, depthStencilBuffer[0] );
  }

  void validate()
  {
    int stat = _gl.glCheckFramebufferStatusEXT( GL.GL_FRAMEBUFFER_EXT );
    switch( stat )
    {
      case GL.GL_FRAMEBUFFER_COMPLETE_EXT:
        println( "GL_FRAMEBUFFER_COMPLETE_EXT" );
        break;
      case GL.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
        println( "GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT" );
        break;
      case GL.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
        println( "GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT" );
        break;
      case GL.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
        println( "GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT" );
        break;
      case GL.GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
        println( "GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT" );
        break;
      case GL.GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
        println( "GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT" );
        break;
      case GL.GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
        println( "GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT" );
        break;
      case GL.GL_FRAMEBUFFER_UNSUPPORTED_EXT:
        println( "GL_FRAMEBUFFER_UNSUPPORTED_EXT" );
        break;
      default:
        println( "Unknown" );
        break;
    }
  }

  void bind()
  { 
//    _gl.glBindTexture( GL.GL_TEXTURE_2D, 0 );
    _gl.glBindFramebufferEXT( GL.GL_FRAMEBUFFER_EXT, FBO[0] );
    //_gl.glFramebufferTexture2DEXT( GL.GL_FRAMEBUFFER_EXT, GL.GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, _texId, 0 );
    //errcheck();
    //_gl.glDrawBuffer( GL.GL_COLOR_ATTACHMENT0_EXT );
    //errcheck();
  }

  void unbind()
  {
    _gl.glBindFramebufferEXT( GL.GL_FRAMEBUFFER_EXT, 0 );
    // errcheck();
  }

  void disable()
  {
    _gl.glBindFramebufferEXT( GL.GL_FRAMEBUFFER_EXT, 0 );
    errcheck();
  }

  void drawBuffer( int idx )
  {
    if( idx == 0 )
      _gl.glDrawBuffer( GL.GL_COLOR_ATTACHMENT0_EXT );			 // Draw into the first texture     
    else if( idx == 1 )
      _gl.glDrawBuffer( GL.GL_COLOR_ATTACHMENT1_EXT );			 // Draw into the second texture     
  }

  void delete()
  {
//    if( _fboID )
      _gl.glDeleteFramebuffersEXT( 1, FBO, 0 );
    
//    if( _depthBufferID )
      _gl.glDeleteRenderbuffersEXT( 1, depthStencilBuffer, 0 );
  }

  int checkStatus()
  {     
    int status = _gl.glCheckFramebufferStatusEXT( GL.GL_FRAMEBUFFER_EXT );  

    //Our FBO is perfect, return true
    if( status == GL.GL_FRAMEBUFFER_COMPLETE_EXT )
    {
      System.out.println("FBO is complete.. ok!");
      return 1;
    }

    return status;
  }
  
  
  void errcheck()
  {
    int errCode = vgl.gl().glGetError();
    if( errCode != GL.GL_NO_ERROR ) 
    {
      String errString = vgl.glu().gluErrorString( errCode );
      //fprintf (stderr, "OpenGL Error: %s\n", errString);
      println( errString );
      exit();
    }
  }



  //
  // Members
  //
  protected GL _gl; 
  
  boolean _depthOnly;
  
  protected int[] FBO;
  protected int[] depthStencilBuffer;   
  
  private int _width;
  private int _height;  
};
public class FFTHelper 
{
  public int num,numbands;
  public float spectrum[],ttv[];
  public double v[];
  private double  tv[];
  double dampUp,dampDown,mult;
  boolean doDampen=false,doDampenAsymm=false,doAverage=false,isFirstTime=true,doNorm=false;

  // variables dealing with the calculation of maximum value
  public double maxinternal;
  public float max,maxMinimum,maxMaximum;
  double maxD;
  int maxCnt;

  double bandv[];
  public float band[],bandmax[];
  public int bandsteps;


  public FFTHelper(int _n, int _nbands, boolean doAvg) 
  {
    num=_n;
    numbands=_nbands;
    spectrum=new float[num]; // Visible outside - normalized values
    v=new double[num]; // Visible outside -  - unmodified values
    tv=new double[num]; // Private - temp values
    ttv=new float[num]; // Private - temp values
    doAverage=doAvg;
    doNorm=true;
    mult=1;

    maxMinimum=200;
    maxMaximum=2000;
    maxinternal=maxMinimum;
    maxCnt=0;

    bandsteps=256/numbands;
    band=new float[numbands]; // Visible outside - normalized bands
    bandv=new double[numbands]; // Visible outside - unmodified bands
    bandmax=new float[numbands];
  }


  public void setMaxLimits(float _min,float _max) 
  {
    maxMinimum=_min;
    maxMaximum=_max;
  }


  public void setDamper(double _dup,double _ddown) 
  {
    dampUp=_dup;
    dampDown=_ddown;
    if(dampUp==-1) doDampen=false;
    else doDampen=true;
    doDampenAsymm=true;
  }


  public void setDamper(double _d) 
  {
    setDamper(_d,_d);
    doDampenAsymm=false;
  }


  public float dampenVal(double oldval,double newval) 
  {
    if(doDampenAsymm) {
      if (oldval>newval) oldval=newval*dampDown+oldval* (1-dampDown);
      else oldval=newval*dampUp+oldval* (1-dampUp);
    }
    else oldval=newval*dampUp+oldval* (1-dampUp);
    return (float)oldval;
  }



  public void update( float [] nv )
  {
    if(isFirstTime) isFirstTime=false;

    // average buffer
    if(doAverage) 
    {
      tv[0]=(nv[0]+nv[1])*0.5;
      tv[num-1]=(nv[num-1]+nv[num-2])*0.5;
      for(int i=1; i<num-1; i++) tv[i]=(nv[i-1]+nv[i]+nv[i+1])*0.333;
    }
    else for(int i=0; i<num; i++) tv[i]=nv[i];


    // dampen values if requested
    if(doDampen && !isFirstTime) 
    {
      if(doDampenAsymm)
        for (int i=0; i<num; i++) {
          if(v[i]>tv[i]) v[i]= tv[i]*dampDown+v[i]*(1-dampDown);
          else v[i]= tv[i]*dampUp+v[i]*(1-dampUp);
        }
      else {
        for (int i=0; i<num; i++) {
          v[i]=tv[i]*dampUp+v[i]* (1-dampUp);
          if(v[i]>maxMaximum) v[i]=maxMaximum;
        }
      }
    } else // just copy values
        System.arraycopy(tv,0, v,0, num);

    // normalize buffer
    if(doNorm) 
    {
      double currmax=0;
      double avg=0;
      if (maxCnt>0) {
        maxinternal+=maxD;
        maxCnt--;
      }
      for (int i=0; i<num; i++) {
        if (v[i]>maxinternal) {
          maxinternal=v[i];

          maxD= (v[i]-maxinternal)/4f;
          maxCnt=4;

          maxinternal+=maxD;
          maxCnt--;

        }
        avg+=v[i];
        if(v[i]>currmax) currmax=v[i];
      }
      if(currmax>maxMaximum) currmax=maxMaximum;
      if(maxinternal>maxMinimum && maxCnt==0) maxinternal=currmax*0.005+maxinternal*(1-0.005);
      else if(maxinternal>maxMaximum) maxinternal=maxMaximum;

      avg/=(double)num;
//      System.out.println("max "+max+" currmax "+currmax+" avg "+avg);
      for (int i=0; i<num; i++) {
        spectrum[i]=(float)(v[i]/maxinternal);
        if(spectrum[i]>1) spectrum[i]=1;
      }
      max=(float)maxinternal;


    }
    else for(int i=0; i<num; i++) spectrum[i]=(float)v[i];


    // create dampening buffer
    int fftindex=0;
    double oldval;
    for(int i=0; i<numbands; i++) 
    {
      oldval=bandv[i];
      bandv[i]=0;
      for(int j=0; j<bandsteps; j++) bandv[i]+=spectrum[fftindex++];
      bandv[i]/=(float)bandsteps;
      bandv[i]=dampenVal(oldval,bandv[i]);
      if(bandmax[i]<bandv[i]) bandmax[i]=(float)bandv[i];
      else bandmax[i] *= 0.995;

      band[i]=(float)bandv[i];///(float)bandsteps;
    }
  }


  public void update(float [] nv,int start,int length) 
  {
    System.arraycopy(nv,start, ttv,0, length);
    update(ttv);
  }


  public void updateBands(float [] nv,int div) 
  {
    int n2=nv.length/div;
    float val=0;
    for(int i=0; i<n2; i++) {
      val=0;
      for(int j=0; j<n2; j++) val+=nv[i*n2+j];
      ttv[i]=val/(float)n2;
    }
    update(ttv);
  }


  public double checkBandMax(int valid) 
  {
    return bandmax[valid/bandsteps];
  }

} // end class
class GrassLine
{
  int id;
  
  int numConnections;
  int[] connectIds;
  
  float ysize;
  int numSegments;
  float segStep;
  float lineWidth;
  
  Vector3 origin;
  Vector3[] points;
  Vector3[] renderPoints;
  
//  boolean isSunflower;
  
  float leafTextureSize;
  //XTexture leafTexture;
  
  float segTextureSize;
  //XTexture segTexture;
  
  int _headTexID;


  GrassLine()
  {
    _headTexID = -1;
  }


  void init( int id, Vector3 origin, int numSegs, float ysize )
  {
//    isSunflower = false;
    
    this.id = id;
    
/*    numConnections = 1;//(int)random( 1, 5 );
    connectIds = new int[numConnections];
    for( int i=0; i<numConnections; i++ )
    {
      connectIds[i] = (int)random(1, numGrass-1 );
    }*/
    
    numSegments = numSegs;
    this.ysize = ysize;
        
//    if( id%10 == 0 )//&& id <= 10 )
//      isSunflower = true;
    
    this.origin = new Vector3( origin );

    points = new Vector3[numSegs];
    renderPoints = new Vector3[numSegs];
    
    points[0] = new Vector3( origin );
    renderPoints[0] = points[0].copy();

    for( int i=1; i<numSegments; i++ )
    {
      points[i] = new Vector3();

      float step = ((float)i/(float)numSegments) * ysize;
      segStep = step;
      points[i].x = origin.x;
      points[i].y = origin.y - step;
      points[i].z = origin.z;
      
      renderPoints[i] = points[i].copy();
    }
    
    lineWidth = 1; //random( 1, 3 );
    vgl.gl().glLineWidth( lineWidth );    
  }
  
  void setLeafTextureSize( float texsize )
  {
    leafTextureSize = texsize;
    //leafTexture = new XTexture( name );
  }

  void loadSegmentTexture( String name, float texsize )
  {
    segTextureSize = texsize;
    //segTexture = new XTexture( name );
  }

  void draw( float time )
  {
    float timeAlpha = time * 0.025; //0.1;  
    if( timeAlpha > 1.0 ) timeAlpha = 1.0;
    
    vgl.enableLighting( false );
    vgl.enableTexture( false );
    vgl.setDepthWrite( true );
    vgl.setDepthMask( false );
    vgl.setAdditiveBlend();

/*    vgl.setDepthWrite( true );
    vgl.setAdditiveBlend();
    vgl.gl().glBegin( GL.GL_LINES );

    for( int i=0; i<numConnections; i++ )
    {
      Vector3 me = grasslines[id].renderPoints[ 0 ];//grasslines[id].numSegments-1 ];
      Vector3 nb = grasslines[ connectIds[i] ].renderPoints[ 0]; //grasslines[connectIds[i]].numSegments-1 ];

      vgl.gl().glColor4f( gl._r, gl._g, gl._b, gl._a );
      vgl.gl().glVertex3f( me.x, me.y, me.z );
      vgl.gl().glVertex3f( nb.x, nb.y, nb.z );
    }
    vgl.gl().glEnd();*/


//    vgl.fill( 4*(4/255.0), 4*(10/255.0), 4*(40/255.0), 0.75*timeAlpha );//sq(ffthelper.bandmax[id%255])*5 );
    vgl.fill( 1, 0.95*timeAlpha );//sq(ffthelper.bandmax[id%255])*5 );

    // Render lines
    vgl.gl().glBegin( GL.GL_LINE_STRIP );    

    vgl.gl().glColor4f( vgl._r, vgl._g, vgl._b, 0.1*timeAlpha );
    vgl.gl().glVertex3f( renderPoints[0].x, renderPoints[0].y, renderPoints[0].z );

    for( int i=1; i<numSegments; i++ )
    {
      float newA = (1.0 - (i/(float)numSegments));
      vgl.gl().glColor4f( vgl._r, vgl._g, vgl._b, vgl._a*newA*timeAlpha );
      vgl.gl().glVertex3f( renderPoints[i].x, renderPoints[i].y, renderPoints[i].z );
      //gl._gl.glVertex3f( renderPoints[i+1].x, renderPoints[i+1].y, renderPoints[i+1].z );
    }
    vgl.gl().glEnd();


/*    // Render segment point sprites
    vgl.setAdditiveBlend();
    vgl.setDepthWrite( false );
    vgl.enableTexture( true );
    if( _headTexID > 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _headTexID );
    }
    //for( int i=0; i<numSegments; i+=2 )
    for( int i=0; i<numSegments; i++ )
    {
      vgl.pushMatrix();
      vgl.translate( renderPoints[i] );
      glReverseCamera( grassScene.eye, grassScene.target );
      vgl.quad( 0, 0, 0, leafTextureSize*(time*0.01)*((sin(time*.952+id+i*0.2))) );
      vgl.popMatrix();            
    }*/


/*
    // Render the leaf 
    vgl.enableTexture( true );
    if( _headTexID > 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _headTexID );
    }
    vgl.fill( 1, (0.1+(sin(time*.52+id)))*timeAlpha ); //random(0, 2.0 ) );
    vgl.pushMatrix();
    vgl.translate( renderPoints[numSegments-1] );
    glReverseCamera( grassScene.eye, grassScene.target );
    vgl.quad( 0, 0, 0, leafTextureSize+vgl._a*2 );
    vgl.popMatrix();*/
    
  }


  void update( float time )
  {  
    float freqmax;
    float freq;

/*    freq = sq(ffthelper.band[id%255]) * 60;

    // if its a sunflower make it grow higher
    // this applies for both sunflowers and every 10th "weed"
    if( id%10 == 0 )
    {
      freqmax = (ffthelper.bandmax[id%255]) * 60 * 1.5;
    }
    else
    {
      freqmax = sq(ffthelper.bandmax[id%255]) * 60;
    }*/
    freq = 20;
    freqmax = 21;

    for( int i=1; i<numSegments; i++ )
    {
      renderPoints[i].x = points[i].x + sin( i*.3+freqmax + time) * i;
      renderPoints[i].y = points[i].y - freqmax;

      // make sure we dont change angle for the 2 sunflowers    
//      if( isSunflower == true )
//        renderPoints[i].z = points[i].z + cos( i*.2 + time + freqmax*.5) * i * 0.5;
//      else
        renderPoints[i].z = points[i].z + cos( (numSegments-i)*.52 + time + freqmax*.5) * i * 2.5;
    }
  }
}
import vitamin.fx.*;


class GrassComparator implements Comparator
{
  public final int compare( Object a, Object b )
  {
     float z1 = ((GrassLine)a).origin.z;
     float z2 = ((GrassLine)b).origin.z;
//    float z1 = ((Vector3)a).z;
//    float z2 = ((Vector3)b).z;

    if( z1 > z2 )  return 1;
    else return -1;
  }
}


class GrassScene //extends Effect
{
  int _numGrass;
  GrassLine[] _grassLines;

  GrassComparator comparator;
  ArrayList _grassList;
//  ArrayList _grassListViewSpace;  
  
  XTexture grassTexture;
//  XTexture flare3;
  
  Vector3 eye, target;
  vitamin.math.Matrix camMatrix;

  FloatBuffer _grassSegPos;
  FloatBuffer _grassSegTexCoords;
  FloatBuffer _grassSegColor;


  GrassScene()
  {
  }
/*

  boolean Init( GL gl )
  {}
  
  void Render( float time )
  {}
  
  void Release()
  {}
*/  
  void init( int num )
  {
    eye = new Vector3();
    target = new Vector3();
    camMatrix = new vitamin.math.Matrix();    
    
    grassTexture = new XTexture( "flare3.png" );
    
    comparator = new GrassComparator();
    _grassList = new ArrayList();
//    _grassListViewSpace = new ArrayList();
    
    int numberOfElements = num;
    
    _numGrass = num;
    _grassLines = new GrassLine[_numGrass];
    for( int i=0; i<_grassLines.length; i++ )
    {
      _grassLines[i] = new GrassLine();
      //_grassLines[i].loadSegmentTexture( "flare2.png", 2 );
      _grassLines[i].setLeafTextureSize( random(8, 30) );

      // this is for the same landscape camera
      int numSegments = 15;
      numberOfElements += numSegments;
      
      _grassLines[i].init( i, new Vector3( random(-1850, 1350), random(1600, 2000), random(-1350,100)), numSegments, random(500, 1500) );
//      _grassLines[i].init( i, new Vector3( random(-2850, 2350), random(2000, 2500), random(-1550,300)), 15, random(500, 1550) );
//      _grassLines[i].init( i, new Vector3( random(-2850, 2350), random(2000, 2500), random(-1550,0)), 15, random(500, 1550) );

      // this is for own camera
      //_grassLines[i].init( i, new Vector3( random(-2850, 2350), random(500, 1000), random(-1550,320)), 15, random(500, 1550) );

      // Set flare texture
      _grassLines[i]._headTexID = grassTexture.getId();
 
      // Add to array
      _grassList.add( _grassLines[i] );
    }    
    
    _grassSegPos = BufferUtil.newFloatBuffer(numberOfElements*18);
    _grassSegPos.rewind();

    _grassSegTexCoords = BufferUtil.newFloatBuffer(numberOfElements*12);
    _grassSegTexCoords.rewind();

    _grassSegColor = BufferUtil.newFloatBuffer(numberOfElements*24);
    _grassSegColor.rewind();
  }

  void draw( float time )
  {
/*    // Sort grasslines
    _grassListViewSpace.clear();
    for( int i=0; i<_grassList.size(); i++ )
    {
      Vector3 v0 = ((GrassLine)_grassList.get(i)).origin;
      Vector3 v1 = Vector3.transform( v0, camMatrix );
      _grassListViewSpace.add( new Vector3Order(v1, i) );
    }
    Collections.sort( _grassListViewSpace, comparator );*/
    Collections.sort( _grassList, comparator );

    
    vgl.setDepthMask( true );
    vgl.setDepthWrite( true );
    vgl.setAdditiveBlend();
    
    int index = 0;
    int indexc = 0;
    int indextc = 0;
    int numSegs = 0;
    for( int i=0; i<_grassList.size(); i++ )
    {
      //int idx = ((Vector3Order)_grassListViewSpace.get(i)).idx;
      //GrassLine ll = (GrassLine)_grassList.get( idx );
      GrassLine ll = (GrassLine)_grassList.get( i );

      numSegs += ll.numSegments;

      float xs = ll.leafTextureSize;
      float ys = ll.leafTextureSize;
      for( int si=0; si<ll.numSegments; si++ )
      {        
        Vector3 pos = ll.renderPoints[si];

        xs = ll.leafTextureSize*(time*0.01)*((sin(time*.952+ll.id+si*0.2)));
        ys = ll.leafTextureSize*(time*0.01)*((sin(time*.952+ll.id+si*0.2)));

        // TRI 1
        _grassSegPos.put( index+0, pos.x-xs );
        _grassSegPos.put( index+1, pos.y+ys );
        _grassSegPos.put( index+2, pos.z );
        _grassSegPos.put( index+3, pos.x+xs );
        _grassSegPos.put( index+4, pos.y+ys );
        _grassSegPos.put( index+5, pos.z );
        _grassSegPos.put( index+6, pos.x-xs );
        _grassSegPos.put( index+7, pos.y-ys );
        _grassSegPos.put( index+8, pos.z );
        _grassSegTexCoords.put( indextc+0, 0 );
        _grassSegTexCoords.put( indextc+1, 0 );
        _grassSegTexCoords.put( indextc+2, 1 );
        _grassSegTexCoords.put( indextc+3, 0 );
        _grassSegTexCoords.put( indextc+4, 0 );
        _grassSegTexCoords.put( indextc+5, 1 );
        _grassSegColor.put( indexc+0, 1*gamma );
        _grassSegColor.put( indexc+1, 1*gamma );
        _grassSegColor.put( indexc+2, 1*gamma );
        _grassSegColor.put( indexc+3, 1*gamma );
        _grassSegColor.put( indexc+4, 1*gamma );
        _grassSegColor.put( indexc+5, 1*gamma );
        _grassSegColor.put( indexc+6, 1*gamma );
        _grassSegColor.put( indexc+7, 1*gamma );
        _grassSegColor.put( indexc+8, 1*gamma );
        _grassSegColor.put( indexc+9, 1*gamma );
        _grassSegColor.put( indexc+10, 1*gamma );
        _grassSegColor.put( indexc+11, 1*gamma );
  
        // TRI 2
        _grassSegPos.put( index+9, pos.x+xs );
        _grassSegPos.put( index+10, pos.y+ys );
        _grassSegPos.put( index+11, pos.z );
        _grassSegPos.put( index+12, pos.x+xs );
        _grassSegPos.put( index+13, pos.y-ys );
        _grassSegPos.put( index+14, pos.z );
        _grassSegPos.put( index+15, pos.x-xs );
        _grassSegPos.put( index+16, pos.y-ys );
        _grassSegPos.put( index+17, pos.z );
        _grassSegTexCoords.put( indextc+6, 1 );
        _grassSegTexCoords.put( indextc+7, 0 );
        _grassSegTexCoords.put( indextc+8, 1 );
        _grassSegTexCoords.put( indextc+9, 1 );
        _grassSegTexCoords.put( indextc+10, 0 );
        _grassSegTexCoords.put( indextc+11, 1 );
        _grassSegColor.put( indexc+12, 1*gamma );
        _grassSegColor.put( indexc+13, 1*gamma );
        _grassSegColor.put( indexc+14, 1*gamma );
        _grassSegColor.put( indexc+15, 1*gamma );
        _grassSegColor.put( indexc+16, 1*gamma );
        _grassSegColor.put( indexc+17, 1*gamma );
        _grassSegColor.put( indexc+18, 1*gamma );
        _grassSegColor.put( indexc+19, 1*gamma );
        _grassSegColor.put( indexc+20, 1*gamma );
        _grassSegColor.put( indexc+21, 1*gamma );
        _grassSegColor.put( indexc+22, 1*gamma );
        _grassSegColor.put( indexc+23, 1*gamma );
        

        index += 18; // 6 vertices of 3 components = 18      
        indexc += 24; // 6 vertices of 4 components = 24
        indextc += 12;   // 6 vertices of 2 components = 12
      }
      
      ll.draw( time );
      ll.update( time + i*4 );
    }

    grassTexture.enable();
    vgl.fill( 1, 1 );

    _grassSegPos.rewind();
    _grassSegColor.rewind();
    _grassSegTexCoords.rewind();
    vgl.gl().glEnableClientState( GL.GL_VERTEX_ARRAY );
    vgl.gl().glEnableClientState( GL.GL_COLOR_ARRAY ); 
    vgl.gl().glEnableClientState( GL.GL_TEXTURE_COORD_ARRAY ); 
    vgl.gl().glVertexPointer( 3, GL.GL_FLOAT, 0, _grassSegPos );
    vgl.gl().glColorPointer( 4, GL.GL_FLOAT, 0, _grassSegColor );
    vgl.gl().glTexCoordPointer( 2, GL.GL_FLOAT, 0, _grassSegTexCoords );
    vgl.gl().glDrawArrays( GL.GL_TRIANGLES, 0, numSegs*3*2 );//*numSegs );
    vgl.gl().glDisableClientState( GL.GL_VERTEX_ARRAY );
    vgl.gl().glDisableClientState( GL.GL_COLOR_ARRAY ); 
    vgl.gl().glDisableClientState( GL.GL_TEXTURE_COORD_ARRAY ); 
    
    grassTexture.disable();
  }
  
}  // end class
class JellyScene
{
  // jellyfish sprites
  int _numFrames;
  int _animFrame;    // currframe of our animation
  float _animFramef;    // currframe of our animation (float)  
  XTexture[] _jellyAnim;
  XTexture flare2;
  XTexture flare4;
//  XTexture nebulaTex;

  int numJellys = 2;
//  int numJellys = 10;
  EmitterJelly jellyField; 
  EmitterPlankton planktonField; 

  Vector3 eye, target;
  vitamin.math.Matrix camMatrix;

  boolean sendmorefish = true;
  boolean sendmorefish2 = true;
  
  JellyScene()
  {
    _numFrames = 0;
    _jellyAnim = null;
    
    _animFrame = 0;
    _animFramef = 0.0;
  }

  void init()
  {
    randomSeed( 29 );
    
    this.eye = new Vector3();
    this.target = new Vector3();
    camMatrix = new vitamin.math.Matrix();
    
    _numFrames = 36;
    _jellyAnim = new XTexture[_numFrames];
    for( int i=0; i<_numFrames; i++ )
    {
      if( i <= 9 )
        _jellyAnim[i] = new XTexture( "jellyfish2/jellyfish000"+i+".png" );
      else
        _jellyAnim[i] = new XTexture( "jellyfish2/jellyfish00"+i+".png" );
    }

    flare2 = new XTexture( "flare2.png" );
    flare4 = new XTexture( "flare4.png" );
//    nebulaTex = new XTexture( "flare2.png" );
      
    jellyField = new EmitterJelly( new Vector3(0, 300, 0), 300 );
    while( jellyField.particles.size() < numJellys )
      jellyField.addParticle( new Vector3(random(-300, 0), random(-300, -270), random(900, 1200) ) );

    //jellyField._particleTexID = flare2.getId();
    jellyField._nebulaTexID = flare2.getId(); //nebulaTex.getId();
    jellyField._tailTexID = flare4.getId();
    
    planktonField = new EmitterPlankton( new Vector3(-100, 0, 0), 100 );
    planktonField.vel.set( random(.1, .1), random(-.2, .2), random(-.1,.3) );
//    while( planktonField.particles.size() < 300 )
//      planktonField.addParticles( 1, new Vector3(random(250, 380), random(-200, -300), random(0, 200) ) );
    planktonField._particleTexID = flare4.getId();
  }

  void draw( float time )
  {
    drawPlankton( time );
    drawJelly( time );        
  }
  
  
  void drawJelly( float time )
  {
    //
    // Draw flow particles
    //
    //  gl._gl.glDisable( GL.GL_FOG );
    vgl.enableLighting( false );
    vgl.setDepthMask( false );
    vgl.setDepthWrite( true );
    vgl.setAdditiveBlend();
    //vgl.gl().glBlendFunc( GL.GL_DST_COLOR, GL.GL_ONE );
    jellyField.draw( -1, time );
//    jellyField.draw( _jellyAnim[_animFrame].getId(), time );
  }

  void drawPlankton( float time )
  {
    //
    // Draw plankton particles
    //
    vgl.enableLighting( false );
    vgl.setDepthMask( false );
    vgl.setDepthWrite( true );
    vgl.setAdditiveBlend();
    //  gl.setAlphaBlend();

    planktonField.draw( time );
    //planktonField.drawUsingVertexArray( time );
  }

  void updatePlankton( float time )
  {
    //
    // Update plankton
    //
    if( planktonField.particles.size() < 300 )
    {
      planktonField.addParticle( new Vector3(random(250, 380), random(-200, -300), random(0, 200) ) );
//      planktonField.addParticles( 1, new Vector3(random(150, 380), random(-300, -200), random(0, 200) ) );
    }
  }


  void updateJelly( float time )
  {
    //
    // Update jellys
    //
    if( time < 180 && jellyField.particles.size() < numJellys+int(floor(time*0.42)) )
    {
      float startZ = random(eye.z-600, eye.z-300);
      jellyField.addParticle( new Vector3(random(-300, 0), random(-270, -150), startZ ) );
      jellyField.addParticle( new Vector3(random(-300, 0), random(-270, -150), random(eye.z-600, eye.z-300) ) );
      jellyField.addParticle( new Vector3(random(-300, 0), random(-270, -150), random(eye.z-600, eye.z-300) ) );
//      jellyField.addParticle( new Vector3(random(-300, 100), random(-150, -270), random(1000-1000, 1800-1000) ) );
    }
    if( time >= 90 )
    {
      if( sendmorefish )
      {
        for( int i=0; i<20; i++ )
        {
          float yy = random(-370, -150);  
          jellyField.addParticle( new Vector3(random(-300, 0), yy, random(-500, eye.z-300) ) );
        }
//          jellyField.addParticle( new Vector3(random(-300, 100), random(-150, -370), random(-400, 400) ) );
        sendmorefish = false;
      }
    }
    if( time >= 120 )
    {
      if( sendmorefish2 )
      {
        for( int i=0; i<20; i++ )
        {
          float yy = random(-370, -150);
          jellyField.addParticle( new Vector3(random(-300, 0), yy, random(-500, eye.z-300) ) );
        }
//          jellyField.addParticle( new Vector3(random(-300, 100), random(-150, -370), random(-400, 400) ) );
        sendmorefish2 = false;
      }
    }
  }


  void update( float time )
  {
    updatePlankton( time );
    updateJelly( time );
  }


  void release()
  {
    if( planktonField != null )
      planktonField = null;
    if( jellyField != null )
      jellyField = null;
  }
} // end class
class LandTriangle
{
  int a, b, c;
  
  Vector3 _normal;
}


class Landscape
{
  Vector3 eye, target;
  
  vitamin.math.Matrix localMatrix;
  vitamin.math.Matrix invCamMatrix;

  boolean _useList;
  int _callListID;
  boolean _callListCompiled;

  float _gridScaleX;
  float _gridScaleZ;
  float _heightScale;
  int _numCells;
  Vector3[] _map;
  int[] _indices;
  Vector3[] _vertexNormals;
  Vector3[] _vertexTexCoords;
  
  Vector3[] _grassOffset;

  LandTriangle[] _triangles;

  XTexture _landTex;

//  CG diffspec;
//  ShaderCGFX diffspec;
  int diffspecID;

  float _alpha;

  GL _gl;


  Landscape( GL gl, float scaleX, float scaleZ, float h, int numCells )
  {
    _gl = gl;

    _useList = true;

    eye = new Vector3();
    target = new Vector3();

    localMatrix = new vitamin.math.Matrix();
    localMatrix.identity();

    writelog( "land - load tex" );
    _landTex = new XTexture( "fur_color2.jpg" );

    writelog( "land - load shader" );
//    diffspec = new CG( vgl.gl() );
//    diffspec.loadFXFromFile( dataPath("diffusespecular.cgfx") );
    diffspecID = vgl.addEffectFromFile( dataPath("diffusespecular.cgfx") );
    
    _gridScaleX = scaleX;
    _gridScaleZ = scaleZ;
    _heightScale = h;
    _numCells = numCells;
    _alpha = 1.0;

    writelog( "land - load data" );    
    _vertexTexCoords = new Vector3[numCells*numCells];
    _grassOffset = new Vector3[(numCells)*(numCells)];

    int i, j;
    if( _map != null ) _map = null;
    _map = new Vector3[numCells*numCells];
    for( j=0; j<numCells; j++) 
    {
      for( i=0; i<numCells; i++) 
      {
        _vertexTexCoords[i+j*numCells] = new Vector3();
        _vertexTexCoords[i+j*numCells].x = (float)i*5 / (float)numCells;
        _vertexTexCoords[i+j*numCells].y = (float)j*5 / (float)numCells;

        _grassOffset[i+j*numCells] = new Vector3();
        _grassOffset[i+j*numCells].x = random( -100, 100 );
        _grassOffset[i+j*numCells].y = 0;
        _grassOffset[i+j*numCells].z = random( -100, 100 );
        
        _map[i+j*numCells] = new Vector3();
        _map[i+j*numCells].x = (numCells*_gridScaleX*0.5) - i * _gridScaleX;
        _map[i+j*numCells].z = (numCells*_gridScaleZ*0.5) - j * _gridScaleZ;

        _map[i+j*numCells].y = ((noise(j*.2, i*.1) * _heightScale) - (sqrt(_map[i+j*numCells].x*_map[i+j*numCells].x+_map[i+j*numCells].z*_map[i+j*numCells].z) * 0.125));
        //_map[i+j*numCells].y = ((noise(i*.1, j*.2) * _heightScale) - (sqrt(_map[i+j*numCells].x*_map[i+j*numCells].x+_map[i+j*numCells].z*_map[i+j*numCells].z) * 0.125));

        //_map[i+j*sizee].y = sin(i*0.1+j*0.2)+cos(i*2.2-j*0.1) * heightscale;// - (sqrt(_map[i+j*a.width].x*_map[i+j*a.width].x+_map[i+j*a.width].z*_map[i+j*a.width].z) * 0.5);
      }
    }


    writelog( "land - compute triangle indices" );    
    // compute triangle indices
    _indices = new int[numCells*numCells*3*2];
    int index = 0;
    for(j=0; j<numCells-1; j++) 
    {
      for(i=0; i<numCells-1; i++) 
      {
         int a1 = i+j*_numCells;
         int a2 = (i+1)+j*_numCells;
         int a3 = i+(j+1)*_numCells;
         int a4 = (i+1)+(j+1)*_numCells;

         _indices[index] = a1;
         index++;
         _indices[index] = a3;
         index++;
         _indices[index] = a2;
         index++;  

         _indices[index] = a2;
         index++;
         _indices[index] = a3;
         index++;
         _indices[index] = a4;
         index++;  
      }
    }
    
    _triangles = new LandTriangle[(numCells-1)*(numCells-1)*2];
    int triIndex = 0;
    for(j=0; j<numCells-1; j++) 
    {
      for(i=0; i<numCells-1; i++) 
      {
         int a1 = i+j*_numCells;
         int a2 = (i+1)+j*_numCells;
         int a3 = i+(j+1)*_numCells;
         int a4 = (i+1)+(j+1)*_numCells;
        
         _triangles[triIndex] = new LandTriangle();
         _triangles[triIndex].a = a1;
         _triangles[triIndex].b = a3;
         _triangles[triIndex].c = a2;
         _triangles[triIndex+1] = new LandTriangle();
         _triangles[triIndex+1].a = a2;
         _triangles[triIndex+1].b = a3;
         _triangles[triIndex+1].c = a4;
         triIndex += 2;
      }
    }
    
    writelog( "land - compute normals" );
    computeNormals();

    writelog( "land - use list" );
    if( _useList )
    {
      _callListCompiled = false;
      _callListID = vgl.gl().glGenLists( 1 );
      renderLandscape();
    }

    writelog( "land - end init" );
  }
  
  
  void computeNormals()
  {
    int i=0;
    
    Vector3[] tmpNormals = new Vector3[ _triangles.length ];
    for( i=0; i<_triangles.length; i++ )
    {
     // println( i + ": " + _triangles[i].a );
      Vector3 v1 = _map[ _triangles[i].a ].copy();
      Vector3 v2 = _map[ _triangles[i].b ].copy();
      Vector3 v3 = _map[ _triangles[i].c ].copy();
      
      Vector3 e1 = Vector3.sub( v2, v1 );
      Vector3 e2 = Vector3.sub( v3, v1 );
      
      Vector3 n = Vector3.cross( e1, e2 );
      tmpNormals[ i ] = n.copy();
      n.normalize();
      
      _triangles[i]._normal = n.copy();
    }
    
    //
    // Compute vertex normals
    //
    // Take average from adjacent face normals.
    // TODO. find coplanar faces or get weighted normals.
    // One could also use the smooth groups from 3ds to compute normals. we'll see about that. 
    // this will have to work for now.
    //
    _vertexNormals = new Vector3[ _map.length ];
    
    Vector3 vn = new Vector3();
    int num = 0;    
    for( int vi=0; vi<_map.length; vi++ )
    {
      Vector3 vertex = _map[ vi ];

      vn.set( 0, 0, 0 );

      for( int fi=0; fi<_triangles.length; fi++ )
      {
    	  LandTriangle f = _triangles[ fi ];

    	  // Does this face shares vertex ?
    	  if( vi == f.a || vi == f.b || vi == f.c )
    	  {
	    num++;
	    vn.add( tmpNormals[fi] );  // add un-normalized face normals that share current vertex
	  }
       }

       if( num > 1 ) vn.mul( 1.0f/(float)num );
       vn.normalize();

       // Save vertex normals
      _vertexNormals[vi] = vn.copy();
    }

    // Release temp memory 
    tmpNormals = null; 	    
  }
  
/*  // Get height value at position x,z on the landscape
  float getHeight( float x, float z )
  {
    int xIdx = (int)(x / _gridScaleX);
    int zIdx = (int)(z / _gridScaleZ);
    xIdx += _numCells/2;
    zIdx += _numCells/2;
    
    //println( xIdx + ", " + zIdx + " at height: " + _map[xIdx+zIdx*_numCells].y );
    if( xIdx < 0 || xIdx >= _numCells ) return -99999;
    if( zIdx < 0 || zIdx >= _numCells ) return -99999;
    
    return _map[xIdx+zIdx*_numCells].y;
  }
*/
/*  public float GetHeight( float x, float z ) 
  { 
    if (_map == null) return -99999; 
 
    int xIdx = (int)(x / _gridScaleX);
    int zIdx = (int)(z / _gridScaleZ);
    xIdx += _numCells/2;
    zIdx += _numCells/2;
    if( xIdx < 0 || xIdx >= _numCells ) return -99999;
    if( zIdx < 0 || zIdx >= _numCells ) return -99999;

    float xNormalized = (x % tileScale) / _gridScaleX; 
    float zNormalized = (z % tileScale) / _gridScaleZ; 

    float topHeight = lerp( heightField.GetHeight(tileX, tileZ), heightField.GetHeight(tileX + 1, tileZ), xNormalized ); 

//      positionX += FullMapSizeX * 0.5f; 
//      positionZ += FullMapSizeZ * 0.5f; 
//      float tileScale = heightField.ScaleX; 
//      uint tileX = (uint)(positionX / tileScale); 
//      uint tileZ = (uint)(positionZ / tileScale); 
//      float xNormalized = (positionX % tileScale) / tileScale; 
//      float zNormalized = (positionZ % tileScale) / tileScale; 
//      float topHeight = MathHelper.Lerp(heightField.GetHeight(tileX, tileZ), heightField.GetHeight(tileX + 1, tileZ), xNormalized); 
//      float bottomHeight = MathHelper.Lerp(heightField.GetHeight(tileX, tileZ + 1), heightField.GetHeight(tileX + 1, tileZ + 1), xNormalized); 
//      return MathHelper.Lerp(topHeight, bottomHeight, zNormalized); 
  } */

  float InterpolatedValue( float xp, float yp ) 
  {
/*    float xIdxf = (xPos / (float)_gridScaleX);
    float zIdxf = (yPos / (float)_gridScaleZ);
    int xIdx = (int)(xPos / (float)_gridScaleX);
    int zIdx = (int)(yPos / (float)_gridScaleZ);
    xIdx += _numCells/2;
    zIdx += _numCells/2;

    float dx = xIdxf - xIdx;
    float dy = zIdxf - zIdx;

    //println( xIdx + ", " + zIdx + " at height: " + _map[xIdx+zIdx*_numCells].y );
    if( xIdx < 0 || xIdx >= _numCells ) return -99999;
    if( zIdx < 0 || zIdx >= _numCells ) return -99999;

    float p00 = _map[xIdx+zIdx*_numCells].y;
    float p10 = _map[(xIdx+1)+zIdx*_numCells].y;
    float p01 = _map[xIdx+(zIdx+1)*_numCells].y;
    float p11 = _map[(xIdx+1)+(zIdx+1)*_numCells].y;
*/
    int xPos = (int)(xp / _gridScaleX);
    int yPos = (int)(yp / _gridScaleZ);
    xPos += _numCells/2;
    yPos += _numCells/2;

    int x = (int)Math.floor( xPos );
    int y = (int)Math.floor( yPos );
    float dx = xPos - x;
    float dy = yPos - y;    
    if( x < 0 || x >= _numCells || y < 0 || y >= _numCells ) 
    {
      System.err.println( "(Landscape)   Position outside of the terrain area. ERROR!" );
      return -99999;
    }

/*    float p00 = getHeight( x, y );
    float p10 = getHeight( x+1, y );
    float p01 = getHeight( x, y+1 );
    float p11 = getHeight( x+1, y+1 );*/
    float p00 = _map[x+y*_numCells].y;
    float p10 = _map[(x+1)+y*_numCells].y;
    float p01 = _map[x+(y+1)*_numCells].y;
    float p11 = _map[(x+1)+(y+1)*_numCells].y;
    
    float h0 = p00 * (1 - dy) + p01 * dy;
    float h1 = p10 * (1 - dy) + p11 * dy;
    float hei = h0 * (1 - dx) + h1 * dx;
    
    //println( xp + ", " + yp );
    //println( p00 + ", " + p10 + ", " + p01 + ", " + p11 );
    //println( "res: " + hei );
    
    return hei;
  }
  
  void setAlpha( float a )
  {
    if( a < 1.0 ) 
      _alpha = a;
    else
      _alpha = 1.0;
  }

  void draw()
  {
    //vgl.pushMatrix();
    //vgl.rotateY( 90 );

    vgl.setShader( diffspecID );
    vgl.setTextureParameter( "ColorSampler", _landTex.getId() );
    vgl.setParameter3f( "cameraPos", eye );
    vgl.setParameter4f( "lightPos", lightPos );
    vgl.setParameter4f( "fogColor", fogColor );
    vgl.setParameter1f( "fogDensity", fogDensity );
    vgl.setParameter1f( "kC", kC );
    vgl.setParameter1f( "kL", kL );
    vgl.setParameter1f( "kQ", kQ );
    vgl.setParameter1f( "specularLevel", 16 );
    vgl.setParameter1f( "useSpecular", 1 );
    
    vgl.setMatrixParameterSemantic( "WORLDVIEWPROJECTION", ShaderSemantics.WORLDVIEWPROJECTION_MATRIX, ShaderSemantics.IDENTITY_MATRIX );
    vgl.setMatrixParameterSemantic( "MODELVIEW", ShaderSemantics.VIEW_MATRIX, ShaderSemantics.IDENTITY_MATRIX );
    vgl.setMatrixParameterSemantic( "VIEWINVERSE", ShaderSemantics.VIEW_MATRIX, ShaderSemantics.INVERSE_MATRIX );
    vgl.setMatrixParameterSemantic( "VIEWINVERSETRANSPOSE", ShaderSemantics.VIEW_MATRIX, ShaderSemantics.INVERSE_TRANSPOSE_MATRIX );
    vgl.setMatrixParameterSemantic( "WORLD", localMatrix.getArray() );
    vgl.setMatrixParameterSemantic( "WORLDTOCAMERA", invCamMatrix.getArray() );
    CGpass pass = ((ShaderCGFX)vgl.getActiveShader()).getTechniqueFirstPass( "Technique_DiffuseSpecular" );
    CgGL.cgSetPassState( pass );     
  
/*    CGpass pass = diffspec.getTechniqueFirstPass( "Technique_DiffuseSpecular" );
    //CGpass pass = diffspec.getTechniqueFirstPass( "Technique_DiffuseSpecularNoTexture" );
    diffspec.setTextureParameter( "ColorSampler", _landTex.getId() );
    diffspec.setParameter3f( "cameraPos", eye );
    diffspec.setParameter4f( "lightPos", lightPos );
    diffspec.setParameter4f( "fogColor", fogColor );
    diffspec.setParameter1f( "fogDensity", fogDensity );
    diffspec.setParameter1f( "kC", kC );
    diffspec.setParameter1f( "kL", kL );
    diffspec.setParameter1f( "kQ", kQ );
    diffspec.setParameter1f( "specularLevel", 16 );
    diffspec.setParameter1f( "useSpecular", 1 );

    diffspec.setParameter4x4fBySemantic( "WorldViewProjection", CgGL.CG_GL_MODELVIEW_PROJECTION_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
    diffspec.setParameter4x4f( "view", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
    diffspec.setParameter4x4f( "viewI", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_INVERSE );
    diffspec.setParameter4x4f( "viewIT", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_INVERSE_TRANSPOSE );
    diffspec.setParameter4x4f( "WorldXf", localMatrix );
    diffspec.setParameter4x4f( "W2C", invCamMatrix );
    CgGL.cgSetPassState( pass );*/

    renderLandscape();

    CgGL.cgResetPassState( pass );
    vgl.disableShader();

    //vgl.popMatrix();
  }

  void renderLandscape()
  {
    // If the list is compiled and everything is ok, render
    if( _useList && _callListID > 0 && _callListCompiled )
    {
      vgl.gl().glCallList( _callListID );
      return;
    }

    if( _useList && _callListID > 0 && !_callListCompiled )
    {
      vgl.gl().glNewList( _callListID, GL.GL_COMPILE ); 
    }

    //
    // render the landscape
    //
     // render!
     int index = 0;
     _gl.glBegin( GL.GL_TRIANGLES );
     for( int i=0; i<_triangles.length; i+=1 )
     {
         Vector3 v1 = _map[ _triangles[i].a ].copy();
         Vector3 v2 = _map[ _triangles[i].b ].copy();
         Vector3 v3 = _map[ _triangles[i].c ].copy();

         Vector3 uv1 = _vertexTexCoords[ _triangles[i].a ].copy();
         Vector3 uv2 = _vertexTexCoords[ _triangles[i].b ].copy();
         Vector3 uv3 = _vertexTexCoords[ _triangles[i].c ].copy();

         //Vector3 n = _triangles[i]._normal;
         Vector3 n1 = _vertexNormals[_triangles[i].a];
         Vector3 n2 = _vertexNormals[_triangles[i].b];
         Vector3 n3 = _vertexNormals[_triangles[i].c];

         //_gl.glColor4f( 1, 1, 1, 1 );
//         float colmul = 3;
//         _gl.glColor4f( (6/255.0)*colmul*_alpha, (13/255.0)*colmul*_alpha, (23/255.0)*colmul*_alpha, 1*_alpha );
//         float colmul = 4.0;
//         _gl.glColor4f( (1/255.0)*colmul*_alpha, (36/255.0)*colmul*_alpha, (36/255.0)*colmul*_alpha, 1*_alpha );

         float colmul = 9.0 - (noise(eye.z*0.2, time*0.01)*0.3*9);
         _gl.glColor4f( ((1*gamma)/255.0)*colmul*_alpha, ((13*gamma)/255.0)*colmul*_alpha, ((36*gamma)/255.0)*colmul*_alpha, 1*_alpha );
         //_gl.glColor4f( (1/255.0)*colmul*_alpha, (7/255.0)*colmul*_alpha, (20/255.0)*colmul*_alpha, 1*_alpha );

//         float colmul = 0.6;
//         _gl.glColor4f( .1*colmul*_alpha, .1*colmul*_alpha, 0.04+1*colmul*_alpha, 1*colmul*_alpha );

         _gl.glNormal3f( n1.x, n1.y, n1.z );
         _gl.glTexCoord2f( uv1.x, uv1.y );
         _gl.glVertex3f( v1.x, v1.y, v1.z );

         _gl.glNormal3f( n2.x, n2.y, n2.z );
         _gl.glTexCoord2f( uv2.x, uv2.y );
         _gl.glVertex3f( v2.x, v2.y, v2.z );

         _gl.glNormal3f( n3.x, n3.y, n3.z );
         _gl.glTexCoord2f( uv3.x, uv3.y );
         _gl.glVertex3f( v3.x, v3.y, v3.z );
     }
     _gl.glEnd();


    // End display list
    if( _useList && _callListID > 0 && !_callListCompiled )
    {
      vgl.gl().glEndList();
      _callListCompiled = true;
    }
  }

} // end class
import krister.Ess.*; 

AudioChannel chn;
FFT fft; 
int frameNumber = 0; 

//float fpsFudgeFactor = 30.0 / 29.97; // normally 1.0f
//float framesPerSecond = 30.0 * fpsFudgeFactor; 
int framesPerSecond = 30;

float level;  // channel level

float[] fftbuffer;

float lastTime;
float currentTime;


void init_sound( int spectrumLength, String filename ) 
{
  lastTime = 0.0;
  currentTime = 0.0;
  
  //
  // ESS
  //
  Ess.start( this ); 
  Ess.masterVolume( 1.0 );

  println( "loading " + filename );
  chn = new AudioChannel( filename ); 
  //println( "channel sample rate:  " + chn.sampleRate );

  fft = new FFT( spectrumLength*2 ); 

//  fft.equalizer( true );
  fft.limits();

//  //
//  // HELPER
//  // 
//  ffthelper = new SoniaHelper( spectrumLength, 256, false );
//  ffthelper.setMaxLimits( 200, 2000 );
//  damperval = 0.62f;
//  ffthelper.setDamper(damperval);

  fftbuffer = new float[spectrumLength];
}


void play_sound()
{
  chn.play();
}


void analyze( float freq_scale ) 
{ 
  int pos = (int)(frameNumber * chn.sampleRate / framesPerSecond);
  //println( "pos: " + pos );
  if( pos >= chn.size )
  {
    exit();
  }

  fft.getSpectrum( chn.samples, pos );
  
  for( int i=0; i<fft.spectrum.length; i++ )
    fftbuffer[i] = fft.spectrum[i] * freq_scale;

//  ffthelper.update( fftbuffer );


  // intensify freq bands
//  for( int i=0; i<ffthelper.band.length; i++ )
//  {
//    ffthelper.band[i] *= freq_scale; 
//    ffthelper.bandmax[i] *= freq_scale; 
//  }
}


void store( String demoName, String directory, String extension ) 
{ 
  saveFrame( directory + "\\" + demoName + "_" + nf(frameNumber, 7) + "." + extension ); 
}


void advance() 
{ 
  if ((frameNumber%framesPerSecond) == 0) 
  {
     lastTime = currentTime;
     currentTime = (millis()*0.001-startTime);
    println( "Frame: " + frameNumber 
             + " | time: " + ((currentTime/60.0)/60.0) + "h"
             + " | average time per frame: " + ((currentTime-lastTime)/30.0) + " secs" );
  }

  frameNumber++; 
}

void volume(float value){
    Ess.masterVolume(value);
}

void stop_sound()
{
  chn.stop();
  Ess.stop();
}  


class ParticleJelly
{
  int index;
  
//  int len;            // number of elements in position array
//  Vector3[] loc;        // array of position vectors
//  Vector3 startLoc;     // just used to make sure every loc[] is initialized to the same position
  Vector3 pos;          // position point
  Vector3 oldPos;
  Vector3 _vel;          // velocity vector
  Vector3 _accel;        // acceleration vector
  float radius;       // particle's size
  float age;          // current age of particle
  float lifeSpan;       // max allowed age of particle
  float agePer;       // range from 1.0 (birth) to 0.0 (death)
  int gen;            // number of times particle has been involved in a SPLIT
  boolean _isDead;     // if age == lifeSpan, make particle die

  int _particleTexID;
  int _nebulaTexID;
  int _tailTexID;
  
  float angleStart;
  float angleEnd;
  
  int numFrames;
  int animFrame;
  float animFramef;    // currframe of our animation (float)
  
  float seaLevel = 350.0;

  Ribbon rib;
  Vector3[] _tailCopy;
  Vector3[] _tailCopy2;
  Vector3[] _tailCopy3;
  Vector3[] _tailCopy4;

//  Nebula neb;


  ParticleJelly( int idx, int gen, Vector3 loc, Vector3 vel )
  {
    index = idx;
    
    //int len = 10;
    //startLoc = loc;
    //this.loc = new Vector3[len];

    pos = loc.copy();
    oldPos = loc.copy();

    _vel = vel.copy();
//    pos = new Vector3(random(-0.52, 0.52), random(-0.2, 0.2), 0);
//    _vel = new Vector3(random(-.52, .52), random(-.2, .2), 0);
//    _vel = new Vector3();
    _accel = new Vector3(random(-.052, .052), random(-.2, .532), random(-.052, .0532)); //new Vector3();

    radius = 60; //30;

    age = 0; //2+random(5);  // birth
    lifeSpan = 112+random(85); // death

    _isDead = false;
    
    angleStart = 0;
    angleEnd = 0;

//    rib = new Ribbon( (int)random(20, 40), 1.0, 8.0, false );
    rib = new Ribbon( (int)random(40,70), 1.0, 8.0, false );
    //rib.loadHeadTexture( "flare2.png" );
    rib.setHead( pos.x, pos.y, pos.z );
    rib.setTimeToLive( lifeSpan );
    rib.computeTail(); 

    _tailCopy = new Vector3[rib._tailSize];
    _tailCopy2 = new Vector3[rib._tailSize];
    _tailCopy3 = new Vector3[rib._tailSize];
    _tailCopy4 = new Vector3[rib._tailSize];
    for( int i=0; i<_tailCopy.length; i++ )
    {
      _tailCopy[i] = new Vector3();
      _tailCopy[i] = rib._tail[i].copy();

      _tailCopy2[i] = new Vector3();
      _tailCopy2[i] = rib._tail[i].copy();

      _tailCopy3[i] = new Vector3();
      _tailCopy3[i] = rib._tail[i].copy();

      _tailCopy4[i] = new Vector3();
      _tailCopy4[i] = rib._tail[i].copy();
    }

//    neb = new Nebula( loc, radius*0.5, false );
    
    numFrames = jellys._numFrames;
    animFrame = (int)random( 0, numFrames-1 );
    animFramef = animFrame;
  }

  void computeAndRender( float time )
  {
    draw( time );
    update( time );
  }
  
  void setTexture( int id )
  {
    //_particleTexID = id;
    _particleTexID = jellys._jellyAnim[animFrame].getId();
  }

  void draw( float time )
  {
    float depthAlpha = 0.75; //(pos.z/154.0);
    
    vgl.setAdditiveBlend();
    
    //
    // Draw the attached tails/ribbons
    //
    //rib.addHead( 0, cos(time*1.06)*6, sin(time*3.4)*8 );
    rib.setHead( pos.x, pos.y, pos.z );
    rib.updateJelly( time );
    if( _tailTexID > 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _tailTexID );
      rib._tailTexID = _tailTexID;
    }
    for( int i=0; i<_tailCopy.length; i++ )
    {
      _tailCopy[i] = rib._tail[i].copy();      
      _tailCopy2[i] = rib._tail[i].copy();
      _tailCopy3[i] = rib._tail[i].copy();
      _tailCopy4[i] = rib._tail[i].copy();

      // offseting tails
      float tailOffset = 1.94;
      _tailCopy[i].x += tailOffset;
      _tailCopy[i].z += tailOffset;
      _tailCopy2[i].x -= tailOffset;
      _tailCopy2[i].z -= tailOffset;
      _tailCopy3[i].x += tailOffset;
      _tailCopy3[i].z -= tailOffset;
      _tailCopy4[i].x -= tailOffset;
      _tailCopy4[i].z += tailOffset;

      float vel = rib._add.y + .21;
//      _tailCopy[i].x += cos(vel*-7*time+rib._head.y*.15) * i*0.1 * 1;
//      _tailCopy[i].z += cos(vel*-7*time+rib._head.y*.15) * i*0.1 * 1;
//      _tailCopy2[i].x += sin(vel*7*time+rib._head.y*.15) * i*0.1 * 1;
//      _tailCopy2[i].z += sin(vel*7*time+rib._head.y*.15) * i*0.1 * 1;
      _tailCopy[i].x += cos(vel*7*time+i*.01+index) * i*0.05 * 1;
      //_tailCopy[i].y -= vel;
      //_tailCopy[i].z += cos(vel*7*time+i*.01) * i*0.1 * 1;
      _tailCopy2[i].x -= cos(vel*7*time+i*.01+index) * i*0.05 * 1;
      //_tailCopy2[i].y -= vel;
      //_tailCopy2[i].z -= cos(vel*7*time+i*.01+index+2) * i*0.1 * 1;
      _tailCopy3[i].x -= cos(vel*7*time+i*.01+index) * i*0.05 * 1;
      //_tailCopy3[i].z -= cos(vel*7*time+i*.01+index+3) * i*0.1 * 1;
      _tailCopy4[i].x -= cos(vel*7*time+i*.01+index) * i*0.05 * 1;
      //_tailCopy4[i].z -= cos(vel*7*time+i*.01+index+4) * i*0.1 * 1;
    }
    //rib.draw( time );
    rib.renderTailFromBuffer( rib._tail, 1, depthAlpha );
    rib.renderTailFromBuffer( _tailCopy, 1, depthAlpha );
    rib.renderTailFromBuffer( _tailCopy2, 1, depthAlpha );
    rib.renderTailFromBuffer( _tailCopy3, 1, depthAlpha );
    rib.renderTailFromBuffer( _tailCopy4, 1, depthAlpha );

/*
    //
    // Render the original point NEBULA (grows on initial position)
    //
    if( _nebulaTexID >= 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _nebulaTexID );
    }
    neb.computeAndRender();
*/

    //
    // Render back "nebula" image
    //
    if( _nebulaTexID >= 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _nebulaTexID );
    }
    vgl.pushMatrix();
    vgl.translate( this.pos );
    glReverseCamera( jellys.eye, jellys.target );
    //vgl.rotateZ( time*20+age );
    vgl.fill( 1, 1-(0.3+0.2*sin(time*2.2+index+agePer)) );
//    gl.fill( 1, agePer*2 );
//    gl.fill( 1, agePer );
//    gl.fill( 1 - ffthelper.band[index*4%255]*5, agePer*2 );
    vgl.rect( radius*.5+time*0.05, radius*.3+time*.05 );
//    vgl.rect( radius*.4+time*0.5, radius*.2+time*.5 );
    vgl.popMatrix();

    //
    // Render the actual particle (jellyfish)
    //
    if( _particleTexID > 0 )
    {
      //vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _particleTexID );
    }
    
/*    float deltaX = this.oldPos.x - this.pos.x; 
    float deltaY = this.oldPos.y - this.pos.y; 
    float deltaZ = this.oldPos.z - this.pos.z; 
    angleEnd = degrees(atan2( deltaY, deltaX ));

    angleStart += (angleEnd-angleStart)*0.1;
    float angle = ((angleStart)+90)*3;
    if( angle < -30 ) angle = -30;
    if( angle > 30 ) angle = 30;*/

    vgl.pushMatrix();
    vgl.translate( pos.x, pos.y-radius*0.1, pos.z );
    glReverseCamera( jellys.eye, jellys.target );
//    vgl.rotateZ( angle );
    vgl.scale( 1, -1, 1 );
    vgl.fill( 1, (1-(0.3+0.2*sin(time*2.2+index+agePer)))*(1-(agePer*2)) );
    //vgl.fill( .96, 1-(agePer*4) ); //*0.1f );
//    gl.fill( .65, 1-agePer*2 ); //*0.1f );
//    gl.quad( radius *.5 + ffthelper.band[(index)%255]*5 );
//    gl.quad( radius *.5 );
    vgl.rect( radius*.5, radius*.4 );
    vgl.rect( radius*.5, radius*.4 );
    vgl.popMatrix();
  }


  void update( float time )
  {
    // keep track on last frame's position
    oldPos = pos.copy();

    // simple physics
    pos.add( _vel );
    _vel.add( _accel );
    _accel.mul( 0 );
//    _vel.mul( 0.95 );
    _vel.mul( 0.88 );//+ ffthelper.band[(index)%255]*0.1 );


    // add some noise to acceleration
    Vector3 noi = new Vector3();
//    noi.y = (-0.5 + noise( _vel.x*0.5, _vel.y*.03, time*0.01 )) * .5;

/*
    noi.x = (-0.5 + noise( pos.x*0.03, pos.y*0.1+pos.z*0.03, time*0.1)) * 2.499;
//    noi.x = (-0.5 + noise( pos.x*0.3, pos.y*0.1+pos.z*0.3, time*0.1)) * 2.499;
    noi.y = (-0.235 + noise( 10+pos.x*0.1, 100+pos.x*.01, time*1 )) * 1.495;
    noi.z = (-0.55 + noise( 10+pos.y*0.1, 100+pos.x*.01, time*1 )) * 1.495;
//    noi.z = -(-0.45 + noise( 10+pos.y*0.1, 100+pos.x*.01, time*1 )) * 1.495;
    noi.mul( 0.35 );*/
    noi.x = (-0.5 + noise( pos.x*0.03, pos.y*0.1+pos.z*0.03, time*0.1)) * 0.13;
//    noi.x = (-0.5 + noise( pos.x*0.3, pos.y*0.1+pos.z*0.3, time*0.1)) * 2.499;
    noi.y = (-0.235 + noise( 10+pos.x*0.1, 100+pos.x*.01, time*1 )) * 0.6; //0.65;
    noi.z = (-0.55 + noise( 10+pos.y*0.1, 100+pos.x*.01, time*1 )) * 1.8;
//    noi.z = -(-0.45 + noise( 10+pos.y*0.1, 100+pos.x*.01, time*1 )) * 1.495;
    noi.mul( 0.65 ); //0.85 );

    _accel.add( noi );

    // check for age
    age += 0.05;
/*    if( age < 0 )
    {
      ISDEAD = true;
      age = 0;
    }*/

//    if( pos.y > seaLevel )
    if( age > lifeSpan )
    {
      _isDead = true;
    } 
    else 
    {
      agePer = (age/(float)lifeSpan);
//      agePer = 1.0 - (age/(float)lifeSpan);
    }


    // Update animation frames
    animFramef += 0.2+abs(_vel.y*0.5); //0.5;
    animFrame = floor(animFramef);
    if( animFrame >= numFrames )
    {
      animFramef = 0.0f;
      animFrame = 0;
    }
  }
}

class ParticlePlankton
{
//  int len;            // number of elements in position array
//  Vector3[] loc;        // array of position vectors
//  Vector3 startLoc;     // just used to make sure every loc[] is initialized to the same position
  Vector3 pos;          // position point
  Vector3 oldPos;
  Vector3 _vel;          // velocity vector
  Vector3 _accel;        // acceleration vector
  float radius;       // particle's size
  float age;          // current age of particle
  float lifeSpan;       // max allowed age of particle
  float agePer;       // range from 1.0 (birth) to 0.0 (death)
  int gen;            // number of times particle has been involved in a SPLIT
  boolean _isDead;     // if age == lifeSpan, make particle die

  int _particleTexID;  


  ParticlePlankton( int gen, Vector3 loc, Vector3 vel )
  {
    //int len = 10;
    //startLoc = loc;
    //this.loc = new Vector3[len];
    
    pos = loc.copy();
    oldPos = loc.copy();
    
    _vel = vel.copy();
//    pos = new Vector3(random(-0.52, 0.52), random(-0.2, 0.2), 0);
//    _vel = new Vector3(random(-.52, .52), random(-.2, .2), 0);
//    _vel = new Vector3();

    _accel = new Vector3(random(-.82, .82), random(-.42, .42), random(-.82, .82)); // push to side
//    _accel = new Vector3(random(-.52, .52), random(-.2, .2), 0); // push to side

//    radius = 2+random(4);
    radius = 1+random(2);

    age = 2+random(5);
    lifeSpan = 2+random(55);

    _isDead = false;
    
    _particleTexID = -1;
  }

  void exist( float time )
  {
    render( time );
    update( time );
  }


  void render( float time )
  {
/*    if( _particleTexID > 0 )
    {
      //vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _particleTexID );
    }*/
    
    vgl.setAdditiveBlend();
    vgl.setDepthWrite( true );
    vgl.setDepthMask( false );
    vgl.enableLighting( false );

    vgl.pushMatrix();
    vgl.translate( this.pos );
//    glReverseCamera( eye, target );    
    glReverseCamera2( this.pos, this.oldPos );
    
    if( time < 230 )
      vgl.fill( 0.6, 0.7, 0.95, abs(cos(.5*time+age*.13)*0.93) );
    else
    {
      float aa = (abs(cos(.5*time+age*.13)*0.93)*(1.0-((time-230)*0.1)));
      if( aa < 0.0 ) aa = 0.0;
      vgl.fill( 0.6, 0.7, 0.95, aa );
    }
//    vgl.rect( 0, 0, 0, radius*1.3*0.5, radius*.475 );
    vgl.rect( 0, 0, 0, radius*.5, radius*.25 );
//    vgl.rect( 0, 0, 0, radius*1.3, radius*.475 );
    vgl.popMatrix();
  }
  
  void update( float time )
  {
    // keep track on last frame's position
    oldPos = pos.copy();
    
    // compute new position with simple physics
    pos.add( _vel );
    _vel.add( _accel );
    _vel.mul( 0.975 );

    _accel.mul( 0.0 );

    // add some noise to acceleration
    Vector3 noi = new Vector3();
    noi.y = (-0.3 + noise( _vel.x*0.5, _vel.y*.03, time*10.01 )) * .85;
//    noi.y = (-0.18 + noise( 10+pos.x*0.1, 100+pos.x*.01, time*.1 )) * .55;
    noi.x = -(-0.3 + noise( pos.x*0.3, pos.y*0.3, time*0.1)) * 0.95;
    noi.z = (-0.4 + noise( pos.x*0.3, pos.y*0.3, time*0.1)) * .135;
    noi.mul( 0.75 );
    _accel.add( noi );
    
    // check for age
    age += 0.1;
/*    if( age < 0 )
    {
      ISDEAD = true;
      age = 0;
    }*/

    if( age > lifeSpan ) //|| pos.y < floorLevel )
    {
      _isDead = true;
    } 
    else 
    {
      agePer = 1.0 - age/(float)lifeSpan;
    }     
  }
  
  void reset( float x, float y, float z )
  {
    pos.set( x, y, z );
    oldPos = pos.copy();
    
    _vel.set( 0, 0, 0 );

    _accel.set( random(-.82, .82), random(-.42, .42), random(-.82, .82) );

//    radius = 2+random(4);
    radius = 1+random(2);

    age = 2+random(5);
    lifeSpan = 2+random(55);
    
    _isDead = false;
  }
    
}
class Ribbon
{
  Ribbon()
  {
    _doRenderHead = true;
    _doUpdate = true;
    
    _tailTexID = -1;
    _headTexID = -1;

    _tailSize = 20;
    _tailRenderSegments = 0;
    _tailWidth = 1.0;

    _initPos = new Vector3();

    _headSize = 8*3;
    _head = new Vector3();
    _right = new Vector3();

    _add = new Vector3();

    _age = 0;
    _agePer = 0;
    _timeToLive = 100;
    _invTimeToLive = 1.0 / _timeToLive;

    _facets = 8;

    _colour = new Vector4( 1, 1, 1, 1 );

    yTable = new int[_tailSize];
    for( int i=0; i<_tailSize; i++ )
      yTable[i] = i * (_facets+1);
    _vertices = new Vector3[ ((_tailSize)*(_facets+1)) ];
    _normals = new Vector3[ ((_tailSize)*(_facets+1)) ];
    for( int i=0; i<((_tailSize)*(_facets+1)); i++ )
    {
      _vertices[i] = new Vector3();
      _normals[i] = new Vector3();
    }
  }

  Ribbon( int tailSize, float tailWidth, float headSize, boolean renderHead )
  {
    _doRenderHead = renderHead;
    _doUpdate = true;

    _tailSize = tailSize;
    _tailRenderSegments = 0;
    _tailWidth = tailWidth;

    _initPos = new Vector3();

    _headSize = headSize;
    _head = new Vector3();
    _right = new Vector3();

    _add = new Vector3();    

    _age = 0;
    _agePer = 0;
    _timeToLive = 100;
    _invTimeToLive = 1.0 / _timeToLive;

    _colour = new Vector4( 1, 1, 1, 1 );

    _facets = 8;
    
    yTable = new int[_tailSize];
    for( int i=0; i<_tailSize; i++ )
      yTable[i] = i * (_facets+1);
    _vertices = new Vector3[ ((_tailSize)*(_facets+1)) ];
    _normals = new Vector3[ ((_tailSize)*(_facets+1)) ];
    for( int i=0; i<((_tailSize)*(_facets+1)); i++ )
    {
      _vertices[i] = new Vector3();
      _normals[i] = new Vector3();
    }
  }


  void setHeadTexture( int id )
  {
    _headTexID = id;
    //_headTex = new XTexture( file );
  }

  void setTailTexture( int id )
  {
    _tailTexID = id;
    //_headTex = new XTexture( file );
  }


  void computeTail()
  {
    if( _tail == null )
    {
      _tail = new Vector3[_tailSize];
    }

    for( int i=0; i<_tailSize; i++ )
    {
      _tail[i] = new Vector3();
      _tail[i] = _head.copy();
    }
  }

  boolean isDead()
  {
    if( _age >= _timeToLive )
      return true;

    return false;
  }


  void setTimeToLive( float t )
  {
    _timeToLive = t;
    _invTimeToLive = 1.0 / _timeToLive;
  }

  void setHeadY( float y )
  {
    _head.y = y;
    _initPos = _head.copy();
  }

  void setHead( float x, float y )
  {
    _head.set( x, y, 0 );
    _initPos = _head.copy();
  }

  void setHead( float x, float y, float z )
  {
    _head.set( x, y, z );
    _initPos = _head.copy();
  }

  void setHead( Vector3 h )
  {
    _head = h;
    _initPos = _head.copy();
  }

  void addHead( float x, float y )
  {
    if( _doUpdate )
      _head.add( x, y, 0 );
  }

  void addHead( float x, float y, float z )
  {
    if( _doUpdate )
      _head.add( x, y, z );
  }

  void addHead( Vector3 a )
  {
    if( _doUpdate )
      _head.add( a );
  }

  void renderHead( boolean f )
  {
    _doRenderHead = f;
  }


  void update( float time )
  {
    if( _age < _timeToLive )
    {
      if( _tailRenderSegments < _tailSize )
      {
        for( int i=_tailRenderSegments; i>0; i-- )
        {
          _tail[i] = _tail[i-1];
        }
        _tail[0] = _head.copy();
        
        if( _tailRenderSegments < _tailSize-1 )
          _tailRenderSegments++;
      }
      else
      {
        _doUpdate = false;
      }
    }
    
    if( _doUpdate )
    {    
      _head.add( _add );
    
      _age += 0.05;
//    _age ++;
      _agePer = _age * _invTimeToLive;
    }
  }


  void updateJelly( float time )
  {
    //if( _age < _timeToLive )
    {
      //if( _tailRenderSegments < _tailSize )
      {
        for( int i=_tailRenderSegments; i>0; i-- )
        {
          _tail[i] = _tail[i-1];
        }
        _tail[0] = _head.copy();
        
        if( _tailRenderSegments < _tailSize-1 )
          _tailRenderSegments++;
      }
      /*else
      {
        _doUpdate = false;
      }*/
    }
    
    //if( _doUpdate )
    {    
      _head.add( _add );
    
      _age += 0.05;
//    _age ++;
      _agePer = _age * _invTimeToLive;
    }
  }


  void draw( float time )
  {
//    if( _age < _timeToLive )
    {
/*      if( _doRenderHead )
      {
        _headTex.enable();
        renderHead();
        _headTex.disable();
      }*/

      //
      // Render shadow tail
      //
      vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.setDepthWrite( true );
      vgl.setDepthMask( false );
//      vgl.setAlphaBlend();

      renderTail();
//      renderTailCylinder();

      // Stop head motion once it completes its growth      
      if( !_doUpdate )
        _head = _tail[0].copy();


      // Render base of each tail (not needed for most cases)
//      renderBase();
    }
  }

  void drawCylinderRibbon( float time )
  {
    if( _age < _timeToLive )
    {
      vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.setDepthWrite( true );
//      gl.setDepthMask( false );
      vgl.setAlphaBlend();

      renderTailCylinder();
    }
  }

/*  void renderBase()
  {
    activeNoteTex.enable();

    // Draw activator center 
    gl.setAlphaBlend();
    gl.fill( 1, 1.0-_agePer );
    gl.pushMatrix();
    gl.translate( _initPos );
    gl.rotateX( 90 );
    gl.quad( 20 );
    gl.popMatrix();

    activeNoteTex.disable();
  }*/


  void renderHead()
  {
    // Draw activator center 
    if( _headTexID >= 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _headTexID );
    }

    vgl.setDepthWrite( false );
    vgl.setAlphaBlend();
    vgl.fill( 1, 1.0-_agePer );
    vgl.pushMatrix();
    vgl.translate( _head.x, _head.y, _head.z );
    vgl.rotateX( 90 );
    vgl.quad( _headSize );
    vgl.popMatrix();

    vgl.setDepthWrite( true );
  }


  void renderTail()
  {
    float per;
    float xp, yp, zp;
    float xOff, yOff, zOff;

/*    if( _tailTexID > 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _tailTexID );
    }*/
    
    /*for ( int i=0; i<_tailSize; i++ )
    {
      per = 1.0 - (((float)i/(float)(_tailSize)));
      //per *= 0.5;
      
      vgl.fill( 1.0, _agePer );
//      gl.fill( 1.0, 1.0-_agePer );
      vgl.pushMatrix();
      vgl.translate( _tail[i] );
      vgl.quad( 1*per );
      vgl.popMatrix();
    }*/
    vgl.enableTexture( false );
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    vgl.gl().glBegin( GL.GL_QUAD_STRIP );
    for ( int i=0; i<_tailSize-1; i++ )
//    int hlen = (int)((_tailSize-1)*0.5);
//    for ( int ii=-hlen; ii<hlen; ii++ )
    {
//      int i = ii+hlen;
//      per           = 1.0 - (((float)(abs(ii))/(float)(hlen)));    

      //per = (((float)i/(float)(_tailSize)));
      per = 1.0-(((float)i/(float)(_tailSize)));
      //per *= 0.5;

      if( per > 1.0 ) per = 1.0;
      if( per < 0.0 ) per = 0.0;

      float ownAlpha = (((float)i/(float)(_tailSize)));

      if( i < _tailSize-1 )
      {
        Vector3 dir = Vector3.sub( _tail[i+1], _tail[i] );
        dir.normalize();
//        Vector3 V = dir.cross( new Vector3( 0, 0, 1 ) );
        Vector3 V = dir.cross( new Vector3( 0, 1, 0 ) );
        V.normalize();
        Vector3 N = dir.cross( V );
        N.normalize();
        V = N.cross( dir );
        //V = dir.cross( N );
        V.normalize();

        _right = V.copy();

        xp = _tail[i].x;
        yp = _tail[i].y;
        zp = _tail[i].z;

        xOff = V.x * _tailWidth * per;// * 0.15;
        yOff = V.y * _tailWidth * per;// * 0.15;
        zOff = V.z * _tailWidth * per;// * 0.15;

        vgl.gl().glColor4f( 1, 1, 1, per * ownAlpha ); //1.0-_agePer );

        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 0, 0 );
        vgl.gl().glVertex3f( xp - xOff, yp - yOff, zp - zOff );
        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 1, 1 );
        vgl.gl().glVertex3f( xp + xOff, yp + yOff, zp + zOff );
      }
    }
    vgl.gl().glEnd();
    
  }


  void renderTailColor( float r, float g, float b, float a )
  {
    float per;
    float xp, yp, zp;
    float xOff, yOff, zOff;

/*    if( _tailTexID > 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _tailTexID );
    }*/
    
    /*for ( int i=0; i<_tailSize; i++ )
    {
      per = 1.0 - (((float)i/(float)(_tailSize)));
      //per *= 0.5;
      
      vgl.fill( 1.0, _agePer );
//      gl.fill( 1.0, 1.0-_agePer );
      vgl.pushMatrix();
      vgl.translate( _tail[i] );
      vgl.quad( 1*per );
      vgl.popMatrix();
    }*/
    //vgl.enableTexture( false );
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    vgl.gl().glBegin( GL.GL_QUAD_STRIP );
    for ( int i=0; i<_tailSize-1; i++ )
//    int hlen = (int)((_tailSize-1)*0.5);
//    for ( int ii=-hlen; ii<hlen; ii++ )
    {
//      int i = ii+hlen;
//      per           = 1.0 - (((float)(abs(ii))/(float)(hlen)));    

      per = (((float)i/(float)(_tailSize)));
      //per = 1.0-(((float)i/(float)(_tailSize)));
      //per *= 0.5;

      if( per > 1.0 ) per = 1.0;
      if( per < 0.0 ) per = 0.0;

      float ownAlpha = (((float)i/(float)(_tailSize)));

      if( i < _tailSize-1 )
      {
        Vector3 dir = Vector3.sub( _tail[i+1], _tail[i] );
        dir.normalize();
//        Vector3 V = dir.cross( new Vector3( 0, 0, 1 ) );
        Vector3 V = dir.cross( new Vector3( 0, 1, 0 ) );
        V.normalize();
        Vector3 N = dir.cross( V );
        N.normalize();
        V = N.cross( dir );
        //V = dir.cross( N );
        V.normalize();

        _right = V.copy();

        xp = _tail[i].x;
        yp = _tail[i].y;
        zp = _tail[i].z;

        xp = _tail[i].x + _right.x*sin(i*.12+time*2)*3*(_tailSize-i)*.053;
        yp = _tail[i].y - 3;// + _right.y*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
        zp = _tail[i].z + _right.z*sin(i*.12+time*2)*3*(_tailSize-i)*.053;

//        xp = _tail[i].x + _right.x*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
//        yp = _tail[i].y + _right.y*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
//        zp = _tail[i].z + _right.z*sin(i*.2+time*8)*3*(_tailSize-i)*.053;


        xOff = V.x * _tailWidth * per;// * 0.15;
        yOff = V.y * _tailWidth * per;// * 0.15;
        zOff = V.z * _tailWidth * per;// * 0.15;

        vgl.gl().glColor4f( r, g, b, 1.0-_agePer );

        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 0, 0 );
        vgl.gl().glVertex3f( xp - xOff, yp - yOff, zp - zOff );
        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 1, 1 );
        vgl.gl().glVertex3f( xp + xOff, yp + yOff, zp + zOff );
      }
    }
    vgl.gl().glEnd();
    
  }


  void renderTailFromBuffer( Vector3[] buf, int tailWidth, float addA )
  {
    float per;
    float xp, yp, zp;
    float xOff, yOff, zOff;
    
    int size = buf.length;

/*    flare3.enable();
    for ( int i=0; i<size; i++ )
    {
      per = 1.0 - (((float)i/(float)(size)));
      per *= 0.5;
      
      gl.fill( 1.0, _agePer );
//      gl.fill( 1.0, 1.0-_agePer );
      gl.pushMatrix();
      gl.translate( buf[i] );
      gl.quad( 10*per );
      gl.popMatrix();
    }*/
    vgl.enableTexture( false );
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    vgl.gl().glBegin( GL.GL_QUAD_STRIP );
    for ( int i=0; i<size; i++ )
//    int hlen = (int)((size-1)*0.5);
//    for ( int ii=-hlen; ii<hlen; ii++ )
    {
//      int i = ii+hlen;
//      per = 1.0 - (((float)(abs(ii))/(float)(hlen)));    

//      per = (((float)i/(float)(_tailSize)));
      per = 1.0-(((float)i/(float)(_tailSize)));
      //per *= 0.5;

      if( per > 1.0 ) per = 1.0;
      if( per < 0.0 ) per = 0.0;

      float ownAlpha = (((float)i/(float)(_tailSize)));

      if( i < size-1 )
      {
        //Vector3 perp0 = Vector3.sub( ploc[j][i], ploc[j][i+1] );
        Vector3 dir = Vector3.sub( buf[i+1], buf[i] );
        dir.normalize();
        Vector3 V = dir.cross( new Vector3( 0, 0, 1 ) );
//        Vector3 V = dir.cross( new Vector3( 0, 1, 0 ) );
        V.normalize();
        Vector3 N = dir.cross( V );
        N.normalize();
        V = N.cross( dir );
        //V = dir.cross( N );
        V.normalize();

        _right = V.copy();

        xp = buf[i].x;
        yp = buf[i].y;
        zp = buf[i].z;

//        xp = _tail[i].x + _right.x*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
//        yp = _tail[i].y + _right.y*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
//        zp = _tail[i].z + _right.z*sin(i*.2+time*8)*3*(_tailSize-i)*.053;


        xOff = V.x * tailWidth * per;// * 0.15;
        yOff = V.y * tailWidth * per;// * 0.15;
        zOff = V.z * tailWidth * per;// * 0.15;


        vgl.gl().glColor4f( 1, 1, 1, per * ownAlpha * addA );
//        vgl.gl().glColor4f( 0, 0, 0, _agePer );
        //      vgl.gl().glColor4f( 1-per, 1-per, 1-per, per );
//        vgl.gl().glColor4f( 0, 0, 0, 1-_agePer );
//        vgl.gl().glColor4f( 1, 1, 1, 1.0-_agePer );
        //      vgl.gl().glColor4f( per, per, per, per );
        //      vgl.gl().glColor4f( per, per*.5, 1.5 - per, per);

        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 0, 0 );
        vgl.gl().glVertex3f( xp - xOff, yp - yOff, zp - zOff );
        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 1, 1 );
        vgl.gl().glVertex3f( xp + xOff, yp + yOff, zp + zOff );
      }
    }
    vgl.gl().glEnd();
  }



  void renderTailCylinder()
  {
    float invsteps = 1.0 / (float)(_tailSize);
    float invfacets = 1.0 / (float)(_facets+1);

//    float pi2OverSteps = TWO_PI / _tailSize;
    float pi2OverFacets = TWO_PI / (_facets+1);
//    float pi2MulInvsteps = TWO_PI * invsteps;
    float pi2MulInvfacets = TWO_PI * invfacets;
    
//    float _p = 5;
//    float _q = 5;
//    float _scale = 20;
//    float _thickness = 10;

    ///////////////////////////////////////
    ///////////////////////////////////////
    for ( int j=0; j<_tailRenderSegments-1; j++ )
    {
      
/*    activeNoteTex.enable();
    // Draw activator center 
    gl.setAlphaBlend();
    gl.setDepthWrite( false );
    gl.fill( .3 );//, 1.0-_agePer );
    gl.pushMatrix();
    gl.translate( _tail[j].x, -115, _tail[j].z );
    gl.rotateX( 90 );
    gl.quad( 15 );
    gl.popMatrix();
    activeNoteTex.disable();*/
      
    float per = (((float)(j+1)/(float)(_tailSize)));
      
      // first point
//      float Pp = _p * j * pi2MulInvsteps;
//      float Qp = _q * j * pi2MulInvsteps;
//      float r = (.5f * (2 + (float)sin(Qp))) * _scale;
      Vector3 center = new Vector3();
/*      center.x = r * (float)cos(Pp);
      center.y = r * (float)cos(Qp);
      center.z = r * (float)sin(Pp);*/
      center = _tail[j].copy();

      // next point
//      Pp = _p * (j+1) * pi2MulInvsteps;
//      Qp = _q * (j+1) * pi2MulInvsteps;
//      r = (.5f * (2 + (float)sin(Qp))) * _scale;
      Vector3 nextPoint = new Vector3();
/*      nextPoint.x = r * (float)cos(Pp);
      nextPoint.y = r * (float)cos(Qp);
      nextPoint.z = r * (float)sin(Pp);*/
      nextPoint = _tail[j+1].copy();

      // get TBN matrix for transformation
      Vector3 T = new Vector3();
      T.x = nextPoint.x - center.x;
      T.y = nextPoint.y - center.y;
      T.z = nextPoint.z - center.z;

      Vector3 N = new Vector3();
      N.x = nextPoint.x + center.x;
      N.y = nextPoint.y + center.y;
      N.z = nextPoint.z + center.z;

      Vector3 B = new Vector3();
      B = T.cross( N );//cross( T, N );
      N = B.cross( T );//cross( B, T );

      // normalize vectors
      B.normalize();
      N.normalize();


      // go through facets and tweak a bit with some distortions
      for( int i=0; i<_facets+1; i++ )
      {
        float x = (sin(i * pi2OverFacets) * _tailWidth * per);
        float y = (cos(i * pi2OverFacets) * _tailWidth * per);
/*        // distort knot along the curve
        if( _displaces != 0.0 )
        {
          x *= (1 + (sin(_dispoffset + _displaces * j * pi2OverSteps) * _dispscale));
          y *= (1 + (cos(_dispoffset + _displaces * j * pi2OverSteps) * _dispscale));
        }*/

        int idx = j*_facets + i;
//        int idx = yTable[j] + i;
        _vertices[ idx ].x = N.x * x + B.x * y + center.x;
        _vertices[ idx ].y = N.y * x + B.y * y + center.y;
        _vertices[ idx ].z = N.z * x + B.z * y + center.z;

        // get vertex normal
        _normals[ idx ].x = _vertices[ idx ].x - center.x;
        _normals[ idx ].y = _vertices[ idx ].y - center.y;
        _normals[ idx ].z = _vertices[ idx ].z - center.z;
        // normalize
        _normals[ idx ].normalize();
      }

      // duplicate sideways vertices/normals
/*      _vertices[j*(_facets+1) + _facets].x = _vertices[j*(_facets+1) + 0].x;
      _vertices[j*(_facets+1) + _facets].y = _vertices[j*(_facets+1) + 0].y;
      _vertices[j*(_facets+1) + _facets].z = _vertices[j*(_facets+1) + 0].z;
      _normals[j*(_facets+1) + _facets].x  = _normals[j*(_facets+1) + 0].x;
      _normals[j*(_facets+1) + _facets].y  = _normals[j*(_facets+1) + 0].y;
      _normals[j*(_facets+1) + _facets].z  = _normals[j*(_facets+1) + 0].z;*/
      _vertices[j*(_facets) + _facets].x = _vertices[j*(_facets) + 0].x;
      _vertices[j*(_facets) + _facets].y = _vertices[j*(_facets) + 0].y;
      _vertices[j*(_facets) + _facets].z = _vertices[j*(_facets) + 0].z;
      _normals[j*(_facets) + _facets].x  = _normals[j*(_facets) + 0].x;
      _normals[j*(_facets) + _facets].y  = _normals[j*(_facets) + 0].y;
      _normals[j*(_facets) + _facets].z  = _normals[j*(_facets) + 0].z;
      
    }

/*    // duplicate vertices/normals. to get a closed surface
    for( int i=0; i<_facets+1; i++ )
    {
        _vertices[yTable[_tailSize-1] + i].x = _vertices[i].x;
        _vertices[yTable[_tailSize-1] + i].y = _vertices[i].y;
        _vertices[yTable[_tailSize-1] + i].z = _vertices[i].z;
        _normals[yTable[_tailSize-1] + i].x  = _normals[i].x;
        _normals[yTable[_tailSize-1] + i].y  = _normals[i].y;
        _normals[yTable[_tailSize-1] + i].z  = _normals[i].z;        
    }
    // first are last as well
    _vertices[yTable[_tailSize-1] + _facets].x = _vertices[0].x;
    _vertices[yTable[_tailSize-1] + _facets].y = _vertices[0].y;
    _vertices[yTable[_tailSize-1] + _facets].z = _vertices[0].z;
    _normals[yTable[_tailSize-1] + _facets].x  = _normals[0].x;
    _normals[yTable[_tailSize-1] + _facets].y  = _normals[0].y;
    _normals[yTable[_tailSize-1] + _facets].z  = _normals[0].z;*/


    // Increase color as it grows
//    _colour.x += 0.01;
//    _colour.y += 0.01;
//    _colour.z += 0.01;


    int facets = _facets;
    int j = 2;
/*      vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
      for( int i=0; i<facets+1; i++ )
      {
        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z,  (i/(float)facets) );//-_agePer );
//        vgl.gl().glColor4f( _colour.x-_agePer, _colour.y-_agePer, _colour.z-_agePer, 1 );//-_agePer );
        
        vgl.gl().glNormal3f( _normals[i+j*(facets)].x, _normals[i+j*(facets)].y, _normals[i+j*(facets)].z );
        vgl.gl().glVertex3f( _head.x, _head.y, _head.z );

        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z, (i/(float)facets) );
        vgl.gl().glNormal3f( _normals[i+(j+1)*(facets)].x, _normals[i+(j+1)*(facets)].y, _normals[i+(j+1)*(facets)].z );
        vgl.gl().glVertex3f( _vertices[i+(j+1)*(facets)].x, _vertices[i+(j+1)*(facets)].y, _vertices[i+(j+1)*(facets)].z );
      }      
      vgl.gl().glEnd();
*/

    for ( j=0; j<_tailSize-1; j++ )
    {
      vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
      for( int i=0; i<facets+1; i++ )
      {
        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z, _colour.w );
//        vgl.gl().glColor4f( _colour.x-_agePer, _colour.y-_agePer, _colour.z-_agePer, 1 );//-_agePer );
        vgl.gl().glNormal3f( _normals[i+j*(facets)].x, _normals[i+j*(facets)].y, _normals[i+j*(facets)].z );
        vgl.gl().glVertex3f( _vertices[i+j*(facets)].x, _vertices[i+j*(facets)].y, _vertices[i+j*(facets)].z );

        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z, _colour.w );
        vgl.gl().glNormal3f( _normals[i+(j+1)*(facets)].x, _normals[i+(j+1)*(facets)].y, _normals[i+(j+1)*(facets)].z );
        vgl.gl().glVertex3f( _vertices[i+(j+1)*(facets)].x, _vertices[i+(j+1)*(facets)].y, _vertices[i+(j+1)*(facets)].z );
      }      
      vgl.gl().glEnd();
    }
  }


  void reset( Vector3 newPos, float ttl )
  {
    setHead( newPos );
    computeTail();
    setTimeToLive( ttl );
    _tailRenderSegments = 0;
    _age = 0;
    _doUpdate = true;  
    
    if( random(100) > 50 )
      _colour.set( 1, 1, 1, 1 );
    else
      _colour.set( 0, 0, 0, 1 );

  }


  int _facets;
  int[] yTable;
  Vector3[] _vertices;
  Vector3[] _normals;
  
  //XTexture _headTex;
  int _headTexID;
  int _tailTexID;
  
  Vector4  _colour;

  boolean _doRenderHead;
  boolean _doUpdate;

  float _age;
  float _agePer;
  float _timeToLive;
  float _invTimeToLive;

  Vector3 _initPos;

  float _headSize;
  Vector3 _head;
  Vector3 _right;

  Vector3  _add;

  float _tailWidth;
  int  _tailRenderSegments;    // counts number of tail segments to render  
  int  _tailSize;
  Vector3[] _tail;
}
class RibbonTactu
{
  RibbonTactu()
  {
    _doRenderHead = true;
    _doUpdate = true;
    
    _tailTexID = -1;
    _headTexID = -1;

    _tailSize = 20;
    _tailRenderSegments = 0;
    _tailWidth = 1.0;

    _initPos = new Vector3();

    _headSize = 8*3;
    _head = new Vector3();
    _right = new Vector3();

    _add = new Vector3();

    _age = 0;
    _agePer = 0;
    _timeToLive = 100;
    _invTimeToLive = 1.0 / _timeToLive;

    _facets = 8;

    _colour = new Vector4( 1, 1, 1, 1 );

    yTable = new int[_tailSize];
    for( int i=0; i<_tailSize; i++ )
      yTable[i] = i * (_facets+1);
    _vertices = new Vector3[ ((_tailSize)*(_facets+1)) ];
    _normals = new Vector3[ ((_tailSize)*(_facets+1)) ];
    for( int i=0; i<((_tailSize)*(_facets+1)); i++ )
    {
      _vertices[i] = new Vector3();
      _normals[i] = new Vector3();
    }
  }

  RibbonTactu( int tailSize, float tailWidth, float headSize, boolean renderHead )
  {
    _doRenderHead = renderHead;
    _doUpdate = true;

    _tailSize = tailSize;
    _tailRenderSegments = 0;
    _tailWidth = tailWidth;

    _initPos = new Vector3();

    _headSize = headSize;
    _head = new Vector3();
    _right = new Vector3();

    _add = new Vector3();    

    _age = 0;
    _agePer = 0;
    _timeToLive = 100;
    _invTimeToLive = 1.0 / _timeToLive;

    _colour = new Vector4( 1, 1, 1, 1 );

    _facets = 8;
    
    yTable = new int[_tailSize];
    for( int i=0; i<_tailSize; i++ )
      yTable[i] = i * (_facets+1);
    _vertices = new Vector3[ ((_tailSize)*(_facets+1)) ];
    _normals = new Vector3[ ((_tailSize)*(_facets+1)) ];
    for( int i=0; i<((_tailSize)*(_facets+1)); i++ )
    {
      _vertices[i] = new Vector3();
      _normals[i] = new Vector3();
    }
  }


  void setHeadTexture( int id )
  {
    _headTexID = id;
    //_headTex = new XTexture( file );
  }

  void setTailTexture( int id )
  {
    _tailTexID = id;
    //_headTex = new XTexture( file );
  }


  void computeTail()
  {
    if( _tail == null )
    {
      _tail = new Vector3[_tailSize];
    }

    for( int i=0; i<_tailSize; i++ )
    {
      _tail[i] = new Vector3();
      _tail[i] = _head.copy();
    }
  }

  boolean isDead()
  {
    if( _age >= _timeToLive )
      return true;

    return false;
  }


  void setTimeToLive( float t )
  {
    _timeToLive = t;
    _invTimeToLive = 1.0 / _timeToLive;
  }

  void setHeadY( float y )
  {
    _head.y = y;
    _initPos = _head.copy();
  }

  void setHead( float x, float y )
  {
    _head.set( x, y, 0 );
    _initPos = _head.copy();
  }

  void setHead( float x, float y, float z )
  {
    _head.set( x, y, z );
    _initPos = _head.copy();
  }

  void setHead( Vector3 h )
  {
    _head = h;
    _initPos = _head.copy();
  }

  void addHead( float x, float y )
  {
    if( _doUpdate )
      _head.add( x, y, 0 );
  }

  void addHead( float x, float y, float z )
  {
    if( _doUpdate )
      _head.add( x, y, z );
  }

  void addHead( Vector3 a )
  {
    if( _doUpdate )
      _head.add( a );
  }

  void renderHead( boolean f )
  {
    _doRenderHead = f;
  }


  void update( float time )
  {
    if( _age < _timeToLive )
    {
      if( _tailRenderSegments < _tailSize )
      {
        for( int i=_tailRenderSegments; i>0; i-- )
        {
          _tail[i] = _tail[i-1];
        }
        _tail[0] = _head.copy();
        
        _tailRenderSegments++;
      }
      else
      {
        _doUpdate = false;
      }
    }
    
    if( _doUpdate )
    {    
      _head.add( _add );
    
      _age += 0.05;
//    _age ++;
      _agePer = _age * _invTimeToLive;
    }
  }


  void draw( float time )
  {
//    if( _age < _timeToLive )
    {
/*      if( _doRenderHead )
      {
        _headTex.enable();
        renderHead();
        _headTex.disable();
      }*/

      //
      // Render shadow tail
      //
      vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.setDepthWrite( false );
//      gl.setDepthMask( false );
//      vgl.setAlphaBlend();

      renderTail( time );
//      renderTailCylinder();

      // Stop head motion once it completes its growth      
      if( !_doUpdate )
        _head = _tail[0].copy();


      // Render base of each tail (not needed for most cases)
//      renderBase();
    }
  }

  void drawCylinderRibbon( float time )
  {
    if( _age < _timeToLive )
    {
      vgl.gl().glDisable( GL.GL_CULL_FACE );
      vgl.setDepthWrite( true );
//      gl.setDepthMask( false );
      vgl.setAlphaBlend();

      renderTailCylinder( time );
    }
  }

/*  void renderBase()
  {
    activeNoteTex.enable();

    // Draw activator center 
    gl.setAlphaBlend();
    gl.fill( 1, 1.0-_agePer );
    gl.pushMatrix();
    gl.translate( _initPos );
    gl.rotateX( 90 );
    gl.quad( 20 );
    gl.popMatrix();

    activeNoteTex.disable();
  }*/


  void renderHead()
  {
    // Draw activator center 
    if( _headTexID >= 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _headTexID );
    }

    vgl.setDepthWrite( false );
    vgl.setAlphaBlend();
    vgl.fill( 1, 1.0-_agePer );
    vgl.pushMatrix();
    vgl.translate( _head.x, _head.y, _head.z );
    vgl.rotateX( 90 );
    vgl.quad( _headSize );
    vgl.popMatrix();

    vgl.setDepthWrite( true );
  }


  void renderTail( float time )
  {
    float per;
    float xp, yp, zp;
    float xOff, yOff, zOff;

/*    if( _tailTexID > 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _tailTexID );
    }*/
    
    /*for ( int i=0; i<_tailSize; i++ )
    {
      per = 1.0 - (((float)i/(float)(_tailSize)));
      //per *= 0.5;
      
      vgl.fill( 1.0, _agePer );
//      gl.fill( 1.0, 1.0-_agePer );
      vgl.pushMatrix();
      vgl.translate( _tail[i] );
      vgl.quad( 1*per );
      vgl.popMatrix();
    }*/
    //vgl.enableTexture( false );
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    vgl.gl().glBegin( GL.GL_QUAD_STRIP );
    for ( int i=0; i<_tailSize-1; i++ )
//    int hlen = (int)((_tailSize-1)*0.5);
//    for ( int ii=-hlen; ii<hlen; ii++ )
    {
//      int i = ii+hlen;
//      per           = 1.0 - (((float)(abs(ii))/(float)(hlen)));    

      per = (((float)i/(float)(_tailSize)));
      //per = 1.0-(((float)i/(float)(_tailSize)));
      //per *= 0.5;

      if( per > 1.0 ) per = 1.0;
      if( per < 0.0 ) per = 0.0;

      if( i < _tailSize-1 )
      {
        Vector3 dir = Vector3.sub( _tail[i+1], _tail[i] );
        dir.normalize();
//        Vector3 V = dir.cross( new Vector3( 0, 0, 1 ) );
        Vector3 V = dir.cross( new Vector3( 0, 1, 0 ) );
        V.normalize();
        Vector3 N = dir.cross( V );
        N.normalize();
        V = N.cross( dir );
        //V = dir.cross( N );
        V.normalize();

        _right = V.copy();

        xp = _tail[i].x;
        yp = _tail[i].y - 10;
        zp = _tail[i].z;

        xp += sin( time*.2 + (i)*0.05 ) * 10;
        yp += sin( time*.2 + (i)*0.05 ) * 10;
        zp += sin( time*.2 + (i)*0.05 ) * 10;

//        xp = _tail[i].x + _right.x*sin((_tailSize-i)*.12+time*2)*3*(_tailSize-i)*.053;
//        yp = _tail[i].y - 3;
//        zp = _tail[i].z + _right.z*sin((_tailSize-i)*.12+time*2)*3*(_tailSize-i)*.053;


        xOff = V.x * _tailWidth * per;// * 0.15;
        yOff = V.y * _tailWidth * per;// * 0.15;
        zOff = V.z * _tailWidth * per;// * 0.15;

        vgl.gl().glColor4f( 0, 0, 0, (1.0-_agePer)*0.25 );

        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 0, 0 );
        vgl.gl().glVertex3f( xp - xOff, yp - yOff, zp - zOff );
        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 1, 1 );
        vgl.gl().glVertex3f( xp + xOff, yp + yOff, zp + zOff );
      }
    }
    vgl.gl().glEnd();
    
  }


  void renderTailColor( float r, float g, float b, float a )
  {
    float per;
    float xp, yp, zp;
    float xOff, yOff, zOff;

/*    if( _tailTexID > 0 )
    {
      vgl.enableTexture( true );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _tailTexID );
    }*/
    
    /*for ( int i=0; i<_tailSize; i++ )
    {
      per = 1.0 - (((float)i/(float)(_tailSize)));
      //per *= 0.5;
      
      vgl.fill( 1.0, _agePer );
//      gl.fill( 1.0, 1.0-_agePer );
      vgl.pushMatrix();
      vgl.translate( _tail[i] );
      vgl.quad( 1*per );
      vgl.popMatrix();
    }*/
    //vgl.enableTexture( false );
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    vgl.gl().glBegin( GL.GL_QUAD_STRIP );
    for ( int i=0; i<_tailSize-1; i++ )
//    int hlen = (int)((_tailSize-1)*0.5);
//    for ( int ii=-hlen; ii<hlen; ii++ )
    {
//      int i = ii+hlen;
//      per           = 1.0 - (((float)(abs(ii))/(float)(hlen)));    

      per = (((float)i/(float)(_tailSize)));
      //per = 1.0-(((float)i/(float)(_tailSize)));
      //per *= 0.5;

      if( per > 1.0 ) per = 1.0;
      if( per < 0.0 ) per = 0.0;

      if( i < _tailSize-1 )
      {
        Vector3 dir = Vector3.sub( _tail[i+1], _tail[i] );
        dir.normalize();
//        Vector3 V = dir.cross( new Vector3( 0, 0, 1 ) );
        Vector3 V = dir.cross( new Vector3( 0, 1, 0 ) );
        V.normalize();
        Vector3 N = dir.cross( V );
        N.normalize();
        V = N.cross( dir );
        //V = dir.cross( N );
        V.normalize();

        _right = V.copy();

        xp = _tail[i].x;
        yp = _tail[i].y;
        zp = _tail[i].z;

        xp = _tail[i].x + _right.x*sin(i*.12+time*2)*3*(_tailSize-i)*.053;
        yp = _tail[i].y - 3;// + _right.y*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
        zp = _tail[i].z + _right.z*sin(i*.12+time*2)*3*(_tailSize-i)*.053;

//        xp = _tail[i].x + _right.x*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
//        yp = _tail[i].y + _right.y*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
//        zp = _tail[i].z + _right.z*sin(i*.2+time*8)*3*(_tailSize-i)*.053;


        xOff = V.x * _tailWidth * per;// * 0.15;
        yOff = V.y * _tailWidth * per;// * 0.15;
        zOff = V.z * _tailWidth * per;// * 0.15;

        vgl.gl().glColor4f( r, g, b, 1.0-_agePer );

        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 0, 0 );
        vgl.gl().glVertex3f( xp - xOff, yp - yOff, zp - zOff );
        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 1, 1 );
        vgl.gl().glVertex3f( xp + xOff, yp + yOff, zp + zOff );
      }
    }
    vgl.gl().glEnd();
    
  }


  void renderTailFromBuffer( Vector3[] buf, int tailWidth )
  {
    float per;
    float xp, yp, zp;
    float xOff, yOff, zOff;
    
    int size = buf.length;

/*    flare3.enable();
    for ( int i=0; i<size; i++ )
    {
      per = 1.0 - (((float)i/(float)(size)));
      per *= 0.5;
      
      gl.fill( 1.0, _agePer );
//      gl.fill( 1.0, 1.0-_agePer );
      gl.pushMatrix();
      gl.translate( buf[i] );
      gl.quad( 10*per );
      gl.popMatrix();
    }*/
    vgl.enableTexture( false );
    
    ///////////////////////////////////////
    ///////////////////////////////////////
    vgl.gl().glBegin( GL.GL_QUAD_STRIP );
    for ( int i=0; i<size; i++ )
//    int hlen = (int)((size-1)*0.5);
//    for ( int ii=-hlen; ii<hlen; ii++ )
    {
//      int i = ii+hlen;
//      per = 1.0 - (((float)(abs(ii))/(float)(hlen)));    

//      per = (((float)i/(float)(_tailSize)));
      per = 1.0-(((float)i/(float)(_tailSize)));
      //per *= 0.5;

      if( per > 1.0 ) per = 1.0;
      if( per < 0.0 ) per = 0.0;

      float ownAlpha = (((float)i/(float)(_tailSize)));

      if( i < size-1 )
      {
        //Vector3 perp0 = Vector3.sub( ploc[j][i], ploc[j][i+1] );
        Vector3 dir = Vector3.sub( buf[i+1], buf[i] );
        dir.normalize();
        Vector3 V = dir.cross( new Vector3( 0, 0, 1 ) );
//        Vector3 V = dir.cross( new Vector3( 0, 1, 0 ) );
        V.normalize();
        Vector3 N = dir.cross( V );
        N.normalize();
        V = N.cross( dir );
        //V = dir.cross( N );
        V.normalize();

        _right = V.copy();

        xp = buf[i].x;
        yp = buf[i].y;
        zp = buf[i].z;

//        xp = _tail[i].x + _right.x*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
//        yp = _tail[i].y + _right.y*sin(i*.2+time*8)*3*(_tailSize-i)*.053;
//        zp = _tail[i].z + _right.z*sin(i*.2+time*8)*3*(_tailSize-i)*.053;


        xOff = V.x * tailWidth * per;// * 0.15;
        yOff = V.y * tailWidth * per;// * 0.15;
        zOff = V.z * tailWidth * per;// * 0.15;


        vgl.gl().glColor4f( 1, 1, 1, _agePer * per * ownAlpha );
//        vgl.gl().glColor4f( 0, 0, 0, _agePer );
        //      vgl.gl().glColor4f( 1-per, 1-per, 1-per, per );
//        vgl.gl().glColor4f( 0, 0, 0, 1-_agePer );
//        vgl.gl().glColor4f( 1, 1, 1, 1.0-_agePer );
        //      vgl.gl().glColor4f( per, per, per, per );
        //      vgl.gl().glColor4f( per, per*.5, 1.5 - per, per);

        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 0, 0 );
        vgl.gl().glVertex3f( xp - xOff, yp - yOff, zp - zOff );
        //      vgl.gl().glNormal3f( N.x, N.y, N.z );
        //      vgl.gl().glTexCoord2f( 1, 1 );
        vgl.gl().glVertex3f( xp + xOff, yp + yOff, zp + zOff );
      }
    }
    vgl.gl().glEnd();
  }



  void renderTailCylinder( float time )
  {
    float invsteps = 1.0 / (float)(_tailSize);
    float invfacets = 1.0 / (float)(_facets+1);

//    float pi2OverSteps = TWO_PI / _tailSize;
    float pi2OverFacets = TWO_PI / (_facets+1);
//    float pi2MulInvsteps = TWO_PI * invsteps;
    float pi2MulInvfacets = TWO_PI * invfacets;
    
//    float _p = 5;
//    float _q = 5;
//    float _scale = 20;
//    float _thickness = 10;

    ///////////////////////////////////////
    ///////////////////////////////////////
    for ( int j=0; j<_tailRenderSegments-1; j++ )
    {
      
/*    activeNoteTex.enable();
    // Draw activator center 
    gl.setAlphaBlend();
    gl.setDepthWrite( false );
    gl.fill( .3 );//, 1.0-_agePer );
    gl.pushMatrix();
    gl.translate( _tail[j].x, -115, _tail[j].z );
    gl.rotateX( 90 );
    gl.quad( 15 );
    gl.popMatrix();
    activeNoteTex.disable();*/
      
    float per = (((float)(j)/(float)(_tailSize)));
      
      // first point
//      float Pp = _p * j * pi2MulInvsteps;
//      float Qp = _q * j * pi2MulInvsteps;
//      float r = (.5f * (2 + (float)sin(Qp))) * _scale;
      Vector3 center = new Vector3();
/*      center.x = r * (float)cos(Pp);
      center.y = r * (float)cos(Qp);
      center.z = r * (float)sin(Pp);*/
      center = _tail[j].copy();

      center.x += sin( time*.2 + (j)*0.05 ) * 10;
      center.y += sin( time*.2 + (j)*0.05 ) * 10;
      center.z += sin( time*.2 + (j)*0.05 ) * 10;

      // next point
//      Pp = _p * (j+1) * pi2MulInvsteps;
//      Qp = _q * (j+1) * pi2MulInvsteps;
//      r = (.5f * (2 + (float)sin(Qp))) * _scale;
      Vector3 nextPoint = new Vector3();
/*      nextPoint.x = r * (float)cos(Pp);
      nextPoint.y = r * (float)cos(Qp);
      nextPoint.z = r * (float)sin(Pp);*/
      nextPoint = _tail[j+1].copy();

      nextPoint.x += sin( time*.2 + (j+1)*0.05 ) * 10;
      nextPoint.y += sin( time*.2 + (j)*0.05 ) * 10;
      nextPoint.z += sin( time*.2 + (j+1)*0.05 ) * 10;

      // get TBN matrix for transformation
      Vector3 T = new Vector3();
      T.x = nextPoint.x - center.x;
      T.y = nextPoint.y - center.y;
      T.z = nextPoint.z - center.z;
      T.normalize();

      Vector3 N = new Vector3(0,1,0);
/*      N.x = nextPoint.x + center.x;
      N.y = nextPoint.y + center.y;
      N.z = nextPoint.z + center.z;*/

      Vector3 B = new Vector3();
      B = T.cross( N );//cross( T, N );
      B.normalize();
      N = B.cross( T );//cross( B, T );

      // normalize vectors
//      B.normalize();
      N.normalize();


      // go through facets and tweak a bit with some distortions
      for( int i=0; i<_facets+1; i++ )
      {
        float x = (sin(i * pi2OverFacets) * _tailWidth * per);
        float y = (cos(i * pi2OverFacets) * _tailWidth * per);
/*        // distort knot along the curve
        if( _displaces != 0.0 )
        {
          x *= (1 + (sin(_dispoffset + _displaces * j * pi2OverSteps) * _dispscale));
          y *= (1 + (cos(_dispoffset + _displaces * j * pi2OverSteps) * _dispscale));
        }*/

        int idx = j*_facets + i;
//        int idx = yTable[j] + i;
        _vertices[ idx ].x = N.x * x + B.x * y + center.x;
        _vertices[ idx ].y = N.y * x + B.y * y + center.y;
        _vertices[ idx ].z = N.z * x + B.z * y + center.z;

        // get vertex normal
        _normals[ idx ].x = _vertices[ idx ].x - center.x;
        _normals[ idx ].y = _vertices[ idx ].y - center.y;
        _normals[ idx ].z = _vertices[ idx ].z - center.z;
        // normalize
        _normals[ idx ].normalize();
      }

      // duplicate sideways vertices/normals
/*      _vertices[j*(_facets+1) + _facets].x = _vertices[j*(_facets+1) + 0].x;
      _vertices[j*(_facets+1) + _facets].y = _vertices[j*(_facets+1) + 0].y;
      _vertices[j*(_facets+1) + _facets].z = _vertices[j*(_facets+1) + 0].z;
      _normals[j*(_facets+1) + _facets].x  = _normals[j*(_facets+1) + 0].x;
      _normals[j*(_facets+1) + _facets].y  = _normals[j*(_facets+1) + 0].y;
      _normals[j*(_facets+1) + _facets].z  = _normals[j*(_facets+1) + 0].z;*/
      _vertices[j*(_facets) + _facets].x = _vertices[j*(_facets) + 0].x;
      _vertices[j*(_facets) + _facets].y = _vertices[j*(_facets) + 0].y;
      _vertices[j*(_facets) + _facets].z = _vertices[j*(_facets) + 0].z;
      _normals[j*(_facets) + _facets].x  = _normals[j*(_facets) + 0].x;
      _normals[j*(_facets) + _facets].y  = _normals[j*(_facets) + 0].y;
      _normals[j*(_facets) + _facets].z  = _normals[j*(_facets) + 0].z;
      
    }

/*    // duplicate vertices/normals. to get a closed surface
    for( int i=0; i<_facets+1; i++ )
    {
        _vertices[yTable[_tailSize-1] + i].x = _vertices[i].x;
        _vertices[yTable[_tailSize-1] + i].y = _vertices[i].y;
        _vertices[yTable[_tailSize-1] + i].z = _vertices[i].z;
        _normals[yTable[_tailSize-1] + i].x  = _normals[i].x;
        _normals[yTable[_tailSize-1] + i].y  = _normals[i].y;
        _normals[yTable[_tailSize-1] + i].z  = _normals[i].z;        
    }
    // first are last as well
    _vertices[yTable[_tailSize-1] + _facets].x = _vertices[0].x;
    _vertices[yTable[_tailSize-1] + _facets].y = _vertices[0].y;
    _vertices[yTable[_tailSize-1] + _facets].z = _vertices[0].z;
    _normals[yTable[_tailSize-1] + _facets].x  = _normals[0].x;
    _normals[yTable[_tailSize-1] + _facets].y  = _normals[0].y;
    _normals[yTable[_tailSize-1] + _facets].z  = _normals[0].z;*/


    // Increase color as it grows
//    _colour.x += 0.01;
//    _colour.y += 0.01;
//    _colour.z += 0.01;


    int facets = _facets;
    int j = 2;
/*      vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
      for( int i=0; i<facets+1; i++ )
      {
        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z,  (i/(float)facets) );//-_agePer );
//        vgl.gl().glColor4f( _colour.x-_agePer, _colour.y-_agePer, _colour.z-_agePer, 1 );//-_agePer );
        
        vgl.gl().glNormal3f( _normals[i+j*(facets)].x, _normals[i+j*(facets)].y, _normals[i+j*(facets)].z );
        vgl.gl().glVertex3f( _head.x, _head.y, _head.z );

        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z, (i/(float)facets) );
        vgl.gl().glNormal3f( _normals[i+(j+1)*(facets)].x, _normals[i+(j+1)*(facets)].y, _normals[i+(j+1)*(facets)].z );
        vgl.gl().glVertex3f( _vertices[i+(j+1)*(facets)].x, _vertices[i+(j+1)*(facets)].y, _vertices[i+(j+1)*(facets)].z );
      }      
      vgl.gl().glEnd();
*/

    for ( j=0; j<_tailSize-1; j++ )
    {
      vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
      for( int i=0; i<facets+1; i++ )
      {
        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z, _colour.w );
//        vgl.gl().glColor4f( _colour.x-_agePer, _colour.y-_agePer, _colour.z-_agePer, 1 );//-_agePer );
        vgl.gl().glNormal3f( _normals[i+j*(facets)].x, _normals[i+j*(facets)].y, _normals[i+j*(facets)].z );
        vgl.gl().glVertex3f( _vertices[i+j*(facets)].x, _vertices[i+j*(facets)].y, _vertices[i+j*(facets)].z );

        vgl.gl().glColor4f( _colour.x, _colour.y, _colour.z, _colour.w );
        vgl.gl().glNormal3f( _normals[i+(j+1)*(facets)].x, _normals[i+(j+1)*(facets)].y, _normals[i+(j+1)*(facets)].z );
        vgl.gl().glVertex3f( _vertices[i+(j+1)*(facets)].x, _vertices[i+(j+1)*(facets)].y, _vertices[i+(j+1)*(facets)].z );
      }      
      vgl.gl().glEnd();
    }
  }


  void reset( Vector3 newPos, float ttl )
  {
    setHead( newPos );
    computeTail();
    setTimeToLive( ttl );
    _tailRenderSegments = 0;
    _age = 0;
    _doUpdate = true;  
    
    if( random(100) > 50 )
      _colour.set( 1, 1, 1, 1 );
    else
      _colour.set( 0, 0, 0, 1 );

  }


  int _facets;
  int[] yTable;
  Vector3[] _vertices;
  Vector3[] _normals;
  
  //XTexture _headTex;
  int _headTexID;
  int _tailTexID;
  
  Vector4  _colour;

  boolean _doRenderHead;
  boolean _doUpdate;

  float _age;
  float _agePer;
  float _timeToLive;
  float _invTimeToLive;

  Vector3 _initPos;

  float _headSize;
  Vector3 _head;
  Vector3 _right;

  Vector3  _add;

  float _tailWidth;
  int  _tailRenderSegments;    // counts number of tail segments to render  
  int  _tailSize;
  Vector3[] _tail;
}

class Sphere{

  int sphereStacks = 120;
  int sphereSlices = 120;
  Vector3[] sphereSurface;
  int[] sphereIndices;
  Vector3[] sphereSurfaceUV;
  Vector3[] sphereSurfaceNormal;
  Color4 _color;
  float _radius;
  
  int _callListID;
  boolean _callListCompiled;

  Sphere()
  {  
    _callListID = 0;
    _callListCompiled = false;

    _color = new Color4( 1, 0, 1, 1 );
  }
  
  Sphere( boolean useList )
  {  
    _callListID = vgl.gl().glGenLists( 1 );
    _callListCompiled = false;

    _color = new Color4( 1, 0, 1, 1 );
  }


  void buildSphere( int stacks, int slices, float rad )
  {
    Vector3 c = new Vector3( 0, 0, 0 );

    sphereStacks = stacks;
    sphereSlices = slices;
    
    int i, j;
    _radius = rad;

    Vector3 e = new Vector3();
    Vector3 p = new Vector3();

    int wid = slices;
    int len = (stacks+1)*(slices);
    sphereSurface = new Vector3[len];
    sphereSurfaceNormal = new Vector3[len];
    sphereSurfaceUV = new Vector3[len];
    
    for (j=0;j<len;j++)
    {
      sphereSurface[j] = new Vector3();
      sphereSurfaceNormal[j] = new Vector3();
      sphereSurfaceUV[j] = new Vector3();
    }
  
  
   //
   // compute sphere surface points
   //
   for( j=0; j<stacks+1; j++ )
   {
        for( i=0; i<slices; i++ )
        {
          float theta = j * PI / (stacks);
  	float phi = i * 2 * PI / (slices);
  	float sinTheta = sin(theta);
  	float sinPhi = sin(phi);
  	float cosTheta = cos(theta);
  	float cosPhi = cos(phi);
  
           float tmpi = (1.0 - ((i) / float(slices-1)));
           tmpi *= 3.0;
           float tmpj = ((j) / float(stacks));
  
           e.x = cosPhi * sinTheta;
           e.y = cosTheta;
           e.z = sinPhi * sinTheta;
           p.x = c.x + _radius * e.x;
           p.y = c.y + _radius * e.y;
           p.z = c.z + _radius * e.z;
  
          int idx = j * wid + i;
          sphereSurface[idx].x = p.x;
          sphereSurface[idx].y = p.y;
          sphereSurface[idx].z = p.z;
          sphereSurfaceNormal[idx].x = e.x;
          sphereSurfaceNormal[idx].y = e.y;
          sphereSurfaceNormal[idx].z = e.z;
          sphereSurfaceNormal[idx].normalize();
          
          sphereSurfaceUV[idx].x = tmpi; //4*(i/(float)n);
          sphereSurfaceUV[idx].y = tmpj; //4*2*((j+1)/(float)n);
        }
    }
  
    for( i=0; i<stacks+1; i++ )
    {
      sphereSurface[(i)*slices+slices-1].x = sphereSurface[(i)*slices+0].x;
      sphereSurface[(i)*slices+slices-1].y = sphereSurface[(i)*slices+0].y;
      sphereSurface[(i)*slices+slices-1].z = sphereSurface[(i)*slices+0].z;
      sphereSurfaceNormal[(i)*slices+slices-1].x = sphereSurfaceNormal[(i)*slices+0].x;
      sphereSurfaceNormal[(i)*slices+slices-1].y = sphereSurfaceNormal[(i)*slices+0].y;
      sphereSurfaceNormal[(i)*slices+slices-1].z = sphereSurfaceNormal[(i)*slices+0].z;
      //sphereSurfaceUV[(i)*slices+slices-1].x = sphereSurfaceUV[(i)*slices+0].x;
      //sphereSurfaceUV[(i)*slices+slices-1].y = sphereSurfaceUV[(i)*slices+0].y;
      //sphereSurfaceUV[(i)*slices+slices-1].z = sphereSurfaceUV[(i)*slices+0].z;
    }

    sphereIndices = new int[len*2];
    int index = 0;
    for( j=0; j<stacks; j++ )
    {
      for( i=0; i<slices; i++ )
      {
        sphereIndices[index+0] = j*slices + (i%slices);
        sphereIndices[index+0] = (j+1)*slices + (i%slices);
      }
    }
  }

  void drawSphere()
  {
    this.drawSphere( 0, 0, 0, _radius );
  }

  void drawSphere( float r )
  {
    this.drawSphere( 0, 0, 0, r );
  }

  void drawSphere( float x, float y, float z, float r )
  {
    // If the list is compiled and everything is ok, render
    if( _callListID > 0 && _callListCompiled )
    {
      vgl.gl().glCallList( _callListID );
      return;
    }

    if( _callListID > 0 && !_callListCompiled )
    {      
      vgl.gl().glNewList( _callListID, GL.GL_COMPILE ); 
      
      //vgl.enableLighting( true );
//      float[] matdiff = { _color.r, _color.g, _color.b, _color.a };
//      FloatBuffer fb = FloatBuffer.wrap( matdiff );
//      vgl.gl().glMaterialfv( GL.GL_FRONT_AND_BACK, GL.GL_DIFFUSE, fb );
    }

    int idx = 0;
    int idx2 = 0;
    for( int j=0; j<sphereStacks; j++ )
    {
      idx = j * (sphereSlices);
      idx2 = (j+1) * (sphereSlices);

      vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
      vgl.gl().glColor4f( _color.r, _color.g, _color.b, _color.a );
      for( int i=0; i<sphereSlices; i++ )
      {
        float x1 = x+(sphereSurface[idx+i].x * r);
        float y1 = y+(sphereSurface[idx+i].y * r);
        float z1 = z+(sphereSurface[idx+i].z * r);
        float x2 = x+(sphereSurface[idx2+i].x * r);
        float y2 = y+(sphereSurface[idx2+i].y * r);
        float z2 = z+(sphereSurface[idx2+i].z * r);

        float nx1 = sphereSurfaceNormal[idx+i].x;
        float ny1 = sphereSurfaceNormal[idx+i].y;
        float nz1 = sphereSurfaceNormal[idx+i].z;
        float nx2 = sphereSurfaceNormal[idx2+i].x;
        float ny2 = sphereSurfaceNormal[idx2+i].y;
        float nz2 = sphereSurfaceNormal[idx2+i].z;

        //      vgl.gl().glColor4f( x1*0.01, y1*0.01, z1*0.01, 1 ); //0.1*abs(sin(i+time*3)) );
  //      vgl.gl().glColor4f( z2*0.01, z2*0.01, z2*0.01, freq2*100 ); //0.1*abs(sin(i+time*3)) );
        vgl.gl().glNormal3f( nx1, ny1, nz1 );
        vgl.gl().glVertex3f( x1, y1, z1 );

        //      vgl.gl().glColor4f( z2*0.01, z2*0.01, z2*0.01, 1 ); //0.1*abs(sin(i+time*3)) );
  //      vgl.gl().glColor4f( x2*0.01, y2*0.01, z2*0.01, freq2*100 ); //0.1*abs(sin(i+time*3)) );
        vgl.gl().glNormal3f( nx2, ny2, nz2 );
        vgl.gl().glVertex3f( x2, y2, z2 );
      }
      vgl.gl().glEnd();
    }

    if( _callListID > 0 && !_callListCompiled )
    {
      vgl.gl().glEndList();
      _callListCompiled = true;
    }
  }


  void drawSphereTextured( float x, float y, float z, float r )
  {
    // If the list is compiled and everything is ok, render
    if( _callListID > 0 && _callListCompiled )
    {
      vgl.gl().glCallList( _callListID );
      return;
    }

    if( _callListID > 0 && !_callListCompiled )
    {
      vgl.gl().glNewList( _callListID, GL.GL_COMPILE ); 

      //vgl.enableLighting( true );
//      float[] matdiff = { _color.r, _color.g, _color.b, _color.a };
//      FloatBuffer fb = FloatBuffer.wrap( matdiff );
//      vgl.gl().glMaterialfv( GL.GL_FRONT_AND_BACK, GL.GL_DIFFUSE, fb );
    }
    
    int idx = 0;
    int idx2 = 0;
    for( int j=0; j<sphereStacks; j++ )
    {
      idx = j * (sphereSlices);
      idx2 = (j+1) * (sphereSlices);
  
      vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
      vgl.gl().glColor4f( _color.r, _color.g, _color.b, _color.a );
      for( int i=0; i<sphereSlices; i++ )
      {
        float x1 = x+(sphereSurface[idx+i].x * r);
        float y1 = y+(sphereSurface[idx+i].y * r);
        float z1 = z+(sphereSurface[idx+i].z * r);
        float x2 = x+(sphereSurface[idx2+i].x * r);
        float y2 = y+(sphereSurface[idx2+i].y * r);
        float z2 = z+(sphereSurface[idx2+i].z * r);
  
        float nx1 = sphereSurfaceNormal[idx+i].x;
        float ny1 = sphereSurfaceNormal[idx+i].y;
        float nz1 = sphereSurfaceNormal[idx+i].z;
        float nx2 = sphereSurfaceNormal[idx2+i].x;
        float ny2 = sphereSurfaceNormal[idx2+i].y;
        float nz2 = sphereSurfaceNormal[idx2+i].z;
  
        vgl.gl().glNormal3f( nx1, ny1, nz1 );
        vgl.gl().glTexCoord2f( sphereSurfaceUV[idx+i].x, sphereSurfaceUV[idx+i].y );
        vgl.gl().glVertex3f( x1, y1, z1 );
  
        vgl.gl().glNormal3f( nx2, ny2, nz2 );
        vgl.gl().glTexCoord2f( sphereSurfaceUV[idx2+i].x, sphereSurfaceUV[idx2+i].y );
        vgl.gl().glVertex3f( x2, y2, z2 );
      }
      vgl.gl().glEnd();
    }
    
    if( _callListID > 0 && !_callListCompiled )
    {
      vgl.gl().glEndList();
      _callListCompiled = true;
    }
  }

  /*
   *
   *
  */
  void setColor( float r, float g, float b, float a )
  {
    _color.set( r, g, b, a );
  }
}

import com.sun.opengl.cg.*; 
import com.sun.opengl.util.*; 

//import vitamin.CG;
import vitamin.math.Vector3;
import vitamin.math.Quaternion;
import vitamin.scenesimple.*;


/*class objPos implements Comparable
{
  Vector3 _pos;
  
  objPos()
  {
    _pos = new Vector3();
  }
  
  public int compareTo( Object o )
  {
    float dist = Vector3.distance( _pos, eye );
    return 0;
  }
}*/

class objComparator implements Comparator
{
  public final int compare( Object a, Object b )
  {
    float z1 = ((Vector3)a).z;
    float z2 = ((Vector3)b).z;

    if( z1 > z2 )  return 1;
    else return -1;
  }
}


// Vector class used for ordering
class Vector3Order extends Vector3
{
  Vector3Order()
  {
    super();
    idx = 0;
  }

  Vector3Order( float x, float y, float z, int i )
  {
    super( x, y, z);
    idx = i;
  }

  Vector3Order( Vector3 v, int i )
  {
    super( v.x, v.y, v.z );
    idx = i;
  }
  
  int idx;
}


class SpikeyScene
{
/*  MeshSphere _sphere;
  ArrayList _cylinders;
  MeshCylinder _cyl;
  Scene _scene;*/
  
  vitamin.math.Matrix tmpMat;
  
  //CG fur;
  int furID;
  
  float _globalAlpha;
 
  float furLength;
  float uvTexScale;
  float uvFurScale;
  
  Vector3 force;
  Vector3 gravity;
  Vector3 normalNoise;
  
  int numLayers;
  float invNumLayers;
  int furTexSize;
  XTexture[] furTex;
  PImage[] noiseTextures;
  XTexture furColor;
  
  XTexture shadowTex;
 
  objComparator comparator;
  int _numBalls;
  ArrayList _ballPos;
  ArrayList _ballPosViewSpace;

  float[] anglesZ;

  float sphereRadius;
  float[] sphereScale;
  Sphere oursphere;
  
  Vector3 eye, target;
  
  //int pqstep = 64;
  //int pqfacet = 16;
  //PQTorus pqtorus;


  SpikeyScene()
  {
/*    _scene = new Scene( vgl.gl() );

    StandardMaterial sphereMat = new StandardMaterial( "sphereMat" );
    sphereMat.addTexture( dataPath("texture_blue.png") );
    _scene.addMaterial( sphereMat );

    _sphere = new MeshSphere( "spikeyball", new Vector3(-200, 0, 0), 150, 10, 10 );
    _sphere.setMaterial( sphereMat );
    _sphere.setUVMultiplier( 10, 10 );
    _sphere.generate();
    _scene.addMesh( _sphere );

/*
    _cylinders = new ArrayList();
    Vector3 cylCenter = new Vector3();
    Vector3 up = new Vector3( 0, 1, 0 );
    int numCyls = _sphere.getVertexCount();
    for( int i=0; i<numCyls; i+=10 )
    {
      Vertex vert = _sphere.getVertex( i );

      MeshCylinder cyl = new MeshCylinder( "cyl"+i, cylCenter, 2, 250, 9 );
      cyl.setMaterial( sphereMat );
      cyl.setUVMultiplier( 1, 1 );
      cyl.generate();

      // Transform cylinder to follow sphere's normal      
      Vector3 dir = vert.getNormal().copy();
      dir.add( new Vector3( random(-10, 10), random(-10, 20), random(-10, 10)) );
      Vector3 pos = vert.getPosition().copy();
      pos.add( new Vector3( random(-10,10), 0, random(-10,10)) );
      transformCylinderMesh( up, dir, pos, (MeshCylinder)cyl ) ;

      // save in an array. just keep track      
      _cylinders.add( cyl );
      _scene.addMesh( cyl );      
    }*/
/*    
    _cyl = new MeshCylinder( "cyl1",  new Vector3(300, 0, 0), 50, 300, 10 );
    _cyl.setUVMultiplier( 5, 4 );
    _cyl.setMaterial( sphereMat );
    _cyl.generate();
    
    _scene.addMesh( _cyl );

    _scene.process();
*/

//    pqtorus = new PQTorus();
//    pqtorus.init( pqstep, pqfacet );

    comparator = new objComparator();
    _ballPos = new ArrayList();
    _ballPosViewSpace = new ArrayList();

    _ballPos.add( new Vector3Order(-600+140, -400, -1230, 6) );
//    _ballPos.add( new Vector3Order(250, 0, -400, 1) );
//    _ballPos.add( new Vector3Order(700, 0, -300, 2) );
//    _ballPos.add( new Vector3Order(-200, 0, -100, 5) );
//    _ballPos.add( new Vector3Order(0, 0, 0, 0) );
    _ballPos.add( new Vector3Order(-1000+290, -200, -500, 4) );
    _ballPos.add( new Vector3Order(-1300+390, 0, 0, 3) );
    _numBalls = _ballPos.size();
    
    sphereScale = new float[_numBalls];
    sphereScale[4-4] = 2.5;
//    sphereScale[1] = 0.8;
//    sphereScale[2] = 1;
//    sphereScale[5] = 1;
//    sphereScale[0] = 1.3;
    sphereScale[abs(3-4)] = 2;
    sphereScale[6-4] = 2;
    
    anglesZ = new float[_numBalls];
    for( int i=0; i<_numBalls; i++ )
      anglesZ[i] = 0;

    sphereRadius = 60;
    oursphere = new Sphere( true );
    oursphere.setColor( 0.7*gamma, 0.7*gamma, 1*gamma, 1 );
    oursphere.buildSphere( 10, 10, sphereRadius );
//    oursphere.buildSphere( 16, 16, 60 ); 

    furLength = 30; //50;
    uvTexScale = 2;//1;
    uvFurScale = 4;//2;
    numLayers = 26;//26;
    invNumLayers = 1.0 / (float)numLayers;
    furTexSize = 128;

    furColor = new XTexture("texture_blue.png" );
    //furColor.loadPImage( "texture_blue.png" );
    furColor.setWrap();
    
    shadowTex = new XTexture("particle_black.png" );
    shadowTex.setClamp();

    //fur = new CG( vgl.gl() );
    //fur.loadFXFromFile( dataPath("fursimple.cgfx") );
    furID = vgl.addEffectFromFile( dataPath("fursimple.cgfx") );
    
    eye = new Vector3();
    target = new Vector3();
    
    _globalAlpha = 0.0;
  }

  void init()
  {
    int idensity = 19000;  //9000;
    furTex = new XTexture[numLayers];
    noiseTextures = new PImage[numLayers];
    for( int ii=0; ii<numLayers; ii++ )
    {
      noiseTextures[ii] = createImage( furTexSize, furTexSize, ARGB );
      noiseTextures[ii].loadPixels();
      for( int j=0; j<furTexSize; j++ )
      {
        for( int i=0; i<furTexSize; i++ )
        {
          noiseTextures[ii].pixels[j*furTexSize+i] = color( 0, 0, 0, 0 );
        }
      }
      noiseTextures[ii].updatePixels();
    }
    /*for( int ii=0; ii<numLayers; ii++ )
    {
      for( int j=0; j<idensity; j++ )
      {
        int xrand = (int)random( 0, furTexSize-1 );
        int yrand = (int)random( 0, furTexSize-1 );

        noiseTextures[ii].pixels[yrand*furTexSize+xrand] = color( 255, 0, 0, 255 );
      }
    }*/
    
    //compute the number of strands that stop at each layer
    int strands = idensity * furTexSize * furTexSize;
    int strandsPerLayer = strands / numLayers;

    for( int ii=0; ii<numLayers; ii++ )
    {
      noiseTextures[ii].loadPixels();
      float length = float(ii)/(float)numLayers; // 0 to 1
      length = 1 - length; // 1 to 0
//    int density = (int)(idensity * length);
      int density = (int)(idensity * length*6);
      randomSeed( 28382 );
      for(int i=0; i<density; i++)
      {
        //compute max layer
        int max_layer = i*numLayers / strandsPerLayer;
        //normalize into [0..1] range
        float max_layer_n = (float)max_layer / (float)numLayers;

        int xrand = (int)random(0, furTexSize);
        int yrand = (int)random(0, furTexSize);
        noiseTextures[ii].pixels[yrand*furTexSize+xrand] = color( 255, 255, 255, 255 );
//        noiseTextures[ii].pixels[yrand*furTexSize+xrand] = color( 255, 255, 255, 255-(255*(i/(float)density)) );
        //noiseTextures[ii].pixels[yrand*furTexSize+xrand] = color( 255, 255, 255, (int)255*max_layer_n );
      }
      noiseTextures[ii].updatePixels();
    }
  
  
    for (int x = 0; x < furTexSize; x++)
    {
      for (int y = 0; y < furTexSize; y++)
      {
	for(int ii=0; ii<numLayers; ii++)
	{
          noiseTextures[ii].loadPixels();
	  
          // length of the hair
	  float length = (float)ii/(float)(numLayers); // 0 to 1
			
	  // tip of the hair is semi-transparent
	  float alpha = alpha(noiseTextures[ii].pixels[y*furTexSize+x]);
	  if( alpha > 0.0f )
	    noiseTextures[ii].pixels[y*furTexSize+x] = color( 255, 255, 255, (1.0-length)*128 ); // More transparent as we get closer to 
				                                    // the tip ,length is from 0 to 1, so the
				                                    // tip or outer layer is 1.
          noiseTextures[ii].updatePixels();
	}
      }
    }

    for( int ii=0; ii<numLayers; ii++ )
    {
      furTex[ii] = new XTexture();
      furTex[ii].loadPImageFromMemory( noiseTextures[ii] );
      furTex[ii].setWrap();
    }
    force = new Vector3();
    gravity = new Vector3( 0, 0, 0 );
    normalNoise = new Vector3();
  }
  

  void draw( float time )
  {
/*    // Sort ball positions in eye-space and save index for render
    _ballPosViewSpace.clear();
    for( int io=0; io<_ballPos.size(); io++ )
    {
      Vector3 v0 = (Vector3)_ballPos.get(io);
      Vector3 v1 = Vector3.transform( v0, camMatrix );
      _ballPosViewSpace.add( new Vector3Order(v1, io) );
    }
    //Collections.sort( _ballPosViewSpace, comparator );*/
    Collections.sort( _ballPos, comparator );

    
    //
    // Render
    //
    for( int i=0; i<_ballPos.size(); i++ )
    {
      // Get ordered ball index
      //int idx = ((Vector3Order)_ballPosViewSpace.get(i)).idx;
      //drawfur( i, time, (Vector3)_ballPos.get(idx), 1+idx, 2 );
      drawfur( i, time, (Vector3)_ballPos.get(i), 1+i, 2 );
    }  
    
    //
    // Update 
    //
    update( time );
  }


  void update( float time )
  {
    _globalAlpha = 1;
    //_globalAlpha = time * 0.5;
    //if( _globalAlpha < 0.0 ) _globalAlpha = 0.0;
    //if( _globalAlpha > 1.0 ) _globalAlpha = 1.0;
    
    //
    // Apply gravity to spikeys
    //
    for( int i=0; i<_ballPos.size(); i++ )
    {
      Vector3 v = (Vector3)_ballPos.get( i );

      float lim= land.InterpolatedValue(v.x, v.z) + sphereRadius;//*sphereScale[i];
      if( (v.y) <= lim )
        v.y = lim;
      else
        v.y -= 0.5;
    }
  }
  
  void drawfur( int idx, float time, Vector3 trans, float uvTexScale, float uvFurScale )
  { 
    CGpass pass;

/*    // Draw shadows below
    shadowTex.enable();
    vgl.setDepthWrite( false );
    vgl.pushMatrix();
    vgl.identity();
    vgl.translate( trans.x, trans.y-(60*sphereScale[idx]), trans.z );
    vgl.rotateX( -90 );
    vgl.fill( 1 );
    vgl.rect( 500, 500 );
    vgl.popMatrix();
    shadowTex.disable();
    vgl.setDepthWrite( true );*/


    //furColor.enable();
    //vgl.fill( 0.1 );
    //drawSphereTextured( 0, 0, 0 );

    // tombé the spikeys at desired time
    if( time >= 185.0 && time < 205.0 && idx == 1 )
    {
      anglesZ[idx] = (time-185)*10;
      //if( anglesZ[idx] > 45 ) anglesZ[idx] = 45;
      //else
      {
        trans.x -= 0.7;
        //trans.y -= 0.4;
        //trans.y = land.InterpolatedValue( trans.x, trans.z );
      }      
    }
/*    if( time >= 105.0 && time < 205.0 && idx == 1 )
    {
      addx = 0;//cos(PI*2*(time-105)*0.10)*50;
      anglesZ[idx] = sin(PI*2*(time-105)*.10)*10;
    }*/

    if( time >= 115.0 && time < 135.0 && idx == 2 )
    {
      trans.x -= 0.3;
      //trans.y -= 0.2;      
      trans.z += 0.1;
      //trans.y = land.InterpolatedValue( trans.x, trans.z );
      
      anglesZ[idx] = (time-115.0)*5;
    }

    // compute world matrix
    vgl.pushMatrix();
    vgl.identity();
    vgl.translate( trans.x, trans.y, trans.z );
    vgl.rotateZ( anglesZ[idx] );
    vgl.scale( sphereScale[idx] );
    tmpMat = vgl.getTransposeViewMatrix();
    vgl.popMatrix();


    vgl.pushMatrix();
    vgl.translate( trans.x, trans.y, trans.z );
    vgl.rotateZ( anglesZ[idx] );
    vgl.scale( sphereScale[idx] );

    float _alpha = _globalAlpha;
    float colmul = 9.0 - (noise(eye.z*0.2, time*0.01)*0.3*9);
    vgl.fill( (1/255.0)*colmul*_alpha, (13/255.0)*colmul*_alpha, (36/255.0)*colmul*_alpha, 1*_alpha );
    //vgl.fill( (1/255.0)*colmul*_alpha, (7/255.0)*colmul*_alpha, (20/255.0)*colmul*_alpha, 1*_alpha );

    vgl.setShader( furID );
    vgl.setParameter1f( "UVTexScale", uvTexScale );
    vgl.setParameter1f( "UVFurScale", uvFurScale );
    vgl.setParameter3f( "gravity", gravity );
    vgl.setParameter4f( "fogColor", fogColor );
    vgl.setParameter1f( "fogDensity", fogDensity );
    vgl.setParameter3f( "cameraPos", eye );
    vgl.setParameter4f( "lightPos", lightPos );
    vgl.setParameter1f( "kC", kC );
    vgl.setParameter1f( "kL", kL );
    vgl.setParameter1f( "kQ", kQ );
    vgl.setMatrixParameterSemantic( "WORLDVIEWPROJECTION", ShaderSemantics.WORLDVIEWPROJECTION_MATRIX, ShaderSemantics.IDENTITY_MATRIX );
    vgl.setMatrixParameterSemantic( "MODELVIEWMATRIX", ShaderSemantics.VIEW_MATRIX, ShaderSemantics.IDENTITY_MATRIX );
    vgl.setMatrixParameterSemantic( "VIEWINVERSETRANSPOSE", ShaderSemantics.VIEW_MATRIX, ShaderSemantics.INVERSE_TRANSPOSE_MATRIX );
    vgl.setMatrixParameterSemantic( "WORLDMATRIX", tmpMat.getArray() );
    vgl.setMatrixParameterSemantic( "VIEWMATRIX", invCamMatrix.getArray() );
    vgl.setTextureParameter( "ColourSampler", furColor.getId() );

    pass = ((ShaderCGFX)vgl.getActiveShader()).getTechniqueFirstPass( "Technique_FurSimple" );

    //oursphere.drawSphereTextured( 0, 0, 0, 1 );

    for( int i=0; i<numLayers; i++ )
    {
      float layer = i * invNumLayers; // / (float)numLayers;
      float length = furLength * layer;

      furLength = 25 + (1+(sin(time*.0165625))*10);
//      force.set( 14*sin(time*10.52), 14*sin(time*10.52), 14*sin(time*10.52) ); //15*(2*cos(time*.7)) );
      force.set( 14*sin(time*1.6), 7*sin(time*1.6), 4*sin(time*2.12) ); //15*(2*cos(time*.7)) );
//      force.set( 14*sin((i*2*PI/(float)numLayers)+time*10.52), 0, 0 ); //15*(2*cos(time*.7)) );
//      force.set( 5*sin((i*2*PI/(float)numLayers)+time*10.52), 7*cos((i*2*PI/(float)numLayers)+time*4), .5*sin(time*.3) ); //15*(2*cos(time*.7)) );

      vgl.setTextureParameter( "FurSampler", furTex[i].getId() );
      vgl.setParameter1f( "Layer", layer );
      vgl.setParameter1f( "FurLength", length );
      vgl.setParameter3f( "force", force );
      CgGL.cgSetPassState( pass );     

/*      pass = fur.getTechniqueFirstPass( "FurSimple" );
      fur.setTextureParameter( "FurSampler", furTex[i].getId() );
      fur.setTextureParameter( "ColourSampler", furColor.getId() );
      fur.setParameter1f( "Layer", layer );
      fur.setParameter1f( "FurLength", length );
      fur.setParameter1f( "UVTexScale", uvTexScale );
      fur.setParameter1f( "UVFurScale", uvFurScale );
      fur.setParameter3f( "force", force );
      fur.setParameter3f( "gravity", gravity );
      fur.setParameter4f( "fogColor", fogColor );
      fur.setParameter1f( "fogDensity", fogDensity );
      fur.setParameter3f( "cameraPos", eye );
      fur.setParameter4f( "lightPos", lightPos );
      fur.setParameter1f( "kC", kC );
      fur.setParameter1f( "kL", kL );
      fur.setParameter1f( "kQ", kQ );
      fur.setParameter4x4fBySemantic( "WorldViewProjection", CgGL.CG_GL_MODELVIEW_PROJECTION_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
      fur.setParameter4x4f( "matModelView", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
      fur.setParameter4x4f( "matViewIT", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_INVERSE_TRANSPOSE );
      fur.setParameter4x4f( "matWorld", tmpMat );
      fur.setParameter4x4f( "matView", invCamMatrix );
      CgGL.cgSetPassState( pass );*/

      //_scene.render();
      oursphere.drawSphereTextured( 0, 0, 0, 1 );
      //drawSphereTextured( 10, 0, 0 );

      CgGL.cgResetPassState( pass );
    }
    vgl.disableShader();
    
    vgl.popMatrix();    
  }


/*
  //
  // Transform a mesh to follow a direction vector
  //
  void transformCylinderMesh( Vector3 up, Vector3 V, Vector3 offset, Mesh mesh ) 
  {
  	for( int i=0; i<mesh.getVertexCount(); i++ )
  	{
  		Vertex v = mesh.getVertex( i );
  
  		Vector3 P = new Vector3( v.getPosition().x, v.getPosition().y, v.getPosition().z );
  
  		Vector3 NY = up.copy();
  		NY.normalize();
  		Vector3 NV = V.copy();
  		NV.normalize();
  
  		Vector3 N = NY.cross( NV );	// axis of rotation
  		N.normalize();
  
  		float dot = NY.dot( NV );	// cos angle
  		float rad = ( acos(dot) );	// angle of rotation (radians)
  
  		// quat from an angle and a rotation axis
  		Quaternion quat = new Quaternion();
  		quat.rotateAxis( N, rad );
  		// transform vertex
  		Vector3 dv = quat.mul( P );  

                // translate to right position
                dv.add( offset );
                
  		v.setPosition( dv.x, dv.y, dv.z );
  	}
  }
*/
}
import penner.easing.*;

//import vitamin.CG;
import vitamin.math.Vector3;
import vitamin.math.Quaternion;
import vitamin.scenesimple.*;

class TactuScene 
{  
/*  SineWave wave; 

  SineWave waveCyl; 
  SineWave waveCyl2; 
  SineWave waveCyl3; 
  SineWave waveCyl4; 

  PinkNoise pnoise;

  boolean addSequencerWave = false;
  boolean addWaveCylinder1 = false;
  boolean addWaveCylinder2 = false;
  boolean addWaveCylinder3 = false;
  boolean addWaveCylinder4 = false;
  boolean addNoiseSignal = false;
*/
  float noiseAmp;
  float noiseTimeStart = 0.0;
  
//  float aspectRatio = 4.0 / 3.0;
  
//  XTexture hll4;
//  XTexture noteTex;
//  XTexture activeNoteTex;
//  XTexture flowerTex;
//  XTexture flowerAlphaTex;
  
  XTexture shadowTex;
  XTexture chapa;
  XTexture chapaPS;
  XTexture chapaV;
  XTexture chapaNNY;
  XTexture chapaKaz;
    
  //CG diffspec;
  int diffspecID;
  
  Vector4 lightPos;
  Vector3 eye, eyeEnd;
  Vector3 target, targetEnd;
  Vector3 up;
  float camSpeed;
  
  Vector4 _fogColor;
  
  //int noteCount = 0;
  //int numNotes = 5;
  //Vector4[] notePos;
  //float[] notePosAlpha;
  //Vector3 noteCenter;
  //float alphaDamp = 0.9;
  
  float lfo1 = 1.0;
  float lfo2 = 1.0;
  float lfo3 = 1.0;
    
  float time = 0.0;
  

  int numRibbons = 8;
  ArrayList ribbons;
  
  int cylsCount = 0;
  int numCyls = 25;
  CylinderRoll[] cyls;
  
  float groundLevel = -105;
  
  Sphere aquario;
  
//  XTexture zBufferTex;
//  FBO zBuffer;

  Vector3 psPos;
  Vector3 vPos;
  Vector3 nnyPos;
  Vector3 kazPos;
  int psIdx = -1;
  int vIdx = -1;
  int nnyIdx = -1;
  int kazIdx = -1;
  boolean psOn = false;
  boolean vOn = false;
  boolean nnyOn = false;
  boolean kazOn = false;
  float psTime;
  float vTime;
  float nnyTime;
  float kazTime;
  
    TactuScene()
    {
    }

    void init()
    {
      _fogColor = new Vector4( 1, 1, 1, 1 );
      lightPos = new Vector4( -600, 300, -600, 1 );

      eye = new Vector3( 0, 200, 180 );
      target = new Vector3( 0, 0, 0 );
      up = new Vector3( 0, 1, 0 );
      eyeEnd = new Vector3();
      targetEnd = new Vector3();
      camSpeed = 1.0 / 150.0;

      shadowTex = new XTexture( "particle_black.png" );
      chapa = new XTexture( "rotulo.png" );
      chapaPS = new XTexture();
      chapaPS.loadPImage( "rotulo_ps.png" );
      chapaPS.setClamp();
      chapaV = new XTexture();
      chapaV.loadPImage( "rotulo_v.png" );
      chapaV.setClamp();
      chapaNNY = new XTexture();
      chapaNNY.loadPImage( "rotulo_nny.png" );
      chapaNNY.setClamp();
      chapaKaz = new XTexture();
      chapaKaz.loadPImage( "rotulo_kaz.png" );
      chapaKaz.setClamp();

      ribbons = new ArrayList();
      for( int i=0; i<numRibbons; i++ )
      {
        RibbonTactu r = new RibbonTactu( 400, 26, 1, false );
        //r._tailWidth = 48;
        //r._headTex = rib._headTex;  // reference to texture
        r.setHead( 0, 90, 0 );
        //r._add.set( sin((i*2*PI)/(float)numRibbons), 0, cos((i*2*PI)/(float)numRibbons) );
        r.setTimeToLive( random(80, 500) );
        r._colour.set( 0, 0, 0, 1 );
        r.computeTail();
        
        ribbons.add( r );
      }

      cyls = new CylinderRoll[numCyls];
      for( int i=0; i<numCyls; i++ )
      {
        cyls[i] = new CylinderRoll();
        cyls[i].setHead( random(-30,30), 0, random(-90,90) );
        cyls[i].setTimeToLive( 4000 );
        cyls[i].setTailSize( 300 );
        cyls[i].setCylinderDetail( 4 );
        cyls[i].setCylinderRadius( (int)random(4, 10) );
        cyls[i]._add.set( random(-.01251, .01251), random(.1251, (i+1)*.51), random(-.01251, .01251) );
        cyls[i]._usePerlin = true;
        cyls[i].computeTail();
      }

      aquario = new Sphere();
      aquario.setColor( 1, 1, 1, 1 );
      aquario.buildSphere( 80, 80, 160.0 ); 

      //diffspec = new CG( vgl.gl() );
//      diffspec.loadFXFromFile( dataPath("diffusespecular.cgfx") );
      //diffspec.loadFXFromFile( dataPath("diffusespecular_notexture.cgfx") );
      diffspecID = vgl.addEffectFromFile( dataPath("diffusespecular_notexture.cgfx") );

      // compute board's positions
      float posAngle = 0;
      float offset = 400;
      float x = cos( radians(posAngle) ) * offset;
      float z = sin( radians(posAngle) ) * offset;
      psPos = new Vector3( x, groundLevel, z );
      posAngle = 90;
      x = cos( radians(posAngle) ) * offset;
      z = sin( radians(posAngle) ) * offset;      
      vPos = new Vector3( x, groundLevel, z );
      posAngle = 180;
      x = cos( radians(posAngle) ) * offset;
      z = sin( radians(posAngle) ) * offset;      
      nnyPos = new Vector3( x, groundLevel, z );
      posAngle = 270;
      x = cos( radians(posAngle) ) * offset;
      z = sin( radians(posAngle) ) * offset;      
      kazPos = new Vector3( x, groundLevel, z );

/*
      //
      // MINIM
      //
      wave = new SineWave( 10, .1, out.sampleRate() );   
      wave.portamento( 800 );
    //  out.addSignal( wave );
    
      waveCyl = new SineWave( 32, .1, out.sampleRate() );   
      out.addSignal( waveCyl );
    
      waveCyl2 = new SineWave( 100, .1, out.sampleRate() );   
      out.addSignal( waveCyl2 );
    
    //  waveCyl3 = new SineWave( 100, .2, out.sampleRate() );   
    //  out.addSignal( waveCyl3 );
    
      pnoise = new PinkNoise( 0 );*/
    }


void draw( float time)
{
  vgl.background( 1 );

  renderScene( time );
}


void renderPlants()
{
  eye.set( sin(time*.1)*1200, 450, cos(time*.1)*1200 );
  target.set( 0, 200, 0 );

  vgl.perspective( 45.0, aspectRatio, 1.0, 4000.0 );
  vgl.camera( eye, target, up );
//  vgl.camera( 0, 250, 1200, 0, 100, 0, 0, 1, 0 );

/*
//  setupPointLight( new Vector3(0, 400, 800) );
  vgl.gl().glEnable( GL.GL_LIGHTING );
  vgl.gl().glEnable( GL.GL_COLOR_MATERIAL );
  vgl.gl().glLightModelfv( GL.GL_LIGHT_MODEL_AMBIENT, new float[]{.03f,.03f,.03f, 1.f }, 0);
  vgl.gl().glColorMaterial( GL.GL_FRONT_AND_BACK,GL.GL_AMBIENT_AND_DIFFUSE );

  //////////////////////////// LIGHT 1 /////////////////////////////////
  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_AMBIENT,new float[]{0, 0, 0, 1.f }, 0 );
  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_DIFFUSE,new float[]{ 0.4, 0.4, 0.4, 1.f }, 0 );
//  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_DIFFUSE,new float[]{ 0.0, 0, 0.4, 1.f }, 0 );
  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_SPECULAR,new float[]{ .7f,.7f,.7f, 1.f  }, 0 );
  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_POSITION,new float[]{ -300, 800, 600, 1.0f }, 0 );
  vgl.gl().glEnable( GL.GL_LIGHT1 );
  ///////////////////////////////////////////////////////////////////////

  vgl.gl().glMaterialfv( GL.GL_FRONT_AND_BACK, GL.GL_SPECULAR, new float[]{1f, 1f, 1f, 1.0f}, 0 ); 
  vgl.gl().glMateriali( GL.GL_FRONT_AND_BACK,GL.GL_SHININESS, 128 );
  vgl.gl().glLightModeli( GL.GL_LIGHT_MODEL_COLOR_CONTROL, GL.GL_SEPARATE_SPECULAR_COLOR );
*/

  //
  // Draw growing distorted cylinders
  //
  
//  float growSpeed = wave.frequency() * 0.002;
  float growSpeed = (time-noiseTimeStart)*3;
  float dispSpeed = (time-noiseTimeStart)*3;


    vgl.enableLighting( false );
//    for( int i=0; i<1; i++ )
    for( int i=0; i<numCyls; i++ )
    {
      cyls[i].addHead( 2*sin(time*2), 0, 0 );
      cyls[i]._colour.set( 0, 0, 0, 1 );
      //cyls[i]._colour.set( 1, 1, 1, 1 );
      cyls[i].update( (time-noiseTimeStart) );
      cyls[i].draw( (time-noiseTimeStart) );
      cyls[i]._dispoffset = 1;// + dispSpeed;
      cyls[i]._displaces  = 0;
      cyls[i]._dispscale  = 19;//+abs(cos(wave.frequency())*.2);
    }
}


void renderScene( float time )
{ 
  /*
  if( time > 1.0 && !addSequencerWave )
//  if( time > 8.0 && !addSequencerWave )
  {
    addSequencerWave = true;
    out.addSignal( wave );
    tactu5.start();
  }
  if( time > 32.0 && !addNoiseSignal )
  {
    addNoiseSignal = true;
    out.addSignal( pnoise );
    noiseTimeStart = time;
  }
*/

/*
  vgl.gl().glEnable( GL.GL_LIGHTING );
  vgl.gl().glEnable( GL.GL_COLOR_MATERIAL );
  vgl.gl().glLightModelfv( GL.GL_LIGHT_MODEL_AMBIENT, new float[]{0.0f,0.0f,0.1f, 1.f }, 0);
  vgl.gl().glColorMaterial( GL.GL_FRONT_AND_BACK,GL.GL_AMBIENT_AND_DIFFUSE );

  //////////////////////////// LIGHT 1 /////////////////////////////////
  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_AMBIENT,new float[]{0, 0, 0.1, 1.f }, 0 );
  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_DIFFUSE,new float[]{ 0.994, 0.994, 0.994, 1.f }, 0 );
  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_SPECULAR,new float[]{ .297f,.297f,.297f, 1.f  }, 0 );
  vgl.gl().glLightfv( GL.GL_LIGHT1,GL.GL_POSITION,new float[]{ -900, -1200, 200, 1.0f }, 0 );
  vgl.gl().glEnable( GL.GL_LIGHT1 );
  ///////////////////////////////////////////////////////////////////////

  vgl.gl().glMaterialfv( GL.GL_FRONT_AND_BACK, GL.GL_SPECULAR, new float[]{1f, 1f, 1f, 1.0f}, 0 ); 
  vgl.gl().glMateriali( GL.GL_FRONT_AND_BACK,GL.GL_SHININESS, 32 );
  vgl.gl().glLightModeli( GL.GL_LIGHT_MODEL_COLOR_CONTROL, GL.GL_SEPARATE_SPECULAR_COLOR );
*/

  float camTime = 7.0;

/*
  eyeEnd.set( sin(time*.14)*1200, 450, cos(time*.14)*1200 );
  targetEnd.set( 0, 200, 0 );
  
  camSpeed = 0.006;
  this.eye.x += (eyeEnd.x-this.eye.x) * camSpeed;
  this.eye.y += (eyeEnd.y-this.eye.y) * camSpeed;
  this.eye.z += (eyeEnd.z-this.eye.z) * camSpeed;
  this.target.x += (targetEnd.x-this.target.x) * camSpeed;
  this.target.y += (targetEnd.y-this.target.y) * camSpeed;
  this.target.z += (targetEnd.z-this.target.z) * camSpeed;
*/



  // lerp to position: 205.28418, 450.0, -1182.3107
  float camDist = time;
  float camAngle = 8;//time-camTime;
  if( camDist < camTime )
  {  
    float cos0 = 100;//-157.85895; // cos(0)*160;
    float sin0 = 100;//-26.087368; // sin(0)*160;
    this.eye.set( Sine.easeInOut(camDist, sin0, (1000*sin(camAngle*.14))-sin0, camTime), //3.358-160, camTime), 
             Sine.easeIn(camDist, 160, 450-160, camTime), 
             Sine.easeInOut(camDist, cos0, (1000*cos(camAngle*.14))-cos0, camTime) ); //1199.99-160, camTime) );
    this.target.set( 0, Sine.easeInOut(camDist, 50, 200-50, camTime), 0 );             
  }
  else
  {
    this.eye.set( 1000*sin(camAngle*.14), 450, 1000*cos(camAngle*.14) );
    //println( time-camTime );
    //this.eye.debug();
    this.target.set( 0, 200, 0 );
  }

  vgl.perspective( 45.0, aspectRatio, 1.0, 4000.0 );
  vgl.camera( this.eye, this.target, up );
  vitamin.math.Matrix cameraMatrix = vgl.getTransposeViewMatrix();

  vgl.rotateY( degrees(time*0.14) );

  //
  // draw floor
  //
  vgl.enableLighting( false );
  vgl.enableTexture( false );
  vgl.gl().glDisable( GL.GL_FOG );
/*  // Setup fog
//  float[] fogCol = { 0, 0, 0, 0 };
  float[] fogCol = { 1, 1, 1, 0 };
  vgl.gl().glEnable( GL.GL_FOG );
  //gl._gl.glFogi( GL.GL_FOG_MODE, GL.GL_LINEAR );
  vgl.gl().glFogi( GL.GL_FOG_MODE, GL.GL_EXP2 );
  vgl.gl().glFogfv( GL.GL_FOG_COLOR, fogCol, 0 );
  vgl.gl().glFogf( GL.GL_FOG_DENSITY, fogDensity );*/
  
  vgl.pushMatrix();
  vgl.translate( 0, groundLevel-5, 0 );
  vgl.rotateX( 90 );
  vgl.fill( 1, 1 );
  vgl.rect( 3000, 3000 );
  vgl.popMatrix();

  

  //
  // draw credtis
  //
  vgl.enableLighting( false );
  vgl.enableTexture( true );
  vgl.setAlphaBlend();
  vgl.fill( 1.0, 1.0 );
  

  float posAngle = 0;
  //float offset = 380;
  //float x = cos( radians(posAngle) ) * offset;
  //float z = sin( radians(posAngle) ) * offset;

  // ps
//  if( !psOn )
  {
    posAngle =  0;
    chapa.enable();
    vgl.pushMatrix();
    vgl.translate( psPos ); //x, groundLevel, z );
    vgl.rotateX( 90 );
    vgl.rotateZ( 90+posAngle );
    vgl.rect( 256, 128 );
    vgl.popMatrix();
  }
//  if( !vOn )
  {
    // V
    chapa.enable();
    posAngle = 90;
    //x = cos( radians(posAngle) ) * offset;
    //z = sin( radians(posAngle) ) * offset;
    vgl.pushMatrix();
    vgl.translate( vPos ); //x, groundLevel, z );
    vgl.rotateX( 90 );
    vgl.rotateZ( 90+posAngle );
    vgl.rect( 256, 128 );
    vgl.popMatrix();
  }
//  if( !nnyOn )
  {
    // NNY
    chapa.enable();
    posAngle = 180;
    //x = cos( radians(posAngle) ) * offset;
    //z = sin( radians(posAngle) ) * offset;
    vgl.pushMatrix();
    vgl.translate( nnyPos ); //x, groundLevel, z );
    vgl.rotateX( 90 );
    vgl.rotateZ( 90+posAngle );
    vgl.rect( 256, 128 );
    vgl.popMatrix();
  }
//  if( !kazOn )
  {
    chapa.enable();
    posAngle = 270;
    //x = cos( radians(posAngle) ) * offset;
    //z = sin( radians(posAngle) ) * offset;
    vgl.pushMatrix();
    vgl.translate( kazPos ); //x, groundLevel, z );
    vgl.rotateX( 90 );
    vgl.rotateZ( 90+posAngle );
    vgl.rect( 256, 128 );
    vgl.popMatrix();
  }

  //if( !((Ribbon)ribbons.get(0))._doUpdate )
  {
    //
    // draw credtis
    //
    vgl.setAdditiveBlend();
    vgl.enableLighting( false );
    vgl.setDepthWrite( false );
    vgl.enableTexture( true );
    vgl.fill( 1.0, 1.0 );
    
    
    float psdist=0.0, vdist=0.0, nnydist=0.0, kazdist=0.0;
    for( int i=0; i<ribbons.size(); i++ )
    {
      RibbonTactu rr = (RibbonTactu)ribbons.get( i );

      Vector3 ribHead = rr._head.copy();
      psdist = Vector3.distance( psPos, ribHead );
      vdist = Vector3.distance( vPos, ribHead );
      nnydist = Vector3.distance( nnyPos, ribHead );
      kazdist = Vector3.distance( kazPos, ribHead );
      if( !psOn && psdist <= 90 )
      {
        psOn = true;
        psIdx = i;
        psTime = time;
        if( useMinim ) credits.loop();
        break;
      }
      if( !vOn && vdist < 90 )
      {
        vOn = true;
        vIdx = i;
        vTime = time;
        break;
      }
      if( !nnyOn && nnydist < 90 )
      {
        nnyOn = true;
        nnyIdx = i;
        nnyTime = time;
        break;
      }
      if( !kazOn && kazdist < 90 )
      {
        kazOn = true;
        kazIdx = i;
        kazTime = time;
        break;
      }
    }
    
    // ps
    if( psOn )
    {
      vgl.fill( 1, random( 0, (time-psTime)*0.25) );
      posAngle = 0;
      chapaPS.enable();
      vgl.pushMatrix();
      vgl.translate( psPos ); //x, groundLevel, z );
      vgl.rotateX( 90 );
      vgl.rotateZ( 90+posAngle );
      vgl.rect( 256, 128 );
      vgl.popMatrix();
    }
    
    // V
    if( vOn )
    {
      posAngle = 90;
      vgl.fill( 1, random( 0, (time-vTime)*0.25) );
      chapaV.enable();
      vgl.pushMatrix();
      vgl.translate( vPos ); //x, groundLevel, z );
      vgl.rotateX( 90 );
      vgl.rotateZ( 90+posAngle );
      vgl.rect( 256, 128 );
      vgl.popMatrix();
    }
    
    // NNY
    if( nnyOn ) 
    {
      posAngle = 180;
      vgl.fill( 1, random( 0, (time-nnyTime)*0.25) );
      chapaNNY.enable();
      vgl.pushMatrix();
      vgl.translate( nnyPos ); //x, groundLevel, z );
      vgl.rotateX( 90 );
      vgl.rotateZ( 90+posAngle );
      vgl.rect( 256, 128 );
      vgl.popMatrix();
    }
    
    // Kaz
    if( kazOn ) 
    {
      posAngle = 270;
      vgl.fill( 1, random( 0, (time-kazTime)*0.25) );
      chapaKaz.enable();
      vgl.pushMatrix();
      vgl.translate( kazPos ); //x, groundLevel, z );
      vgl.rotateX( 90 );
      vgl.rotateZ( 90+posAngle );
      vgl.rect( 256, 128 );
      vgl.popMatrix();
    }
  }

  //
  // Draw sphere's shadow
  //
  vgl.setDepthWrite( true );
  vgl.setDepthMask( false );
  vgl.setAlphaBlend();
  
  vgl.fill( .0095, .75 );
  shadowTex.enable();
  vgl.pushMatrix();
  vgl.translate( 0, groundLevel, 0 );
  vgl.rotateX( 90 );
  //vgl.rotateZ( time*10 );
  vgl.fill( 0, 1 );
  vgl.rect( 315, 315 );
  vgl.popMatrix(); 
  vgl.pushMatrix();
  vgl.translate( 0, groundLevel, 0 );
  vgl.rotateX( 90 );
  //vgl.rotateZ( time*10 );
  vgl.fill( 0, 1 );
  vgl.rect( 155, 155 );
  vgl.popMatrix(); 
  vgl.setDepthMask( true );


  if( time > camTime*0.8 )
  { 
    //
    // Draw tentacles and their shadows
    //
    vgl.setAlphaBlend();
    vgl.enableTexture( false );
    //vgl.enableLighting( false );
    
//    addSequencerWave = true;
//    if( addSequencerWave )
    {
      float freq = .1;//radians( time*.52 ) * .02; //wave.frequency() * 0.25) * 2;
      for( int i=0; i<ribbons.size(); i++ )
      {
        RibbonTactu r = (RibbonTactu)ribbons.get( i );
        
        // Change width of tail
        r._tailWidth = 12;   
        //r._colour.set( 0, 0, 0, 1 );
  
        //float rr = r._head.x*r._head.x + r._head.y*r._head.y;
        //r._head.y -= 1236*rr*exp(-10.0*rr);
        //if( i == 0 )  println( r._head.y );
        //r.addHead( freq*cos(i+time*1.06)*16, 0, freq*sin(i+time*.4)*16 );
        
        float angle = -(i*2*PI/(float)ribbons.size());
        r.addHead( freq*cos(-angle)*16, ((groundLevel-r._head.y)+r._tailWidth)*0.025, freq*sin(-angle)*16 );
    
        r.update( time );
        r.draw( time );
      //if( r.isDead() )
        //r.reset( new Vector3(0, -90, 0), random(50, 500) );
      }
      for( int i=0; i<ribbons.size(); i++ )
      {
        /*vgl.gl().glBlendFunc( GL.GL_DST_COLOR, GL.GL_ZERO );
        if( psOn ) ((RibbonTactu)ribbons.get(psIdx)).renderTail( time-psTime );
        if( vOn ) ((RibbonTactu)ribbons.get(vIdx)).renderTail( time-vTime );
        if( nnyOn ) ((RibbonTactu)ribbons.get(nnyIdx)).renderTail( time-nnyTime );
        if( kazOn ) ((RibbonTactu)ribbons.get(kazIdx)).renderTail( time-kazTime );*/
        
        vgl.setAlphaBlend();
        RibbonTactu r = (RibbonTactu)ribbons.get( i );
        r.drawCylinderRibbon( time );
      }
    }
  }


  // Draw Sphere
  vgl.enableLighting( true );
  vgl.setDepthWrite( true );
  vgl.setDepthMask( true ); 
  vgl.enableTexture( false );

  vgl.fill( 0, 0, 0.1, 1 );
  vgl.pushMatrix();
  vgl.translate( 0, groundLevel+160, 0 );
  vgl.rotateY( time*10 );

  // get world matrix
  vgl.pushMatrix();
  vgl.identity();
  vgl.translate( 0, groundLevel+160, 0 );  
  vgl.rotateY( time*10 );
  vitamin.math.Matrix localMatrix = vgl.getTransposeViewMatrix();
  vgl.popMatrix();
  //Matrix localMatrix = new Matrix();
  //localMatrix.translate( 0, groundLevel+160, 0 );
  //localMatrix.rotateY( time*10 );

  vgl.setShader( diffspecID );
  vgl.setParameter3f( "cameraPos", this.eye );
  vgl.setParameter4f( "lightPos", lightPos );
  vgl.setParameter4f( "fogColor", fogColor );
  vgl.setParameter1f( "fogDensity", 0.00008f );
  vgl.setParameter1f( "kC", kC );
  vgl.setParameter1f( "kL", kL );
  vgl.setParameter1f( "kQ", kQ );
  vgl.setParameter1f( "specularLevel", 8 );
  vgl.setParameter1f( "useSpecular", 1 );
  vgl.setMatrixParameterSemantic( "WORLDVIEWPROJECTION", ShaderSemantics.WORLDVIEWPROJECTION_MATRIX, ShaderSemantics.IDENTITY_MATRIX );
  vgl.setMatrixParameterSemantic( "MODELVIEW", ShaderSemantics.VIEW_MATRIX, ShaderSemantics.IDENTITY_MATRIX );
  vgl.setMatrixParameterSemantic( "VIEWINVERSE", ShaderSemantics.VIEW_MATRIX, ShaderSemantics.INVERSE_MATRIX );
  vgl.setMatrixParameterSemantic( "VIEWINVERSETRANSPOSE", ShaderSemantics.VIEW_MATRIX, ShaderSemantics.INVERSE_TRANSPOSE_MATRIX );
  vgl.setMatrixParameterSemantic( "WORLD", vitamin.math.Matrix.transpose(localMatrix).getArray() );
  vgl.setMatrixParameterSemantic( "WORLDTOCAMERA", cameraMatrix.getArray() );
  CGpass pass = ((ShaderCGFX)vgl.getActiveShader()).getTechniqueFirstPass( "Technique_DiffuseSpecularNoTextureWrap" );

/*
  //diffspec.setTextureParameter( "ColorSampler", chapaNNY.getId() );
  diffspec.setParameter3f( "cameraPos", this.eye );
  diffspec.setParameter4f( "lightPos", this.lightPos.x, this.lightPos.y, this.lightPos.z, 1.0 );
  diffspec.setParameter4f( "fogColor", _fogColor );
  diffspec.setParameter1f( "fogDensity", 0.00008f );
  diffspec.setParameter1f( "kC", kC );
  diffspec.setParameter1f( "kL", kL );
  diffspec.setParameter1f( "kQ", kQ );
  diffspec.setParameter1f( "specularLevel", 8.0f );
  diffspec.setParameter1f( "useSpecular", 1 );
  diffspec.setParameter4x4fBySemantic( "WorldViewProjection", CgGL.CG_GL_MODELVIEW_PROJECTION_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
  diffspec.setParameter4x4f( "view", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
  diffspec.setParameter4x4f( "viewI", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_INVERSE );
  diffspec.setParameter4x4f( "viewIT", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_INVERSE_TRANSPOSE );
  diffspec.setParameter4x4f( "WorldXf", vitamin.math.Matrix.transpose(localMatrix) );
  diffspec.setParameter4x4f( "W2C", cameraMatrix );
  CGpass pass;
  pass = diffspec.getTechniqueFirstPass( "Technique_DiffuseSpecularNoTextureWrap" );
  //pass = diffspec.getTechniqueFirstPass( "Technique_DiffuseSpecularNoTexture" );
*/
  CgGL.cgSetPassState( pass );

//  aquario.drawSphereTextured( 0, 0, 0 );
  aquario.drawSphere( 0, 0, 0, 1 );

  CgGL.cgResetPassState( pass );
  vgl.disableShader();

  vgl.popMatrix();



  if( psOn )
  {
    //
    // Draw the growing vines
    //
    cylsCount = (int)(time*0.5) - 2;
    
    //dirty hack shit q o vic nao gosta!!
    if (cylsCount < 0 ) cylsCount = 0;
    
    if( cylsCount >= numCyls ) cylsCount = numCyls;
    
//    addNoiseSignal = true;
    noiseAmp = random(0.0, 0.9);
//    if( addNoiseSignal )
    {
      //float growSpeed = wave.frequency() * 0.002;
      float growSpeed = (time-noiseTimeStart) * 6 * noiseAmp; //wave.frequency() * 0.0035;
      float dispSpeed = (time-noiseTimeStart) * 6 * noiseAmp * 10; //wave.frequency() * 0.002;
  /*
      //vgl.enableLighting( false );
  //  CGpass pass = diffspec.getTechniqueFirstPass( "Technique_DiffuseSpecular" );
      pass = diffspec.getTechniqueFirstPass( "Technique_DiffuseSpecularNoTexture" );
      CgGL.cgSetPassState( pass );
  
      //diffspec.setTextureParameter( "ColorSampler", chapaNNY.getId() );
      diffspec.setParameter3f( "cameraPos", this.eye );
      diffspec.setParameter4f( "lightPos", this.lightPos.x, this.lightPos.y, this.lightPos.z, 1.0 );
      diffspec.setParameter4f( "fogColor", fogColor );
      diffspec.setParameter1f( "fogDensity", 0.00008f );
      diffspec.setParameter1f( "kC", kC );
      diffspec.setParameter1f( "kL", kL );
      diffspec.setParameter1f( "kQ", kQ );
      diffspec.setParameter1f( "specularLevel", 8.0f );
      diffspec.setParameter1f( "useSpecular", 1 );
    
      diffspec.setParameter4x4fBySemantic( "WorldViewProjection", CgGL.CG_GL_MODELVIEW_PROJECTION_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
      diffspec.setParameter4x4f( "view", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_IDENTITY );
      diffspec.setParameter4x4f( "viewI", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_INVERSE );
      diffspec.setParameter4x4f( "viewIT", CgGL.CG_GL_MODELVIEW_MATRIX, CgGL.CG_GL_MATRIX_INVERSE_TRANSPOSE );
      diffspec.setParameter4x4f( "WorldXf", Matrix.transpose(localMatrix) );
      diffspec.setParameter4x4f( "W2C", cameraMatrix );
      */
      for( int i=0; i<cylsCount; i++ )
      {
        cyls[i]._colour.set( 0, 0, 0.0, 1 );
        cyls[i].update( (time-noiseTimeStart) );
        cyls[i].draw( (time-noiseTimeStart) );
        cyls[i]._dispoffset = 1 + dispSpeed;
        cyls[i]._displaces  = 0;
        cyls[i]._dispscale  = 19;//+abs(cos(wave.frequency())*.2);
      }
  
      //CgGL.cgResetPassState( pass );
  
      vgl.enableLighting( true );
    }
  }
  
/*  
    //
    // update lfo's
    //
    lfo1 = ((sin(time*12)+1.0)*0.5)+0.25;
    lfo2 = ((sin(90+time*12)+1.0)*0.5)+0.5;

    if( addNoiseSignal )
    {
      if( random(500) < 50 )
      {
        if( cylsCount < numCyls-1 )
          cylsCount ++;
        noiseAmp = 1.0;
      }
      else  noiseAmp = 0.0;

      pnoise.setAmp( noiseAmp );
    }
    
    //waveCyl.setFreq( 32 );
  
    lfo3 = sin( random(100,500) );
    waveCyl2.setFreq( lfo3 );*/
  }


/*
    void renderMainTrail( int len, Vector3[] ribloc, float ribWidth )
    {
      float per;
      float xp, yp, zp;
      float xOff, yOff, zOff;
    
      vgl.gl().glDisable( GL.GL_CULL_FACE );
    
      //  gl.enableLighting( true );
      vgl.setDepthWrite( true );
      vgl.setDepthMask( false );
      vgl.setAlphaBlend();
      //  gl.setAdditiveBlend();
      //  gl._gl.glBlendFunc( GL.GL_DST_COLOR, GL.GL_ZERO );
    
      ///////////////////////////////////////
      ///////////////////////////////////////
    //  ribbonTexture.enable();
    //  ribbonBlack.enable();
      vgl.gl().glBegin( GL.GL_QUAD_STRIP );
      for ( int i=0; i<len-1; i++ )
    //  int hlen = (int)((len-1)*0.5);
    //  for ( int ii=-hlen; ii<hlen; ii++ )
      {
    //    int i = ii+hlen;
    //    per           = 1.0 - (((float)(abs(ii))/(float)(hlen)));    
    
        per           = (((float)i/(float)(len)));
    //    per           = 1.0-(((float)i/(float)(len-1)));
    
    //    per *= 10.0;
        if( per > 1.0 ) per = 1.0;
        if( per < 0.0 ) per = 0.0;
    
        xp            = ribloc[i].x;
        yp            = ribloc[i].y;
        zp            = ribloc[i].z;
    
        if( i < len )
        {
          //Vector3 perp0 = Vector3.sub( ploc[j][i], ploc[j][i+1] );
          Vector3 dir = Vector3.sub( ribloc[i+1], ribloc[i] );
          dir.normalize();
          Vector3 V = dir.cross( new Vector3( 0, 0, 1 ) );
    //      Vector3 V = dir.cross( new Vector3( 0, 1, 0 ) );
          V.normalize();
          Vector3 N = dir.cross( V );
          N.normalize();
          V = N.cross( dir );
          //V = dir.cross( N );
          V.normalize();
    
          xOff        = V.x * ribWidth * per * 1.5;
          yOff        = V.y * ribWidth * per * 1.5;
          zOff        = V.z * ribWidth * per * 1.5;
    
    //      vgl.gl().glColor4f( 1-per, 1-per, 1-per, per );
          vgl.gl().glColor4f( 0, 0, 0, 1 );
    //      vgl.gl().glColor4f( 1, 1, 1, 1 );
    //      vgl.gl().glColor4f( per, per, per, per );
    //      vgl.gl().glColor4f( per, per*.5, 1.5 - per, per);
    
    //      gl._gl.glNormal3f( N.x, N.y, N.z );
    //      gl._gl.glTexCoord2f( 0, 0 );
          vgl.gl().glVertex3f( xp - xOff, yp - yOff, 0 );//zp - zOff );
    //      gl._gl.glNormal3f( N.x, N.y, N.z );
    //      gl._gl.glTexCoord2f( 1, 1 );
          vgl.gl().glVertex3f( xp + xOff, yp + yOff, 0 );//zp + zOff );
        }
      }   
    }
*/

}
/*
  Hack up texture class to load and create opengl textures..  decrepated!
  use vitamin texture loading 
*/  

import java.nio.*;
import com.sun.opengl.util.texture.TextureIO;   
import com.sun.opengl.util.texture.Texture;   

class XTexture
{
  XTexture()
  {
    _tex = null;
    _texType = GL.GL_TEXTURE_2D;
  }

  XTexture(int texType )
  {
    _tex = null;
//    _buffer = null;
//    _img = null;
    
    isLoaded = false;
    
    _texType = texType;
  }

  XTexture( String fName )
  {
    fileName = fName;
    _tex = null;
    _buffer = null;
    _texType = GL.GL_TEXTURE_2D;
    load( fName );
  }

 XTexture( String fName, int texType )
  {
    fileName = fName;
    _tex = null;
    _buffer = null;
    _img = null;
    
    isLoaded = false;
    
    _texType = texType;
    
    loadPImage( fName );
  }
  
  void bind()
  {
    if( _texType == GL.GL_TEXTURE_2D )
    {
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _id );
    }
    else
    {
      vgl.gl().glBindTexture( GL.GL_TEXTURE_RECTANGLE_ARB, _id );
    }
  }

  void unbind()
  {
    if( _texType == GL.GL_TEXTURE_2D )
    {
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, 0 );
    }
    else
    {
      vgl.gl().glBindTexture( GL.GL_TEXTURE_RECTANGLE_ARB, 0 );
    }
  }

  void enable()
  {
    if( _texType == GL.GL_TEXTURE_2D )
    {
      vgl.gl().glEnable( GL.GL_TEXTURE_2D );
    }
    else
    {
      vgl.gl().glEnable( GL.GL_TEXTURE_RECTANGLE_ARB );
    }    

    bind();
  }

  void disable()
  {
    if( _texType == GL.GL_TEXTURE_2D )
    {
      vgl.gl().glDisable( GL.GL_TEXTURE_2D );
    }
    else
    {
      vgl.gl().glDisable( GL.GL_TEXTURE_RECTANGLE_ARB );
    }    

    unbind();
  }

  void setWrap()
  {
    if( _tex != null )
    {
      _tex.setTexParameteri( GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT );
      _tex.setTexParameteri( GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT );
    }
    else
    {
      vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT );
      vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT );
    }
  }

  void setClamp()
  {
    if( _tex != null )
    {
      _tex.setTexParameteri( GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP );
      _tex.setTexParameteri( GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP );
    }
    else
    {
      vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP );
      vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP );
    }
  }

  void setClampToEdge()
  {
    if( _tex != null )
    {
      _tex.setTexParameterf( GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE );
      _tex.setTexParameterf( GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE );
    }
    else
    {
      vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE );
      vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE );
    }
  }

  void createGL( int w, int h )
  {
     _width = w;
     _height = h;
     
     int[] id = { 0 };

    // Creating texture.
    vgl.gl().glGenTextures( 1, id, 0 );
    _id = id[0];
      println( "texture created: " + _id );
    
    vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _id );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR );//_MIPMAP_LINEAR );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR );

//    vgl.gl().glTexImage2D( GL.GL_TEXTURE_2D, 0, GL.GL_R16G16, _width, _height, 0, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, null );
    vgl.gl().glTexImage2D( GL.GL_TEXTURE_2D, 0, GL.GL_RGBA, _width, _height, 0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE, null );
  }
  

  void createGLDepth( int w, int h )
  {
     _width = w;
     _height = h;
     
     int[] id = { 0 };

    // Creating texture.
    vgl.gl().glGenTextures( 1, id, 0 );
    _id = id[0];
      println( "texture created: " + _id );
    
    vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _id );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_NEAREST );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_NEAREST );

    // Three next lines are necessary if we wan to use the convenient shadow2DProj function in the shader.
    // Otherwise we have to rely on texture2DProj
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_COMPARE_MODE, GL.GL_COMPARE_R_TO_TEXTURE );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_COMPARE_FUNC, GL.GL_LEQUAL );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_DEPTH_TEXTURE_MODE, GL.GL_LUMINANCE );

//    vgl.gl().glTexImage2D( GL.GL_TEXTURE_2D, 0, GL.GL_RGBA, _width, _height, 0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE, null );
    vgl.gl().glTexImage2D( GL.GL_TEXTURE_2D, 0, GL.GL_DEPTH_COMPONENT32, _width, _height, 0, GL.GL_DEPTH_COMPONENT, GL.GL_FLOAT, null );

  }

  void create( int w, int h )
  {
      _width = w;
      _height = h;
      _buffer = new BufferedImage( w, h, BufferedImage.TYPE_INT_ARGB );//_PRE );
      _tex = TextureIO.newTexture( _buffer, false );
      _id = _tex.getTextureObject();
      println( "texture created: " + _id );

//      _tex.setTexParameteri( GL.GL_TEXTURE_WRAP_R, GL.GL_REPEAT );
      _tex.setTexParameterf( GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT );
      _tex.setTexParameterf( GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT );
      _tex.setTexParameterf( GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR );//_MIPMAP_LINEAR );
      _tex.setTexParameterf( GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR );//_MIPMAP_LINEAR );
  }

  void load( String fName )//, boolean mipmap )  
  {
    //Texture tex = null;
    fileName = fName;
    try
    {
      _tex = TextureIO.newTexture( new File(dataPath(fileName)), true );  //mipmap );
      _id = _tex.getTextureObject();

      //_tex.setTexParameterf( GL.GL_TEXTURE_WRAP_R, GL.GL_REPEAT );     
      _tex.setTexParameterf( GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT ); 
      _tex.setTexParameterf( GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT );  
      //tex.setTexParameteri( GL.GL_TEXTURE_WRAP_R, GL.GL_CLAMP );     
      //tex.setTexParameteri( GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP ); 
      //tex.setTexParameteri( GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP );  
      _tex.setTexParameterf( GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR );//_MIPMAP_LINEAR );
      _tex.setTexParameterf( GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR_MIPMAP_LINEAR );
    }
    catch( Exception e )
    {
      println("texture error: " + e);
    }
    
    //_id = _tex.getTarget();
    //println( "Texture: '" + fileName + "' with id: '" + _id + "'" );
    //println( "Estimated Memory Size: " + _tex.getEstimatedMemorySize() / 1024 + " KBytes" );

    //return tex;
  }

void loadPImage( String fName )
  {
    fileName = fName;

    PImage _img = loadImage( fName );
    if( _img == null )
    {
      println( "couldnt load texture: " + fileName );
      return;
    }

    _width = _img.width;
    _height = _img.height;

    int[] texId = new int[1];
    vgl.gl().glGenTextures( 1, texId, 0 );
    _id = texId[0];

    if( _texType == GL.GL_TEXTURE_2D )
    {    
      //println( "texture is 2D" );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _id );
      vgl.gl().glPixelStorei( GL.GL_UNPACK_ALIGNMENT, 1 );
      vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_GENERATE_MIPMAP, GL.GL_TRUE );
      vgl.gl().glTexParameterf( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP );
      vgl.gl().glTexParameterf( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP );
      vgl.gl().glTexParameterf( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR_MIPMAP_LINEAR );
      vgl.gl().glTexParameterf( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR );//_MIPMAP_LINEAR );
      vgl.gl().glTexImage2D( GL.GL_TEXTURE_2D, 0, 4, _width, _height, 0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE, IntBuffer.wrap(_img.pixels) ); 
      //vgl.glu().gluBuild2DMipmaps( GL.GL_TEXTURE_2D, 3, _width, _height, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE, IntBuffer.wrap(_img.pixels) ); 
    }
    else if( _texType == GL.GL_TEXTURE_RECTANGLE_ARB )
    {
      //println( "texture is RECT" );
      vgl.gl().glBindTexture( GL.GL_TEXTURE_RECTANGLE_ARB, _id );
//      vgl.gl().glPixelStorei( GL.GL_UNPACK_ALIGNMENT, 1 );
      vgl.gl().glTexParameterf( GL.GL_TEXTURE_RECTANGLE_ARB, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE ); 
      vgl.gl().glTexParameterf( GL.GL_TEXTURE_RECTANGLE_ARB, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE );  
      vgl.gl().glTexParameterf( GL.GL_TEXTURE_RECTANGLE_ARB, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR );
      vgl.gl().glTexParameterf( GL.GL_TEXTURE_RECTANGLE_ARB, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR );
      vgl.gl().glTexImage2D( GL.GL_TEXTURE_RECTANGLE_ARB, 0, 3, _width, _height, 0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE, IntBuffer.wrap(_img.pixels) ); 
    }

    //_img = null;

    //println("loading texture: " + fileName + " with id= " + _id );
  }

  
void loadPImageFromMemory( PImage img )
  {
    fileName = "__";

    _width = img.width;
    _height = img.height;

    int[] texId = new int[1];

    //println( "gen tex" );
    vgl.gl().glGenTextures( 1, texId, 0 );
    _id = texId[0];
    vgl.gl().glBindTexture( GL.GL_TEXTURE_2D, _id );
    vgl.gl().glPixelStorei( GL.GL_UNPACK_ALIGNMENT, 1 );
//    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_GENERATE_MIPMAP, GL.GL_TRUE );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR );//_MIPMAP_LINEAR );
    vgl.gl().glTexParameteri( GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR );
    vgl.gl().glTexImage2D( GL.GL_TEXTURE_2D, 0, 4, _width, _height, 0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE, IntBuffer.wrap(img.pixels) ); 
//    vgl.glu().gluBuild2DMipmaps( GL.GL_TEXTURE_2D, 4, img.width, img.height, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, IntBuffer.wrap(img.pixels) ); 

    //_img = null;

    //isLoaded = true;
    //println("loading texture: " + fileName + " with id= " + _id );
  }


  int getTarget()
  {
    return _tex.getTarget();
  }
  
  int getId()
  {
    return _id;
  }
  
  int getWidth()
  {
    return _width;
  }
  
  int getHeight()
  {
    return _height;
  }
  

	String fileName;
	Texture _tex;
        int    _id;
        
        int _texType;
        PImage _img;
  
        int _width, _height;
        
        BufferedImage  _buffer;
        boolean isLoaded;
};
import javax.media.opengl.*; 
import java.nio.*; 

void glReverseCamera( Vector3 eye, Vector3 center )
{
  float deltaX   = eye.x - center.x; 
  float deltaY   = eye.y - center.y; 
  float deltaZ   = eye.z - center.z; 

  float angleZ   = atan2( deltaY, deltaX ); 
  float hyp      = sqrt( sq(deltaX) + sq(deltaY) ); 
  float angleY   = atan2( hyp, deltaZ ); 

  vgl.gl().glRotatef( degrees(angleZ)+90, 0, 0, 1.0 );
  vgl.gl().glRotatef( degrees(angleY), 0, 1.0, 0 );
}

void glReverseCamera2( Vector3 eye, Vector3 center )
{
  float deltaX   = eye.x - center.x; 
  float deltaY   = eye.y - center.y; 
  float deltaZ   = eye.z - center.z; 

  float angleZ   = atan2( deltaY, deltaX ); 
  float hyp      = sqrt( sq(deltaX) + sq(deltaY) ); 
  float angleY   = atan2( hyp, deltaZ ); 

  vgl.gl().glRotatef( degrees(angleZ), 0, 0, 1.0 );
//  vgl.gl().glRotatef( degrees(angleY), 0, 1.0, 0 );
}

void glReverseCameraJelly( Vector3 eye, Vector3 center )
{
  float deltaX   = eye.x - center.x; 
  float deltaY   = eye.y - center.y; 
  float deltaZ   = eye.z - center.z; 

  float angleZ   = atan2( deltaY, deltaX ); 
  //float hyp      = sqrt( sq(deltaX) + sq(deltaY) ); 
  //float angleY   = atan2( hyp, deltaZ );
  
    vgl.gl().glRotatef( degrees(angleZ), 0, 0, 1.0 );
//  vgl.gl().glRotatef( degrees(angleY), 0, 1.0, 0 );
}


/*
void quad( GL gl, float s, float z, float a )
{  
  gl.glBegin( GL.GL_QUADS );
  gl.glNormal3f( 0.0f, 0.0f, 1.0f );
  gl.glColor4f( 1, 1, 1, a );
  gl.glTexCoord2f(0, 0);
  gl.glVertex3f( -1*s,  1*s, z );
  gl.glTexCoord2f(1, 0);
  gl.glVertex3f(  1*s,  1*s, z );
  gl.glTexCoord2f(1, 1);
  gl.glVertex3f(  1*s, -1*s, z );
  gl.glTexCoord2f(0, 1);
  gl.glVertex3f( -1*s, -1*s, z );
  gl.glEnd();   
}

void quad( GL gl, float s, float z, float ts, float a )
{  
  gl.glBegin( GL.GL_QUADS );
  gl.glNormal3f( 0.0f, 0.0f, 1.0f );
  gl.glColor4f( 1, 1, 1, a );
  gl.glTexCoord2f(0*ts, 0*ts);
  gl.glVertex3f( -1*s,  1*s, z );
  gl.glTexCoord2f(1*ts, 0*ts);
  gl.glVertex3f(  1*s,  1*s, z );
  gl.glTexCoord2f(1*ts, 1*ts);
  gl.glVertex3f(  1*s, -1*s, z );
  gl.glTexCoord2f(0*ts, 1*ts);
  gl.glVertex3f( -1*s, -1*s, z );
  gl.glEnd();   
}


void rect( GL gl, float sx, float sy, float z )
{  
  gl.glBegin( GL.GL_QUADS );
  gl.glNormal3f( 0.0f, 0.0f, 1.0f ); 
  gl.glColor4f( 1, 1, 1, 1 );
  gl.glTexCoord2f(0, 0); 
  gl.glVertex3f( -1*sx, -1*sy, z );
  gl.glTexCoord2f(1, 0); 
  gl.glVertex3f(  1*sx, -1*sy, z );
  gl.glTexCoord2f(1, 1); 
  gl.glVertex3f(  1*sx,  1*sy, z );
  gl.glTexCoord2f(0, 1); 
  gl.glVertex3f( -1*sx,  1*sy, z );
  gl.glEnd();   
}
*/

void box( float w, float h, float d )
{
   Vector3 pmin = new Vector3( -w,-h,-d );
   Vector3 pmax = new Vector3(  w, h, d );

   //xvgl.gl().glColor4f(1.0, 1.0, 1.0, 0.75 );
   
   vgl.gl().glBegin( GL.GL_LINE_STRIP );
   vgl.gl().glVertex3f( pmin.x, pmin.y, pmin.z );
   vgl.gl().glVertex3f( pmax.x, pmin.y, pmin.z );
   vgl.gl().glVertex3f( pmax.x, pmin.y, pmax.z );
   vgl.gl().glVertex3f( pmin.x, pmin.y, pmax.z );
   vgl.gl().glVertex3f( pmin.x, pmin.y, pmin.z );
   vgl.gl().glVertex3f( pmin.x, pmax.y, pmin.z );
   vgl.gl().glVertex3f( pmax.x, pmax.y, pmin.z );
   vgl.gl().glVertex3f( pmax.x, pmax.y, pmax.z );
   vgl.gl().glVertex3f( pmin.x, pmax.y, pmax.z );
   vgl.gl().glVertex3f( pmin.x, pmax.y, pmin.z );
   vgl.gl().glEnd();
   vgl.gl().glBegin( GL.GL_LINES);
   vgl.gl().glVertex3f(pmax.x,pmin.y,pmin.z); vgl.gl().glVertex3f(pmax.x,pmax.y,pmin.z);
   vgl.gl().glEnd();
   vgl.gl().glBegin( GL.GL_LINES);
   vgl.gl().glVertex3f(pmax.x,pmin.y,pmax.z); vgl.gl().glVertex3f(pmax.x,pmax.y,pmax.z);
   vgl.gl().glEnd();
   vgl.gl().glBegin( GL.GL_LINES);
   vgl.gl().glVertex3f(pmin.x,pmin.y,pmax.z); vgl.gl().glVertex3f(pmin.x,pmax.y,pmax.z);
   vgl.gl().glEnd();
}


int sphereStacks = 120;
int sphereSlices = 120;
Vector3[] sphereSurface;
int[] sphereIndices;
Vector3[] sphereSurfaceUV;
Vector3[] sphereSurfaceNormal;
//Vector3[] sphereSurface2;
//Vector3[] sphereSurfaceNormal2;
void buildSphere( int stacks, int slices, float rad )
{
  Vector3 c = new Vector3( 0, 0, 0 );

  sphereStacks = stacks;
  sphereSlices = slices;
  
  int i, j;
  float radius = rad;
   
  Vector3 e = new Vector3();
  Vector3 p = new Vector3();

  int wid = slices;
  int len = (stacks+1)*(slices);
  sphereSurface = new Vector3[len];
  sphereSurfaceNormal = new Vector3[len];
  sphereSurfaceUV = new Vector3[len];
  
  for (j=0;j<len;j++)
  {
    sphereSurface[j] = new Vector3();
    sphereSurfaceNormal[j] = new Vector3();
    sphereSurfaceUV[j] = new Vector3();
  }


 //
 // compute sphere surface points
 //
 for( j=0; j<stacks+1; j++ )
 {
      for( i=0; i<slices; i++ )
      {
        float theta = j * PI / (stacks);
	float phi = i * 2 * PI / (slices);
	float sinTheta = sin(theta);
	float sinPhi = sin(phi);
	float cosTheta = cos(theta);
	float cosPhi = cos(phi);

         float tmpi = (1.0 - ((i) / float(slices-1)));
         tmpi *= 3.0;
         float tmpj = ((j) / float(stacks));

         e.x = cosPhi * sinTheta;
         e.y = cosTheta;
         e.z = sinPhi * sinTheta;
         p.x = c.x + radius * e.x;
         p.y = c.y + radius * e.y;
         p.z = c.z + radius * e.z;

        int idx = j * wid + i;
        sphereSurface[idx].x = p.x;
        sphereSurface[idx].y = p.y;
        sphereSurface[idx].z = p.z;
        sphereSurfaceNormal[idx].x = e.x;
        sphereSurfaceNormal[idx].y = e.y;
        sphereSurfaceNormal[idx].z = e.z;
        sphereSurfaceUV[idx].x = tmpi; //4*(i/(float)n);
        sphereSurfaceUV[idx].y = tmpj; //4*2*((j+1)/(float)n);
      }
  }

  for( i=0; i<stacks+1; i++ )
  {
    sphereSurface[(i)*slices+slices-1].x = sphereSurface[(i)*slices+0].x;
    sphereSurface[(i)*slices+slices-1].y = sphereSurface[(i)*slices+0].y;
    sphereSurface[(i)*slices+slices-1].z = sphereSurface[(i)*slices+0].z;
    sphereSurfaceNormal[(i)*slices+slices-1].x = sphereSurfaceNormal[(i)*slices+0].x;
    sphereSurfaceNormal[(i)*slices+slices-1].y = sphereSurfaceNormal[(i)*slices+0].y;
    sphereSurfaceNormal[(i)*slices+slices-1].z = sphereSurfaceNormal[(i)*slices+0].z;
    //sphereSurfaceUV[(i)*slices+slices-1].x = sphereSurfaceUV[(i)*slices+0].x;
    //sphereSurfaceUV[(i)*slices+slices-1].y = sphereSurfaceUV[(i)*slices+0].y;
    //sphereSurfaceUV[(i)*slices+slices-1].z = sphereSurfaceUV[(i)*slices+0].z;
  }
  
  sphereIndices = new int[len*2];
  int index = 0;
  for( j=0; j<stacks; j++ )
  {
    for( i=0; i<slices; i++ )
    {
      sphereIndices[index+0] = j*slices + (i%slices);
      sphereIndices[index+0] = (j+1)*slices + (i%slices);
    }
  }
}


void drawSphere( float x, float y, float z, float r )
{
  int idx = 0;
  int idx2 = 0;
  for( int j=0; j<sphereStacks; j++ )
  {
    idx = j * (sphereSlices);
    idx2 = (j+1) * (sphereSlices);

    vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
    vgl.gl().glColor4f( vgl._r, vgl._g, vgl._b, vgl._a );
    for( int i=0; i<sphereSlices; i++ )
    {
      float x1 = sphereSurface[idx+i].x * r;
      float y1 = sphereSurface[idx+i].y * r;
      float z1 = sphereSurface[idx+i].z * r;
      float x2 = sphereSurface[idx2+i].x * r;
      float y2 = sphereSurface[idx2+i].y * r;
      float z2 = sphereSurface[idx2+i].z * r;

      float nx1 = sphereSurfaceNormal[idx+i].x;
      float ny1 = sphereSurfaceNormal[idx+i].y;
      float nz1 = sphereSurfaceNormal[idx+i].z;
      float nx2 = sphereSurfaceNormal[idx2+i].x;
      float ny2 = sphereSurfaceNormal[idx2+i].y;
      float nz2 = sphereSurfaceNormal[idx2+i].z;

      //      vgl.gl().glColor4f( x1*0.01, y1*0.01, z1*0.01, 1 ); //0.1*abs(sin(i+time*3)) );
//      vgl.gl().glColor4f( z2*0.01, z2*0.01, z2*0.01, freq2*100 ); //0.1*abs(sin(i+time*3)) );
      vgl.gl().glNormal3f( nx1, ny1, nz1 );
      vgl.gl().glVertex3f( x1, y1, z1 );

      //      vgl.gl().glColor4f( z2*0.01, z2*0.01, z2*0.01, 1 ); //0.1*abs(sin(i+time*3)) );
//      vgl.gl().glColor4f( x2*0.01, y2*0.01, z2*0.01, freq2*100 ); //0.1*abs(sin(i+time*3)) );
      vgl.gl().glNormal3f( nx2, ny2, nz2 );
      vgl.gl().glVertex3f( x2, y2, z2 );
    }
    vgl.gl().glEnd();
  }
}


void drawSphereTextured( float x, float y, float z )
{
  int idx = 0;
  int idx2 = 0;
  for( int j=0; j<sphereStacks; j++ )
  {
    idx = j * (sphereSlices);
    idx2 = (j+1) * (sphereSlices);

    vgl.gl().glBegin( GL.GL_TRIANGLE_STRIP );
    vgl.gl().glColor4f( vgl._r, vgl._g, vgl._b, vgl._a );
    for( int i=0; i<sphereSlices; i++ )
    {
      float x1 = sphereSurface[idx+i].x + x;
      float y1 = sphereSurface[idx+i].y + y;
      float z1 = sphereSurface[idx+i].z + z;
      float x2 = sphereSurface[idx2+i].x + x;
      float y2 = sphereSurface[idx2+i].y + y;
      float z2 = sphereSurface[idx2+i].z + z;

      float nx1 = sphereSurfaceNormal[idx+i].x+x;
      float ny1 = sphereSurfaceNormal[idx+i].y+y;
      float nz1 = sphereSurfaceNormal[idx+i].z+z;
      float nx2 = sphereSurfaceNormal[idx2+i].x+x;
      float ny2 = sphereSurfaceNormal[idx2+i].y+y;
      float nz2 = sphereSurfaceNormal[idx2+i].z+z;

      //      vgl.gl().glColor4f( x1*0.01, y1*0.01, z1*0.01, 1 ); //0.1*abs(sin(i+time*3)) );
//      vgl.gl().glColor4f( z2*0.01, z2*0.01, z2*0.01, freq2*100 ); //0.1*abs(sin(i+time*3)) );
      vgl.gl().glColor4f( vgl._r, vgl._g, vgl._b, vgl._a );
      vgl.gl().glNormal3f( nx1, ny1, nz1 );
      vgl.gl().glTexCoord2f( sphereSurfaceUV[idx+i].x, sphereSurfaceUV[idx+i].y );
      vgl.gl().glVertex3f( x1, y1, z1 );

      //      vgl.gl().glColor4f( z2*0.01, z2*0.01, z2*0.01, 1 ); //0.1*abs(sin(i+time*3)) );
//      vgl.gl().glColor4f( x2*0.01, y2*0.01, z2*0.01, freq2*100 ); //0.1*abs(sin(i+time*3)) );
      vgl.gl().glColor4f( vgl._r, vgl._g, vgl._b, vgl._a );
      vgl.gl().glNormal3f( nx2, ny2, nz2 );
      vgl.gl().glTexCoord2f( sphereSurfaceUV[idx2+i].x, sphereSurfaceUV[idx2+i].y );
      vgl.gl().glVertex3f( x2, y2, z2 );
    }
    vgl.gl().glEnd();
  }
}


/*void buildSphere( float rad )
{
  int i, j;
  int n = sphere_detail;
  float in = 1.0f / (float)n; 
  double t1, t2, t3;
  float r = rad;
   
  float PI = 3.141592653589793238462643;
  float PID2 = 1.570796326794896619231322;
   
  Vector3 e = new Vector3();
  Vector3 p = new Vector3();
  Vector3 c = new Vector3();

  int wid = n;
  int len = (n/2)*(n+1)*2;
  sphereSurface = new Vector3[len];
  sphereSurfaceNormal = new Vector3[len];
  sphereSurfaceUV = new Vector3[len];
  for (j=0;j<len;j++)
  {
    sphereSurface[j] = new Vector3();
    sphereSurfaceNormal[j] = new Vector3();
    sphereSurfaceUV[j] = new Vector3();
  }


  //
  // compute sphere surface points
  //
  for( j=0; j<n/2; j++ )
  {
//      t1 = -PID2 + j * PI * (in*0.5f); // / (n/2);
//      t2 = -PID2 + (j + 1) * PI * (in*0.5f); // / (n/2);
      t1 = j * 2 * PI / n - PID2;
      t2 = (j+1) * 2 * PI / n - PID2;

      for( i=0; i<n+1; i++ )
      {
         t3 = (i * 2 * PI) / n; //* in; // / n;

         float tmpi = (i) / float(n); //* in; // / n;
         float tmpj = (j) / float(n); //* in; // / n;
         float tmpj1 = (j+1) / float(n); //* in; // / n;
         println( tmpj );

         e.x = (float)Math.cos(t1) * (float)Math.cos(t3);
         e.y = (float)Math.sin(t1);
         e.z = (float)Math.cos(t1) * (float)Math.sin(t3);
         p.x = c.x + r * e.x;
         p.y = c.y + r * e.y;
         p.z = c.z + r * e.z;
//         vgl.gl().glNormal3f(e.x,e.y,e.z);
//         vgl.gl().glTexCoord2f( 2*i*in, 2*j*in );
//         vgl.gl().glVertex3f(p.x,p.y,p.z);
        sphereSurface[j*wid+i].x = p.x;
        sphereSurface[j*wid+i].y = p.y;
        sphereSurface[j*wid+i].z = p.z;
        sphereSurfaceNormal[j*wid+i].x = e.x;
        sphereSurfaceNormal[j*wid+i].y = e.y;
        sphereSurfaceNormal[j*wid+i].z = e.z;
        sphereSurfaceUV[j*wid+i].x = 4*(i/(float)n);//*in;
        sphereSurfaceUV[j*wid+i].y = 4*2*((j+1)/(float)n);//*in;

         e.x = (float)Math.cos(t2) * (float)Math.cos(t3);
         e.y = (float)Math.sin(t2);
         e.z = (float)Math.cos(t2) * (float)Math.sin(t3);
         p.x = c.x + r * e.x;
         p.y = c.y + r * e.y;
         p.z = c.z + r * e.z;
//         vgl.gl().glNormal3f(e.x,e.y,e.z);
//         vgl.gl().glTexCoord2f( 2*i*in, 2*(j+1)*in );
//         vgl.gl().glVertex3f(p.x,p.y,p.z);
        sphereSurface[j*wid+i].x = p.x;
        sphereSurface[j*wid+i].y = p.y;
        sphereSurface[j*wid+i].z = p.z;
        sphereSurfaceNormal[j*wid+i].x = e.x;
        sphereSurfaceNormal[j*wid+i].y = e.y;
        sphereSurfaceNormal[j*wid+i].z = e.z;
        sphereSurfaceUV[j*wid+i].x = 4*(i/(float)n);//*in;
        sphereSurfaceUV[j*wid+i].y = 4*2*(j/(float)n);//*in;
      }
   }
}*/

void sphere( float rad, int detail, boolean doFill )
{
  int i, j;
  int n = detail;
  float in = 1.0f / (float)n; 
  double t1, t2, t3;
  float r = rad;
   
  float PI = 3.141592653589793238462643;
  float PID2 = 1.570796326794896619231322;
   
  Vector3 e = new Vector3();
  Vector3 p = new Vector3();
  Vector3 c = new Vector3();

  if( !doFill )
    vgl.gl().glPolygonMode( GL.GL_FRONT_AND_BACK, GL.GL_LINE );
    
  for (j=0;j<n*2;j++) 
  {
      t1 = -PID2 + j * PI * (in*0.5f); // / (n/2);
      t2 = -PID2 + (j + 1) * PI * (in*0.5f); // / (n/2);

      vgl.gl().glBegin( GL.GL_QUAD_STRIP);
      vgl.gl().glColor4f( vgl._r, vgl._g, vgl._b, vgl._a );
      for (i=0;i<=n;i++) 
      {
         t3 = i * PI *  2 * in; // / n;

         e.x = (float)Math.cos(t1) * (float)Math.cos(t3);
         e.y = (float)Math.sin(t1);
         e.z = (float)Math.cos(t1) * (float)Math.sin(t3);
         p.x = c.x + r * e.x;
         p.y = c.y + r * e.y;
         p.z = c.z + r * e.z;
         vgl.gl().glNormal3f(e.x,e.y,e.z);
         vgl.gl().glVertex3f(p.x,p.y,p.z);

         e.x = (float)Math.cos(t2) * (float)Math.cos(t3);
         e.y = (float)Math.sin(t2);
         e.z = (float)Math.cos(t2) * (float)Math.sin(t3);
         p.x = c.x + r * e.x;
         p.y = c.y + r * e.y;
         p.z = c.z + r * e.z;
         vgl.gl().glNormal3f(e.x,e.y,e.z);
         vgl.gl().glVertex3f(p.x,p.y,p.z);

      }
      vgl.gl().glEnd();
   }
  if( !doFill )
   vgl.gl().glPolygonMode( GL.GL_FRONT_AND_BACK, GL.GL_FILL );
}

void sphereTextured( float rad, int detail, boolean doFill )
{
  int i, j;
  int n = detail;
  float in = 1.0f / (float)n; 
  float jn = 1.0f / (float)n*2; 
  double t1, t2, t3;
  float r = rad;
   
  float PI = 3.141592653589793238462643;
  float PID2 = 1.570796326794896619231322;
   
  Vector3 e = new Vector3();
  Vector3 p = new Vector3();
  Vector3 c = new Vector3();

  for (j=0;j<n;j++) 
  {
      t1 = -PID2 + j * PI * (in*0.5f); // / (n/2);
      t2 = -PID2 + (j + 1) * PI * (jn*0.5f); // / (n/2);

      vgl.gl().glBegin( GL.GL_QUAD_STRIP);
      vgl.gl().glColor4f( vgl._r, vgl._g, vgl._b, vgl._a );
      for (i=0;i<=n;i++) 
      {
         t3 = i * PI *  2 * in; // / n;
         
         float u = i / (float)n;
         float v = (j / (float)n);
         float v2 = ((j+1) / (float)n);

         e.x = (float)Math.cos(t1) * (float)Math.cos(t3);
         e.y = (float)Math.sin(t1);
         e.z = (float)Math.cos(t1) * (float)Math.sin(t3);
         p.x = c.x + r * e.x;
         p.y = c.y + r * e.y;
         p.z = c.z + r * e.z;
         vgl.gl().glNormal3f(e.x, e.y, e.z);
         vgl.gl().glTexCoord2f( u, v );
         vgl.gl().glVertex3f(p.x, p.y, p.z);

         e.x = (float)Math.cos(t2) * (float)Math.cos(t3);
         e.y = (float)Math.sin(t2);
         e.z = (float)Math.cos(t2) * (float)Math.sin(t3);
         p.x = c.x + r * e.x;
         p.y = c.y + r * e.y;
         p.z = c.z + r * e.z;
         vgl.gl().glNormal3f(e.x, e.y, e.z);
         vgl.gl().glTexCoord2f( u, v2 );
         vgl.gl().glVertex3f(p.x, p.y, p.z);

      }
      vgl.gl().glEnd();
   }
}


void setupPointLight( Vector3 pos )
{
  GL g = vgl.gl();

  float[] light_emissive = { 0.0f, 0.0f, 0.0f, 1 };
  float[] light_ambient = { 0.01f, 0.01f, 0.01f, 0 };
  float[] light_diffuse = { 0.9f, 0.9f, 0.9f, 1.0f };
//  float[] light_diffuse = { 0.10f, 0.10f, 0.10f, 1.0f };
  float[] light_specular = { 1.0f, 1.0f, 1.0f, 1.0f };  
  float[] mat_shininess = { 64 };

  float[] light_position = { pos.x, pos.y, pos.z, 1.0f };  

  FloatBuffer fb;
  fb = FloatBuffer.wrap( light_ambient );
  g.glLightfv ( GL.GL_LIGHT1, GL.GL_AMBIENT, fb );
  fb = FloatBuffer.wrap( light_diffuse );
  g.glLightfv ( GL.GL_LIGHT1, GL.GL_DIFFUSE, fb );
  fb = FloatBuffer.wrap( light_specular );
  g.glLightfv ( GL.GL_LIGHT1, GL.GL_SPECULAR, fb );
//  fb = FloatBuffer.wrap( mat_shininess );
//  g.glLightfv( GL.GL_LIGHT1, GL.GL_SHININESS, fb );

  fb = FloatBuffer.wrap( light_position );
  g.glLightfv ( GL.GL_LIGHT1, GL.GL_POSITION, fb );  

  g.glEnable( GL.GL_LIGHT1 );
  g.glEnable( GL.GL_LIGHTING );

  g.glEnable( GL.GL_COLOR_MATERIAL );
  fb = FloatBuffer.wrap( light_emissive );
  g.glMaterialfv( GL.GL_FRONT_AND_BACK, GL.GL_AMBIENT, fb );
  fb = FloatBuffer.wrap( light_diffuse );
  g.glMaterialfv( GL.GL_FRONT_AND_BACK, GL.GL_DIFFUSE, fb );
  fb = FloatBuffer.wrap( mat_shininess );
  g.glMaterialfv( GL.GL_FRONT_AND_BACK, GL.GL_SHININESS, fb );
  fb = FloatBuffer.wrap( light_specular );
  g.glMaterialfv( GL.GL_FRONT_AND_BACK, GL.GL_SPECULAR, fb );
  
}  

int[][] field;
Signal s[];
int NUM = 8;
boolean change[][];

Recorder r;
boolean rec = false;

int tl = 1;

int cout = 0;

void setup(){

	size(720,480,P2D);

	frameRate(25);

	field = new int[width][height];
	for(int ii = 0; ii< field[0].length;ii++){
		for(int i = 0; i< field.length;i++){
			field[i][ii] = 5;//(int)random(8);
			//print(field[i][ii]);
		}
	
	}


	change = new boolean[width][height];
	for(int ii = 0; ii< change[0].length;ii++){
		for(int i = 0; i< change.length;i++){
			change[i][ii] = false;//(int)random(8);
			//print(field[i][ii]);
		}
	}

	s = new Signal[NUM];
	for(int i = 0;i<s.length;i++)
		s[i] = new Signal();


	if(rec){

		r = new Recorder("fields","timeLapse"+tl);
	}

	background(0);

}


void draw(){

	//background(0);

	//colorizeField();

	fade(5);


	change = new boolean[width][height];
	for(int ii = 0; ii< change[0].length;ii++){
		for(int i = 0; i< change.length;i++){
			change[i][ii] = false;//(int)random(8);
			//print(field[i][ii]);
		}
	}
	
	cout = s.length*2;

	for(int i = 0;i<s.length;i++)
		s[i].update();

	for(int i = 0;i<s.length;i++)
		s[i].draw();


	if(rec&&frameCount%tl==0){
		//filter(BLUR,1.5);
		r.add();
	}



}

void keyReleased(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}
}

void fade(int al){
	fill(0,al);
	noStroke();
	rect(0,0,width,height);
}

void colorizeField(){
	for(int yy = 0;yy<height;yy++){
		for(int xx = 0;xx<width;xx++){
			if(field[xx][yy]%2==0){
				stroke(255,15);
			}else{
				stroke(0,15);

			}
			//stroke(lerpColor(#ff0000,#00ff00,norm(field[xx][yy],0,7) ), 15);
			point(xx,yy);
		}
	}

}

class Signal{

	int x,y;
	int nx,ny;

	Signal(){
		x = (int)random(width);
		y = (int)random(height);

	}

	Signal(int _x,int _y){
		x = _x;
		y = _y;

	}

	void update(){

		if(field[x][y]==0){
			nx = (x + width - 1)%width;
			ny = (y + height - 1)%height;
		}else if(field[x][y]==1){
			nx = (x + width + 0)%width;
			ny = (y + height - 1)%height;
		}else if(field[x][y]==2){
			nx = (x + width + 1)%width;
			ny = (y + height - 1)%height;
		}else if(field[x][y]==3){
			nx = (x + width + 1)%width;
			ny = (y + height + 0)%height;
		}else if(field[x][y]==4){
			nx = (x + width + 1)%width;
			ny = (y + height + 1)%height;
		}else if(field[x][y]==5){
			nx = (x + width + 0)%width;
			ny = (y + height + 1)%height;
			
		}else if(field[x][y]==6){
			nx = (x + width - 1)%width;
			ny = (y + height + 1)%height;
		}else if(field[x][y]==7){
			nx = (x + width - 1)%width;
			ny = (y + height + 0)%height;
		}

		if(!change[x][y]){
			field[x][y] = (field[x][y]+2)%8;//(int)random(4);
			change[x][y] = true;
		}
		
		if(frameCount%10==0&&s.length<=cout&&random(100)<5){
			
			expa();
		}
	
		x = nx;
		y = ny;

	}

	void expa(){
		s = (Signal[])expand(s,s.length+1);
		s[s.length-1] = new Signal((x+1)%width,y);
	}

	void draw(){
		pushMatrix();
		translate(x,y);
		stroke(255,120);
		point(0,0);
		popMatrix();

	}

	int computeNextStep(){
		int tmp = 0;


		return tmp;
	}



}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
byte[] data;

import codeanticode.gsvideo.*;

GSPipeline pipe;
void setup(){
	size(300,300);
	
	data = new byte[width*height];
	
	
	println(data.length);
	
	pipe = new GSPipeline(this, "ximagesrc name=fifoWriter ! queue ! videorate ! video/x-raw-yuv,framerate=25/1 ! xvidenc ! queue ! avimux ! queue ! filesink location=/tmp/tmp");



}



void draw(){

	background(0);
	stroke(255);
	
	int y = (int)random(height);
	
	line(0,y,width,y);
	
	loadPixels();
	
	for(int i =0;i<pixels.length;i++)
	data[i] = (byte)pixels[i];
	
	saveBytes("/tmp/tmp",data);


}
// Basic example of GLTexture and GLTextureFilter.
// By Andres Colubri

//import processing.opengl.*;
import codeanticode.gltexture.*;

GLTextureFilter pulseEmboss;
GLTexture tex0, tex1;
PImage img;
PFont font;

void setup()
{
    size(640, 480, OPENGL);

    tex0 = new GLTexture(this, "glow.png");
    tex1 = new GLTexture(this, tex0.width, tex0.height);
    
    // A filter is defined in an xml file where the glsl shaders and grid are specified.
    pulseEmboss = new GLTextureFilter(this, "pulsatingEmboss.xml");
    
    img = new PImage();
    font = createFont("Pixel",8);
    textFont(font, 8); 
    
    // A GLTexture object can be created in different ways:
    /*
    //tex0 = new GLTexture(this);
    //tex0 = new GLTexture(this, 200, 200);
    //tex0.loadImage("milan_rubbish.jpg");
    */
    
    /*     
    // GLTexture is a descendant of PImage, so it has pixels that can be 
    // modified.
    tex0.init(100, 100);
    tex0.loadPixels();
    int k = 0;
    for (int j = 0; j < tex0.height; j++)
        for (int i = 0; i < tex0.width; i++)    
        {
           if (j < 50) tex0.pixels[k] = 0xffffffff;
           else tex0.pixels[k] = 0xffffff00;        
           k++;
        }
    // loadTexture function copies pixels to texture.
    tex0.loadTexture();
    */

    /*
    // Images can pe passed to a GLTexture object using a PImage as an intermediate container:
    img = loadImage("milan_rubbish.jpg"); 
    tex0.putImage(img);
    */
}

void draw()
{
   background(0); 

   image(tex0, 0, 0);
   text("source texture", 0, 220);
  
   // A filer is applied on a texture by passing it as a parameter,
   // together with the destination texture. Right after applying the
   // filter, only the texture data in tex1 contains the filtered image,
   // not the pixel nor the image.
   tex0.filter(pulseEmboss, tex1);
      
   // For fastest drawing, the texture can be rendered using  
   // the renderTexture function.
   tex1.renderTexture(mouseX, mouseY);
   fill(0);
   rect(mouseX, mouseY + 200, 200, 40);
   fill(255);
   text("filtered texture", mouseX, mouseY + 220);

   /*   
   // A PImage can be obtained from a GLTexture object.
   tex1.getImage(img);
   image(img, mouseX, mouseY);
   */

   /*
   // updateTexture() copies the texture to the pixels, and then
   // the pixels are updated, so the texture can be drawn as a regular
   // PImage object.
   tex1.updateTexture();
   tex1.updatePixels();
   image(tex1, mouseX, mouseY);
   */
}

Monster m[];
int num = 12;

void setup(){
	size(320,240,P2D);
	background(#61684f);
	m = new Monster[num];

	for(int i =0;i<num;i++)
		m[i] = new Monster(i);

	stroke(#e9c40f,50);

}

void draw(){
	background(#464c3d);


	for(int i =0;i<num;i++)
		m[i].draw();


}

class Monster{

	float x,y,tx,ty;
	Chapadlo ch[];
	int nCh,id,timeToMove;
	float tempo;

	Monster(int _id){

		id = _id;
		tx = x = random(width);
		ty = y = random(height);

		timeToMove = (int)random(20,1600);
		
		nCh = (int)random(6,14);
		tempo = random(120,600);
		ch = new Chapadlo[nCh];

		for(int i =0;i<nCh;i++)
			ch[i] = new Chapadlo(i,(int)random(20,80),x,y,this);


	}

	void draw(){
		
		
		if(frameCount%timeToMove==0){
			if(random(50)>25){
			int rnd = (int)random(num);
		tx = m[rnd].x;
		
		ty = m[rnd].y;
			}else{
			tx = random(width);
			ty = random(height);
			
			}
		}

		x+=(tx-x)/30.0;
		y+=(ty-y)/30.0;
		
		for(int i =0;i<nCh;i++)
			ch[i].kresba();


	}

}

class Chapadlo{

	String dna = "";
	float x,y;
	float[] angles;
	int id,len;
	float angOne,angTwo,speed = 0,rot = 0;
	int MonsterId;
	Monster parent;
	float anomalie = 0;
	int anoId = 0;
	float step = 5;


	Chapadlo(int _id, int _len,float _x,float _y,Monster _parent){
		x = _x;
		y = _y;
		id = _id;
		len = _len;
		parent = _parent;
		init();

	}


	void init(){

		x = parent.x;
		y = parent.y;



		angOne = random(60);//random(9);
		angTwo = -random(60);//random(9)*-1;


		angles = new float[len];
		
		dna = "";
		for(int i =0;i<len;i++){
			if(random(50)>25){
				dna+="A";
				angles[i] = angOne;
			}else{
				dna+="B";
				angles[i] = angTwo;
			}
		}
		
		

	}

	void kresba(){

		//angOne-=0.1;
		//angTwo-=0.1;
/*
		if(random(500)<3){
			anomalie = random(100)/50.0;
			anoId = 0;
		}
		
		if(frameCount%3==0)
		anoId+=1;
		anoId = anoId%len;
		*/
		speed+=((dist(parent.x,parent.y,x,y)+1.0)-speed)/3.0;
		rot = (atan2(parent.ty-parent.y,parent.tx-parent.x)-HALF_PI);
		
		step = speed+0.1;
		
		x = parent.x;
		y = parent.y;
		
		pushMatrix();
		translate(x,y);
		rotate(rot);

		pushMatrix();
		for(int i = 0;i<len;i++){
			
			rotate(radians(angles[i])/(speed*2.0));
			angles[i]+=(random(-100,100)/100.0);
			line(0,0,0,-step);
			translate(0,-step);

		}
		popMatrix();



		popMatrix();

	}




}
Neuron n[][] = new Neuron[262/2][420/2];


void setup(){
	size(4*n[0].length,4*n.length,P2D);
	background(0);

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii] = new Neuron(i,ii);
		}
	}
	
	noFill();
	noCursor();

}


void draw(){
	background(0);
	
	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].cycle();
		}
	}
	
	
	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].update();
		}
	}
	
	
	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			pushMatrix();
			translate(ii*4,i*4);
			n[i][ii].draw();
			popMatrix();
		}
	}
}

class Neuron{

	int lay,id;
	float vibra,val,val2;
	float tone = 0,amount = 0;
	float[] w;

	Neuron(int _lay,int _id){
		lay = _lay;
		id = _id;
		w = new float[n.length];
		for(int i =0;i<w.length;i++){
			w[i] = random(400)/100.0;
		}
		vibra = random(1,1000)/10000.0;
		val = random(255);
	}

	void cycle(){
		tone+=vibra;
		amount = (sin(tone)+1.0)/2.0;

		if(lay>=1){
			val2 = 1.0;

			for(int i =0;i<w.length;i++){
				val2 += n[lay-1][i].val*amount*w[i];
			}
			val2 /= (w.length+0.0);
		}else{
			val2 = n[n.length-1][id].val;
		
		}
	}
	
	void update(){
		val += (val2-val)/1.01;
		val = constrain(val,1,254);
	}
	
	void draw(){
		stroke(lerpColor(#0a0a0a,#f7fd58,val/(255.0)));
		rect(0,0,3,3);
	
	
	}




}
Neuron n[][] = new Neuron[480][720];
Recorder r;
boolean rec = false;

void setup(){
	size(n[0].length,n.length,P2D);
	background(0);

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii] = new Neuron(i,ii);
		}
	}

	noFill();

	if(rec)
		r= new Recorder("brainPix","neuroPix.mp4");
}

void draw(){
	background(0);

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].cycle();
		}
	}

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].update();
		}
	}

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			pushMatrix();
			translate(ii,i);
			n[i][ii].draw();
			popMatrix();
		}
	}

	if(rec){
		r.add();
	}
}

void keyPressed(){
	if(key=='q'){
		if(rec)
			r.finish();
		exit();
	}
}

class Neuron{

	int lay,id;
	float vibra,val,val2;
	float tone = 0,amount = 0;
	float[] w;

	Neuron(int _lay,int _id){
		lay = _lay;
		id = _id;
		w = new float[3];

		for(int i =0;i<w.length;i++){
			w[i] = random(400)/100.0;
		}

		vibra = random(800,1000)/10000.0;

		val = random(255);
	}

	void cycle(){
		tone+=vibra;
		amount = (sin(tone)+1.0)/2.0;

		val2 = 0.0;

		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[0];
		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].val*amount*w[1];
		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[2];

		//val2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];
		//val2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[3];

		val2 /= (w.length+0.0);
		//stochaist(10.0);
	}

	void update(){
		val += (val2-val)/1.0;
		val = constrain(val,1,254);
	}

	void draw(){
		stroke(lerpColor(#000000,#f7fd58,val/(255.0)));
		point(0,0);


	}

	void sync(float kolik){
		n[(lay+n.length+1)%n.length][id].amount += (amount-n[(lay+n.length+1)%n.length][id].amount)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].vibra += (vibra-n[(lay+n.length+1)%n.length][id].vibra)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].tone += (tone-n[(lay+n.length+1)%n.length][id].tone)*(map(val,0,255,0,kolik));


	}

	void stochaist(float kolik){
		for(int i =0;i<w.length;i++){
			w[i]+=random(-kolik,kolik)/1000.0;
			//vibra+=random(-kolik,kolik)/1000.0;
			w[i] = constrain(w[i],0.01,5.0);
		}
	}




}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
Neuron n[][] = new Neuron[200][200];


void setup(){
	size(n[0].length,n.length,P2D);
	background(0);

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii] = new Neuron(i,ii);
		}
	}

	noFill();


}


void draw(){
	background(0);

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].cycle();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].update();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			pushMatrix();
			translate(ii,i);
			n[i][ii].draw();
			popMatrix();
		}
	}




}

void mouseDragged(){
	n[mouseY][mouseX].val =255;

}

class Neuron{

	int lay,id;
	float vibra,val,val2;
	float tone = 0,amount = 0;
	float[] w  = new float[8];

	float prum[] = new float[3];
	float tresh = 230.0;

	Neuron(int _lay,int _id){
		lay = _lay;
		id = _id;

		for(int i =0;i<w.length;i++){
			w[i] = random(440)/100.0;
		}

		vibra = random(90000,100000)/1000000.0;
		tone = random(100.0)/100.0;
		amount = random(100.0)/100.0;
		
		
		val = 128;//random(255);
		
	}

	void cycle(){
		tone+=vibra;
		amount = (sin(tone)+1.0)/2.0;


		val2 = 0.0;

		/**
		-1,-1 0,-1 1,-1
		-1,0 x,x 1,0
		-1,1 0,1 1,1

		*/

		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[0];
		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].val*amount*w[1];
		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[2];

		val2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[3];
		val2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[4];

		val2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[5];
		val2 += n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].val*amount*w[6];
		val2 += n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[7];

		/*

		val2 += n[lay-1][(id+n[0].length-2)%n[0].length].val*amount*w[0];
		val2 += n[lay-1][(id+n[0].length-1)%n[0].length].val*amount*w[1];
		val2 += n[lay-1][id].val*amount*w[2];
		val2 += n[lay-1][(id+n[0].length+1)%n[0].length].val*amount*w[3];
		val2 += n[lay-1][(id+n[0].length+2)%n[0].length].val*amount*w[4];
		*/

		val2 /= (w.length+0.0);
		
		
		
		float Rprum = 0.0;
		prum[(frameCount)%prum.length] = val;
		for(int i = 0;i<prum.length;i++){
			Rprum += prum[i];
		}
		Rprum/=prum.length;

		if(Rprum>=tresh){
			assimilate(0.0,0.01,0.0);
			//val = 1;
			
			//n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val = 255-val;
		}
		stochaist(20);

	}

	void update(){
		val += (val2-val)/2.01;
		val = constrain(val,1,254);

		



	}

	void stochaist(float kolik){
		for(int i =0;i<w.length;i++){
			w[i]+=random(-kolik,kolik)/1000.0;
		w[i] = constrain(w[i],0.01,4.0);
		}
	}

	void assimilate(float kolik,float kolik2,float kolik3){

		/**
		-1,-1 0,-1 1,-1
		-1,0 x,x 1,0
		-1,1 0,1 1,1

		*/
		
		// synchronize to vibra val
		n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
		n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
		n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;

		n[lay][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length-1)%n[0].length].vibra)*kolik;
		n[lay][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length+1)%n[0].length].vibra)*kolik;

		n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
		n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
		n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;



		// approx. counter weights
		n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7] += (w[0]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7])*kolik2;
		n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6] += (w[1]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6])*kolik2;
		n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5] += (w[2]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

		n[lay][(id+n[0].length-1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length-1)%n[0].length].w[4])*kolik2;
		n[lay][(id+n[0].length+1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

		n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[2].length].w[2] += (w[5]-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].w[2])*kolik2;
		n[(lay+n.length+1)%n.length][(id+n[0].length)%n[1].length].w[1] += (w[6]-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].w[1])*kolik2;
		n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0] += (w[7]-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0])*kolik2;
		
		
		// (experimental) approx. tones
		n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[0] += (w[7]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
		n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[1] += (w[6]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
		n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[2] += (w[5]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;

		n[lay][(id+n[0].length-1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length-1)%n[0].length].tone)*kolik3;
		n[lay][(id+n[0].length+1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length+1)%n[0].length].tone)*kolik3;

		n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
		n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
		n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;
	}

	void draw(){
		stroke(lerpColor(#000000,#ffffff,val/(255.0)));
		point(0,0);


	}




}
Neuron n[][] = new Neuron[240][320];
Recorder r;
boolean rec = false;
import krister.Ess.*;

AudioStream myStream;
float[] streamBuffer;
int y  = 0;

float bluramount = 0.5;

void setup(){
	size(n[0].length,n.length,P3D);
	background(0);

	frameRate(25);

	noSmooth();

	Ess.start(this);

	myStream=new AudioStream();
	myStream.sampleRate(44100/4);
	myStream.bufferSize(width);
	streamBuffer=new float[myStream.size];
	myStream.start();


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii] = new Neuron(i,ii);
		}
	}

	noFill();

	if(rec)
		r= new Recorder("brainPix","neuroPix.mp4");


}

void keyPressed()
{
	if(keyCode==UP){
		bluramount+=0.1;
	}else if(keyCode==DOWN){
		bluramount-=0.1;
	}else if(key=='q'){
		if(rec)
			r.finish();
		exit();

	}


	bluramount=constrain(bluramount,0.5,40);

}


void fillAudioBufferL(){
	loadPixels();

	int cnt =0;
	for(int X=0; X<width; X++) {
		streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
	}
	/*
	for(int X=width-1; X>=0; X--) {
		streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
}*/

	//y=(int)((sin(frameCount/30.0)+1.0)*height/2.0);// width/3;//mouseY;
	y=height/2;//y%height;

}

void fillAudioBuffer(){
	loadPixels();


	for(int Y=0; Y<height; Y++) {
		if(Y%2==0){
			for(int X=0; X<width; X++) {

				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}

		}else{
			for(int X=width-1; X>=0; X--) {

				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}
	}



	//myLowPass=new LowPass(220,-80,4);

	//myLowPass.filter(myStream);
}
void audioStreamWrite(AudioStream theStream) {
	System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
}

void draw(){
	//background(0);

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].cycle();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].update();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			pushMatrix();
			translate(ii,i);
			n[i][ii].draw();
			popMatrix();
		}
	}

	if(bluramount>0.5)
		filter(BLUR,bluramount);

	fillAudioBufferL();
	stroke(255,0,0);
	//line(0,y,width,y);


	if(rec){
		r.add();
	}


}

public void stop() {
	Ess.stop();
	super.stop();
}


class Neuron{

	int lay,id;
	float vibra,val,val2;
	//float tresh = 240.0;
	//float prum[] = new float[3];

	float tone = 0,amount = 0;
	float[] w;

	Neuron(int _lay,int _id){
		lay = _lay;
		id = _id;
		w = new float[8];
		for(int i =0;i<w.length;i++){
			w[i] = random(400)/100.0;
		}
		vibra = random(800,1000)/10000.0;


		val = random(255);

	}

	void cycle(){

		tone+=vibra;
		amount = (sin(tone)+1.0)/2.0;

		val2 = 0.0;



		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[0];
		val2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[1];
		val2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];

		//val2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];
		//val2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[3];

		/*

				float Rprum = 0.0;
				prum[(frameCount)%prum.length] = val;
				for(int i = 0;i<prum.length;i++){
					Rprum += prum[i];
				}
				Rprum/=prum.length;

				if(Rprum>=tresh){
					assimilate(0.01,0.00,0.001);
					//val = 1;

					//n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val = 255-val;
				}

		*/
		val2 /= (3.0);
		
		if(val<50||val>200)
		stochaist(470.0);


	}
	/*
		void assimilate(float kolik,float kolik2,float kolik3){

			-1,-1 0,-1 1,-1
			-1,0 x,x 1,0
			-1,1 0,1 1,1

			

			// synchronize to vibra val
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[lay][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[lay][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;



			// approx. counter weights
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7] += (w[0]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6] += (w[1]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5] += (w[2]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[lay][(id+n[0].length-1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length-1)%n[0].length].w[4])*kolik2;
			n[lay][(id+n[0].length+1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[2].length].w[2] += (w[5]-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].w[2])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[1].length].w[1] += (w[6]-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].w[1])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0] += (w[7]-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0])*kolik2;


			// (experimental) approx. tones
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[0] += (w[7]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[1] += (w[6]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[2] += (w[5]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[lay][(id+n[0].length-1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[lay][(id+n[0].length+1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;
		}
	*/
	void update(){
		val += (val2-val)/1.0;
		val = constrain(val,1,254);
	}

	void draw(){
		stroke(lerpColor(#000000,#f7fd58,val/(255.0)),30.0);
		point(0,0);


	}

	void sync(float kolik){
		n[(lay+n.length+1)%n.length][id].amount += (amount-n[(lay+n.length+1)%n.length][id].amount)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].vibra += (vibra-n[(lay+n.length+1)%n.length][id].vibra)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].tone += (tone-n[(lay+n.length+1)%n.length][id].tone)*(map(val,0,255,0,kolik));


	}

	void stochaist(float kolik){
		for(int i =0;i<w.length;i++){
			w[i]+=random(-kolik,kolik)/1000.0;
			//vibra+=random(-kolik,kolik)/1000.0;
			w[i] = constrain(w[i],0.01,5.0);
		}
	}




}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
Neuron n[][] = new Neuron[80][320];
Recorder r;
boolean rec = false;
import krister.Ess.*;

import codeanticode.gsvideo.*;

GSPipeline cam;

AudioStream myStream;
float[] streamBuffer;
int y  = 0;

boolean hasPictur = false;

float bluramount = 0.5;

void setup(){
	size(n[0].length,n.length,P2D);
	background(0);

	frameRate(25);

	noSmooth();

	Ess.start(this);

	myStream=new AudioStream();
	myStream.sampleRate(44100/4);
	myStream.bufferSize(width-10);
	streamBuffer=new float[myStream.size];
	myStream.start();



	cam = new GSPipeline(this, "v4l2src ! queue2 ! ffvideoscale !"+"video/x-raw-rgb,width="+(width)+",height="+(height));

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii] = new Neuron(i,ii);
		}
	}

	noFill();

	if(rec)
		r= new Recorder("brainPix","neuroPix.mp4");
}

void keyPressed()
{
	if(keyCode==UP){
		bluramount+=0.1;
	}else if(keyCode==DOWN){
		bluramount-=0.1;
	}else if(key=='q'){
		if(rec)
			r.finish();
		exit();

	}
	bluramount=constrain(bluramount,0.5,40);
}


void fillAudioBufferL(){
	loadPixels();

	int cnt =0;
	for(int X=10; X<width; X++) {
		streamBuffer[cnt] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
	}
	/*
	for(int X=width-1; X>=0; X--) {
		streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
		}*/

	//y=(int)((sin(frameCount/30.0)+1.0)*height/2.0);// width/3;//mouseY;
	y=height/2;//y%height;

}

void fillAudioBuffer(){
	loadPixels();


	for(int Y=0; Y<height; Y++) {
		if(Y%2==0){
			for(int X=0; X<width; X++) {
				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}else{
			for(int X=width-1; X>=0; X--) {
				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}
	}
	//myLowPass=new LowPass(220,-80,4);
	//myLowPass.filter(myStream);
}

void audioStreamWrite(AudioStream theStream) {
	System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
}

void draw(){
	//background(0);

	hasPictur = false;
	if (cam.available() == true){
		cam.read();
		hasPictur = true;
		//set(0,0,cam);
		//neuroFeed();
	}

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].cycle();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].update();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			pushMatrix();
			translate(ii,i);
			n[i][ii].draw();
			popMatrix();
		}
	}

	if(bluramount>0.5)
		filter(BLUR,bluramount);

	fillAudioBufferL();
	stroke(255,0,0);
	line(0,y,width,y);


	if(rec){
		r.add();
	}


}

public void stop() {
	Ess.stop();
	super.stop();
}

class Neuron{
	int lay,id;
	float vibra,val,val2;
	float r2,g2,b2;
	float r,g,b;
	//float tresh = 240.0;
	//float prum[] = new float[3];

	float tone = 0,amount = 0;
	float[] w;

	Neuron(int _lay,int _id){
		lay = _lay;
		id = _id;
		w = new float[8];
		for(int i =0;i<w.length;i++){
			w[i] = random(90,110)/100.0;//random(400)/100.0;
		}
		vibra = random(800,1000)/10000.0;

		//val = random(255);
		r = g = b = r2 = g2 = b2 = 0;
	}

	void cycle(){

		if(id<=10){
			if(hasPictur){
				r = red(cam.pixels[lay*width+id]);
				g = red(cam.pixels[lay*width+id]);
				b = red(cam.pixels[lay*width+id]);
			}
		}else{
			tone+=vibra;
			amount = 1 + (sin(tone))/40.0;                      
			//amount = 1;
			
			r2 = g2 = b2 = 0.0;

			r2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[0];
			r2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[1];
			r2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[2];

			g2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[0];
			g2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[1];
			g2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[2];

			b2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[0];
			b2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[1];
			b2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[2];

		}
		//val2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];
		//val2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[3];

		/*

				float Rprum = 0.0;
				prum[(frameCount)%prum.length] = val;
				for(int i = 0;i<prum.length;i++){
					Rprum += prum[i];
				}
				Rprum/=prum.length;

				if(Rprum>=tresh){
					assimilate(0.01,0.00,0.001);
					//val = 1;

					//n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val = 255-val;
				}

		*/
		r2 /= (3.0);
		g2 /= (3.0);
		b2 /= (3.0);

		//if(val<50||val>200)
		stochaist(50.7);


	}
	/*
		void assimilate(float kolik,float kolik2,float kolik3){

			-1,-1 0,-1 1,-1
			-1,0 x,x 1,0
			-1,1 0,1 1,1

			

			// synchronize to vibra val
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[lay][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[lay][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;



			// approx. counter weights
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7] += (w[0]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6] += (w[1]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5] += (w[2]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[lay][(id+n[0].length-1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length-1)%n[0].length].w[4])*kolik2;
			n[lay][(id+n[0].length+1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[2].length].w[2] += (w[5]-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].w[2])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[1].length].w[1] += (w[6]-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].w[1])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0] += (w[7]-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0])*kolik2;


			// (experimental) approx. tones
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[0] += (w[7]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[1] += (w[6]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[2] += (w[5]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[lay][(id+n[0].length-1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[lay][(id+n[0].length+1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;
		}
	*/
	void update(){
		if(id>10){
		r += (r2-r)/2.0;
		g += (g2-g)/2.0;
		b += (b2-b)/2.0;

		r= constrain(r,1,254);
		g= constrain(g,1,254);
		b= constrain(b,1,254);
		}
	}

	void draw(){
		stroke(r,g,b);
		point(0,0);
	}

	void sync(float kolik){
		n[(lay+n.length+1)%n.length][id].amount += (amount-n[(lay+n.length+1)%n.length][id].amount)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].vibra += (vibra-n[(lay+n.length+1)%n.length][id].vibra)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].tone += (tone-n[(lay+n.length+1)%n.length][id].tone)*(map(val,0,255,0,kolik));
	}

	void stochaist(float kolik){
		for(int i =0;i<w.length;i++){
			w[i]+=random(-kolik,kolik)/1000.0;
			//vibra+=random(-kolik,kolik)/1000.0;
			w[i] = constrain(w[i],0.01,5.0);
		}
	}
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
Neuron n[][] = new Neuron[120][160];
Recorder r;
boolean rec = false;
import krister.Ess.*;

import codeanticode.gsvideo.*;

GSPipeline cam;

AudioStream myStream;
float[] streamBuffer;
int y  = 0;

int W = 64;
int H = 48;

int gx = 0;
int gy = 10;

boolean hasPictur = false;

float bluramount = 0.5;

void setup(){
	size(n[0].length,n.length,P2D);
	background(0);

	frameRate(25);

	noSmooth();

	gx = (int)(width/2.0-(W/2.0));
	gy = (int)(height/2.0-(H/2.0));
	
	Ess.start(this);

	myStream=new AudioStream();
	myStream.sampleRate(44100/4);
	myStream.bufferSize(width-10);
	streamBuffer=new float[myStream.size];
	myStream.start();

	String webcam = "v4l2src ! queue2 ! ffvideoscale ! "+"video/x-raw-rgb,width="+W+",height="+H;
	String dv = "dv1394src ! ffdemux_dv ! ffdec_dvvideo ! queue2 ! ffvideoscale ! "+"video/x-raw-rgb,width="+W+",height="+H;
	
	cam = new GSPipeline(this, dv);
	
	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii] = new Neuron(i,ii);
		}
	}

	noFill();

	if(rec)
		r= new Recorder("brainPix","neuroPix.mp4");
}

void keyPressed()
{
	if(keyCode==UP){
		bluramount+=0.1;
	}else if(keyCode==DOWN){
		bluramount-=0.1;
	}else if(key=='q'){
		if(rec)
			r.finish();
		exit();

	}
	bluramount=constrain(bluramount,0.5,40);
}

void fillAudioBufferL(){
	loadPixels();

	int cnt =0;
	for(int X=10; X<width; X++) {
		streamBuffer[cnt] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
	}
	/*
	for(int X=width-1; X>=0; X--) {
		streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
		}*/

	//y=(int)((sin(frameCount/30.0)+1.0)*height/2.0);// width/3;//mouseY;
	y=height/2;//y%height;

}

void fillAudioBuffer(){
	loadPixels();


	for(int Y=0; Y<height; Y++) {
		if(Y%2==0){
			for(int X=0; X<width; X++) {
				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}else{
			for(int X=width-1; X>=0; X--) {
				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}
	}
	//myLowPass=new LowPass(220,-80,4);
	//myLowPass.filter(myStream);
}

void audioStreamWrite(AudioStream theStream) {
	System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
}

void draw(){
	//background(0);

	hasPictur = false;
	if (cam.available() == true){
		cam.read();
		hasPictur = true;
		//set(0,0,cam);
		//neuroFeed();
	}

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].cycle();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].update();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			pushMatrix();
			translate(ii,i);
			n[i][ii].draw();
			popMatrix();
		}
	}

	if(bluramount>0.5)
		filter(BLUR,bluramount);

	fillAudioBufferL();
	//stroke(255,0,0);
	//line(0,y,width,y);


	if(rec){
		r.add();
	}


}

public void stop() {
	Ess.stop();
	super.stop();
}

class Neuron{
	int lay,id;
	float vibra,val,val2;
	float r2,g2,b2;
	float r,g,b;
	//float tresh = 240.0;
	//float prum[] = new float[3];

	float tone = 0,amount = 0;
		float[] w  = new float[8];

	Neuron(int _lay,int _id){
		lay = _lay;
		id = _id;
		w = new float[8];
		for(int i =0;i<w.length;i++){
			w[i] = random(90,110)/100.0;//random(400)/100.0;
		}
		vibra = random(1000,10000)/10000.0;

		//val = random(255);
		r = g = b = r2 = g2 = b2 = 0;
	}

	void cycle(){

		if(id>gx&&id<W+gx&&lay>gy&&lay<H+gy){
			if(hasPictur){
				r = red(cam.pixels[(lay-gy)*W+(id-gx)]);
				g = green(cam.pixels[(lay-gy)*W+(id-gx)]);
				b = blue(cam.pixels[(lay-gy)*W+(id-gx)]);
			}
		}else{
			tone+=vibra;
			amount = 1 + (sin(tone))/20.0;                      
			//amount = 1;
			
			r2 = g2 = b2 = 0.0;
/*
			r2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[0];
			r2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[1];
			r2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[2];

			g2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[0];
			g2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[1];
			g2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[2];

			b2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[0];
			b2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[1];
			b2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[2];
*/
		r2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[0];
		r2 += n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].r*amount*w[1];
		r2 += n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].r*amount*w[2];

		r2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[3];
		r2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].r*amount*w[4];

		r2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].r*amount*w[5];
		r2 += n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].r*amount*w[6];
		r2 += n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].r*amount*w[7];

		
		g2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[0];
		g2 += n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].g*amount*w[1];
		g2 += n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].g*amount*w[2];

		g2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[3];
		g2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].g*amount*w[4];

		g2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].g*amount*w[5];
		g2 += n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].g*amount*w[6];
		g2 += n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].g*amount*w[7];

		
		b2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[0];
		b2 += n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].b*amount*w[1];
		b2 += n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].b*amount*w[2];

		b2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[3];
		b2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].b*amount*w[4];

		b2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].b*amount*w[5];
		b2 += n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].b*amount*w[6];
		b2 += n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].b*amount*w[7];

		
		}
		//val2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];
		//val2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[3];

		/*

				float Rprum = 0.0;
				prum[(frameCount)%prum.length] = val;
				for(int i = 0;i<prum.length;i++){
					Rprum += prum[i];
				}
				Rprum/=prum.length;

				if(Rprum>=tresh){
					assimilate(0.01,0.00,0.001);
					//val = 1;

					//n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val = 255-val;
				}

		*/
		r2 /= (8.0);
		g2 /= (8.0);
		b2 /= (8.0);

		//if(val<50||val>200)
		//stochaist(50.7);


	}
	/*
		void assimilate(float kolik,float kolik2,float kolik3){

			-1,-1 0,-1 1,-1
			-1,0 x,x 1,0
			-1,1 0,1 1,1

			

			// synchronize to vibra val
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[lay][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[lay][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;



			// approx. counter weights
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7] += (w[0]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6] += (w[1]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5] += (w[2]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[lay][(id+n[0].length-1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length-1)%n[0].length].w[4])*kolik2;
			n[lay][(id+n[0].length+1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[2].length].w[2] += (w[5]-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].w[2])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[1].length].w[1] += (w[6]-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].w[1])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0] += (w[7]-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0])*kolik2;


			// (experimental) approx. tones
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[0] += (w[7]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[1] += (w[6]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[2] += (w[5]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[lay][(id+n[0].length-1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[lay][(id+n[0].length+1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;
		}
	*/
	void update(){
		//if(id>=W-1&&lay>=H-1){
		r += (r2-r)/3.1;
		g += (g2-g)/3.1;
		b += (b2-b)/3.1;

		r= constrain(r,1,254);
		g= constrain(g,1,254);
		b= constrain(b,1,254);
		//}
	}

	void draw(){
		stroke(r,g,b);
		point(0,0);
	}

	void sync(float kolik){
		n[(lay+n.length+1)%n.length][id].amount += (amount-n[(lay+n.length+1)%n.length][id].amount)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].vibra += (vibra-n[(lay+n.length+1)%n.length][id].vibra)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].tone += (tone-n[(lay+n.length+1)%n.length][id].tone)*(map(val,0,255,0,kolik));
	}

	void stochaist(float kolik){
		for(int i =0;i<w.length;i++){
			w[i]+=random(-kolik,kolik-1)/1000.0;
			//vibra+=random(-kolik,kolik)/1000.0;
			w[i] = constrain(w[i],0.01,5.0);
		}
	}
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import ddf.minim.analysis.*;
import ddf.minim.*;

Minim minim;
AudioInput in;
FFT fftLog;

float vals[];
float speed = 1.0;

boolean flicker = false;

void setup()
{
	size(1678, 1048, OPENGL);
//	textMode(SCREEN);

	frameRate(30);

	minim = new Minim(this);

	in = minim.getLineIn(Minim.STEREO, 1024);
	
	//println(PFont.list());
	//textFont(createFont("Electron", 8));

	fftLog = new FFT(in.bufferSize(), in.sampleRate());
	fftLog.logAverages(22, 3);

	vals = new float[fftLog.avgSize()];
	for(int i = 0;i<vals.length;i++)
		vals[i] = 0;
	
	fftLog.window(FFT.HAMMING);
	noStroke();
	//noCursor();

}
void draw()
{
	fftLog.forward(in.mix);
	float density = 5;
	int w = int(width/fftLog.avgSize());
	float x = 0;

	// update vals
	for(int i = 0; i<fftLog.avgSize() ;i++){
		density = map(fftLog.getAvg(i),0,20,1,2);
		vals[i] += (density-vals[i])/speed;
		x += vals[i]*2.0;
	}

	//colours
	if(flicker){
		if(frameCount%2==0){
			background(0);
			fill(255);
		}else{
			background(255);
			fill(0);

		}
	}else{
		background(0);
		fill(255,200);


	}

	// draw
	for(int i =0;i<vals.length;i++){
		fill(255,200);
		rect(i*(width/vals.length),0,map(pow(vals[i]-0.5,1.5),0,x,0,width),height);
		fill(0);
		//for(int q = 0;q<height;q+=8)
		//text((int)map(pow(vals[i]-0.5,1.5),0,x,0,width)+"",i*(width/vals.length),q);
	}
}


void stop()
{
	// always close Minim audio classes when you finish with them
	in.close();
	minim.stop();

	super.stop();
}
import krister.Ess.*;
import codeanticode.gsvideo.*;


AudioStream myStream;
Reverb myReverb;
LowPass myLowPass;
Normalize myNormalize;
float[] streamBuffer;
Envelope myEnvelope;
GSPipeline cam;

int x = 0;


void setup() {
	size(320/2,240/2,P2D);

	frameRate(25);

	cam = new GSPipeline(this, "v4l2src   ! queue2 ! ffvideoscale !"+"video/x-raw-rgb,width="+(width)+",height="+(height));

	Ess.start(this);
	myStream=new AudioStream();
	myStream.sampleRate(44100/4);
	myStream.bufferSize(height*width);
	streamBuffer=new float[myStream.size];

	/*
	fillAudioBuffer();
	*/
	//myReverb=new Reverb();

	//myReverb.filter(myStream,0,myStream.frames(4000));
	// apply a low pass filter
	//myLowPass=new LowPass(160,39,32);
	//myLowPass.filter(myStream);

	// normalize
	myNormalize=new Normalize();

	myNormalize.filter(myStream);

	//EPoint[] env=new EPoint[3];
	//env[0]=new EPoint(0,0);
	//env[1]=new EPoint(.25,1);
	//env[2]=new EPoint(2,0);

	//myEnvelope=new Envelope(env);

	//myEnvelope.filter(myStream);
	myStream.start();

}

void fillAudioBuffer(){


	for(int Y=0; Y<height; Y++) {
		if(Y%2==0){
			for(int X=0; X<width; X++) {

				streamBuffer[Y*width+X] = map(brightness(cam.pixels[Y*width+X]),0,255,-0.9,0.9);
			}

		}else{
			for(int X=width-1; X>=0; X--) {

				streamBuffer[Y*width+X] = map(brightness(cam.pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}
	}
	
	

	//myLowPass=new LowPass(220,-80,4);

	//myLowPass.filter(myStream);
}

void draw() {
	if (cam.available() == true){
		cam.read();
		set(0,0,cam);
		fillAudioBuffer();

	}

}

void audioStreamWrite(AudioStream theStream) {
	System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
}

void keyReleased(){


	int mod= keyCode-49;
	mod = constrain(mod,2,8);
	myStream.sampleRate(44100/mod);
	myStream.start();


}

public void stop() {
	Ess.stop();
	super.stop();
}

import krister.Ess.*;
import codeanticode.gsvideo.*;


AudioStream myStream;
Reverb myReverb;
LowPass myLowPass;
Normalize myNormalize;
float[] streamBuffer;
Envelope myEnvelope;
GSPipeline cam;

int x = 0;
int y  = 0;

void setup() {
	size(320/2,240/2,P2D);

	frameRate(25);

	cam = new GSPipeline(this, "v4l2src ! queue2 ! ffvideoscale !"+"video/x-raw-rgb,width="+(width)+",height="+(height));

	Ess.start(this);
	myStream=new AudioStream();
	myStream.sampleRate(44100);
	myStream.bufferSize(width*2);
	streamBuffer=new float[myStream.size];

	/*
	fillAudioBuffer();
	*/
	//myReverb=new Reverb();

	//myReverb.filter(myStream,0,myStream.frames(4000));
	// apply a low pass filter
	//myLowPass=new LowPass(160,39,32);
	//myLowPass.filter(myStream);

	// normalize
	myNormalize=new Normalize();

	myNormalize.filter(myStream);

	//EPoint[] env=new EPoint[3];
	//env[0]=new EPoint(0,0);
	//env[1]=new EPoint(.25,1);
	//env[2]=new EPoint(2,0);

	//myEnvelope=new Envelope(env);

	//myEnvelope.filter(myStream);
	myStream.start();

}

void fillAudioBuffer(){


	for(int Y=0; Y<height; Y++) {
		if(Y%2==0){
			for(int X=0; X<width; X++) {

				streamBuffer[Y*width+X] = map(brightness(cam.pixels[Y*width+X]),0,255,-0.9,0.9);
			}

		}else{
			for(int X=width-1; X>=0; X--) {

				streamBuffer[Y*width+X] = map(brightness(cam.pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}
	}
	
	

	//myLowPass=new LowPass(220,-80,4);

	//myLowPass.filter(myStream);
}

void fillAudioBufferL(){
	loadPixels();

	int cnt =0;
	for(int X=0; X<width; X++) {
		streamBuffer[cnt] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
	}
	
	for(int X=width-1; X>=0; X--) {
		streamBuffer[cnt] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
}

	//y=(int)((sin(frameCount/30.0)+1.0)*height/2.0);// width/3;//mouseY;
	y=height/2;//y%height;

}

void draw() {
	if (cam.available() == true){
		cam.read();
		set(0,0,cam);
		fillAudioBufferL();

	}
	
	
	stroke(#ff0000);
	line(0,height/2,width,height/2);

}

void audioStreamWrite(AudioStream theStream) {
	System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
}

void keyReleased(){


	int mod= keyCode-49;
	mod = constrain(mod,2,8);
	myStream.sampleRate(44100/mod);
	myStream.start();


}

public void stop() {
	Ess.stop();
	super.stop();
}

// basemeent of wave generator
// bona (www.papamuerta.com) & dimitre
int count = 500;
int step = 13;
PImage src;

int num = (int)((200+88200)*0.2);
byte[] buffer;
// 88200 = 44100 samples/sec * 2 channels = 1 second of wave

int index;
float amplitude;
double sample, sample2;

String name = "ram.png";
int numbr = 2;

void setup() {

	src=loadImage(name);
	src.loadPixels();
	num = src.pixels.length;//+waveHeader.length+200;
	buffer = new byte[num];
	println(num);

	System.arraycopy(waveHeader, 0, buffer, 0, waveHeader.length);

	// volume do som, vai de 0 a 127
	amplitude = 80;
	// frequencia em HZ, 440 � a nota L�
	/*vyska = (float)i;
	vyska2 = count-(float)i;
	vyska3 = abs(vyska-vyska2);*/

	for (index=0; index<num-waveHeader.length; index++) {

		// onda normal
		// sample = (sin(2*PI*index/divisor) * amplitude);
		// onda composta
		sample = brightness(color(src.pixels[index]));//((sin(2*PI*index/divisor) * amplitude) + (sin(2*PI*index/divisor2) * amplitude) + (sin(2*PI*index/divisor3) * amplitude)) / 2;

		//tremolo
		//amplitude = (sin(index/1000f) * 127);
		if (sample < 0) sample = 255 - (sample * -1) ;
		buffer[waveHeader.length+index] = (byte)(sample);
	}
	geraWave();

	exit();
}

void geraWave(){
	//File file = null;
	//file = new File("tuu.wav");

	saveBytes("out/listenTheFotography_"+name+".wav", buffer);
	println(name+" done!");

}



static byte waveHeader[] = {
                                   (byte)0x52, (byte)0x49, (byte)0x46, (byte)0x46, (byte)0x8a, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x57,
                                   (byte)0x41, (byte)0x56, (byte)0x45, (byte)0x66, (byte)0x6d, (byte)0x74, (byte)0x20, (byte)0x10, (byte)0x00,
                                   (byte)0x00, (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x44, (byte)0xac, (byte)0x00,
                                   (byte)0x00, (byte)0x88, (byte)0x58, (byte)0x01, (byte)0x00, (byte)0x02, (byte)0x00, (byte)0x10, (byte)0x00,
                                   (byte)0x64, (byte)0x61, (byte)0x74, (byte)0x61, (byte)0x8A, (byte)0x58, (byte)0x01, (byte)0x00
                           };
import codeanticode.gsvideo.*;

import java.util.ArrayList;
//import processing.opengl.*;
import ddf.minim.effects.*;
//import processing.video.*;
import ddf.minim.*;
import ddf.minim.signals.*;


GSPipeline cam;


//////// camera res ////////
int numX = 320;
int numY = 240;
//////////////////////////////

Minim minim;

AudioSample sam;
AudioOutput out;

playBack pb;
LowPassFS lpf;
Amplitude_Modulation AM;

//MovieMaker mm;

void setup()
{
	size(numX, numY, P2D);

	frameRate(25);
	noFill();
	noSmooth();

	//numX = (int)(koef*numX);
	//numY = (int)(koef*numY);


	//img = new int[numX*numY];
	cam = new GSPipeline(this, "v4l2src  ! queue ! ffvideoscale !"+"video/x-raw-rgb,width="+numX+",height="+numY);

	float[] tmp = new float[width*height];
	for(int i = 0;i<tmp.length;i++)
		tmp[i] = random(-100,100)/100.0;
	
	sam  = createSample(tmp,Minim.WAV,tmp.length);

	minim = new Minim(this);
	out = minim.getLineOut(Minim.STEREO,numX*numY);
	AM = new Amplitude_Modulation();

	pb = new playBack();

	out.addSignal(sam);
	out.addEffect(AM);

	//lpf = new LowPassFS(100, out.sampleRate());
	//lpf.setFreq(1350);

	//recorder = Minim.createRecorder(out, "output.wav", true);
	//recorder.beginRecord();
}

void draw()
{
	if (cam.available() == true){
		cam.read();
		set(0,0,cam);

		loadPixels();
		float[] tmp = new float[pixels.length];
		for(int i = 0;i<tmp.length;i++)
			tmp[i] = map(brightness(pixels[i]),0,255,0,1);

		pb.generate(tmp);
		//AM.process(tmp);

		//pb.generate(tmp,tmp);
		//println(tmp[0]);
	}
}

void keyReleased()
{
	if ( key == 'r' )
	{
		// to indicate that you want to start or stop capturing audio data, you must call
		// beginRecord() and endRecord() on the AudioRecorder object. You can start and stop
		// as many times as you like, the audio data will be appended to the end of the buffer
		// (in the case of buffered recording) or to the end of the file (in the case of streamed recording).
		if ( recorder.isRecording() )
		{
			recorder.endRecord();
		}
		else
		{
			recorder.beginRecord();
		}
	}
	if ( key == 's' )
	{
		// we've filled the file out buffer,
		// now write it to the file we specified in createRecorder
		// in the case of buffered recording, if the buffer is large,
		// this will appear to freeze the sketch for sometime
		// in the case of streamed recording,
		// it will not freeze as the data is already in the file and all that is being done
		// is closing the file.
		// the method returns the recorded audio as an AudioRecording,
		// see the example  AudioRecorder >> RecordAndPlayback for more about that
		recorder.save();
		println("Done saving.");
	}
}

class playBack implements AudioSignal{ //Just a simple "re-route" audio class.
	float[] left = new float[numX*numY];
	float[] right = new float[numX*numY];
	float mix[] = new float[numX*numY];
	//Getting.
	/*
		public void samples(float[] arg0) {
			left = arg0;
		}

		public void samples(float[] arg0, float[] arg1) {
			left = arg0;
			right = arg1;
		}*/
	//Sending back.

/*
	public void generate(float[] samp) {
		for(int i =0;i<samp.length;i++)
			samp[i];
	}
*/
	public void process(float[] samp) {
		for(int i =0;i<samp.length;i++)
			left[i] = samp[i];
	}
	
	void generate(float[] samp){
	
		for(int i = 0;i<samp.length;i++){
			this.samples[i] = samp[i];
		}
	}


	void generate(float[] left, float[] right)
	{
		generate(left);
		generate(right);
	}
	/*
	public void generate(float[] arg0, float[] arg1) {
	//System.out.println(arg0[0]);
	if (left!=null && right!=null){
		System.arraycopy(left, 0, arg0, 0, arg0.length);
		System.arraycopy(right, 0, arg1, 0, arg1.length);
}
}*/
}

class Amplitude_Modulation implements AudioEffect
{ // the mono version doesn’t do anything
	void process(float[] samp)
	{
		float[] AM = new float[samp.length];

		for (int j = 0; j < samp.length; j++) AM[j] = samp[j];

		// we have to copy the values back into samp for this to work
		arraycopy(AM, samp);
	}

	void process(float[] samp1, float[] samp2)
	{
		float[] AM = new float[samp1.length];

		for (int j = 0; j < samp1.length; j++) AM[j] = samp1[j]*samp2[j];
		// we have to copy the values back into samp for this to work
		arraycopy(AM, samp1);
		arraycopy(AM, samp2);
	}
}


void stop()
{
	out.close();
	minim.stop();
	super.stop();
}
/**
* WireWorlds OSC
*
* + .. zoomin
* - .. zoomout
* s .. ulozit stav do txt
* l .. nacist stav do txt
* spiky .. pohyb po plose
* DEL .. clrscreen
* ENTER .. zazehni signal na pozici
* L klik .. vytvor drat
* R klik vymaz drat
* e .. nasadit senzor
* INSERT .. ulozit do bmp
* HOME .. nacist z png
* q .. exit
* a .. nahravani videa .. vyzaduje GStreamer lib
*/



//import codeanticode.gsvideo.*;
import netP5.*;
import oscP5.*;

// globalni rozliseni
int plochaX = 320;
int plochaY = 200;

//GSMovieMaker mm;
OSC osc;

int X, Y;
int SID = 0;
//Recorder r;

boolean emit = true;
boolean rec = false;

int top = 4;
int numx = plochaX/top,numy = plochaY/top;

Cell c[][] = new Cell[numx*top][numy*top];
color col[] = {color(0),color(50),color(120),color(255)};

int shiftx=0,shifty=0;

int scaler = 4;
String filename;

void setup(){
	size(plochaX,plochaY,P2D);
	background(0);

	noCursor();

	filename =  "machines/looper_"+c.length+"x"+c[0].length;

	frameRate(25);

	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			c[x][y] = new Cell(x,y);
		}
	}

	/*if(rec){
		mm = new GSMovieMaker(this,width,height,"out/out.avi",GSMovieMaker.X264,GSMovieMaker.BEST,25);
		mm.start();
}*/


	//for(int x=0;x<c.length;x++){
	//	c[x][30].state=1;
	//}

	noStroke();
	noSmooth();


}

void initOSC(){
		osc = new OSC("127.0.0.1",12000);
}

void loadState(){
	try{
		String temp[] = loadStrings(filename+".txt");

		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].state = parseInt(temp[y].charAt(x))-48;
			}
		}

	}catch(NullPointerException e){
		println("no such a file, please save before");
	}
	println("machine loaded: "+filename+".txt");
}

void saveState(){

	String data[] = new String[0];

	for(int y=0;y<c[0].length;y++){
		data = (String[])expand(data,data.length+1);
		data[data.length-1] = "";
		for(int x=0;x<c.length;x++){
			data[data.length-1]+=c[x][y].state!=0?"1":"0";
		}
	}

	saveStrings(filename,data);
	println("saved as: "+filename+".txt");
}


void loadStateFromImage(){
		
	if(emit)
		initOSC();
	try{
		PImage temp = loadImage(filename+".png");

		if(temp.width==c.length&&temp.height==c[0].length){

			c = new Cell[numx*top][numy*top];

			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y] = new Cell(x,y);
					if((brightness(color(temp.pixels[y*temp.width+x]))) != 0.0){
						c[x][y].state=1;
					}else{
						c[x][y].state=0;
					}
				}
			}

			println("state loaded sucessfully from: "+filename+".bmp");
		}else{
			println("error: stored values does not correpondent to dimensions");
		}

	}catch(NullPointerException e){
		println("error: saved record does not found " +e);
	}
}

void saveStateToImage(){
	PImage temp = createImage(c.length,c[0].length,RGB);

	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			if(c[x][y].state>0){temp.pixels[y*temp.width+x]=color(255);}else{temp.pixels[y*temp.width+x]=color(0);}
		}
	}

	temp.save(filename+".bmp");
	println("state saved as image: "+filename+".bmp");
}

void draw(){
	background(0);

	step(1);

	pushMatrix();
	translate(-shiftx,-shifty);

	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			c[x][y].draw();
		}
	}

	noFill();
	stroke(255);
	rect(-1,-1,1,1);
	rect(c.length*scaler+1,-1,1,1);
	rect(-1,c[0].length*scaler+1,1,1);
	rect(c.length*scaler-1,c[0].length*scaler+1,1,1);
	noStroke();

	popMatrix();

	X = constrain((int)((mouseX/scaler)+shiftx/scaler),0,c.length-1);
	Y = constrain((int)((mouseY/scaler)+shifty/scaler),0,c[0].length-1);

	c[X][Y].sel=true;

	if(mousePressed){
		if(mouseButton==LEFT)
			c[X][Y].state=1;
		if(mouseButton==RIGHT)
			c[X][Y].state=0;
		if(mouseButton==3){
			c[X][Y].state=3;
			mousePressed=false;
		}
	}


}

void keyPressed(){
	if(key==' '){
		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].calm();
			}

		}
	}else if(key=='='){
		scaler++;
	}else if(key=='-'){
		scaler--;
	}else if(key =='s'){
		saveState();
	}else if(key =='l'){
		loadState();
	}else if(keyCode==LEFT){
		shiftx-=3;
	}else if(keyCode==RIGHT){
		shiftx+=3;
	}else if(keyCode==UP){
		shifty-=3;
	}else if(keyCode==DOWN){
		shifty+=3;
	}else if(keyCode==DELETE){
		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].state=c[x][y].nextState=0;
			}
		}
	}else if(keyCode==ENTER){
		c[X][Y].state=3;


	}else if(keyCode == 155){
		saveStateToImage();

	}else if(keyCode==36){
		loadStateFromImage();
	}else if(key == 'q'){

		exit();
	}else if(key == 'a'){
		rec=!rec;
	}else if(key == 'e'){
		if(!emit){
			//osc = new OSC("127.0.0.1",12000);
			emit = true;
			c[X][Y].s = new Senzor(SID);
			SID++;
		}
		
		c[X][Y].hasSenzor = !c[X][Y].hasSenzor;
	}


	scaler=constrain(scaler,1,top);
	keyPressed=false;
}

void step(int n){
	boolean anim = false;
	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			if(c[x][y].state>1){
				anim=true;
				break;
			}
		}
	}

	if(anim){
		if(frameCount%n==0){
			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y].act();
				}
			}

			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y].update();
				}
			}
		}
	}

}

class Senzor{
	int id;
	float freq;

	Senzor(int _id){
		id=_id;
		freq = ceil(random(10))*16;
	}
}

class Cell{
	//state 0=black, 1=wire, 2= tail, 3=head
	int state = 0;
	int nextState = 0;
	int x,y;
	boolean sel = false;
	Senzor s;
	boolean hasSenzor = false;

	Cell(int _x,int _y){
		x=_x;
		y=_y;

		
	}

	void act(){
		compute();

		if(state==3&&hasSenzor){
			if(s==null){
			s = new Senzor(SID);
			SID++;
			}
			osc.send(s.id);
		}


	}

	void draw(){



		if(state>0){

			noStroke();
			if(hasSenzor)
				fill(#ffcc00);
			else
				fill(col[state]);
			rect(x*scaler,y*scaler,scaler,scaler);
		}

		if(sel){
			stroke(255);
			fill(col[state]);
			rect(x*scaler,y*scaler,scaler,scaler);
		}
		sel=false;



	}

	void compute(){

		//is wire?
		if(state>0){

			if(state==3){
				nextState = 2;
			}else if(state==2){
				nextState=	1;
			}else if(state==1){
				nextState=1;

				int q = getStates(3);
				if(q==1||q==2){
					nextState=3;
				}
			}

		}else{
			nextState=0;
		}

	}

	void update(){
		state=nextState;
	}

	int getStates(int wh){
		int cnt = 0;

		if(c[(x+c.length-1)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length-1)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length-1)%c.length][(y+c[0].length)%c[0].length].state==wh)cnt++;

		return cnt;

	}

	void calm(){

		if(state>0){
			nextState=1;
			update();
		}

	}
}

class OSC{
	OscP5 osc;
	NetAddress addr;
	int port;

	//////////////////////////////////////////////////////////

	OSC(String _addr,int _port){
		port=_port;
		osc = new OscP5(this,_port-1);
		addr = new NetAddress(_addr,port);
	}

	//////////////////////////////////////////////////////////


	void send(float _whatX,float _whatY,float _whatZ){
		OscMessage message = new OscMessage("/msg");
		//message.add("x ");
		message.add(_whatX);
		//message.add("y ");
		message.add(_whatY);

		message.add(_whatZ);
		osc.send(message, addr);


	}
	
	//////////////////////////////////////////////////////////

	void send(int _ident){
		OscMessage message = new OscMessage("/msg");
		int ident = (_ident);
		message.add(ident);
		//message.add(_what);
		osc.send(message, addr);
	}

	//////////////////////////////////////////////////////////

	void send(int _ident,float _what){
		OscMessage message = new OscMessage("/msg");
		int ident = (_ident);
		message.add(ident);
		message.add(_what);
		osc.send(message, addr);
	}

	//////////////////////////////////////////////////////////

	void send(String _ident,float _what){
		OscMessage message = new OscMessage("/msg");
		String ident = _ident+"";
		message.add(ident);
		message.add(_what);
		osc.send(message, addr);
	}

	//////////////////////////////////////////////////////////

}
/**
* WireWorlds OSC
*
* + .. zoomin
* - .. zoomout
* s .. ulozit stav do txt
* l .. nacist stav do txt
* spiky .. pohyb po plose
* DEL .. clrscreen
* ENTER .. zazehni signal na pozici
* L klik .. vytvor drat
* R klik vymaz drat
* e .. nasadit senzor
* INSERT .. ulozit do bmp
* HOME .. nacist z png
* q .. exit
* a .. nahravani videa .. vyzaduje GStreamer lib
*/



//import codeanticode.gsvideo.*;
import netP5.*;
import oscP5.*;

// globalni rozliseni
int plochaX = 200;
int plochaY = 100;

//GSMovieMaker mm;
OSC osc;
Receiver rece[] = new Receiver[0];

int X, Y;
int SID = 0;
//Recorder r;

boolean emit = true;
boolean rec = false;
boolean receive = true;

int top = 4;
int numx = plochaX/top,numy = plochaY/top;

Cell c[][] = new Cell[numx*top][numy*top];
color col[] = {color(0),color(50),color(120),color(255)};

int shiftx=0,shifty=0;

int scaler = 4;
String filename;

boolean somecells = false;

void setup(){
	size(plochaX,plochaY,P2D);
	background(0);

	noCursor();

	filename =  "machines/looper_"+c.length+"x"+c[0].length;

	frameRate(25);

	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			c[x][y] = new Cell(x,y);
		}
	}

	/*if(rec){
		mm = new GSMovieMaker(this,width,height,"out/out.avi",GSMovieMaker.X264,GSMovieMaker.BEST,25);
		mm.start();
}*/


	//for(int x=0;x<c.length;x++){
	//	c[x][30].state=1;
	//}

	noStroke();


}


void initOSC(){
	osc = new OSC("127.0.0.1",12000);
}

void loadState(){
	try{
		String temp[] = loadStrings(filename+".txt");

		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].state = parseInt(temp[y].charAt(x))-48;
			}
		}

	}catch(NullPointerException e){
		println("no such a file, please save before");
	}
	println("machine loaded: "+filename+".txt");
}

void saveState(){

	String data[] = new String[0];

	for(int y=0;y<c[0].length;y++){
		data = (String[])expand(data,data.length+1);
		data[data.length-1] = "";
		for(int x=0;x<c.length;x++){
			data[data.length-1]+=c[x][y].state!=0?"1":"0";
		}
	}

	saveStrings(filename,data);
	println("saved as: "+filename+".txt");
}


void loadStateFromImage(){

	if(emit)
		initOSC();
	try{
		PImage temp = loadImage(filename+".png");

		if(temp.width==c.length&&temp.height==c[0].length){

			c = new Cell[plochaX][plochaY];
			for(int x=0;x<c.length;x++){
				for(int y=0;y<c[0].length;y++){

					c[x][y] = new Cell(x,y);
					if((brightness(color(temp.pixels[y*temp.width+x]))) == 255){
						c[x][y].state=1;
					}else if((red(color(temp.pixels[y*temp.width+x]))) == 146){
						//println( red(temp.pixels[y*temp.width+x]) );


						c[x][y].state=1;
						c[x][y].hasRece=true;

						rece = (Receiver[])expand(rece,rece.length+1);
						rece[rece.length-1] = new Receiver(x,y,rece.length-1);

						//println("got red no. "+(rece.length-1)+" on "+x+" : "+y);

					}else if((red(color(temp.pixels[y*temp.width+x]))) == 223){
						c[x][y].state=1;
						c[x][y].hasSenzor = true;
						//println( (red(color(temp.pixels[y*temp.width+x]))) );
					}else{
						c[x][y].state=0;
					}
				}
			}

			println("state loaded sucessfully from: "+filename+".bmp");
		}else{
			println("error: stored values does not correpondent to dimensions");
		}

	}catch(NullPointerException e){
		println("error: saved record does not found " +e);
	}
}

void saveStateToImage(){
	PImage temp = createImage(c.length,c[0].length,RGB);

	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			if(c[x][y].state>0){temp.pixels[y*temp.width+x]=color(255);}else{temp.pixels[y*temp.width+x]=color(0);}
		}
	}

	temp.save(filename+".bmp");
	println("state saved as image: "+filename+".bmp");
}

void draw(){
	background(0);

	step(1);

	pushMatrix();
	translate(-shiftx,-shifty);

	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			c[x][y].draw();
		}
	}

	noFill();
	stroke(255);
	rect(-1,-1,1,1);
	rect(c.length*scaler+1,-1,1,1);
	rect(-1,c[0].length*scaler+1,1,1);
	rect(c.length*scaler-1,c[0].length*scaler+1,1,1);
	noStroke();

	popMatrix();

	X = constrain((int)((mouseX/scaler)+shiftx/scaler),0,c.length-1);
	Y = constrain((int)((mouseY/scaler)+shifty/scaler),0,c[0].length-1);

	c[X][Y].sel=true;

	if(mousePressed){
		if(mouseButton==LEFT)
			c[X][Y].state=1;
		if(mouseButton==RIGHT)
			c[X][Y].state=0;
		if(mouseButton==3){
			c[X][Y].state=3;
			mousePressed=false;
		}
	}


}

void keyPressed(){
	if(key==' '){
		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].calm();
			}

		}
	}else if(key=='='){
		scaler++;
	}else if(key=='-'){
		scaler--;
	}else if(key =='s'){
		saveState();
	}else if(key =='l'){
		loadState();
	}else if(keyCode==LEFT){
		shiftx-=3;
	}else if(keyCode==RIGHT){
		shiftx+=3;
	}else if(keyCode==UP){
		shifty-=3;
	}else if(keyCode==DOWN){
		shifty+=3;
	}else if(keyCode==DELETE){
		for(int y=0;y<c[0].length;y++){
			for(int x=0;x<c.length;x++){
				c[x][y].state=c[x][y].nextState=0;
			}
		}
	}else if(keyCode==ENTER){
		c[X][Y].state=3;


	}else if(keyCode == 155){
		saveStateToImage();

	}else if(keyCode==36){
		loadStateFromImage();
	}else if(key == 'q'){

		exit();
	}else if(key == 'a'){
		rec=!rec;
	}else if(key == 'e'){
		if(!emit){
			//osc = new OSC("127.0.0.1",12000);
			emit = true;
			c[X][Y].s = new Senzor(SID);
			SID++;
		}

		c[X][Y].hasSenzor = !c[X][Y].hasSenzor;
	}


	scaler=constrain(scaler,1,top);
	keyPressed=false;
}

void step(int n){
	boolean anim = false;
	for(int y=0;y<c[0].length;y++){
		for(int x=0;x<c.length;x++){
			if(c[x][y].state>1){
				anim=true;
				break;
			}
		}
	}

	if(anim){
		if(frameCount%n==0){
			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y].act();
				}
			}

			for(int y=0;y<c[0].length;y++){
				for(int x=0;x<c.length;x++){
					c[x][y].update();
				}
			}
		}
	}

}

class Senzor{
	int id;
	float freq;

	Senzor(int _id){
		id=_id;
		freq = ceil(random(10))*16;
	}
}

class Receiver{
	int id;
	int x,y;
	Receiver(int _x,int _y,int _id){
		x=_x;
		y=_y;
		id=_id;
	}
}

class Cell{
	//state 0=black, 1=wire, 2= tail, 3=head
	int state = 0;
	int nextState = 0;
	int x,y;
	boolean sel = false;
	Senzor s;
	//Receiver r;
	boolean hasSenzor = false;
	boolean hasRece = false;

	Cell(int _x,int _y){
		x=_x;
		y=_y;


	}

	void act(){
		compute();

		if(state==3&&hasSenzor){
			if(s==null){
				s = new Senzor(SID);
				SID++;
			}
			osc.send(s.id);
		}


	}

	void draw(){



		if(state>0){

			noStroke();
			if(hasRece){
				fill(#ff0000);
			}else{

				if(hasSenzor)
					fill(#ffcc00);
				else
					fill(col[state]);
			}

			rect(x*scaler,y*scaler,scaler,scaler);
		}

		if(sel){
			stroke(255);
			fill(col[state]);
			rect(x*scaler,y*scaler,scaler,scaler);
		}
		sel=false;



	}

	void compute(){

		//is wire?
		if(state>0){

			if(state==3){
				nextState = 2;
			}else if(state==2){
				nextState=	1;
			}else if(state==1){
				nextState=1;

				int q = getStates(3);
				if(q==1||q==2){
					nextState=3;
				}
			}

		}else{
			nextState=0;
		}

	}

	void update(){
		state=nextState;
	}

	int getStates(int wh){
		int cnt = 0;

		if(c[(x+c.length-1)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length-1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length+1)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length-1)%c.length][(y+c[0].length+1)%c[0].length].state==wh)cnt++;
		if(c[(x+c.length-1)%c.length][(y+c[0].length)%c[0].length].state==wh)cnt++;

		return cnt;

	}

	void calm(){

		if(state>0){
			nextState=1;
			update();
		}

	}
}

class OSC{
	OscP5 osc;
	NetAddress addr;
	int port;

	//////////////////////////////////////////////////////////

	OSC(String _addr,int _port){
		port=_port;
		osc = new OscP5(this,_port-1);
		addr = new NetAddress(_addr,port);
	}

	//////////////////////////////////////////////////////////


	void send(float _whatX,float _whatY,float _whatZ){
		OscMessage message = new OscMessage("/msg");
		//message.add("x ");
		message.add(_whatX);
		//message.add("y ");
		message.add(_whatY);

		message.add(_whatZ);
		osc.send(message, addr);


	}

	//////////////////////////////////////////////////////////

	void send(int _ident){
		OscMessage message = new OscMessage("/msg");
		int ident = (_ident);
		message.add(ident);
		//message.add(_what);
		osc.send(message, addr);
	}

	//////////////////////////////////////////////////////////

	void send(int _ident,float _what){
		OscMessage message = new OscMessage("/msg");
		int ident = (_ident);
		message.add(ident);
		message.add(_what);
		osc.send(message, addr);
	}

	//////////////////////////////////////////////////////////

	void send(String _ident,float _what){
		OscMessage message = new OscMessage("/msg");
		String ident = _ident+"";
		message.add(ident);
		message.add(_what);
		osc.send(message, addr);
	}

	//////////////////////////////////////////////////////////

	void oscEvent(OscMessage theOscMessage) {

		if(receive){
			int tmp = theOscMessage.get(0).intValue();
			tmp = constrain(tmp,0,rece.length-1);
			c[rece[tmp].x][rece[tmp].y].state = 3;
		}
		//println("/impulse");



		//print("### received an osc message.");
		//print(" addrpattern: "+theOscMessage.addrPattern());
		//println(" typetag: "+theOscMessage.typetag());
	}

}
// values to modify


for(int i = 0; i<20;i++){
int value = 60;
color white = color(255);
color myBlack = color(0);

background(myBlack);

stroke(random(255),random(255),random(255),255);
fill(random(255),random(255),random(255));
rect(random(40),random(40),random(40), random(255) );

stroke(random(255));
fill(random(255),random(255),random(255));
rect(random(40),random(40),random(255),random(255));
save("test"+i+".png");

}
exit();
import processing.serial.*;
import cc.arduino.*;

boolean listen = true;


Arduino arduino;

float smoothv = 0;

void setup() {


	size(600,300,P2D);

	println(Arduino.list());
	arduino = new Arduino(this, Arduino.list()[0], 57600);

	frameRate(25);


	for (int i = 0; i <= 13; i++)
		arduino.pinMode(i, Arduino.OUTPUT);
	//arduino.pinMode(0,Arduino.INPUT);
	background(0);
}

int cnt=0;

void draw(){

	//background(0);

	stroke(255);


	int a = arduino.analogRead(0);
	smoothv += (a-smoothv)/3.0;


	//arduino.digitalWrite(13,Arduino.HIGH);


	line(cnt,map(smoothv,0,120,height,0),cnt+1,map(smoothv,0,120,height,0));


	cnt += 1;
	if(cnt>width){
		background(0);
		cnt=0;
	}

	println(a);


}



Recorder r;
boolean rec = false;

import krister.Ess.*;


Node[] n = new Node[12];
PImage shape1 ;


AudioStream myStream;
float[] streamBuffer;

int y  = 0;

void setup()
{

	size(720,576/2,OPENGL);
	background(0);
	frameRate(25);
	smooth();
	
	Ess.start(this);

	myStream=new AudioStream();
	myStream.sampleRate(44100/4);
	myStream.bufferSize(width*2);
	streamBuffer=new float[myStream.size];
	myStream.start();
	
	shape1 = loadImage("shape1.png");
	
	y = height /2;
	strokeWeight(1.77);
	
	for(int i =0;i<n.length;i++)
	{
		n[i] = new Node(i);
	}

	
	if(rec)
		r = new Recorder("out","fluental");

}



void audioStreamWrite(AudioStream theStream) {
	System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
}

void fillAudioBufferL(){
	loadPixels();

	int cnt =0;
	for(int X=0; X<width; X++) {
		streamBuffer[cnt] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
	}
	
	for(int X=width-1; X>=0; X--) {
		streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
		}

	//y=(int)((sin(frameCount/30.0)+1.0)*height/2.0);// width/3;//mouseY;
	y=height/2;//y%height;

}


public void stop() {
	Ess.stop();
	super.stop();
}

void draw()
{
	background(0);
	//fill(0,90);
	//rect(0,0,width,height);
	
	for(int i =0;i<n.length;i++)
	{
		n[i].live();
	}	

	
	fillAudioBufferL();
	
	stroke(255,90);
	line(0,height/2,width,height/2);
	
	if(rec)
		r.add();
}

void keypressed(){
	if(key=='q')
	{
		if(rec)
		r.finish();
		exit();
	}
}

void BBox(){

	//pushMatrix();
	
	
	pushMatrix();
	translate(width/2.0,height/2.0);
	rotateY(radians(frameCount/3.0));
	noFill();
	noTint();
	stroke(0,10);
	box(400);

	
	popMatrix();


	
	//popMatrix();

}

class Node
{
	float x,y,sx,sy,speed = 60.0;
	float pulsar = 0;
	float pulseSpeed;
	int id;
	float area,areaB = 40.0;
	color c;

	Node(int _id)
	{
		id = _id;
		sx = x = random(width);
		sy = y = random(height);
		
		areaB = random(5,200);
		area = areaB;
		
		pulsar = random(1000)/100.0;
		pulseSpeed = random(4,3000);

		c = color(255);//color(random(255));
	}

	void seek()
	{

		area = 1+areaB*(sin(pulsar/pulseSpeed)+1.0)/2.0;
		pulsar +=2*(sin(frameCount/3.0)+1.0)*150.0;
		
		Node tmp = getNearest();

		if(dist(sx,sy,tmp.sx,tmp.sy)>=area+1){

			x += (tmp.x-x)/speed;
			y += (tmp.y-y)/speed;
		}else if(dist(sx,sy,tmp.sx,tmp.sy)<=area){

			x -= (tmp.x-x)/(speed*0.033);
			y -= (tmp.y-y)/(speed*0.033);

		}

		//stroke(255,40);
		//line(tmp.sx,tmp.sy,sx,sy);

	}
	
	void bordr()
	{
	
		if(x>width-area/2.0)x=width-area/2.0;
		if(x<area/2.0)x=area/2.0;
		
		
		if(y>height-area/2.0)y=height-area/2.0;
		if(y<area/2.0)y=area/2.0;
		
	
	}

	Node getNearest()
	{
		float lenn = width * height;
		Node a = this;

		for(int i = 0;i<n.length;i++)
		{

			float temp = dist(x,y,n[i].x,n[i].y);
			if(lenn>temp && i != id)
			{
				lenn = temp;
				a = null;
				a = n[i];
			}

		}

		return a;

	}


	void connect()
	{




	}

	void pulse()
	{


	}

	void live()
	{

		seek();
		bordr();
		
		//x+=(mouseX-x)/(abs(x-mouseX)+1);
		//y+=(mouseY-y)/(abs(y-mouseY)+1);
		
		sx += (x-sx)/1000.0;
		
		sy += (y-sy)/1000.0;
		//sy += (sin(x/30.0)*50.0-sy+height/2)/3.0;
		
		pushStyle();
		noFill();
		stroke(255,80);
		rectMode(CENTER);
		//imageMode(CENTER);
		
		for(float i = 0 ;i<250;i+=8+map(area,0,250,10,-5)){
		stroke(c,90);
		ellipse(sx,sy,i,i);
		}
		
		//tint(c,90);
		//image(shape1,sx,sy,area*2,area*2);
		
		//ellipse(sx,sy,area,area);

		//rect(sx,sy,3,3);
		popStyle();

	}



}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
String[] data;
String[] dates;

String[] DMD;

int[] played;
int[] liked;
int maxplayed = 0;
int maxliked = 0;
float smoo;

void setup(){


	size(600,300,P3D);
	
	grabStat();
	
	textFont(createFont("Pixel",8));
	textMode(SCREEN);

	data = loadStrings("vals.txt");
	dates = loadStrings("dates.txt");
	
	println(data.length+" <---> "+dates.length+" should be the same number");
	
	if(data.length!=dates.length){
		println("parsing error! the number of values has no propried dates");
		exit();
	}else{

	parseData();
	}
	background(255);
}

void draw(){

	background(255);
	
	noFill();
	stroke(0,155);
	
	smoo = map(mouseY,0,height,300,2);
	
	float prum = 0;
	
	beginShape();
	for(int i = 0;i<data.length;i++){
		
		float x = map(i,0,data.length,0,width);
		float val = map(played[i],0,maxplayed,height,0);
		
		if(i==0)
			prum = val;
		
		vertex(x,val);
		prum += (val-prum)/smoo;
		if(abs(x-mouseX)<2){
		text(DMD[i],x,prum);
		fill(0,50);
		}
		point(x,prum);
	}
	
	endShape();
	
	
	/*
	stroke(255,0,0,155);
	
	beginShape();
	for(int i = 0;i<data.length;i++){
		vertex(map(i,0,data.length,0,width),map(liked[i],0,maxliked,height,0));
	
	}
	
	endShape();
*/

}

public class SomeException extends Exception {
    public SomeException() {
      super(); // calls Exception(), which ultimately calls Object()
    }
    public SomeException(String s) {
      super(s); // calls Exception(String), to pass argument to base class
    }
    public SomeException (int error_code) {
      this("error"); // class constructor above, which calls super(s)
      System.err.println(error_code);
    }
}


void parseData(){
	int result[][] = new int[2][data.length];
	DMD = new String[data.length];
	liked = new int[data.length];
	played = new int[data.length];
	
	for(int i = 0;i<data.length;i++){
		String tmp = data[i];
		String tmp2[] = splitTokens(tmp," ");
		
		played[i] = parseInt(tmp2[4]);
		liked[i] = parseInt(tmp2[7]);
		
		if(maxplayed<played[i])
			maxplayed=played[i];
		
		if(maxliked<liked[i])
			maxliked=liked[i];
		
		tmp = dates[i];
		tmp2 = splitTokens(tmp," ");
		DMD[i] = tmp2[2]+" "+tmp2[3]+" "+tmp2[4];
	}

}



void grabStat(){

	try{
		Runtime.getRuntime().exec("xterm -e grabstat");
		println("grabbing data");
	}catch(java.io.IOException e){
		println(e);
	}
}
