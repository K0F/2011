
int num = 8000;

float GLOB = 1.0;
Migra m[];

int xs[],ys[];
int len = 77;

void setup(){
	size(800,300,P2D);
	background(0);


	xs = new int[len];
	ys = new int[len];

	for(int i = 0;i<xs.length;i++){
		float a = random(100);
		if(a<25){
			xs[i]=1;
		}else if(a<50){
			xs[i]=-2;
		}else if(a<75){
			ys[i]=1;

		}else{
			ys[i]=-1;
		}
		
	}

	m = new Migra[num];

	for(int i = 0;i<m.length;i++)
		m[i] = new Migra(width/3*2,(int)map(i,0,m.length,0,height));


	loadPixels();
}




void draw(){

	//background(0);

	//loadPixels();
	

	tint(23,2,0,noise(frameCount/10.0)*25);
	image(g,-1,random(-1,1));//xs[frameCount%xs.length],ys[frameCount%ys.length]);

	for(int i = 0;i<m.length;i++){	
		m[i].compute();
		m[i].draw();
	}


pushMatrix();
	translate(random(-5,5),random(-5,5));


	pushStyle();

	for(int i = 0;i<5000;i++){
	stroke(random(255),18);
	strokeWeight(random(1.25,2));
	point(random(width),random(height));
	}

	popStyle();

popMatrix();


pushMatrix();

	pushStyle();
        noFill();
        stroke(0,180);
        strokeWeight(10);
        rect(0,0,width,height);

	popStyle();
popMatrix();

}

class Migra{
	
	int x,y;
	int tlak;
	float speed = 30.0;

	Migra(int _x,int _y){
		x = _x;
		y = _y;
		tlak = 255;//(int)random(255);
		speed = GLOB;//.01387263;
		GLOB+=0.124314;
	}


	void compute(){


		if(x>width)x=0;
                if(x<0)x=width;
		if(y>height)y=0;
                if(y<0)y=height;

		int brigh = 1;//(int)(brightness(pixels[constrain(y*width+x,0,pixels.length-1)]))+1;

		if(noise(frameCount/speed) > 0.75){
			x+=brigh;
		}else if(noise(frameCount/speed) > .5){
			x-=brigh;
		}else if(noise(frameCount/speed) > .25){
			y+=brigh;
                }else{
			y-=brigh;
                }




	}

	void draw(){
		stroke(255,90);
		point(x,y);
		
	}


}

PGraphics vignette;

void setup(){
  size(480,320,P2D);

  frameRate(50);
  rectMode(CENTER);
  noFill();
  stroke(255,220);
  smooth();

  vignette = createGraphics(width+20,height+20,JAVA2D);
  vignette.beginDraw();
  vignette.smooth();
  vignette.noFill();
  vignette.strokeWeight(1.5);
  for(int i = 0;i<width*2;i++){
    vignette.stroke(0,map(i,0,width*2,0,255));
    vignette.ellipse(vignette.width/2,vignette.height/2,i,i);

  }
  vignette.endDraw();

}


void draw(){
  //background(0);
  pushStyle();
  fill(0,120);
  rect(width/2,height/2,width,height);
  popStyle();

pushMatrix();
  translate(random(-1,1),random(-1,1));

  for(int i = 0;i<400;i+=2){
    pushMatrix();
    translate(width/2,height/2);
    rotate(frameCount*(1.0+i/400.0*noise(frameCount/300.0)));
    stroke(255,noise((frameCount-i)/30.0)*220);
    rect(0,0,5+i,5+i);
    popMatrix();
  }
  
  
  popMatrix();
  
  //tint(random(200,255),random(200,255),30,180);
  //tint(255,120);
  image(vignette,random(-20),random(-20));


  //tint(random(200,255),random(200,255),12,150);
  //image(g,random(-2,2),random(-2,2));


  pushStyle();
  strokeWeight(10);
  stroke(0);
   noFill();
   
  rect(width/2,height/2,width,height);
  popStyle();

}


PGraphics vignette;

void setup(){
  size(480,320,P2D);

  frameRate(50);
  rectMode(CENTER);
  noFill();
  stroke(255,220);
  smooth();

  vignette = createGraphics(width+20,height+20,JAVA2D);
  vignette.beginDraw();
  vignette.smooth();
  vignette.noFill();
  vignette.strokeWeight(1.5);
  for(int i = 0;i<width*2;i++){
    vignette.stroke(0,map(i,0,width*2,0,255));
    vignette.ellipse(vignette.width/2,vignette.height/2,i,i);

  }
  vignette.endDraw();

}


void draw(){
  //background(0);
  pushStyle();
  fill(0,120);
  rect(width/2,height/2,width,height);
  popStyle();

pushMatrix();
  translate(random(-1,1),random(-1,1));

  for(int i = 0;i<400;i+=2){
    pushMatrix();
    translate(width/2,height/2);
    rotate(frameCount*(1.0+i/400.0*noise(frameCount/300.0)));
    stroke(255,noise((frameCount-i)/30.0)*220);
    rect(0,0,5+i,5+i);
    popMatrix();
  }
  
  
  popMatrix();
  
  //tint(random(200,255),random(200,255),30,180);
  //tint(255,120);
  image(vignette,random(-20),random(-20));


  //tint(random(200,255),random(200,255),12,150);
  //image(g,random(-2,2),random(-2,2));


  pushStyle();
  strokeWeight(10);
  stroke(0);
   noFill();
   
  rect(width/2,height/2,width,height);
  popStyle();

}

import processing.pdf.*;

int[][] field;
Signal s[];
int NUM = 90;
boolean change[][];

Recorder r;
boolean rec = false;

int tl = 1;

int cout = 0;

boolean render = false;

void setup() {

// a3 = 4960 x 3507 
  size(3506/2, 4960/2 ,P2D);


  frameRate(25);

  field = new int[width][height];
  for(int ii = 0; ii< field[0].length;ii++) {
    for(int i = 0; i< field.length;i++) {
      field[i][ii] = 5;//(int)random(8);
      //print(field[i][ii]);
    }
  }


  change = new boolean[width][height];
  for(int ii = 0; ii< change[0].length;ii++) {
    for(int i = 0; i< change.length;i++) {
      change[i][ii] = false;//(int)random(8);
      //print(field[i][ii]);
    }
  }

  s = new Signal[NUM];
  for(int i = 0;i<s.length;i++)
    s[i] = new Signal();


  if(rec) {

    r = new Recorder("fields","timeLapse"+tl);
  }

  background(0);


  if(render) {
    beginRecord(PDF, "screen.pdf");
 
  }
}


void draw() {


if(!render){
 //   if(frameCount<10)
   //   background(0);

    //colorizeField();

    //
}

    change = new boolean[width][height];
    for(int ii = 0; ii< change[0].length;ii++) {
      for(int i = 0; i< change.length;i++) {
        change[i][ii] = false;//(int)random(8);
        //print(field[i][ii]);
      }
    }

    cout = s.length*2;

    for(int i = 0;i<s.length;i++)
      s[i].update();


if(frameCount>1100){
	fade(5);
    for(int i = 0;i<s.length;i++)
      s[i].draw();
      if(frameCount>1450){
      save("print.png");
      exit();
      }
      }else{
      println(frameCount);
      }


    if(rec&&frameCount%tl==0) {
      //filter(BLUR,1.5);
      r.add();
    }
  }

  void keyReleased() {
    if(key=='q') {
      if(rec)
        r.finish();
      exit();
    }
    else if(key == 'r') {
      endRecord();
      exit();
    }
  }

  void fade(int al) {
    fill(0,al);
    noStroke();
    rect(0,0,width,height);
  }

  void colorizeField() {
    for(int yy = 0;yy<height;yy++) {
      for(int xx = 0;xx<width;xx++) {
        if(field[xx][yy]%2==0) {
          	fill(255,15);
		noStroke();
        }
        else {
		fill(0,15);
          noStroke();
        }
        //stroke(lerpColor(#ff0000,#00ff00,norm(field[xx][yy],0,7) ), 15);
        rect(xx,yy,1,1);
      }
    }
  }

  class Signal {

    int x,y;
    int nx,ny;

    Signal() {
      x = (int)random(width);
      y = (int)random(height);
    }

    Signal(int _x,int _y) {
      x = _x;
      y = _y;
    }

    void update() {

      if(field[x][y]==0) {
        nx = (x + width - 1)%width;
        ny = (y + height - 1)%height;
      }
      else if(field[x][y]==1) {
        nx = (x + width + 0)%width;
        ny = (y + height - 1)%height;
      }
      else if(field[x][y]==2) {
        nx = (x + width + 1)%width;
        ny = (y + height - 1)%height;
      }
      else if(field[x][y]==3) {
        nx = (x + width + 1)%width;
        ny = (y + height + 0)%height;
      }
      else if(field[x][y]==4) {
        nx = (x + width + 1)%width;
        ny = (y + height + 1)%height;
      }
      else if(field[x][y]==5) {
        nx = (x + width + 0)%width;
        ny = (y + height + 1)%height;
      }
      else if(field[x][y]==6) {
        nx = (x + width - 1)%width;
        ny = (y + height + 1)%height;
      }
      else if(field[x][y]==7) {
        nx = (x + width - 1)%width;
        ny = (y + height + 0)%height;
      }

      if(!change[x][y]) {
        field[x][y] = (field[x][y]+2)%8;//(int)random(4);
        change[x][y] = true;
      }

      if(frameCount%10==0&&s.length<=cout&&random(100)<5) {

        expa();
      }

      x = nx;
      y = ny;
    }

    void expa() {
      s = (Signal[])expand(s,s.length+1);
      s[s.length-1] = new Signal((x+1)%width,y);
    }

    void draw() {
      pushMatrix();
      translate(x,y);
      //noStroke();
      stroke(255,100);//map(frameCount,0,100,0,120));
      point(0,0);
      popMatrix();
    }

    int computeNextStep() {
      int tmp = 0;


      return tmp;
    }
  }

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import processing.opengl.*;

void setup(){
	size(1024,768,OPENGL);
	background(255);


}

int y=0;

void draw(){
	line(0,y,width,y++);	



}
import ddf.minim.*;
import ddf.minim.signals.*;

Minim minim;
AudioOutput out;
SineWave sine;

void setup()
{
  size(512, 200, P2D);
  
  minim = new Minim(this);
  
  // get a line out from Minim, default sample rate is 44100, default bit depth is 16
  out = minim.getLineOut(Minim.STEREO, 2048);
  
  // create a sine wave Oscillator, set to 440 Hz, at 0.5 amplitude, sample rate 44100 to match the line out
  sine = new SineWave(440, 0.5, out.sampleRate());
  // add the oscillator to the line out
  out.addSignal(sine);
}

void draw()
{
  background(0);
  stroke(255);
  // draw the waveforms
  for(int i = 0; i < out.bufferSize() - 1; i++)
  {
    line(i, 50 + out.left.get(i)*50, i+1, 50 + out.left.get(i+1)*50);
    line(i, 150 + out.right.get(i)*50, i+1, 150 + out.right.get(i+1)*50);
  }
}


void stop()
{
  // always close Minim audio classes when you are done with them
  out.close();
  minim.stop();

  super.stop();
}
Neuron n[];
Signal s[];

boolean render = true;

float sx,sy;

void setup(){

	size(800,480,P2D);

	n = new Neuron[3000];

	for(int i = 0;i<n.length;i++)
		n[i] = new Neuron(i,random(-width,width*2),random(-height,height*2));


	for(int i = 0;i<n.length;i++)
		n[i].makeSynapse();

	rectMode(CENTER);


	n[0].makeSignal(0);
	n[1].makeSignal(0);
	n[2].makeSignal(0);
	
	background(0);
	sx = sy = 0;

	textFont(createFont("Veranda",9,false));
	textMode(SCREEN);
}


void draw(){
	//background(255);

	fill(0,80);
	rect(width/2,height/2,width,height);
	
	
	
	
	pushMatrix();

	translate(width/2.5+(sx-width/2)*0.1,height/2.5+(sy-height/2)*0.1);
	scale(0.2);
	
	
	int cnt = 0;
	for(int i = 0;i<n.length;i++){
		for(int q = 0;q<n[i].sig.length;q++){
			if(n[i].sig[q].running){
				cnt ++;
				sx -= (n[i].sig[q].x+sx)/(n.length*5);
				sy -= (n[i].sig[q].y+sy)/(n.length*5);
			}
		}
	}
	
	
	for(int i = 0;i<n.length;i++)
		n[i].draw();

	
	popMatrix();
	
	if (render){
		saveFrame("out/neuro####.png");
		println(frameCount);
	}
	
	pushStyle();
	fill(0);
	noStroke();
	rect(40,20,80,40);
	fill(255);
	text(cnt,20,10);
	popStyle();

}

class  Neuron{
	int id;
	float x,y,val;
	float radius = 150.0;

	Synapse s[];
	Signal sig[];

	Neuron(int _id,float _x,float _y){
		id=_id;
		x=_x;
		y=_y;
	}

	void makeSynapse(){
		s = new Synapse[0];
		sig = new Signal[0];

		for(int i = 0;i<n.length;i++){
			if(i!=id && dist(x,y,n[i].x,n[i].y)<=radius&&noise(i/100.0)<0.6){
				s = (Synapse[])expand(s,s.length+1);
				s[s.length-1] = new Synapse(id,i);

				sig = (Signal[])expand(sig,sig.length+1);
				sig[sig.length-1] = new Signal(s[s.length-1]);

			}
		}
	}



	void makeSignal(int which){
		int i = which;
		sig[i].x = x;
		sig[i].y = y;
		sig[i].running = true;
	}




	void drawSynapse(){


		if(sig.length>0){
			for(int i = 0;i<sig.length;i+=1){
				if(sig[i].running){
					pushStyle();
					stroke(255,90);
					noFill();
					rect(sig[i].x,sig[i].y,1,1);
					popStyle();
					sig[i].step();
				}
			}
		}


		stroke(#ffcc11,3);
		for(int i = 0;i<s.length;i+=1){
			line(n[s[i].B].x,n[s[i].B].y,x,y);
		}




	}

	void draw(){
		drawSynapse();
		//move();
	}

	void move(){
		x+=(noise(id+frameCount/10.0)-.5);
		y+=(noise(id*5+frameCount/10.0)-.5);
	}

}

class Synapse{

	float weight = 1.5;
	int A,B;

	Synapse(int _A, int _B){

		A=_A;
		B=_B;

		weight = random(1001,1100)/300.0;

	}

}

class Signal{

	Synapse base;
	int cyc = 0;
	float x,y;
	float speed = 1.1;

	boolean running = false;
	boolean visible = true;

	int deadnum = 50;
	int deadcount = 0;

	Signal(Synapse _base){
		base = _base;
		x = n[base.A].x;
		y = n[base.A].y;
		speed *= base.weight;
	}

	void step(){
		running = true;

		x += (n[base.B].x-x) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
		y += (n[base.B].y-y) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);



		if(dist(x,y,n[base.B].x,n[base.B].y)<1.0){

			if(deadcount<0){
				deadcount = deadnum;

				//deadnum += (int)random(-1,1);
				//println("run "+base.A+" : "+base.B);

				running = false;
				for(int i = 0; i < n[base.B].s.length;i++){
					if(!n[base.B].sig[i].running){
						n[base.B].makeSignal(i);
						n[base.B].sig[i].base.weight += (base.weight-n[base.B].sig[i].base.weight)/((dist(x,y,n[base.A].x,n[base.A].y)+1.0)/2.0);
					}

				}

				//base.weight = random(1001,3000) / 1000.0;

				x=n[base.A].x;
				y=n[base.A].y;


			}else{
				deadcount--;


			}
		}
	}
}




/**
* Free Form construction by Kof 2010
*
*/


import peasy.*;



//////////////////////////////// >

PeasyCam cam;

Rez o[] = new Rez[200];

//////////////////////////////// >
void setup(){

	size(800,480,P3D);
	noStroke();
	fill(0,30);

	noSmooth();

	for(int i = 0;i<o.length;i++)
		o[i] = new Rez(i);

	cam = new PeasyCam(this, 800);
	cam.setMinimumDistance(600);
	cam.setMaximumDistance(3000);

	textFont(loadFont("Norasi-Italic-16.vlw"));
	textMode(SCREEN);

}



//////////////////////////////// >
void draw(){


	background(255);
	stroke(0,10);
	for(int i = -o.length/2;i<o.length/2;i+=2){

		//   line(i*5,600,0,i*5,0,0);
		//    line(0,i*5,600,0,i*5,0);

		line(-300,-300,i*5,-300,300,i*5);
		line(-300,300,i*5,300,300,i*5);
		line(-300,300,i*5,300,300,i*5);
	}

	stroke(#6A4B2F,40);

	pushMatrix();
	resetMatrix();
	scale(0.001);
	translate(-738,-369);
	
	
	
	for(int n = 0;n<o.length;n++){
		beginShape();
		for(int i = 0;i<o[0].q;i++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],o[n].ys[i],0);
		}
		endShape(CLOSE);
	}
	
	
	line(-width,0,width*3,0);
	line(0,-width,0,width*3);
	
	translate(507,0);
	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].zs[i],o[n].ys[i]);
		}
		endShape();
	}

	translate(-507,507);
	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],o[n].zs[i]);
		}
		endShape();
	}

	popMatrix();

	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],300,o[n].zs[i]);
		}
		endShape();
	}



	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(-300,o[n].ys[i],o[n].zs[i]);
		}
		endShape();
	}


	fill(0,120);
	text("Freeform construcion by Kof",width-220,height-10);

	noFill();
	for(int i = 0;i<o.length;i++){
		o[i].draw();
	}

	pushStyle();
	noFill();
	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],o[n].ys[i],o[n].zs[i]);
		}
		endShape();
	}
	popStyle();


	line(-width/4,0,0,width/4,0,0);
	line(0,-width/4,0,0,width/4,0);
	line(0,0,-600,0,0,600);
}

//////////////////////////////// >
class Rez{
	float x,y,r;
	float step = 0.3;
	int id;
	float xs[],ys[],zs[];
	int q = 0;

	Rez(int _id){
		id = _id;
		x = width/2;
		y = height/2;
		r = 40;


		for(float f = -PI;f < PI;f+=step)
			q++;

		xs = new float[q];
		ys = new float[q];
		zs = new float[q];
	}

	void draw(){

		r  = noise((frameCount+id)/100.33)*120+noise((frameCount+id)/1000.43)*21+4;
		beginShape();
		int i = 0;
		for(float f = -PI;f < PI;f+=step){
			xs[i] = cos(f)*r*2*noise(cos(f/2.0)+id/10.0+frameCount/20.0)+(noise((id+frameCount)/101.0)-0.5)*500;
			ys[i] = sin(f)*r*2*noise(sin(f/2.0)+id/10.0+frameCount/20.1)+(noise((id+frameCount)/111.0)-0.5)*500;
			zs[i] = id*5-((o.length/2)*5);

			stroke(0,(sin(f)+1)*70);
			vertex(xs[i],ys[i],zs[i]);
			i++;
		}
		endShape(CLOSE);
	}
}
/**
* Free Form construction by Kof 2010
*
*/


import peasy.*;



//////////////////////////////// >

PeasyCam cam;

Rez o[] = new Rez[200];

//////////////////////////////// >
void setup(){

	size(800,480,P3D);
	noStroke();
	fill(0,30);

	noSmooth();

	for(int i = 0;i<o.length;i++)
		o[i] = new Rez(i);

	cam = new PeasyCam(this, 800);
	cam.setMinimumDistance(600);
	cam.setMaximumDistance(3000);

	textFont(loadFont("Norasi-Italic-16.vlw"));
	textMode(SCREEN);

}



//////////////////////////////// >
void draw(){


	background(255);
	stroke(0,10);
	for(int i = -o.length/2;i<o.length/2;i+=2){

		//   line(i*5,600,0,i*5,0,0);
		//    line(0,i*5,600,0,i*5,0);

		line(-300,-300,i*5,-300,300,i*5);
		line(-300,300,i*5,300,300,i*5);
		line(-300,300,i*5,300,300,i*5);
	}

	stroke(#6A4B2F,40);

	pushMatrix();
	resetMatrix();
	scale(0.001);
	translate(-738,-369);
	
	
	
	for(int n = 0;n<o.length;n++){
		beginShape();
		for(int i = 0;i<o[0].q;i++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],o[n].ys[i],0);
		}
		endShape(CLOSE);
	}
	
	
	line(-width,0,width*3,0);
	line(0,-width,0,width*3);
	
	translate(507,0);
	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].zs[i],o[n].ys[i]);
		}
		endShape();
	}

	translate(-507,507);
	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],o[n].zs[i]);
		}
		endShape();
	}

	popMatrix();

	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],300,o[n].zs[i]);
		}
		endShape();
	}



	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			//stroke(0,(sin(i/o.length)+1)*30);
			vertex(-300,o[n].ys[i],o[n].zs[i]);
		}
		endShape();
	}


	fill(0,120);
	text("Freeform construcion by Kof",width-220,height-10);

	noFill();
	for(int i = 0;i<o.length;i++){
		o[i].draw();
	}

	pushStyle();
	noFill();
	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],o[n].ys[i],o[n].zs[i]);
		}
		endShape();
	}
	popStyle();


	line(-width/4,0,0,width/4,0,0);
	line(0,-width/4,0,0,width/4,0);
	line(0,0,-600,0,0,600);
}

//////////////////////////////// >
class Rez{
	float x,y,r;
	float step = 0.3;
	int id;
	float xs[],ys[],zs[];
	int q = 0;

	Rez(int _id){
		id = _id;
		x = width/2;
		y = height/2;
		r = 40;


		for(float f = -PI;f < PI;f+=step)
			q++;

		xs = new float[q];
		ys = new float[q];
		zs = new float[q];
	}

	void draw(){

		r  = noise((frameCount+id)/100.33)*120+noise((frameCount+id)/1000.43)*21+4;
		beginShape();
		int i = 0;
		for(float f = -PI;f < PI;f+=step){
			xs[i] = cos(f)*r*2*noise(cos(f/2.0)+id/10.0+frameCount/20.0)+(noise((id+frameCount)/101.0)-0.5)*500;
			ys[i] = sin(f)*r*2*noise(sin(f/2.0)+id/10.0+frameCount/20.1)+(noise((id+frameCount)/111.0)-0.5)*500;
			zs[i] = id*5-((o.length/2)*5);

			stroke(0,(sin(f)+1)*70);
			vertex(xs[i],ys[i],zs[i]);
			i++;
		}
		endShape(CLOSE);
	}
}

Neuron n[];
Signal s[];

boolean render = false;

//////////////////////////////////////////////////////
void setup(){

	size(800,480,P2D);

	n = new Neuron[500];

	for(int i = 0;i<n.length;i++)
		n[i] = new Neuron(i,random(width),random(height));


	for(int i = 0;i<n.length;i++)
		n[i].makeSynapse();

	rectMode(CENTER);

        for(int i = 0;i<n[0].s.length;i++)
	n[0].makeSignal(i);
	//n[1].makeSignal(0);
	//n[2].makeSignal(0);

	background(0);

}

////////////////////////////////////////////////////////
void mousePressed(){
  
  for(int i = 0;i<n.length;i++){
		n[i].x = random(width);
        		n[i].y = random(height);
  }
  
	for(int i = 0;i<n.length;i++)
		n[i].makeSynapse();

        for(int i = 0;i<n[0].s.length;i++)
	n[0].makeSignal(i);
  
}

////////////////////////////////////////////////////////
void draw(){
	//background(255);

	pushStyle();
	fill(11,50);
	stroke(0,190);
	strokeWeight(20);
	rect(width/2,height/2,width,height);
	popStyle();

	pushMatrix();

	scale(1);

	for(int i = 0;i<n.length;i++)
		n[i].draw();


	popMatrix();

	if (render){
		saveFrame("out/neuro####.png");
		println(frameCount);
	}

}


/////////////////////////////////////////////////////////
class  Neuron{
	int id;
	float x,y,val,xx,yy;
	float radius = 60.0;

	Synapse s[];
	Signal sig[];

	Neuron(int _id,float _x,float _y){
		val = random(255);
		id=_id;
		xx = x=_x;
		yy = y=_y;
	}

	void makeSynapse(){
		s = new Synapse[0];
		sig = new Signal[0];

		for(int i = 0;i<n.length;i++){
			if(i!=id && dist(x,y,n[i].x,n[i].y)<=radius&&noise(i/100.0)<0.8){
				s = (Synapse[])expand(s,s.length+1);
				s[s.length-1] = new Synapse(id,i);

				sig = (Signal[])expand(sig,sig.length+1);
				sig[sig.length-1] = new Signal(s[s.length-1]);

			}
		}
	}



	void makeSignal(int which){
		int i = which;
		sig[i].x = xx;
		sig[i].y = yy;
		sig[i].running = true;
	}




	void drawSynapse(){
		if(sig.length>0){
			for(int i = 0;i<sig.length;i+=1){
				if(sig[i].running){
					pushStyle();
					strokeWeight(3);
					stroke(255,90);
					noFill();
					line(sig[i].x,sig[i].y,sig[i].lx,sig[i].ly);
					popStyle();
					sig[i].step();
				}
			}
		}


		//stroke(#ffcc11,3);
		stroke(lerpColor(#ffcc11,#ffffff,norm(val,0,255)),4);
		for(int i = 0;i<s.length;i+=1){
			line(n[s[i].B].xx,n[s[i].B].yy,xx,yy);
		}
	}

	void draw(){
		drawSynapse();
		xx += (x-xx) / 10.0;
		yy += (y-yy) / 10.0;
		//move();
	}

	void move(){
		x+=(noise(id+frameCount/10.0)-.5);
		y+=(noise(id*5+frameCount/10.0)-.5);
	}

}


///////////////////////////////////////////////////////
class Synapse{

	float weight = 1.5;
	int A,B;

	Synapse(int _A, int _B){

		A=_A;
		B=_B;

		weight = random(101,1100)/300.9;
	}

}

//////////////////////////////////////////////////////////
class Signal{

	Synapse base;
	int cyc = 0;
	float x,y,lx,ly;
	float speed = 10.1;

	boolean running = false;
	boolean visible = true;

	int deadnum = 200;
	int deadcount = 0;

	Signal(Synapse _base){
		deadnum = (int)random(2,400);
		base = _base;
		lx = x = n[base.A].x;
		ly = y = n[base.A].y;
		speed *= base.weight;
	}

	void step(){
		running = true;

		lx = x;
		ly = y;

		x += (n[base.B].xx-x) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
		y += (n[base.B].yy-y) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);



		if(dist(x,y,n[base.B].x,n[base.B].y)<1.0){

			if(deadcount<0){
				deadcount = deadnum;

				for(int i = 0;i<10;i++){
					fill(255,10);
					ellipse(x,y,1.5*i,1.5*i);
				}

				//deadnum += (int)random(-1,1);
				//println("run "+base.A+" : "+base.B);

				running = false;
				for(int i = 0; i < n[base.B].s.length;i++){
					if(!n[base.B].sig[i].running && base.A!=n[base.B].sig[i].base.B){
						n[base.B].makeSignal(i);
						n[base.B].sig[i].base.weight += (base.weight-n[base.B].sig[i].base.weight)/((dist(x,y,n[base.A].xx,n[base.A].yy)+1.0)/200.0);
					}

				}


				//base.weight = random(1001,3000) / 1000.0;

				n[base.A].xx+=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.A].id)/11.0);;
				n[base.A].yy+=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.A].id)/10.0);



				n[base.A].xx-=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.B].id)/10.0);;
				n[base.A].yy-=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.B].id)/11.0);

				lx = n[base.A].xx;
				ly = n[base.A].yy;

				n[base.A].val+=(n[base.B].val-n[base.A].val)/5.0;
			}else{

				deadcount--;
			}
		}
	}
}





Neuron n[];
Signal s[];

boolean render = false;

//////////////////////////////////////////////////////
void setup(){

	size(800,480,P2D);

	n = new Neuron[500];

	for(int i = 0;i<n.length;i++)
		n[i] = new Neuron(i,random(width),random(height));


	for(int i = 0;i<n.length;i++)
		n[i].makeSynapse();

	rectMode(CENTER);

        for(int i = 0;i<n[0].s.length;i++)
	n[0].makeSignal(i);
	//n[1].makeSignal(0);
	//n[2].makeSignal(0);

	background(0);

}

////////////////////////////////////////////////////////
void mousePressed(){
  
  for(int i = 0;i<n.length;i++){
		n[i].x = random(width);
        		n[i].y = random(height);
  }
  
	for(int i = 0;i<n.length;i++)
		n[i].makeSynapse();

        for(int i = 0;i<n[0].s.length;i++)
	n[0].makeSignal(i);
  
}

////////////////////////////////////////////////////////
void draw(){
	//background(255);

	pushStyle();
	fill(11,50);
	stroke(0,190);
	strokeWeight(20);
	rect(width/2,height/2,width,height);
	popStyle();

	pushMatrix();

	scale(1);

	for(int i = 0;i<n.length;i++)
		n[i].draw();


	popMatrix();

	if (render){
		saveFrame("out/neuro####.png");
		println(frameCount);
	}

}


/////////////////////////////////////////////////////////
class  Neuron{
	int id;
	float x,y,val,xx,yy;
	float radius = 60.0;

	Synapse s[];
	Signal sig[];

	Neuron(int _id,float _x,float _y){
		val = random(255);
		id=_id;
		xx = x=_x;
		yy = y=_y;
	}

	void makeSynapse(){
		s = new Synapse[0];
		sig = new Signal[0];

		for(int i = 0;i<n.length;i++){
			if(i!=id && dist(x,y,n[i].x,n[i].y)<=radius&&noise(i/100.0)<0.8){
				s = (Synapse[])expand(s,s.length+1);
				s[s.length-1] = new Synapse(id,i);

				sig = (Signal[])expand(sig,sig.length+1);
				sig[sig.length-1] = new Signal(s[s.length-1]);

			}
		}
	}



	void makeSignal(int which){
		int i = which;
		sig[i].x = xx;
		sig[i].y = yy;
		sig[i].running = true;
	}




	void drawSynapse(){
		if(sig.length>0){
			for(int i = 0;i<sig.length;i+=1){
				if(sig[i].running){
					pushStyle();
					strokeWeight(3);
					stroke(255,90);
					noFill();
					line(sig[i].x,sig[i].y,sig[i].lx,sig[i].ly);
					popStyle();
					sig[i].step();
				}
			}
		}


		//stroke(#ffcc11,3);
		stroke(lerpColor(#ffcc11,#ffffff,norm(val,0,255)),4);
		for(int i = 0;i<s.length;i+=1){
			line(n[s[i].B].xx,n[s[i].B].yy,xx,yy);
		}
	}

	void draw(){
		drawSynapse();
		xx += (x-xx) / 10.0;
		yy += (y-yy) / 10.0;
		//move();
	}

	void move(){
		x+=(noise(id+frameCount/10.0)-.5);
		y+=(noise(id*5+frameCount/10.0)-.5);
	}

}


///////////////////////////////////////////////////////
class Synapse{

	float weight = 1.5;
	int A,B;

	Synapse(int _A, int _B){

		A=_A;
		B=_B;

		weight = random(101,1100)/300.9;
	}

}

//////////////////////////////////////////////////////////
class Signal{

	Synapse base;
	int cyc = 0;
	float x,y,lx,ly;
	float speed = 10.1;

	boolean running = false;
	boolean visible = true;

	int deadnum = 200;
	int deadcount = 0;

	Signal(Synapse _base){
		deadnum = (int)random(2,400);
		base = _base;
		lx = x = n[base.A].x;
		ly = y = n[base.A].y;
		speed *= base.weight;
	}

	void step(){
		running = true;

		lx = x;
		ly = y;

		x += (n[base.B].xx-x) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
		y += (n[base.B].yy-y) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);



		if(dist(x,y,n[base.B].x,n[base.B].y)<1.0){

			if(deadcount<0){
				deadcount = deadnum;

				for(int i = 0;i<10;i++){
					fill(255,10);
					ellipse(x,y,1.5*i,1.5*i);
				}

				//deadnum += (int)random(-1,1);
				//println("run "+base.A+" : "+base.B);

				running = false;
				for(int i = 0; i < n[base.B].s.length;i++){
					if(!n[base.B].sig[i].running && base.A!=n[base.B].sig[i].base.B){
						n[base.B].makeSignal(i);
						n[base.B].sig[i].base.weight += (base.weight-n[base.B].sig[i].base.weight)/((dist(x,y,n[base.A].xx,n[base.A].yy)+1.0)/200.0);
					}

				}


				//base.weight = random(1001,3000) / 1000.0;

				n[base.A].xx+=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.A].id)/11.0);;
				n[base.A].yy+=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.A].id)/10.0);



				n[base.A].xx-=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.B].id)/10.0);;
				n[base.A].yy-=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.B].id)/11.0);

				lx = n[base.A].xx;
				ly = n[base.A].yy;

				n[base.A].val+=(n[base.B].val-n[base.A].val)/5.0;
			}else{

				deadcount--;
			}
		}
	}
}




import peasy.*;

PeasyCam cam;



Rez o[] = new Rez[200];

void setup(){

	size(800,480,P3D);
	noStroke();
	fill(0,30);

	noSmooth();

	for(int i = 0;i<o.length;i++)
		o[i] = new Rez(i);

	cam = new PeasyCam(this, 400);
	cam.setMinimumDistance(500);
	cam.setMaximumDistance(2000);

}



void draw(){


	background(255);
	/*pushStyle();
	fill(255);
	strokeWeight(20);
	rect(0,0,width,height);
	popStyle();
	*/



	noFill();

	for(int i = 0;i<o.length;i++){

		o[i].draw();
	}


	pushStyle();
	noFill();

	for(int i = 0;i<o[0].q;i++){
		beginShape();
		for(int n = 0;n<o.length;n++){
			stroke(0,(sin(i/o.length)+1)*30);
			vertex(o[n].xs[i],o[n].ys[i],o[n].zs[i]);
		}
		endShape();
	}
	popStyle();




}


class Rez{
	float x,y,r;
	float step = 0.3;
	int id;
	float xs[],ys[],zs[];
	int q = 0;

	Rez(int _id){
		id = _id;
		x = width/2;
		y = height/2;
		r = 40;


		for(float f = -PI;f < PI;f+=step)
			q++;

		xs = new float[q];
		ys = new float[q];
		zs = new float[q];
	}

	void draw(){
		
		r  = noise((frameCount+id)/100.33)*120+noise((frameCount+id)/1000.43)*21+4;
		beginShape();
		int i = 0;
		for(float f = -PI;f < PI;f+=step){
			xs[i] = cos(f)*r*2*noise(cos(f/2.0)+id/10.0+frameCount/20.0)+(noise((id+frameCount)/101.0)-0.5)*500;
			ys[i] = sin(f)*r*2*noise(sin(f/2.0)+id/10.0+frameCount/20.1)+(noise((id+frameCount)/111.0)-0.5)*500;
			zs[i] = id*5-((o.length/2)*5);

			stroke(0,(sin(f)+1)*70);
			vertex(xs[i],ys[i],zs[i]);
			i++;
		}
		endShape(CLOSE);
	}
}
import peasy.*;


int num = 2000;
float RADIUS = 36;
float SCALE = 200.0;

int globKonexID = 0;
PeasyCam cam;
Neuron n[];

void setup(){
	size(460,460,P3D);
	n = new Neuron[num];

	cam = new PeasyCam(this, 800);
	cam.setMinimumDistance(300);
	cam.setMaximumDistance(3000);

	for(int i = 0;i<n.length;i++){
		n[i] = new Neuron(i);
	}


	for(int i = 0;i<n.length;i++){
		n[i].makeConnections();
	}

	noSmooth();
	stroke(0,5);

	for(int i = 0;i<n[0].k.length;i++)
		n[0].makeSignal(i);

}

void mousePressed(){
	if(mouseButton==RIGHT){
		for(int i = 0;i<n.length;i++){
			n[i].x = random(-width/2,width/2);
			n[i].y = random(-width/2,width/2);
			n[i].z = random(-width/2,width/2);
		}

		for(int i = 0;i<n.length;i++)
			n[i].makeConnections();

		for(int i = 0;i<n[0].sig.length;i++)
			n[0].makeSignal(i);
	}
}

void draw(){
	background(0);

	for(int i = 0;i<n.length;i++){
		n[i].draw();
	}
}


////////////////////////// >>

class Neuron{
	float x,y,z,radius,xx,yy,zz,val;
	int id;
	boolean imobile = false;
	Konexe k[] = new Konexe[0];
	Signal sig[] = new Signal[0];


	Neuron(int _id){
		xx = x = random(-width/2,width/2);
		yy = y = random(-width/2,width/2);
		zz = z = random(-width/2,width/2);
		id= _id;
		radius = RADIUS;
		val = 0;
		if(id==1)imobile = true;
	}


	void makeConnections(){
		k = new Konexe[0];
		sig = new Signal[0];
		
		for(int i = 0 ;i<n.length;i++){
			if(i!=id && dist(x,y,z,n[i].x,n[i].y,n[i].z) < radius){
				k = (Konexe[])expand(k,k.length+1);
				k[k.length-1] = new Konexe(id,i);

				sig = (Signal[])expand(sig,sig.length+1);
				sig[sig.length-1] = new Signal(k[sig.length-1]);
			}
		}
	}

	void makeSignal(int which){
		int i = which;
		sig[i].x = xx;
		sig[i].y = yy;
		sig[i].z = zz;
		sig[i].running = true;
	}

	void drawConnections(){
		for(int i = 0 ;i<k.length;i++){
			line(xx,yy,zz,n[k[i].B].xx,n[k[i].B].yy,n[k[i].B].zz);
		}


	}

	void draw(){
		
		xx += (x-xx) / 10.0;
		yy += (y-yy) / 10.0;
		zz += (z-zz) / 10.0;

		if(sig.length>0){
			for(int i = 0;i<sig.length;i+=1){

				if(sig[i].running){
					if(sig[i].moving){
						pushMatrix();
						pushStyle();
						//strokeWeight(3);
						stroke(255,15);
						noFill();
						//line(sig[i].x,sig[i].y,sig[i].z,sig[i].lx,sig[i].ly,sig[i].lz);
						translate(sig[i].x,sig[i].y,sig[i].z);
						box(2);
						popStyle();
						popMatrix();
					}
					sig[i].step();

				}

			}
		}

		stroke(lerpColor(#ffcc11,#ffffff,norm(val,0,255)),20);
		drawConnections();

	}





}

////////////////////////// >>

class Konexe{
	int A,B,id;
	float weight = 1.5;
	Konexe(int _A,int _B){
		A = _A;
		B = _B;
		id = globKonexID++;
		weight = random(101,200)/SCALE;
	}
}


class Signal{

	Konexe base;
	int cyc = 0;
	float x,y,z,lx,ly,lz;
	float speed = 10.1;

	boolean running = false;
	boolean visible = true;
	boolean moving = false;

	int deadnum = 200;
	int deadcount = 0;

	Signal(Konexe _base){
		deadnum = (int)random(2,40);
		base = _base;
		lx = x = n[base.A].x;
		ly = y = n[base.A].y;
		lz = z = n[base.A].z;
		speed *= base.weight;
	}

	void step(){
		running = true;

		if(abs(lx-x)>.1||abs(ly-y)>.1||abs(lz-z)>.1)
			moving = true;
		else
			moving = false;

		lx = x;
		ly = y;
		lz = z;


		if(!n[base.A].imobile){
			x += (n[base.B].xx-x) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
			y += (n[base.B].yy-y) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
			z += (n[base.B].zz-z) / speed;
		}

		n[base.A].val+=(0-n[base.A].val)/5000.0;

		if(dist(x,y,z,n[base.B].xx,n[base.B].yy,n[base.B].zz)<1.0){

			if(deadcount<0){
				deadcount = deadnum;


				//deadnum += (int)random(-1,1);
				//println("run "+base.A+" : "+base.B);

				running = false;
				for(int i = 0; i < n[base.B].k.length;i++){
					if(!n[base.B].sig[i].running && base.A!=n[base.B].sig[i].base.B){
						n[base.B].makeSignal(i);
						n[base.B].sig[i].base.weight += (base.weight-n[base.B].sig[i].base.weight)/((dist(x,y,z,n[base.A].xx,n[base.A].yy,n[base.A].zz)+1.0)/200.0);
					}

				}


				//base.weight = random(1001,3000) / 1000.0;
				if(n[base.A].id!=1){
					n[base.A].xx+=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.A].id)/18.0);;
					n[base.A].yy+=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.A].id)/17.0);
					n[base.A].zz+=((n[base.B].z-n[base.A].z)/1.1)*noise((frameCount+n[base.A].id)/16.0);



					n[base.A].xx-=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.B].id)/18.2);;
					n[base.A].yy-=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.B].id)/17.2);
					n[base.A].zz-=((n[base.B].z-n[base.A].z)/1.1)*noise((frameCount+n[base.B].id)/16.2);
				}

				lx = n[base.A].x;
				ly = n[base.A].y;
				lz = n[base.A].z;

				n[base.A].val+=(255-n[base.A].val)/10.0;
			}else{

				deadcount--;
			}
		}
	}
}
import peasy.*;


int num = 2000;
float RADIUS = 36;
float SCALE = 200.0;

int globKonexID = 0;
PeasyCam cam;
Neuron n[];

void setup(){
	size(460,460,P3D);
	n = new Neuron[num];

	cam = new PeasyCam(this, 800);
	cam.setMinimumDistance(300);
	cam.setMaximumDistance(3000);

	for(int i = 0;i<n.length;i++){
		n[i] = new Neuron(i);
	}


	for(int i = 0;i<n.length;i++){
		n[i].makeConnections();
	}

	noSmooth();
	stroke(0,5);

	for(int i = 0;i<n[0].k.length;i++)
		n[0].makeSignal(i);

}

void mousePressed(){
	if(mouseButton==RIGHT){
		for(int i = 0;i<n.length;i++){
			n[i].x = random(-width/2,width/2);
			n[i].y = random(-width/2,width/2);
			n[i].z = random(-width/2,width/2);
		}

		for(int i = 0;i<n.length;i++)
			n[i].makeConnections();

		for(int i = 0;i<n[0].sig.length;i++)
			n[0].makeSignal(i);
	}
}

void draw(){
	background(0);

	for(int i = 0;i<n.length;i++){
		n[i].draw();
	}
}


////////////////////////// >>

class Neuron{
	float x,y,z,radius,xx,yy,zz,val;
	int id;
	boolean imobile = false;
	Konexe k[] = new Konexe[0];
	Signal sig[] = new Signal[0];


	Neuron(int _id){
		xx = x = random(-width/2,width/2);
		yy = y = random(-width/2,width/2);
		zz = z = random(-width/2,width/2);
		id= _id;
		radius = RADIUS;
		val = 0;
		if(id==1)imobile = true;
	}


	void makeConnections(){
		k = new Konexe[0];
		sig = new Signal[0];
		
		for(int i = 0 ;i<n.length;i++){
			if(i!=id && dist(x,y,z,n[i].x,n[i].y,n[i].z) < radius){
				k = (Konexe[])expand(k,k.length+1);
				k[k.length-1] = new Konexe(id,i);

				sig = (Signal[])expand(sig,sig.length+1);
				sig[sig.length-1] = new Signal(k[sig.length-1]);
			}
		}
	}

	void makeSignal(int which){
		int i = which;
		sig[i].x = xx;
		sig[i].y = yy;
		sig[i].z = zz;
		sig[i].running = true;
	}

	void drawConnections(){
		for(int i = 0 ;i<k.length;i++){
			line(xx,yy,zz,n[k[i].B].xx,n[k[i].B].yy,n[k[i].B].zz);
		}


	}

	void draw(){
		
		xx += (x-xx) / 10.0;
		yy += (y-yy) / 10.0;
		zz += (z-zz) / 10.0;

		if(sig.length>0){
			for(int i = 0;i<sig.length;i+=1){

				if(sig[i].running){
					if(sig[i].moving){
						pushMatrix();
						pushStyle();
						//strokeWeight(3);
						stroke(255,15);
						noFill();
						//line(sig[i].x,sig[i].y,sig[i].z,sig[i].lx,sig[i].ly,sig[i].lz);
						translate(sig[i].x,sig[i].y,sig[i].z);
						box(2);
						popStyle();
						popMatrix();
					}
					sig[i].step();

				}

			}
		}

		stroke(lerpColor(#ffcc11,#ffffff,norm(val,0,255)),20);
		drawConnections();

	}





}

////////////////////////// >>

class Konexe{
	int A,B,id;
	float weight = 1.5;
	Konexe(int _A,int _B){
		A = _A;
		B = _B;
		id = globKonexID++;
		weight = random(101,200)/SCALE;
	}
}


class Signal{

	Konexe base;
	int cyc = 0;
	float x,y,z,lx,ly,lz;
	float speed = 10.1;

	boolean running = false;
	boolean visible = true;
	boolean moving = false;

	int deadnum = 200;
	int deadcount = 0;

	Signal(Konexe _base){
		deadnum = (int)random(2,40);
		base = _base;
		lx = x = n[base.A].x;
		ly = y = n[base.A].y;
		lz = z = n[base.A].z;
		speed *= base.weight;
	}

	void step(){
		running = true;

		if(abs(lx-x)>.1||abs(ly-y)>.1||abs(lz-z)>.1)
			moving = true;
		else
			moving = false;

		lx = x;
		ly = y;
		lz = z;


		if(!n[base.A].imobile){
			x += (n[base.B].xx-x) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
			y += (n[base.B].yy-y) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
			z += (n[base.B].zz-z) / speed;
		}

		n[base.A].val+=(0-n[base.A].val)/5000.0;

		if(dist(x,y,z,n[base.B].xx,n[base.B].yy,n[base.B].zz)<1.0){

			if(deadcount<0){
				deadcount = deadnum;


				//deadnum += (int)random(-1,1);
				//println("run "+base.A+" : "+base.B);

				running = false;
				for(int i = 0; i < n[base.B].k.length;i++){
					if(!n[base.B].sig[i].running && base.A!=n[base.B].sig[i].base.B){
						n[base.B].makeSignal(i);
						n[base.B].sig[i].base.weight += (base.weight-n[base.B].sig[i].base.weight)/((dist(x,y,z,n[base.A].xx,n[base.A].yy,n[base.A].zz)+1.0)/200.0);
					}

				}


				//base.weight = random(1001,3000) / 1000.0;
				if(n[base.A].id!=1){
					n[base.A].xx+=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.A].id)/18.0);;
					n[base.A].yy+=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.A].id)/17.0);
					n[base.A].zz+=((n[base.B].z-n[base.A].z)/1.1)*noise((frameCount+n[base.A].id)/16.0);



					n[base.A].xx-=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.B].id)/18.2);;
					n[base.A].yy-=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.B].id)/17.2);
					n[base.A].zz-=((n[base.B].z-n[base.A].z)/1.1)*noise((frameCount+n[base.B].id)/16.2);
				}

				lx = n[base.A].x;
				ly = n[base.A].y;
				lz = n[base.A].z;

				n[base.A].val+=(255-n[base.A].val)/10.0;
			}else{

				deadcount--;
			}
		}
	}
}

int b = 50;

void setup(){
	size(800,480);
	rectMode(CENTER);
	noStroke();
	fill(255,120);
	
	//println(PFont.list());
	
	textFont(createFont("Sawasdee Bold",32,true));
	textAlign(CENTER);
	background(0);
	loadPixels();
}


void draw(){
	background(0);
	
	
	
	translate(noise(frameCount/10.0)*3,noise(2*frameCount/10.0)*3);
	rect(width/2,height/2-b,b,b);
	
	
	
	translate(noise(frameCount/10.0)*3,noise(2*frameCount/10.0)*3);
	rect(width/2+b,height/2,b,b);
	
	
	
	
	
	translate(noise(frameCount/10.0)*3,noise(2*frameCount/10.0)*3);
	rect(width/2+b,height/2+b,b,b);

	
	translate(noise(frameCount/10.0)*3,noise(2*frameCount/10.0)*3);
	rect(width/2,height/2+b,b,b);
	
	
	translate(noise(frameCount/10.0)*3,noise(2*frameCount/10.0)*3);
	rect(width/2-b,height/2+b,b,b);
	
	
	translate(noise(frameCount/10.0)*3,noise(2*frameCount/10.0)*3);
	text("hello world!",width/2,height/2+2.5*b);
	
	//saveFrame("anim/anim#####.png");

}

Neuron n[];
Signal s[];

boolean render = false;

//////////////////////////////////////////////////////
void setup(){

	size(800,480,P2D);

	n = new Neuron[800];

	for(int i = 0;i<n.length;i++)
		n[i] = new Neuron(i,random(width),random(height));


	n[1].x = width/2;
	n[1].y = height + 40;
	n[1].radius = 3;


	for(int i = 0;i<n.length;i++)
		n[i].makeSynapse();

	rectMode(CENTER);

	for(int i = 0;i<n[0].s.length;i++)
		n[0].makeSignal(i);

	background(0);

}

void mousePressed(){
	for(int i = 0;i<n[0].s.length;i++)
		n[0].makeSignal(i);
}

////////////////////////////////////////////////////////
void draw(){
	//background(255);

	pushStyle();
	fill(11,50);
	stroke(0,190);
	strokeWeight(20);
	rect(width/2,height/2,width,height);
	popStyle();

	pushMatrix();
	translate(width/4,height/4);
	scale(0.5);

	for(int i = 0;i<n.length;i++)
		n[i].draw();


	popMatrix();

	if (render){
		saveFrame("out/neuro####.png");
		println(frameCount);
	}

}


/////////////////////////////////////////////////////////
class  Neuron{
	int id;
	float x,y,val,xx,yy;
	float radius = 60.0;

	boolean imobile = false;

	Synapse s[];
	Signal sig[];

	Neuron(int _id,float _x,float _y){
		val = 0;//random(255);
		if(id==1)imobile = true;
		id=_id;
		xx = x=_x;
		yy = y=_y;
	}

	void makeSynapse(){
		s = new Synapse[0];
		sig = new Signal[0];

		for(int i = 0;i<n.length;i++){
			if(i!=id && (dist(x,y,n[i].x,n[i].y)<=radius&&noise(i/100.0)<0.6) || i==1){
				s = (Synapse[])expand(s,s.length+1);
				s[s.length-1] = new Synapse(id,i);

				sig = (Signal[])expand(sig,sig.length+1);
				sig[sig.length-1] = new Signal(s[s.length-1]);

			}
		}
	}



	void makeSignal(int which){
		int i = which;
		sig[i].x = xx;
		sig[i].y = yy;
		sig[i].running = true;
	}




	void drawSynapse(){
		if(sig.length>0){
			for(int i = 0;i<sig.length;i+=1){
				if(sig[i].running){
					pushStyle();
					strokeWeight(3);
					stroke(255,90);
					noFill();
					line(sig[i].x,sig[i].y,sig[i].lx,sig[i].ly);
					popStyle();
					sig[i].step();
				}
			}
		}


		//stroke(#ffcc11,3);
		stroke(lerpColor(#ffcc11,#ffffff,norm(val,0,255)),4);
		for(int i = 0;i<s.length;i+=1){
			line(n[s[i].B].xx,n[s[i].B].yy,xx,yy);
		}
	}

	void draw(){
		drawSynapse();

		if(!imobile){
			xx += (x-xx) / 10.0;
			yy += (y-yy) / 10.0;
		}
		//move();
	}

	void move(){
		x+=(noise(id+frameCount/10.0)-.5);
		y+=(noise(id*5+frameCount/10.0)-.5);
	}

}


///////////////////////////////////////////////////////
class Synapse{

	float weight = 1.5;
	int A,B;

	Synapse(int _A, int _B){

		A=_A;
		B=_B;

		weight = random(101,1100)/300.9;
	}

}

//////////////////////////////////////////////////////////
class Signal{

	Synapse base;
	int cyc = 0;
	float x,y,lx,ly;
	float speed = 10.1;

	boolean running = false;
	boolean visible = true;

	int deadnum = 200;
	int deadcount = 0;

	Signal(Synapse _base){
		deadnum = (int)random(2,400);
		base = _base;
		lx = x = n[base.A].x;
		ly = y = n[base.A].y;
		speed *= base.weight;
	}

	void step(){
		running = true;

		lx = x;
		ly = y;


		if(!n[base.A].imobile){
			x += (n[base.B].xx-x) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
			y += (n[base.B].yy-y) / speed;//(speed+(dist(n[base.A].x,n[base.A].y,n[base.B].x,n[base.B].y)+1)/100.0);
		}

		n[base.A].val+=(0-n[base.A].val)/5000.0;

		if(dist(x,y,n[base.B].x,n[base.B].y)<1.0){

			if(deadcount<0){
				deadcount = deadnum;

				for(int i = 0;i<10;i++){
					fill(255,10);
					ellipse(x,y,1.5*i,1.5*i);
				}

				//deadnum += (int)random(-1,1);
				//println("run "+base.A+" : "+base.B);

				running = false;
				for(int i = 0; i < n[base.B].s.length;i++){
					if(!n[base.B].sig[i].running && base.A!=n[base.B].sig[i].base.B){
						n[base.B].makeSignal(i);
						n[base.B].sig[i].base.weight += (base.weight-n[base.B].sig[i].base.weight)/((dist(x,y,n[base.A].xx,n[base.A].yy)+1.0)/200.0);
					}

				}


				//base.weight = random(1001,3000) / 1000.0;
				if(n[base.A].id!=1){
					n[base.A].xx+=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.A].id)/11.0);;
					n[base.A].yy+=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.A].id)/10.0);



					n[base.A].xx-=((n[base.B].x-n[base.A].x)/1.1)*noise((frameCount+n[base.B].id)/10.0);;
					n[base.A].yy-=((n[base.B].y-n[base.A].y)/1.1)*noise((frameCount+n[base.B].id)/11.0);
				}

				lx = n[base.A].xx;
				ly = n[base.A].yy;

				n[base.A].val+=(255-n[base.A].val)/10.0;
			}else{

				deadcount--;
			}
		}
	}
}




import ddf.minim.*;
 
Minim minim;
AudioSample jingle;
 
void setup()
{
  size(512, 200, P2D);
 
  minim = new Minim(this);
 
  jingle = minim.loadSample("/home/kof/Music/triosk-moment_returns-2004-rns/03-triosk-love_chariot-rns.mp3", 1024);

  float[] leftChannel = jingle.getChannel(BufferedAudio.LEFT);
 
  float[] reversed = reverse(leftChannel);
  arraycopy(reversed, 0, leftChannel, 0, leftChannel.length);
}
 
void draw()
{
  background(0);
  stroke(255);
  for(int i = 0; i < jingle.bufferSize() - 1; i++)
  {
	  jingle.left.set(i);
    line(map(i,0, jingle.bufferSize(),0,width), 50 - jingle.left.get(i)*50, map(i+1,0, jingle.bufferSize(),0,width), 50 - jingle.left.get(i+1)*50);
    line(map(i,0, jingle.bufferSize(),0,width), 150 - jingle.right.get(i)*50, map(i+1,0, jingle.bufferSize(),0,width), 150 - jingle.right.get(i+1)*50);
  }
}
 
void keyPressed()
{
  jingle.trigger();
}
 
void stop()
{
  jingle.close();
  minim.stop();
 
  super.stop();
}
import gifAnimation.*;
import processing.opengl.*;

Postava p;
//Postava2 p2;

int skalovani = 2;

/////////////////////////////////////
String globName = "stallman";
boolean render = true;
/////////////////////////////////////


color trans=color(85,255,255);
PImage bck;

void setup() {

	size(320*skalovani,240*skalovani);
	frameRate(25);

	noSmooth();
	hint(DISABLE_OPENGL_2X_SMOOTH);


	reload();
	//imageMode(CENTER);

	textFont(createFont("FreeSans",9,false));
	textMode(SCREEN);

}
void reload(){
	bck = loadImage("cube_01.jpg");
	p = new Postava(this,globName, width/2-35 , height/2-64);
	//p2 = new Postava2(this,globName, width /2-128 , height/2-128);
}

void draw() {

	scale(skalovani);
	//image(bck,0,0);
	background(trans);
	//image(bck,0,0);
	
	//p2.draw();
	p.draw();
	if(render)
		saveFrame(p.name+"/"+p.name+"###.png");



}



void keyPressed(){
	if(key==' '){
		reload();
	}else if(key == 'q'){
		String params = "xterm -e 'cd "+sketchPath+" && tar zcvf "+globName+".tar.gz "+globName+"'";
		println(params);
		try{
			Runtime.getRuntime().exec(params);//(params);
		}catch(Exception e){
			println(e);
		}

		exit();
	}else if(keyCode==LEFT){
		p.wL=true;
	}else if(keyCode==RIGHT){
		p.wR=true;
	}else if(keyCode==DOWN){
		p.wD=true;
	}else if(keyCode==UP){
		p.wU=true;
	}

}

void keyReleased(){
	p.wL = p.wR = p.wU = p.wD = false;

}


class Postava{
	PImage walkL[],walkR[],walkU[],walkD[];
	PImage still;
	int x,y;
	String name;
	PApplet parent;
	PGraphics msk;

	boolean walking = false;
	boolean oneFrame = false;
	boolean wL,wR,wD,wU;


	int faze = 0;

	Postava(PApplet _parent, String _name,int _x, int _y){
		parent = _parent;
		name = ""+_name;
		walkL = Gif.getPImages(parent, name+"WalkL.gif");//new Gif(parent, name+"WalkL.gif");
		walkR = Gif.getPImages(parent, name+"WalkR.gif");
		walkU = Gif.getPImages(parent, name+"WalkU.gif");
		walkD = Gif.getPImages(parent, name+"WalkD.gif");

		msk = createGraphics(walkR[0].width,walkR[0].height,JAVA2D);
		//= Gif.getPImages(this, "lavalamp.gif");

		x =  _x;//width/2-walkL[0].width;//width/2;
		y = _y;//height-200;

		still = walkR[0];
		applyMask();
	}

	void applyMask(){

		if(walkL!=null)
			for(int i =0;i<walkL.length;i++){
				walkL[i].loadPixels();
				msk.loadPixels();
				//println(walkL[0].pixels[10]);
				for(int q = 0;q<msk.width*msk.height;q++){
					if(walkL[i].pixels[q]==trans)
						msk.pixels[q] = color(0);
					else
						msk.pixels[q] = color(255);
				}
				walkL[i].mask(msk);
			}

		if(walkR!=null)
			for(int i =0;i<walkR.length;i++){
				walkR[i].loadPixels();
				msk.loadPixels();
				//println(walkR[0].pixels[10]);
				for(int q = 0;q<msk.width*msk.height;q++){
					if(walkR[i].pixels[q]==trans)
						msk.pixels[q] = color(0);
					else
						msk.pixels[q] = color(255);
				}
				walkR[i].mask(msk);
			}
		if(walkD!=null)
			for(int i =0;i<walkD.length;i++){
				walkD[i].loadPixels();
				msk.loadPixels();
				//println(walkD[0].pixels[10]);
				for(int q = 0;q<msk.width*msk.height;q++){
					if(walkD[i].pixels[q]==trans)
						msk.pixels[q] = color(0);
					else
						msk.pixels[q] = color(255);
				}
				walkD[i].mask(msk);
			}

		if(walkU!=null)
			for(int i =0;i<walkU.length;i++){
				walkU[i].loadPixels();
				msk.loadPixels();
				//println(walkU[0].pixels[10]);
				for(int q = 0;q<msk.width*msk.height;q++){
					if(walkU[i].pixels[q]==trans)
						msk.pixels[q] = color(0);
					else
						msk.pixels[q] = color(255);
				}
				walkU[i].mask(msk);
			}
	}

	void walkLeft(){

	//	x-=2;

		if(x<-walkL[0].width)x=width;
		image(walkL[faze],x/skalovani,y/skalovani,walkL[faze].width*skalovani,walkL[faze].height*skalovani);
		still = walkL[faze];
		if(frameCount%2==0)faze++;
		if(faze>=walkL.length)faze = 0;
	}

	void walkDown(){
	//	y+=2;


		if(y>height)y=-walkD[0].height;
		image(walkD[faze],x/skalovani,y/skalovani,walkD[faze].width*skalovani,walkD[faze].height*skalovani);
		still = walkD[faze];
		if(frameCount%2==0)faze++;
		if(faze>=walkD.length)faze = 0;
	}

	void walkRight(){
	//	x+=2;


		if(x>width)x=-walkR[0].width;
		image(walkR[faze],x/skalovani,y/skalovani,walkR[faze].width*skalovani,walkR[faze].height*skalovani);
		still = walkR[faze];
		if(frameCount%2==0)faze++;
		if(faze>=walkR.length)faze = 0;
	}

	void walkUp(){
	//	y-=2;
		if(y<-walkU[0].height)y=0;
		image(walkU[faze],x/skalovani,y/skalovani,walkU[faze].width*skalovani,walkU[faze].height*skalovani);
		still = walkU[faze];
		if(frameCount%2==0)faze++;
		if(faze>=walkU.length)faze = 0;

	}

	void draw(){
		if(!wR&&!wL&&!wU&&!wD){
			image(still,x/skalovani,y/skalovani,walkR[faze].width*skalovani,walkR[faze].height*skalovani);
			faze = 0;
		}

		if(wR)
			walkRight();

		if(wL)
			walkLeft();

		if(wD)
			walkDown();

		if(wU)
			walkUp();



	}
}


class Postava2{

	int x,y;
	String name;
	PApplet parent;
	PGraphics msk;
	PImage anim[];
	int faze = 0;

	Postava2(PApplet _parent, String _name,int _x, int _y){
		parent = _parent;
		name = ""+_name;
		anim = Gif.getPImages(parent, name+".gif");

		msk = createGraphics(anim[0].width,anim[0].height,JAVA2D);

		x = _x;
		y = _y;

		for(int i =0;i<anim.length;i++){
			anim[i].loadPixels();
			msk.loadPixels();
			//println(walkR[0].pixels[10]);
			for(int q = 0;q<msk.width*msk.height;q++){
				if(anim[i].pixels[q]==trans)
					msk.pixels[q] = color(0);
				else
					msk.pixels[q] = color(255);
			}
			anim[i].mask(msk);
		}

	}


	void draw(){

		image(anim[faze],x/skalovani,y/skalovani,anim[faze].width*skalovani,anim[faze].height*skalovani);
		//still = anim[faze];
		if(frameCount%3==0)faze++;
		if(faze>=anim.length)faze = 0;

	}


}

Interpreter brush;
//PImage divka;

void setup(){
	size(520,640,P2D);
	frameRate(25);
	brush = new Interpreter("wermer.jpg","splat.png",5000);
	//divka = loadImage("wermer.png");
	//divka.filter(GRAY);
	background(0);
	
}


void draw(){
	noTint();
	image(g,(noise(frameCount)-0.5)*20.0,(noise(frameCount*2)-0.5)*20.0);
	
	brush.draw();
	
	//image(divka,0,-40,divka.width/1.4,divka.height/1.4);


}

class Interpreter{
	PImage src;
	PImage vzor;
	color c[];
	

	Interpreter(String file, String file2, int num){
		vzor = loadImage(file2);
		src = loadImage(file);
		src.loadPixels();
		//src.filter(GRAY);
		c = new color[num];
		for(int i = 0;i<num;i++){
			c[i] = src.pixels[(int)random(src.pixels.length)];
		}
	}
	
	void draw(){
		for(int i = 0;i<2;i++){
			pushMatrix();
			
			translate(random(-width,width),random(-height,height));
			pushMatrix();
			float sc=  random(0.12,3);
			translate(sc*vzor.width/2,sc*vzor.height/2);
			pushMatrix();
			rotate(random(-PI,PI));
			tint(c[(int)random(c.length)],200);
			image(vzor,0,0,vzor.width*sc,vzor.height*sc);
			popMatrix();
			popMatrix();
			popMatrix();
		}
	
	}


}

Interpreter brush;
//PImage divka;

void setup(){
	size(520,640,P2D);
	frameRate(25);
	brush = new Interpreter("wermer.jpg","splat.png",5000);
	//divka = loadImage("wermer.png");
	//divka.filter(GRAY);
	background(0);
	
}


void draw(){
	noTint();
	image(g,(noise(frameCount)-0.5)*20.0,(noise(frameCount*2)-0.5)*20.0);
	
	brush.draw();
	
	//image(divka,0,-40,divka.width/1.4,divka.height/1.4);


}

class Interpreter{
	PImage src;
	PImage vzor;
	color c[];
	

	Interpreter(String file, String file2, int num){
		vzor = loadImage(file2);
		src = loadImage(file);
		src.loadPixels();
		//src.filter(GRAY);
		c = new color[num];
		for(int i = 0;i<num;i++){
			c[i] = src.pixels[(int)random(src.pixels.length)];
		}
	}
	
	void draw(){
		for(int i = 0;i<2;i++){
			pushMatrix();
			
			translate(random(-width,width),random(-height,height));
			pushMatrix();
			float sc=  random(0.12,3);
			translate(sc*vzor.width/2,sc*vzor.height/2);
			pushMatrix();
			rotate(random(-PI,PI));
			tint(c[(int)random(c.length)],200);
			image(vzor,0,0,vzor.width*sc,vzor.height*sc);
			popMatrix();
			popMatrix();
			popMatrix();
		}
	
	}


}

PImage monsieur,monsieurFiltered;

float xmin = -1.5;
float ymin = -2.5;
float wh = 40;
float ZOOM = -0.2;

void setup() {
	size(320, 320, P2D);
	monsieur = loadImage("mb.png");
	//PImage msk = mb;
	monsieurFiltered = monsieur;
	monsieurFiltered.filter(THRESHOLD,0.7);
	//mb.mask(mb);
	loadPixels();
}

void draw() {
	
	
	
	tint(-1);
	image(g,0,0.1);
	
	

	wh = 8;

	xmin = map(height/3*2,0,height,0,-wh);
	ymin = map(width/2,0,width,0,-wh);

	float mod1 = noise(frameCount/50.0)+0.001;
	float mod2 = noise(232+frameCount/353.0)+0.001;
	float mod3 = noise(12323+frameCount/355.0)+0.001;
	float mod4 = noise(-10239+frameCount/30.0)+0.001;
	
	
	
	
	
	//noTint();
	tint(255,60);
	pushMatrix();
	//scale(mod1*mod2*mod3*mod4);
	image(monsieurFiltered,mod1*500*ZOOM,mod1*500*ZOOM,width-mod1*1000*ZOOM,height-mod1*1000*ZOOM);

	popMatrix();
	int maxiterations = 20;

	float xmax = xmin + wh;
	float ymax = ymin + wh;

	float dx = (xmax - xmin) / (width);
	float dy = (ymax - ymin) / (height);

	// Start y
	float y = ymin;
	for (int j = 0; j < height; j++) {
		// Start x
		float x = xmin;
		for (int i = 0;  i < width; i++) {

			float a = x;
			float b = y;
			int n = 0;
			while (n < maxiterations) {
				float aa = a * a * mod3;
				float bb = b * b * mod2;
				float twoab = 2.0 * a * b * mod1;
				a = aa - bb + x * mod2;
				b = twoab + y * mod4;
				if(aa + bb > 16) {
					break;  
				}
				n++;
			}

			if (n == maxiterations) {
				//pixels[j+i*width] = color(255);
				
			} else {
				pixels[j+i*width] = lerpColor(color(n*10 % 255),pixels[j+i*width],0.12);
			}
			x += dx;
		}
		y += dy;
	}
	updatePixels();
	

}


PImage monsieur,monsieurFiltered;

float xmin = -1.5;
float ymin = -2.5;
float wh = 40;
float ZOOM = -0.2;

void setup() {
	size(320, 320, P2D);
	monsieur = loadImage("mb.png");
	//PImage msk = mb;
	monsieurFiltered = monsieur;
	monsieurFiltered.filter(THRESHOLD,0.7);
	//mb.mask(mb);
	loadPixels();
}

void draw() {
	
	
	
	tint(-1);
	image(g,0,0.1);
	
	

	wh = 8;

	xmin = map(height/3*2,0,height,0,-wh);
	ymin = map(width/2,0,width,0,-wh);

	float mod1 = noise(frameCount/50.0)+0.001;
	float mod2 = noise(232+frameCount/353.0)+0.001;
	float mod3 = noise(12323+frameCount/355.0)+0.001;
	float mod4 = noise(-10239+frameCount/30.0)+0.001;
	
	
	
	
	
	//noTint();
	tint(255,60);
	pushMatrix();
	//scale(mod1*mod2*mod3*mod4);
	image(monsieurFiltered,mod1*500*ZOOM,mod1*500*ZOOM,width-mod1*1000*ZOOM,height-mod1*1000*ZOOM);

	popMatrix();
	int maxiterations = 20;

	float xmax = xmin + wh;
	float ymax = ymin + wh;

	float dx = (xmax - xmin) / (width);
	float dy = (ymax - ymin) / (height);

	// Start y
	float y = ymin;
	for (int j = 0; j < height; j++) {
		// Start x
		float x = xmin;
		for (int i = 0;  i < width; i++) {

			float a = x;
			float b = y;
			int n = 0;
			while (n < maxiterations) {
				float aa = a * a * mod3;
				float bb = b * b * mod2;
				float twoab = 2.0 * a * b * mod1;
				a = aa - bb + x * mod2;
				b = twoab + y * mod4;
				if(aa + bb > 16) {
					break;  
				}
				n++;
			}

			if (n == maxiterations) {
				//pixels[j+i*width] = color(255);
				
			} else {
				pixels[j+i*width] = lerpColor(color(n*10 % 255),pixels[j+i*width],0.12);
			}
			x += dx;
		}
		y += dy;
	}
	updatePixels();
	

}


Car car;


void setup(){
	size(800,600,P2D);

	car = new Car();
	stroke(255);
	background(0);
}


void draw(){
	//background(0);
	car.compute();
	car.draw();


}

void keyPressed(){
	if(keyCode==UP){
		car.speedUp(1.1);
	}else if(keyCode==DOWN){
		car.speedDown(1.2);
	}else if(keyCode==LEFT){
		car.turn(-1/car.vel.mag());
	}else if(keyCode==RIGHT){
		car.turn(1/car.vel.mag());

	}

}


class Car{
	PVector acc;
	PVector loc;
	PVector vel;
	PVector z = new PVector(0,0,-1);
	float rot;
	float r = 5;
	float theta = 0;

	Car(){
		acc = new PVector(0,0,0);
		loc = new PVector(width/2,height/2,0);
		vel = new PVector(0,0,0);
		rot = 0;
	}


	void speedUp(float _in){
		acc.add(0,-_in,0);

	}

	void speedDown(float _in){
		acc.add(0,_in,0);
	}

	void turn(float _kolik){
		rot += _kolik;


		//vel = rotate2(vel,z,rot);
		//loc = rotate2(loc,z,rot);
		//acc = rotate2(acc,z,rot);
	}

	void compute(){

		//rot*=0.76;
		PVector target = new PVector(cos(rot),sin(rot),0);
		target.add(new PVector(cos(target.y)/1.2,sin(target.x)/1.2,0));
		target.normalize();
		//acc.add(target);

		vel.add(target);
		acc.add(target);
		vel.add(acc);
		//vel.add(steer(new PVector(rot/100.0+loc.x,loc.y-1,0),true));
		//vel = rotate2(vel,z,0.01);
		loc.add(vel);
		rezist();

		if(loc.x>width)loc.x=0;
		if(loc.x<0)loc.x=width;

		if(loc.y>height)loc.y=0;
		if(loc.y<0)loc.y=height;


	}

	void rezist(){
		acc.mult(0.58);
		//rot*=0.8;
		vel.mult(0.99);
		vel.limit(3.0);
		acc.limit(0.5);
	}

	void draw(){
		theta = vel.heading2D() + PI/2;
		fill(200,100);
		stroke(255);
		pushMatrix();
		translate(loc.x,loc.y);
		rotate(theta);
		beginShape(TRIANGLES);
		vertex(0, -r*2);
		vertex(-r, r*2);
		vertex(r, r*2);
		endShape();
		popMatrix();

	}

	PVector rotate2(PVector v, PVector _axis,float ang)
	{
		PVector axis=new PVector(_axis.x,_axis.y,_axis.z);
		PVector vnorm=new PVector(v.x,v.y,v.z);
		float _parallel= axis.dot(v);
		PVector parallel = PVector.mult(axis, _parallel);

		PVector perp= PVector.sub(parallel,v);
		PVector Cross=v.cross(axis);
		//PVector result=PVector.add(Cross.mult(sin(-ang)),perp.mult(cos(-ang)),parallel);

		PVector result=PVector.add(parallel,PVector.add(PVector.mult(Cross,sin(-ang)),PVector.mult(perp,cos(-ang))));
		return result;
	}

	PVector steer(PVector target, boolean slowdown) {
		float maxspeed = .21;
		float maxforce = 1.2;
		PVector steer;  // The steering vector
		PVector desired = PVector.sub(target,loc);  // A vector pointing from the location to the target
		float d = desired.mag(); // Distance from the target is the magnitude of the vector
		// If the distance is greater than 0, calc steering (otherwise return zero vector)
		if (d > 0) {
			// Normalize desired
			desired.normalize();
			// Two options for desired vector magnitude (1 -- based on distance, 2 -- maxspeed)
			if ((slowdown) && (d < 100.0f)) desired.mult(maxspeed*(d/100.0f)); // This damping is somewhat arbitrary
			else desired.mult(maxspeed);
			// Steering = Desired minus Velocity
			steer = PVector.sub(desired,vel);
			steer.limit(maxforce);  // Limit to maximum steering force
		} else {
			steer = new PVector(0,0);
		}
		return steer;
	}


}

Bitnum bn[];
int SEL = 0;
int num = 0;
void setup(){
	size(500,320,P2D);
	background(255);

	num = height/5;

	bn = new Bitnum[num];

	for(int i = 0 ;i<bn.length;i++){
		bn[i] = new Bitnum(10,i*5,i);
	}

	textFont(createFont("Veranda",8,false));
	textMode(SCREEN);

	noSmooth();
}


void draw(){

	background(255);

	for(int i = 0 ;i<bn.length;i++){
		bn[i].draw();// = new Bitnum(10,10,i);
	}


	SEL++;
	if(SEL>=bn.length)
		SEL=0;

	stroke(0);
	line(0,SEL*5,width,SEL*5);
}

void keyPressed(){
	
	save("folder.jpg");
}



class Bitnum{

	int x,y,id;
	boolean bits[];
	int len = 24;
	float nn[] = new float[1000];
	int maX;

	Bitnum(int _x , int _y,int _id){
		x = _x;
		y= _y;
		id = _id;
		bits = new boolean[len];

		String m = "";

		for(int i = 0;i<bits.length;i++){

			bits[i] = random(50)>45?true:false;


			m+=""+"1";
		}
		for(int i = 0;i<nn.length;i++){
			nn[i] = width;
		}

		maX = unbinary(m);
	}

	void draw(){
		stroke(100);
		for(int i = 0;i<bits.length;i++){
			if(bits[i])
				fill(0);
			else
				fill(255);
			rect(x+i*4,y,4,4);
		}

		fill(0);
		String q = "";
		for(int i = 0 ;i<len;i++)
			q+=""+(bits[i]?"1":"0");

		nn[0] = map(unbinary(q),0,maX,(len*4),width-20);//(-nn[0])/3.0;
		for(int i = 1 ;i<nn.length;i++){
			nn[i] += (nn[i-1]-nn[i])/1.4;
		}

		//text((int)nn[0],x+(5*len),y+5);

		stroke(0,15);
		for(int i = 0;i<nn.length;i++)
			line(nn[i]+(len*4),y,nn[i]+(len*4),y+4);
		//y = unbinary(q);


		if(SEL==id){
			addOthers();
			degen();
		}

		//if(frameCount%40==0)
		/*
		if(SEL==id){
		addOthers();


		if(SEL%len==0){
			degen();
	}
	}
		*/


	}

	void addOthers(){

		int i = (id+bn.length-1)%(bn.length);
		for(int q = len-1 ;q>=0;q--){

			if(bn[i].bits[(q+3)%len]==bits[q]&&bn[i].bits[(q+1)%len]==bits[q]&&bn[i].bits[(q+2)%len]!=bits[q]){
				bits[q] = !bits[q];
			}



		}

	}

	void degen(){
		int sel = (int)random(len);
		bits[sel] = !bits[sel];
	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
Neuron n[][] = new Neuron[240][320];
Recorder r;

boolean rec = true;
boolean sound = true;

import krister.Ess.*;

AudioStream myStream;
boolean hasNew = false;

boolean soundRec = true;
AudioFile myFile;
int bytesWritten;


float[] streamBuffer;
int y  = 0;

float bluramount = 0.5;

void setup(){
	size(n[0].length,n.length,P3D);
	background(0);

	frameRate(25);

	noSmooth();


	if(sound){

		Ess.start(this);


		myStream=new AudioStream();
		myStream.sampleRate(44100);
		myStream.bufferSize(width);
		streamBuffer=new float[myStream.size];
		myStream.start();

		if(soundRec){
			myFile = new AudioFile();
			myFile.open(sketchPath+"/brainPix/test.aif",(int)(44100),Ess.WRITE);
		}
	}

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii] = new Neuron(i,ii);
		}
	}

	noFill();

	if(rec)
		r= new Recorder("brainPix","neuroPix.mp4");


}

void keyPressed()
{
	if(keyCode==UP){
		bluramount+=0.1;
	}else if(keyCode==DOWN){
		bluramount-=0.1;
	}else if(key=='q'){
		if(rec)
			r.finish();


		if(soundRec)
			myFile.close();

		if(sound)
			Ess.stop();

		exit();

	}


	bluramount=constrain(bluramount,0.5,40);

}


void fillAudioBufferL(){
	loadPixels();

	int cnt =0;

	if(sound)
		for(int X=0; X<width; X++) {
			streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9)+sin(noise(frameCount/2.0)*255);
			cnt++;
		}
	/*
	for(int X=width-1; X>=0; X--) {
		streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
}*/

	//y=(int)((sin(frameCount/30.0)+1.0)*height/2.0);// width/3;//mouseY;
	y=height/2;//y%height;

}

void fillAudioBuffer(){
	loadPixels();


	for(int Y=0; Y<height; Y++) {
		if(Y%2==0){
			for(int X=0; X<width; X++) {

				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}

		}else{
			for(int X=width-1; X>=0; X--) {

				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}
	}



	//myLowPass=new LowPass(220,-80,4);

	//myLowPass.filter(myStream);
}
void audioStreamWrite(AudioStream theStream) {
	System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
	
	
	if (soundRec && hasNew) {
		myFile.write(myStream.buffer); //,bytesWritten,bytesWritten+myStream.size
		bytesWritten+=myStream.size*2;		
	}
}

void draw(){
	//background(0);

	hasNew = true;
	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].cycle();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].update();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			pushMatrix();
			translate(ii,i);
			n[i][ii].draw();
			popMatrix();
		}
	}

	if(bluramount>0.5)
		filter(BLUR,bluramount);

	if(sound)
		fillAudioBufferL();

	stroke(255,0,0);
	//line(0,y,width,y);


	if(rec){
		r.add();
	}



}

public void stop() {
	if(soundRec)
		myFile.close();


	if(sound)
		Ess.stop();

	super.stop();
}


class Neuron{

	int lay,id;
	float vibra,val,val2;
	//float tresh = 240.0;
	//float prum[] = new float[3];

	float tone = 0,amount = 0;
	float[] w;

	Neuron(int _lay,int _id){
		lay = _lay;
		id = _id;
		w = new float[8];
		for(int i =0;i<w.length;i++){
			w[i] = random(400)/100.0;
		}
		vibra = random(800,1000)/10000.0;


		val = random(255);

	}

	void cycle(){

		tone+=vibra;
		amount = (sin(tone)+1.0)/2.0;

		val2 = 0.0;



		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[0];
		val2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[1];
		val2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];

		//val2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];
		//val2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[3];

		/*

				float Rprum = 0.0;
				prum[(frameCount)%prum.length] = val;
				for(int i = 0;i<prum.length;i++){
					Rprum += prum[i];
				}
				Rprum/=prum.length;

				if(Rprum>=tresh){
					assimilate(0.01,0.00,0.001);
					//val = 1;

					//n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val = 255-val;
				}

		*/
		val2 /= (3.0);

		if(val<50||val>200)
			stochaist(470.0);


	}
	/*
		void assimilate(float kolik,float kolik2,float kolik3){

			-1,-1 0,-1 1,-1
			-1,0 x,x 1,0
			-1,1 0,1 1,1

			

			// synchronize to vibra val
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[lay][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[lay][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;



			// approx. counter weights
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7] += (w[0]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6] += (w[1]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5] += (w[2]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[lay][(id+n[0].length-1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length-1)%n[0].length].w[4])*kolik2;
			n[lay][(id+n[0].length+1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[2].length].w[2] += (w[5]-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].w[2])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[1].length].w[1] += (w[6]-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].w[1])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0] += (w[7]-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0])*kolik2;


			// (experimental) approx. tones
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[0] += (w[7]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[1] += (w[6]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[2] += (w[5]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[lay][(id+n[0].length-1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[lay][(id+n[0].length+1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;
		}
	*/
	void update(){
		val += (val2-val)/1.0;
		val = constrain(val,1,254);
	}

	void draw(){
		stroke(noise(frameCount/20.0)*255+val);//lerpColor(#000000,#f7fd58,val/(255.0)),30.0);
		point(0,0);


	}

	void sync(float kolik){
		n[(lay+n.length+1)%n.length][id].amount += (amount-n[(lay+n.length+1)%n.length][id].amount)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].vibra += (vibra-n[(lay+n.length+1)%n.length][id].vibra)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].tone += (tone-n[(lay+n.length+1)%n.length][id].tone)*(map(val,0,255,0,kolik));


	}

	void stochaist(float kolik){
		for(int i =0;i<w.length;i++){
			w[i]+=random(-kolik,kolik)/1000.0;
			//vibra+=random(-kolik,kolik)/1000.0;
			w[i] = constrain(w[i],0.01,5.0);
		}
	}




}
import oscP5.*;
import netP5.*;

OscP5 oscP5;
NetAddress myRemoteLocation;

int num = 10;
Lum lum[] = new Lum[num];
int W = 800;

int H = 600;


void setup(){
	size(W,H,P2D);

	frameRate(30);

	oscP5 = new OscP5(this,12000);
	myRemoteLocation = new NetAddress("127.0.0.1",1234);

	textFont(createFont("FreeSans",9,false));
	textMode(SCREEN);
	rectMode(CENTER);
	noStroke();
	noSmooth();

	for(int i = 0;i<lum.length;i++){
		lum[i] = new Lum(i);
	}
}

void draw(){
	background(0);
	for(int i = 0;i<lum.length;i++){
		lum[i].draw();
	}
	sendAll();
}


void sendAll(){
	/* in the following different ways of creating osc messages are shown by example */
	OscMessage myMessage = new OscMessage("/lumid");

	for(int i =0;i<lum.length;i++)
		myMessage.add(lum[i].vald); /* add an int to the osc message */

	/* send the message */
	oscP5.send(myMessage, myRemoteLocation);
}

void keyPressed(){
	if(key >= '0' && key <= '9' ){
		//println((int)key);
		lum[(int)key-48].valUp();
		//lum
	}


}

void keyReleased(){
	if(key >= '0' && key <= '9' ){
		lum[(int)key-48].valDown();
		//lum
	}


}

class Lum{
	PGraphics vzor;
	int val,id,vald = 0;
	int x,y,w,h;

	boolean render = false;

	Lum(int _id){
		id = _id;
		x = (int)random(width);
		y = (int)random(height);
		w = (int)random(-width,width);
		h = (int)random(-height,height);

		if(render){
			vzor = createGraphics(W,H,P2D);
			vzor.beginDraw();
			vzor.fill(255);
			vzor.noSmooth();
			vzor.noStroke();
			vzor.rect(random(width),random(height),random(-w,w),random(-h,h));
			//vzor.filter(BLUR,2.0);
			vzor.endDraw();
		}
	}

	void step(){
		val = (int)(noise(id+frameCount/2.0)*255);
	}

	void valUp(){
		val = 255;
	}

	void valDown(){
		val = 0;
	}

	void draw(){

		if(render){
			tint(255,vald);
			image(vzor,0,0);
		}else{
			vald = val*(frameCount%2);
			fill(255,vald);
			rect(x,y,w,h);

		}
	}

}

/**
*
*/

import hipstersinc.sunflow.*;
import hipstersinc.sunflow.shader.*;
import hipstersinc.*;

int numSpheres = 400;
Sph[] sph;

void setup() {
	size(720, 480 ,"hipstersinc.P5Sunflow");
	sph = new Sph[numSpheres];
	//noLoop();

	for(int i = 0;i<numSpheres;i++)
		sph[i] = new Sph();
}


void draw() {
	background(0);

	for(int i=0; i<numSpheres; i++) {
		sph[i].draw();
	}

	saveFrame("out/fram####.png");
}

class Sph{

	float x,y,z,speed = 40.0;

	Sph(){
		x = random(-width,width*2);
		y = random(-width,width*2);
		z = -random(width);
	}

	void draw(){
		compute();
		pushMatrix();
		translate(x,y,z);
		fill( 255 );
		sphere(40);
		popMatrix();
	}

	void compute(){
		x+= (width/2-x)/speed;
		y+= (height/2-y)/speed;
		z+= (-z)/speed;
	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
Packer pac[];
Site sites[];

///////////////////////////////////////////////// >
int num = 300;
int precision = 4;
///////////////////////////////////////////////// >

Recorder r;
boolean rec = true;

void setup(){
	size(800,600,P2D);
	background(255);
	rectMode(CENTER);

	sites = new Site[num];
	for(int i =0;i<sites.length;i++){
		sites[i] = new Site(i);
	}

	for(int i =0;i<sites.length;i++){
		sites[i].compute();
	}

	pac = new Packer[num];
	for(int i =0;i<sites.length;i++){
		pac[i] = new Packer(sites[i]);
	}

	if(rec)
		r = new Recorder("out","voro.mp4");


}

void reset(){
	for(int i =0;i<sites.length;i++){
		sites[i].live();
	}
	
	for(int i =0;i<sites.length;i++){
		pac[i].reassign(sites[i]);
	}
}

void draw(){
	boolean fin = true;
	for(int i =0;i<pac.length;i++){
		if(!pac[i].stopthis){
			pac[i].update();
			fin = false;
		}
	}

	if(fin){
		reset();
		
		if(rec)
			r.add();
		
		fill(255,90);
		rect(width/2,height/2,width,height);
	}



}


void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();

		exit();
	}

}

class Packer{

	color c;
	PVector dir;
	PVector loc;
	float treshold = 200;
	Site s;
	PVector data[];
	int step = 0;
	boolean stopthis = false;

	Drawer d;


	Packer(){
		relocate();
		reset();
		d = new Drawer(this);
		smooth();
	}

	Packer(Site _s){
		c = color(random(60));
		d = new Drawer(this);
		reassign(_s);
	}

	void reassign(Site _s){
		stopthis = false;
		s = _s;
		data = new PVector[s.poradi.size()];
		for(int i = 0;i<s.poradi.size();i++){
			data[i] = new PVector(lerp((float)(Float)s.vX.get((Integer)s.poradi.get(i)),s.x,0.05),lerp((float)(Float)s.vY.get((Integer)s.poradi.get(i)),s.y,0.05));
		}

		step = 0;

		nextnode();
	}

	void nextnode(){
		loc = new PVector(data[step].x,data[step].y);
		dir = PVector.sub(new PVector(data[(step+1)%(s.poradi.size())].x,data[(step+1)%(s.poradi.size())].y),new PVector(data[step].x,data[step].y));
		dir.normalize();

		step++;

		if(step>data.length-1){
			stopthis = true;
			//reassign(sites[s.id+1]);
		}

	}

	void update(){

		if(dist(loc.x,loc.y,data[step].x,data[step].y)<=1)
			nextnode();

		loc.add(dir);

		//rotatePV(dir,0.8);

		if(loc.x>=width||loc.x<=0||loc.y>=height||loc.y<=0)
			relocate();

		d.draw(c);
	}

	void reset(){
		dir = new PVector(random(-100,100)/100.0,random(-100,100)/100.0);
		dir.normalize();
	}

	void relocate(){
		loc = new PVector(random(width),random(height));
	}

	void turnR(){
		rotatePV(dir,90);
	}

	void turn(float _an){
		rotatePV(dir,random(_an));
	}

	void turnL(){
		rotatePV(dir,90);
	}

	PVector perp(){
		PVector side = new PVector(dir.y,dir.x);
		return side;

	}

	void rotatePV(PVector what, float _deltaAngle){
		float deltaAngle = radians(_deltaAngle);
		float x = what.x;
		float y = what.y;
		what.x = (float) ( x * Math.cos( deltaAngle ) - y * Math.sin( deltaAngle ) );
		what.y = (float) ( x * Math.sin( deltaAngle ) + y * Math.cos( deltaAngle ) );
	}
}


class Drawer{

	Packer p;
	PVector up = new PVector(0,10);

	Drawer(Packer _p){
		p = _p;

	}

	void draw(color _c){
		pushMatrix();
		//PVector temp = PVector.add(p.loc, p.dir);
		//PVector d = PVector.sub(temp, p.loc);
		//PVector polar = cartesianToPolar(d);

		translate(p.loc.x,p.loc.y);
		rotate( p.dir.heading2D()+HALF_PI );


		stroke(_c,random(1,2));
		for(int i =0;i<20;i++){
			line(0,0,random(2),0);
			line(0,0,random(50),0);

		}
		popMatrix();


	}


}


// Daniel Shiffman
// <http://www.shiffman.net>
// "Landscape" example

class Landscape {

  int scl;           // size of each cell
  int w,h;           // width and height of thingie
  int rows, cols;    // number of rows and columns
  float zoff = 0.0;  // perlin noise argument
  float[][] z;       // using an array to store all the height values 

  Landscape(int scl_, int w_, int h_) {
    scl = scl_;
    w = w_;
    h = h_;
    cols = w/scl;
    rows = h/scl;
    z = new float[cols][rows];
  }


  // Calculate height values (based off a neural netork)
  void calculate(Network nn) {
    float x = 0;
    float dx = (float) 1.0 / cols;
    for (int i = 0; i < cols; i++)
    { 
      float y = 0;
      float dy = (float) 1.0 / rows;
      for (int j = 0; j < rows; j++)
      {
        float[] input = new float[2];
        input[0] = x; 
        input[1] = y;
        float result = nn.feedForward(input);
        z[i][j] = z[i][j]*0.95 + 0.05*(float)(result*280.0f-140.0);
        y += dy;
      }
      x += dx;
    }

  }

  // Render landscape as grid of quads
  void render() {
    // Every cell is an individual quad
    // (could use quad_strip here, but produces funny results, investigate this)
    for (int x = 0; x < z.length-1; x++)
    {
      for (int y = 0; y < z[x].length-1; y++)
      {
        // one quad at a time
        // each quad's color is determined by the height value at each vertex
        // (clean this part up)
        stroke(0,80);
	fill(0,25);
        pushMatrix();
        beginShape(QUADS);
        translate(x*scl-w/2,y*scl-h/2,0);
       // stroke(z[x][y]+127,220);
        vertex(0,0,z[x][y]);
       // stroke(z[x+1][y]+127,220);
        vertex(scl,0,z[x+1][y]);
       // stroke(z[x+1][y+1]+127,220);
        vertex(scl,scl,z[x+1][y+1]);
       // stroke(z[x][y+1]+127,220);
        vertex(0,scl,z[x][y+1]);
        endShape();
	//line(0,scl,z[x][y+1],0,scl,0);
        popMatrix();
	
      }
    }
  }
}

import nn.*;

ArrayList inputs;  // List of training input values
Network nn;        // Neural Network Object

int count;         // Total training interations
Landscape land;    // Solution space
float theta = 0.0; // Angle of rotation
PFont f;           // Font


void setup() {

	size(400,400,P3D);

	// Create a landscape object
	land = new Landscape(10,300,300);
	//println(PFont.list());
	f = createFont("Silkscreen",9,false);
	textMode(SCREEN);

	nn = new Network(2,8);

	// Create a list of 4 training inputs
	inputs = new ArrayList();
	float[] input = new float[2];
	input[0] = 0;
	input[1] = 0;
	inputs.add((float []) input.clone());
	input[0] = 1;
	input[1] = 0;
	inputs.add((float []) input.clone());
	input[0] = 0;
	input[1] = 1;
	inputs.add((float []) input.clone());
	input[0] = 1;
	input[1] =1;
	inputs.add((float []) input.clone());
	
	noSmooth();//smooth();
}



void draw() {

	int trainingIterationsPerFrame = 5;

	for (int i = 0; i < trainingIterationsPerFrame; i++) {
		// Pick a random training input
		int pick = int(random(inputs.size()));
		// Grab that input
		float[] inp = (float[]) inputs.get(pick);
		// Compute XOR
		float known = 1;
		if ((inp[0] == 1.0 && inp[1] == 1.0) || (inp[0] == 0 && inp[1] == 0)) known = 0;
		// Train that sucker!
		float result = nn.train(inp,known);
		count++;
	}

	// Ok, visualize the solution space
	background(175);
	pushMatrix();
	translate(width/2,height/2+20,-160);
	rotateX(PI/3);
	rotateZ(theta);

	// Put a little BOX on screen
	pushMatrix();
	stroke(50);
	noFill();
	translate(-10,-10,0);
	box(280);

	// Draw the landscape
	popMatrix();
	land.calculate(nn);
	land.render();
	theta += 0.001;
	popMatrix();

	// Display overal neural net stats
	networkStatus();

}


void networkStatus() {
	float mse = 0.0;

	textFont(f);
	fill(0);
	text("Your friendly neighborhood neural network solving XOR.",10,20);
	text("Total iterations: " + count,10,30);

	for (int i = 0; i < inputs.size(); i++) {
		float[] inp = (float[]) inputs.get(i);
		float known = 1;
		if ((inp[0] == 1.0 && inp[1] == 1.0) || (inp[0] == 0 && inp[1] == 0)) known = 0;
		float result = nn.feedForward(inp);
		//System.out.println("For: " + inp[0] + " " + inp[1] + ":  " + result);
		mse += (result - known)*(result - known);
	}

	float rmse = sqrt(mse/4.0);
	DecimalFormat df = new DecimalFormat("0.000");
	text("Root mean squared error: " + df.format(rmse), 10,40);

}



public class Connection{

	private Neuron from;     // Connection goes from. . .
	private Neuron to;       // To. . .
	private float weight;   // Weight of the connection. . .

	// Constructor  builds a connection with a random weight
	public Connection(Neuron a_, Neuron b_) {
		from = a_;
		to = b_;
		weight = (float) Math.random()*2-1;
	}

	// In case I want to set the weights manually, using this for testing
	public Connection(Neuron a_, Neuron b_, float w) {
		from = a_;
		to = b_;
		weight = w;
	}

	public Neuron getFrom() {
		return from;
	}

	public Neuron getTo() {
		return to;
	}

	public float getWeight() {
		return weight;
	}

	// Changing the weight of the connection
	public void adjustWeight(float deltaWeight) {
		weight += deltaWeight+random(-100,100)/200.0;
	}


}

class Neuron{
	protected Neuron a,b;
	protected float output;
	protected ArrayList connections;
	protected boolean bias = false;

	public Neuron(){
		output  = 0;
		connections = new ArrayList();
		bias = false;
	}

	public Neuron(int i){
		output = i;
		connections = new ArrayList();
		bias = true;
	}


	// Function to calculate output of this neuron
	// Output is sum of all inputs*weight of connections
	public void calcOutput() {
		if (bias) {
			// do nothing
		} else {
			float sum = 0;
			float bias = 0;
			//System.out.println("Looking through " + connections.size() + " connections");
			for (int i = 0; i < connections.size(); i++) {
				Connection c = (Connection) connections.get(i);
				Neuron from = c.getFrom();
				Neuron to = c.getTo();
				// Is this connection moving forward to us
				// Ignore connections that we send our output to
				if (to == this) {
					// This isn't really necessary
					// But I am treating the bias individually in case I need to at some point
					if (from.bias) {
						bias = from.getOutput()*c.getWeight();
					} else {
						sum += from.getOutput()*c.getWeight();
					}
				}
			}
			// Output is result of sigmoid function
			output = f(bias+sum);
		}
	}

	void addConnection(Connection c) {
		connections.add(c);
	}

	float getOutput() {
		return output;
	}

	// Sigmoid function
	public float f(float x) {
		return 1.0f / (1.0f + (float) Math.exp(-x));
	}

	public ArrayList getConnections() {
		return connections;
	}
}

public class InputNeuron extends Neuron {
	public InputNeuron() {
		super();
	}

	public InputNeuron(int i) {
		super(i);
	}

	public void input(float d) {
		output = d;
	}

}

public class OutputNeuron extends Neuron {
	public OutputNeuron() {
		super();
	}
}

public class HiddenNeuron extends Neuron {

	public HiddenNeuron() {
		super();
	}

	public HiddenNeuron(int i) {
		super(i);
	}

}

public class Network {

	// Layers
	InputNeuron[] input;
	HiddenNeuron[] hidden;
	OutputNeuron output;

	public static final float LEARNING_CONSTANT = 0.5f;

	// Only One output now to start!!! (i can do better, really. . .)
	// Constructor makes the entire network based on number of inputs & number of neurons in hidden layer
	// Only One hidden layer!!!  (fix this dood)

	public Network(int inputs, int hiddentotal) {

		input = new InputNeuron[inputs+1];  // Got to add a bias input
		hidden = new HiddenNeuron[hiddentotal+1];

		// Make input neurons
		for (int i = 0; i < input.length-1; i++) {
			input[i] = new InputNeuron();
		}

		// Make hidden neurons
		for (int i = 0; i < hidden.length-1; i++) {
			hidden[i] = new HiddenNeuron();
		}

		// Make bias neurons
		input[input.length-1] = new InputNeuron(1);
		hidden[hidden.length-1] = new HiddenNeuron(1);

		// Make output neuron
		output = new OutputNeuron();

		// Connect input layer to hidden layer
		for (int i = 0; i < input.length; i++) {
			for (int j = 0; j < hidden.length-1; j++) {
				// Create the connection object and put it in both neurons
				Connection c = new Connection(input[i],hidden[j]);
				input[i].addConnection(c);
				hidden[j].addConnection(c);
			}
		}

		// Connect the hidden layer to the output neuron
		for (int i = 0; i < hidden.length; i++) {
			Connection c = new Connection(hidden[i],output);
			hidden[i].addConnection(c);
			output.addConnection(c);
		}

	}


	public float feedForward(float[] inputVals) {

		// Feed the input with an array of inputs
		for (int i = 0; i < inputVals.length; i++) {
			input[i].input(inputVals[i]);
		}

		// Have the hidden layer calculate its output
		for (int i = 0; i < hidden.length-1; i++) {
			hidden[i].calcOutput();
		}

		// Calculate the output of the output neuron
		output.calcOutput();

		// Return output
		return output.getOutput();
	}

	public float train(float[] inputs, float answer) {
		float result = feedForward(inputs);


		// This is where the error correction all starts
		// Derivative of sigmoid output function * diff between known and guess
		float deltaOutput = result*(1-result) * (answer-result);


		// BACKPROPOGATION
		// This is easier b/c we just have one output
		// Apply Delta to connections between hidden and output
		ArrayList connections = output.getConnections();
		for (int i = 0; i < connections.size(); i++) {
			Connection c = (Connection) connections.get(i);
			Neuron neuron = c.getFrom();
			float output = neuron.getOutput();
			float deltaWeight = output*deltaOutput;
			c.adjustWeight(LEARNING_CONSTANT*deltaWeight);
		}

		// ADJUST HIDDEN WEIGHTS
		for (int i = 0; i < hidden.length; i++) {
			connections = hidden[i].getConnections();
			float sum  = 0;
			// Sum output delta * hidden layer connections (just one output)
			for (int j = 0; j < connections.size(); j++) {
				Connection c = (Connection) connections.get(j);
				// Is this a connection from hidden layer to next layer (output)?
				if (c.getFrom() == hidden[i]) {
					sum += c.getWeight()*deltaOutput;
				}
			}
			// Then adjust the weights coming in based:
			// Above sum * derivative of sigmoid output function for hidden neurons
			for (int j = 0; j < connections.size(); j++) {
				Connection c = (Connection) connections.get(j);
				// Is this a connection from previous layer (input) to hidden layer?
				if (c.getTo() == hidden[i]) {
					float output = hidden[i].getOutput();
					float deltaHidden = output * (1 - output);  // Derivative of sigmoid(x)
					deltaHidden *= sum;   // Would sum for all outputs if more than one output
					Neuron neuron = c.getFrom();
					float deltaWeight = neuron.getOutput()*deltaHidden;
					c.adjustWeight(LEARNING_CONSTANT*deltaWeight);
				}
			}
		}

		return result;
	}
}
import javax.media.opengl.*;
import processing.opengl.*;

float a; 

void setup() {
  size(800, 600, OPENGL);
}

void draw() {
  //background(255);
  
  PGraphicsOpenGL pgl = (PGraphicsOpenGL) g;  // g may change
  GL gl = pgl.beginGL();  // always use the GL object returned by beginGL
  
  drawGL(gl);
  gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT);// Vymaže obrazovku a hloubkový buffer
  
  pgl.endGL();
  
  a += 1.0;
}

float rtri = 0;
float rquad = 0;


void drawGL(GL gl){


gl.glLoadIdentity();// Reset matice
gl.glTranslatef(-150f,0.0f,-60f);// Posun doleva a do hloubky
gl.glRotatef(rtri,0.0f,1.0f,0.0f);// Otočí trojúhelník okolo osy y

gl.glBegin(gl.GL_TRIANGLES);// Začátek kreslení trojúhelníků

gl.glColor3f(1.0f, 0.0f, 0.0f);// Červená barva

gl.glVertex3f(0.0f, 100.0f, 0.0f);// Horní bod

gl.glColor3f(0.0f, 1.0f, 0.0f);// Zelená barva

gl.glVertex3f(-100.0f, -100.0f, 0.0f);// Levý dolní bod

gl.glColor3f(0.0f, 0.0f, 1.0f);// Modrá barva

gl.glVertex3f(100.0f, -100.0f, 0.0f);// Pravý dolní bod

gl.glEnd();// Ukončení kreslení trojúhelníků

gl.glLoadIdentity();// Reset matice

gl.glTranslatef(150f,0.0f,-60f);// Posun počátku

gl.glRotatef(rquad,1.0f,0.0f,0.0f);// Pootočení čtverce okolo osy x

gl.glColor3f(0.5f,0.5f,1.0f);// Světle modrá barva

gl.glBegin(gl.GL_QUADS);// Začátek kreslení obdélníků

gl.glVertex3f(100.0f, -100.0f, 0.0f);// Levý horní bod

gl.glVertex3f( -100.0f, -100.0f, 0.0f);// Pravý horní bod

gl.glVertex3f( -100.0f,100.0f, 0.0f);// Pravý dolní bod

gl.glVertex3f(100.0f,100.0f, 0.0f);// Levý dolní bod

gl.glEnd();// Konec kreslení obdélníků

rtri+=0.2f;// Inkrementace úhlu pootočení trojúhelníku

rquad-=0.15f;// Inkrementace úhlu pootočení čtverce
}
import processing.opengl.*;

PImage shape;

int shX,shY;
int eff = 10;

ArrayList pos,fl;
int next = 0;

//ArrayList a<int>;

boolean plochy = false;

int tx,ty;

void setup(){

	size(1440-1,1050-1,OPENGL);
	frameRate(40);

	background(0);
	shape = loadImage("xift.bmp");
	//shape.filter(BLUR,5);
	shX = 1;
	shY = 55;
	strokeWeight(10);
	textFont(createFont("Veranda",20,true));
	pos = new ArrayList();
	fl = new ArrayList();
	//cursor(CROSS);
}

void draw(){

	//background(0);

	fill(0,10);
	rect(0,0,width,height);


	if(plochy){
		tint(random(255),random(255),random(255),random(50));
		image(shape,shX+random(-100,100)/10.0,shY+random(-100,100)/10.0);


		//eff = (int)random(3,50);

		for(int i =0;i<height;i+=eff){
			stroke(0,random(55));
			line(0,i,width,i);
		}
	}

	if(fl.size()>0){
		for(int i = 0;i<fl.size();i++){
			Follower tmp = (Follower)fl.get(i);
			tmp.move();
			tmp.draw();

		}


	}
	
	fill(255,50);
	text("kof",tx,ty);




}

class Follower{

	int next = 0;

	float x,y,lx,ly;
	float speed;
	boolean destroyOnEnd = false;

	Follower(boolean _a){

		destroyOnEnd = _a;
		PVector tmp = (PVector)pos.get(0);
		lx = x = tmp.x;
		ly = y = tmp.y;
		next = 1;
		speed = random(5,60);
	}




	void move(){
		lx = x;
		ly = y;

		PVector tmp = (PVector)pos.get(next);
		x+=(tmp.x-x)/speed;
		y+=(tmp.y-y)/speed;


		PVector nxt = (PVector)pos.get(next);
		if(dist(nxt.x,nxt.y,x,y)<1){
			next++;
			if(next>=pos.size()){

				if(destroyOnEnd){
					fl.remove(this);
					fl.add(new Follower(true));
				}else{
					next = 0;
				}

			}
		}


	}

	void draw(){
		pushStyle();
		strokeWeight(1);
		stroke(255);
		line(lx,ly,x,y);
		popStyle();


	}


}

void mousePressed(){

	if(mouseButton==LEFT){
	pos.add(new PVector(mouseX,mouseY));
	}else{
	tx=mouseX;
	ty=mouseY;
	}

}

void keyPressed(){

	if(keyCode==LEFT){
		shX--;

	}else if(keyCode==RIGHT){
		shX++;
	}else if(keyCode==UP){
		shY--;
	}else if(keyCode==DOWN){
		shY++;
	}else if(keyCode==ENTER){
		if(pos.size()>2){
			fl.add(new Follower(true));
		}
	}else if(keyCode==DELETE){
		fl = new ArrayList();
		pos = new ArrayList();

	}else if(keyCode==BACKSPACE){
		background(0);
	}else if(key=='v'){
	plochy =  !plochy;
	
	}

}

boolean rightDown, leftDown, middleDown,once;
float px = 0;
float px2 = 0;
float scrn[] = {0, 0, 0};
float model[] = new float[3];

void mousePressed()
{
	if (mouseButton==LEFT )
	{

		once = true;
		leftDown = true;

		// apply transformation matrices to mouse coords
		scrn[0] = mouseX;
		scrn[1] = mouseY;
		scrn[2] = 0;

		model = new float[3];

		//pro jistotu provede transformace
		camer.applyMatrices();

		pridejRetez();
		

		/*
		vertexKlicked = vertexMouseOver;
		 		zModelKlick = zModelMouseOver;
		 
		 		// calculate transformation matrix for projecting mouse coords
		 		// to the plane where the current selected vertex is
		 		// this doesn't work!
		 		screen2Model = modvwInv;
		 		screen2Model.apply(cam);
		 		*/

		//screen2Model.apply(proj);
		//screen2Model.translate(0, 0, zModelKlick);
	}
}

//mys odkliknuta
void mouseReleased()
{
	leftDown = rightDown = middleDown = false;
}

//mys tazena
void mouseDragged()
{
	if (mouseButton==RIGHT)
	{
		// mouse controlled rotation
		float x1 = mouseX-pmouseX;
		float y1 = mouseY-pmouseY;

		//add to global rotation
		rotX += -y1 * 0.01;
		rotY += x1 * 0.01;
	}
}

void keyPressed()
{
	// obrati gravitaci
	if (keyCode == ENTER)
	{
		gravity *= -1;//gravity;
	}
	// smaze body
	else if(keyCode == DELETE)
	{
		initRetez();
	}


}

PGraphics3D p3d;
PMatrix3D proj = new PMatrix3D();
PMatrix3D cam = new PMatrix3D();
PMatrix3D modvw = new PMatrix3D();
PMatrix3D modvwInv = new PMatrix3D();
PMatrix3D screen2Model = new PMatrix3D();


// rotation
float rotX, rotY;



// index of current mouseover / clicked vertex
int vertexMouseOver = -1;
int vertexKlicked= -1;

// z value in model/world space of current vertex
float zModelMouseOver;
float zModelKlick;



class Camera{

  Camera()
  {
    p3d = (PGraphics3D)g;
    //rotX=PI;
  }


  void preDraw()
  {

    pushMatrix();

    //apply mouse rotation and translation to center of screen
    translations();

    getMatrices();

    applyMatrices();

  }
  void translations()
  {
    translate(width/2, height/2);
    //mouse rotate
    rotateX(rotX);
    rotateZ(-rotY);
  }

  void getMatrices()
  {
    //get 3d matrices
    proj = p3d.projection.get();
    cam = p3d.camera.get();
    modvw = p3d.modelview.get();
    modvwInv = p3d.modelviewInv.get();



  }

  void applyMatrices()
  {
    screen2Model.mult(scrn, model);
    screen2Model = modvwInv;
    screen2Model.apply(cam);
  }

  void postDraw()
  {

    //visualize 3d axes for orientation
    //camer.drawAxes3D();

    //visualize vertices
    //camer.drawVertSphere();
    //	camer.drawVert();

   //hitDetect();

    // 3d object space end
    popMatrix();

   // drawHitDetect();
  }



  void drawAxes3D()
  {
    stroke(255,0,0);
    line(0,0,0, 100,0,0);
    stroke(0,255,0);
    line(0,0,0, 0,-100,0);
    stroke(0,0,255);
    line(0,0,0, 0,0,100);
  }



 





}







float gravity = 1;
float hustutaProstredi = 1.2;

class Retez
{

	RetezClanek[] pt = new RetezClanek[0];
	Point ptStart, ptEnd, ptControl;
	int segmentCount;
	float rozpon;
	boolean[] inserted = new boolean[2];
	boolean selected, preConstructLine;
	int overId = -1;

	Retez rodice[] = new Retez[2];

	// ma alespon nejakeho rodice (varianta rodic + fix bod)
	boolean hasRodic = false;
	// ma dva rodice
	boolean hasRodice = false;
	RetezClanek[] rodicePt = new RetezClanek[2];
	int rodicPtId[] = new int[2];


	Retez()
	{
		segmentCount = 30;
		pt = new RetezClanek[segmentCount];

		inserted[0] = false;
		inserted[1] = false;
		selected = false;
		preConstructLine = false;


	}

	void pridej(Point bod)
	{

		if(inserted[0] == false)
		{
			inserted[0] = true;
			preConstructLine = true;
			ptStart = bod;

			collRetez.add(currentRetez);
		}
		else
		{
			inserted[1] = true;
			preConstructLine = false;
			ptEnd = bod ;
			ptControl = new Point((ptEnd.x+ptStart.x)/2, (ptEnd.y+ptStart.y)/2, (ptEnd.z+ptStart.z)+ptStart.z+100);
			rozpon = ptStart.DistanceTo(ptEnd);

			for(int i = 0; i < segmentCount; i++)
			{
				pt[i] = new RetezClanek( new Point( (ptEnd.x-ptStart.x)/(segmentCount-1)*i+ptStart.x,
				                                    (ptEnd.y-ptStart.y)/(segmentCount-1)*i+ptStart.y,
				                                    (ptEnd.z-ptStart.z)/(segmentCount-1)*i+ptStart.z));
				pt[i].Mass(1,1,1,1);
			}

			pt[0].fixed = true;
			pt[segmentCount-1].fixed = true;


			collRetez.add(currentRetez);
			currentRetez = new Retez();
		}
	}


	// prichyceni na druhy retez
	void pridej(Retez _parent)
	{

		if(inserted[0] == false)
		{
			//zpaise si prvni retez
			rodice[0] = _parent;

			// uskladni aktualni oznaceny bod rodice ..fuj!
			rodicePt[0] = rodice[0].pt[ rodice[0].overId ];



			inserted[0] = true;
			preConstructLine = true;
			ptStart = rodicePt[0].origin;

			//collRetez.add(currentRetez);
		}
		else
		{
			rodice[1] = _parent;
			// uskladni aktualni oznaceny bod rodice ..fuj!
			rodicePt[1] = rodice[1].pt[ rodice[1].overId ];

			inserted[1] = true;
			preConstructLine = false;
			ptEnd = rodicePt[1].origin;

			ptControl = new Point((ptEnd.x+ptStart.x)/2, (ptEnd.y+ptStart.y)/2, (ptEnd.z+ptStart.z)+ptStart.z+100);
			rozpon = ptStart.DistanceTo(ptEnd);

			for(int i = 0; i < segmentCount; i++)
			{
				pt[i] = new RetezClanek( new Point( (ptEnd.x-ptStart.x)/(segmentCount-1)*i+ptStart.x,
				                                    (ptEnd.y-ptStart.y)/(segmentCount-1)*i+ptStart.y,
				                                    (ptEnd.z-ptStart.z)/(segmentCount-1)*i+ptStart.z));
				pt[i].Mass(1,1,1,1);
			}

			//pt[0].fixed = true;
			//pt[segmentCount-1].fixed = true;


			collRetez.add(currentRetez);
			currentRetez = new Retez();
		}
	}

	boolean[] maRodice()
	{
		boolean one = (rodice[0]==null)?false:true;
		boolean two =  (rodice[1]==null)?false:true;
		boolean answr[] = {one,two};
		return answr;
	}

	void Calculate()
	{
		if(inserted[1] == true)
		{
			//kalkulace trech moznych variant maRodice()[true,false]
			preCalc();

		}
	}

	void preCalc()
	{
		//has no
		if(!maRodice()[0]&&!maRodice()[1])
		{
			for(int i = 0; i < pt.length ; i++)
			{
				if(i>0) pt[i].SousedOne(pt[i-1].origin);
				if(i < pt.length-1) pt[i].SousedTwo(pt[i+1].origin);

				if(i==0) pt[i].SousedOne(null);
				if(i==pt.length) pt[i].SousedTwo(null);

			}
			pt[10].SousedOther(new Point(0,0,0));

			for(int i = 0; i < pt.length ; i++)
			{
				pt[i].Move();
			}
		}
		else if(maRodice()[0] && !maRodice()[1])
		{
			for(int i = 1; i < pt.length ; i++)
			{
				if(i>0) pt[i].SousedOne(pt[i-1].origin);
				if(i < pt.length-1) pt[i].SousedTwo(pt[i+1].origin);

				if(i==0) pt[i].SousedOne(null);
				if(i==pt.length) pt[i].SousedTwo(null);

			}
			pt[10].SousedOther(new Point(0,0,0));

			for(int i = 1; i < pt.length ; i++)
			{
				pt[i].Move();
			}

			pt[0] = rodicePt[0];
			ptStart = rodicePt[0].origin;

		}else if(!maRodice()[0] && maRodice()[1])
		{
			for(int i = 0; i < pt.length-1 ; i++)
			{
				if(i>0) pt[i].SousedOne(pt[i-1].origin);
				if(i < pt.length-1) pt[i].SousedTwo(pt[i+1].origin);

				if(i==0) pt[i].SousedOne(null);
				if(i==pt.length) pt[i].SousedTwo(null);

			}
			pt[10].SousedOther(new Point(0,0,0));

			for(int i = 0; i < pt.length-1 ; i++)
			{
				pt[i].Move();
			}

			pt[pt.length-1] = rodicePt[0];
			ptStart = rodicePt[0].origin;

		}else if(maRodice()[0] && maRodice()[1])
		{
			for(int i = 1; i < pt.length-1 ; i++)
			{
				if(i>0) pt[i].SousedOne(pt[i-1].origin);
				if(i < pt.length-1) pt[i].SousedTwo(pt[i+1].origin);

				if(i==0) pt[i].SousedOne(null);
				if(i==pt.length) pt[i].SousedTwo(null);

			}
			pt[10].SousedOther(new Point(0,0,0));

			for(int i = 1; i < pt.length-1 ; i++)
			{
				pt[i].Move();
			}
			pt[0] = rodicePt[0];
			ptStart = rodicePt[0].origin;
			pt[pt.length-1] = rodicePt[1];
			ptStart = rodicePt[0].origin;

		}
	}



	void Draw()
	{
		// plati pokud byl jiz zadan prvni bod
		if(inserted[0] == true)
		{
			// ptStart.Draw();
			if(preConstructLine)
			{

			}
		}

		// plati pokud byli zadany oba kotevni body
		if (inserted[1] == true)
		{
			// ptControl.Draw();

			//retez selection
			selected = retezOver();

			//jestlize oznacen
			if(selected)
			{
				stroke(239,230,30);
				pushMatrix();
				translate(pt[overId].origin.x,pt[overId].origin.y,pt[overId].origin.z);
				box(5);
				popMatrix();
			}
			else
			{
				stroke(220);

			}

			for(int i = 1; i < pt.length ; i++)
			{
				//pt[i].origin.Draw();
				line(pt[i].origin.x,pt[i].origin.y,pt[i].origin.z, pt[i-1].origin.x,pt[i-1].origin.y,pt[i-1].origin.z);
			}

			stroke(255,0,0);
			ptStart.Draw();
			ptEnd.Draw();

			//line(ptStart.x, ptStart.y, ptStart.z, ptEnd.x, ptEnd.y, ptEnd.z);


			//stroke(239,230,30);

		}

	}

	boolean retezOver(){
		boolean tmp = false;

		for(int i = 0;i<pt.length;i++)
		{
			if(pt[i].over())
			{
				overId = i;
				tmp = true;
				break;

			}
		}
		return tmp;

	}




}

class RetezClanek
{
	Point origin;
	Vector vecOne, vecTwo, vecOther, vecGrav;
	boolean fixed;
	float tension, mass;
	int scx,scy;

	// arrays hold the vertices of 3d object
	float[] vertices3D = new float[0];
	int[] vertices2D = new int[0];


	RetezClanek(Point origin)
	{
		this.origin = origin;
		this.tension = 0.3;// tension/100;
		mass = 1;
		vecGrav = new Vector(0,0,-mass*gravity);
	}

	void Mass(float a, float b, float h, float ro)
	{
		mass = a*b*h*ro;
		vecGrav = new Vector(0,0,-mass*gravity);
	}


	void SousedOne(Point sousedOne)
	{
		if(sousedOne == null)
		{
			vecOne = null;
		}
		else
		{
			vecOne = new Vector(origin,sousedOne);
			vecOne.Unitize();
			vecOne.MultipleBy(origin.DistanceTo(sousedOne)*tension);

		}
	}

	void SousedTwo(Point sousedTwo)
	{
		if(sousedTwo == null)
		{
			vecTwo = null;
		}
		else
		{
			vecTwo = new Vector(origin,sousedTwo);
			vecTwo.Unitize();
			vecTwo.MultipleBy(origin.DistanceTo(sousedTwo)*tension);

		}
	}

	void SousedOther(Point sousedOther)
	{
		if(sousedOther == null)
		{
			vecOther = null;
		}
		else
		{
			vecOther = new Vector(origin,sousedOther);
			vecOther.Unitize();
			vecOther.MultipleBy(origin.DistanceTo(sousedOther)*tension);
		}
	}

	void Move()
	{
		//prepocita gravitaci
		vecGrav = new Vector(0,0,-mass*gravity);

		if(fixed == false)
		{
			Vector dir = new Vector(0,0,0);

			dir.Plus(vecGrav);

			if(vecOne != null) dir.Plus(vecOne);
			if(vecTwo != null) dir.Plus(vecTwo);
			if(vecOther != null) dir.Plus(vecOther);

			dir.MultipleBy(1/hustutaProstredi);

			origin.Plus(dir);
		}
	}

	boolean over()
	{
		// mouse hit detection using screnX, screenY
		scx = int(screenX(origin.x, origin.y, origin.z));
		scy = int(screenY(origin.x, origin.y, origin.z));;

		if (scx > mouseX-7 && scx < mouseX+7 && scy > mouseY-7 && scy < mouseY+7)
		{
			return true;

		}
		else
		{
			return false;
		}

	}


}








































/**
 *	Retezovka Script
 *	by Jachym & Krystof PESEK
 *	2010
 */

Camera camer;

ArrayList collRetez;
Retez currentRetez = new Retez();


int whichSelected = -1;


Plane pln;



void setup()
{
	size(1200,800,P3D);
	//	hint(DISABLE_OPENGL_2X_SMOOTH);
	noSmooth();

	camer = new Camera();

	// vytvoreni pole pro ukladani retzu (collRetez) a prida currentRetez jakozto novy urceny pro vsechny operace
	initRetez();

	// konstrukcni rovina
	pln = new Plane(0,0,0);
	pln.displaySize = 200;
	pln.numOfGrid = 20;

}

void initRetez(){
	collRetez = new ArrayList();
	currentRetez = new Retez();
	//collRetez.add(currentRetez);
}

void draw()
{
	background(0);

	//vypocet polohy
	for(int i = 0; i<collRetez.size(); i++)
	{
		Retez rView = (Retez) collRetez.get(i);
		rView.Calculate();
	}

	// pocatek kresleni
	camer.preDraw();

	//retezy draw
	for(int i = 0; i<collRetez.size();i++)
	{
		Retez rView = (Retez) collRetez.get(i);
		rView.Draw();
	}

	//plane draw
	pln.Draw();

	//konec kresleni
	camer.postDraw();

}


void pridejRetez(){

	if(someSelected())
	{
		// prida bod linkly na rodice
		Retez tmp = (Retez) collRetez.get(whichSelected);
		currentRetez.pridej(tmp);
	}
	else
	{
		//prida body
		currentRetez.pridej(new Point(model[0],model[1],model[2]));
	}

}

boolean someSelected(){
	boolean answr = false;
	for(int i = 0 ;i<collRetez.size();i++){
		Retez tmp = (Retez) collRetez.get(i);
		if(tmp.selected)
		{
			whichSelected = i;
			answr = true;
			break;
		}
	}
	
	return answr;

}


























public class Point
{
	public Point(Point point)
	{
		x = point.x;
		y = point.y;
		z = point.z;
	}
	public Point(float x, float y)
	{
		this.x = x;
		this.y = y;
		this.z = 0;
	}
	public Point(float x, float y, float z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
	public Point(Point origin, Vector direction)
	{
		x = origin.x + direction.x;
		y = origin.y + direction.y;
		z = origin.z + direction.z;
	}
	public float DistanceTo(Point targetPoint)
	{
		float d = 0;
		d = sqrt((targetPoint.x - x) * (targetPoint.x - x) +
		         (targetPoint.y - y) * (targetPoint.y - y) +
		         (targetPoint.z - z) * (targetPoint.z - z));
		return (d);
	}

	public void Plus(Vector direction)
	{
		x += direction.x;
		y += direction.y;
		z += direction.z;
	}

	void Draw()
	{
		pushMatrix();
		translate(x,y,z);
		noFill();
		stroke(255,20,20);
		box(5);
		popMatrix();
	}

	float x, y, z;

}

public class Vector
{
	public Vector(Vector vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
	}
	public Vector(float x, float y, float z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
	public Vector(float x1, float y1, float z1, float x2, float y2, float z2)
	{
		this.x = x2 - x1;
		this.y = y2 - y2;
		this.z = z1 - z2;
	}
	public Vector(Point fromPoint, Point toPoint)
	{
		x = toPoint.x - fromPoint.x;
		y = toPoint.y - fromPoint.y;
		z = toPoint.z - fromPoint.z;
	}

	public void MultipleBy(float koef)
	{
		x *= koef;
		y *= koef;
		z *= koef;
	}

	public void Plus(Vector addVector)
	{
		x += addVector.x;
		y += addVector.y;
		z += addVector.z;
	}

	public void Reverse()
	{
		x *= -1;
		y *= -1;
		z *= -1;
	}

	public void CrossProduct(Vector secondVector)
	{
		float tempX, tempY, tempZ;
		tempX = x;
		tempY = y;
		tempZ = z;

		x = tempY * secondVector.z - tempZ * secondVector.y;
		y = tempZ * secondVector.x - tempX * secondVector.z;
		z = tempX * secondVector.y - tempY * secondVector.x;
	}

	public void Unitize()
	{
		float d = Delka();
		x /=  d;
		y /=  d;
		z /=  d;
	}

	public float Delka()
	{
		float d = 0;
		//length = sqrt((ax * ax) + (ay * ay) + (az * az))
		d = sqrt((x * x) + (y * y) + (z * z));
		return d;
	}

	public boolean IsZero()
	{
		if ((x == 0) && (y == 0) && (z == 0)) return true;
		return false;
	}

	float x, y, z;

}

public class Plane
{
	public Plane(float x, float y, float z)
	{
		this.origin = new Point(x, y, z);

		xAxis = new Vector(1, 0, 0);
		yAxis = new Vector(0, 1, 0);
		zAxis = new Vector(0, 0, 1);

		displaySize = 10;
		numOfGrid = 4;
	}
	public Plane(Point origin)
	{
		this.origin = origin;

		xAxis = new Vector(1, 0, 0);
		yAxis = new Vector(0, 1, 0);
		zAxis = new Vector(0, 0, 1);

		displaySize = 10;
		numOfGrid = 4;
	}
	public Plane(Point origin, Point xVectorPoint, Point yVectorPoint)
	{
		this.origin = origin;
		xAxis = new Vector(origin, xVectorPoint);
		xAxis.Unitize();

		yAxis = new Vector(origin, yVectorPoint);

		yAxis.CrossProduct(xAxis);
		yAxis.Reverse();
		zAxis = new Vector(yAxis);
		zAxis.Unitize();
		zAxis.Reverse();

		yAxis.CrossProduct(xAxis);
		yAxis.Unitize();

		displaySize = 10;
		numOfGrid = 4;
	}
	public Plane(Point origin, Vector xDirection, Vector yDirection)
	{
		this.origin = origin;

		xDirection.Unitize();

		xAxis = xDirection;
		yAxis = yDirection;

		yAxis.CrossProduct(xDirection);
		yAxis.Reverse();
		zAxis = new Vector(yAxis);
		zAxis.Unitize();
		zAxis.Reverse();

		yAxis.CrossProduct(xDirection);
		yAxis.Unitize();

		displaySize = 10;
		numOfGrid = 4;
	}

	public Point PointAt(float u, float v, float w)
	{
		Vector xVec =new Vector(xAxis);
		xVec.MultipleBy(u);

		Vector yVec = new Vector(yAxis);
		yVec.MultipleBy(v);

		Vector zVec = new Vector(zAxis);
		zVec.MultipleBy(w);

		float pozX, pozY, pozZ;
		pozX = origin.x + xVec.x + yVec.x + zVec.x;
		pozY = origin.y + xVec.y + yVec.y + zVec.y;
		pozZ = origin.z + xVec.z + yVec.z + zVec.z;

		return new Point(pozX, pozY, pozZ);
	}

	public void Draw()
	{
		pushMatrix();
		translate(origin.x, origin.y, origin.z);


		stroke (40,40,40,255);

		for (float i = -displaySize / 2; i <= displaySize / 2; i += displaySize / numOfGrid)
		{
			if (i == 0)
			{
				Point ptStart = new Point(PointAt(0, -displaySize / 2, 0));
				line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);

				ptStart = new Point(PointAt(0, displaySize / 2, 0));
				stroke (0, 255, 0, 255);
				line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);
				stroke (40,40,40,255);
			}
			else
			{
				Point ptStart = new Point(PointAt(i, displaySize / 2, 0));
				Point ptEnd = new Point(PointAt(i, -displaySize / 2, 0));

				line(ptStart.x, ptStart.y, ptStart.z,ptEnd.x, ptEnd.y, ptEnd.z);
			}
		}

		for (float i = -displaySize / 2; i <= displaySize / 2; i += displaySize / numOfGrid)
		{
			if (i == 0)
			{
				Point ptStart = new Point(PointAt(-displaySize / 2, 0, 0));
				line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);

				ptStart = new Point(PointAt(displaySize / 2, 0, 0));
				stroke(255, 0, 0, 255);
				line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);
				stroke(40, 40, 40, 255);
			}
			else
			{
				Point ptStart = new Point(PointAt(displaySize / 2, i, 0));
				Point ptEnd = new Point(PointAt(-displaySize / 2, i, 0));

				line(ptStart.x, ptStart.y, ptStart.z,ptEnd.x, ptEnd.y, ptEnd.z);
			}


		}
		Point ptStartZ = new Point(PointAt(0, 0, displaySize / 2));
		stroke(0, 0, 255, 255);
		line(ptStartZ.x, ptStartZ.y, ptStartZ.z,origin.x, origin.y, origin.z);
		stroke(40, 40, 40, 255);

		popMatrix();

	}

	Point origin;
	Vector xAxis, yAxis, zAxis;
	float displaySize;
	int numOfGrid;

}












Test[] a = new Test[0];

void setup(){

	size(200,200,P2D);
	a = (Test[])append(a,new Test());
	a = (Test[])append(a,new Test());
	a = (Test[])append(a,new Test());
	println(a.length);

}


class Test{

	
	float b;



}
import saito.objloader.*;
int index;

OBJModel model;

float rotX;
float rotY;

PVector verts[];
int len;

void setup()
{
	size(600, 600, OPENGL);


	frameRate(30);
	//smooth();
	hint(ENABLE_OPENGL_4X_SMOOTH);
	model = new OBJModel(this);
	model.load("model.obj");
	model.drawMode(TRIANGLES);
	 len = model.getVertexsize(); 
	model.enableTexture();
	
	verts = new PVector[len];
	

	for(int i = 0;i<len;i++){
		verts[i] = model.getVertex(i); 
		 
	}
	
}

void draw()
{
	background(0);
	//stroke(255,80);
	noStroke();


	
	
	//lights();
	//directionalLight(200, 200, 200, -1, 0, 0);
	ambientLight(122, 0,0);


	pushMatrix();
	
	
	translate(width/2, height/2, 0);
	rotateX(rotY);
	rotateY(rotX);
	scale(100.0);

	//model.draw();
	
	
	for(int i = 0;i<len-4;i+=1){
	beginShape(TRIANGLES);
	
		vertex(verts[i].x,verts[i].y,verts[i].z);
		vertex(verts[i+1].x,verts[i+1].y,verts[i+1].z);
		vertex(verts[i+2].x,verts[i+2].y,verts[i+2].z);
	//	vertex(verts[i+1].x,verts[i+1].y,verts[i+1].z);
		
	
	endShape();
	}
	
	popMatrix();
}

void keyPressed()
{
	if(key == 'a')
		model.enableTexture();

	else if(key=='b')
		model.disableTexture();
}
void mouseDragged()
{
	rotX += (mouseX - pmouseX) * 0.01;
	rotY -= (mouseY - pmouseY) * 0.01;
}
// Substrate Watercolor
// j.tarbell   June, 2004
// Albuquerque, New Mexico
// complexification.net

// Processing 0085 Beta syntax update
// j.tarbell   April, 2005

int dimx = 800;
int dimy = 600;
int num = 0;
int maxnum = 50;

// grid of cracks
int[] cgrid;
Crack[] cracks;

// color parameters
int maxpal = 2048;
int numpal = 0;
color[] goodcolor = new color[maxpal];

// sand painters
SandPainter[] sands;

// MAIN METHODS ---------------------------------------------

void setup() {
	size(dimx,dimy,P2D);
	//  size(dimx,dimy,P3D);

	background(0);
	takecolor("pollock8.jpg");

	cgrid = new int[dimx*dimy];
	cracks = new Crack[maxnum];

	begin();
	smooth();
}

void draw() {
	// crack all cracks
	for (int n=0;n<num;n++) {
		cracks[n].move();
	}


}

void mousePressed() {
	begin();
}


// METHODS --------------------------------------------------

void makeCrack() {
	if (num<maxnum) {
		// make a new crack instance
		cracks[num] = new Crack();
		num++;
	}
}


void begin() {
	// erase crack grid
	for (int y=0;y<dimy;y++) {
		for (int x=0;x<dimx;x++) {
			cgrid[y*dimx+x] = 10001;
		}
	}
	// make random crack seeds
	for (int k=0;k<16;k++) {
		int i = int(random(dimx*dimy-1));
		cgrid[i]=int(random(360));
	}

	// make just three cracks
	num=0;
	for (int k=0;k<3;k++) {
		makeCrack();
	}
	background(255);
}



// COLOR METHODS ----------------------------------------------------------------

color somecolor() {
	// pick some random good color
	return goodcolor[int(random(numpal))];
}

void takecolor(String fn) {
	PImage b;
	b = loadImage(fn);
	//image(b,0,0);

	b.loadPixels();
	for (int x=0;x<b.width;x+=3){
		for (int y=0;y<b.height;y+=3) {
			color c = color(b.pixels[y*b.width+x]);
			boolean exists = false;
			for (int n=0;n<numpal;n++) {
				if (c==goodcolor[n]) {
					exists = true;
					break;
				}
			}
			if (!exists) {
				// add color to pal
				if (numpal<maxpal) {
					goodcolor[numpal] = c;
					numpal++;
				}
			}
		}
	}
}




// OBJECTS -------------------------------------------------------

class Crack {
	float x, y;
	float t;    // direction of travel in degrees

	// sand painter
	SandPainter sp;

	Crack() {
		// find placement along existing crack
		findStart();
		sp = new SandPainter();
	}

	void findStart() {
		// pick random point
		int px=0;
		int py=0;

		// shift until crack is found
		boolean found=false;
		int timeout = 0;
		while ((!found) || (timeout++>1000)) {
			px = int(random(dimx));
			py = int(random(dimy));
			if (cgrid[py*dimx+px]<10000) {
				found=true;
			}
		}

		if (found) {
			// start crack
			int a = cgrid[py*dimx+px];
			if (random(100)<50) {
				a-=90+int(random(-2,2.1));
			} else {
				a+=90+int(random(-2,2.1));
			}
			startCrack(px,py,a);
		} else {
			//println("timeout: "+timeout);
		}
	}

	void startCrack(int X, int Y, int T) {
		x=X;
		y=Y;
		t=T;//%360;
		x+=0.61*cos(t*PI/180);
		y+=0.61*sin(t*PI/180);
	}

	void move() {
		// continue cracking
		x+=0.42*cos(t*PI/180);
		y+=0.42*sin(t*PI/180);

		//t+=sin(frameCount/3000.0);


		// bound check
		float z = 0.33;
		int cx = int(x+random(-z,z));  // add fuzz
		int cy = int(y+random(-z,z));

		// draw sand painter
		regionColor();

		// draw black crack
		stroke(0,5);
		point(x+random(-z,z),y+random(-z,z));


		if ((cx>=0) && (cx<dimx) && (cy>=0) && (cy<dimy)) {
			// safe to check
			if ((cgrid[cy*dimx+cx]>10000) || (abs(cgrid[cy*dimx+cx]-t)<5)) {
				// continue cracking
				cgrid[cy*dimx+cx]=int(t);
			} else if (abs(cgrid[cy*dimx+cx]-t)>2) {
				// crack encountered (not self), stop cracking
				findStart();
				makeCrack();
			}
		} else {
			// out of bounds, stop cracking
			findStart();
			makeCrack();
		}
	}

	void regionColor() {
		// start checking one step away
		float rx=x;
		float ry=y;
		boolean openspace=true;

		// find extents of open space
		while (openspace) {
			// move perpendicular to crack
			rx+=0.81*sin(t*PI/180);
			ry-=0.81*cos(t*PI/180);
			int cx = int(rx);
			int cy = int(ry);
			if ((cx>=0) && (cx<dimx) && (cy>=0) && (cy<dimy)) {
				// safe to check
				if (cgrid[cy*dimx+cx]>10000) {
					// space is open
				} else {
					openspace=false;
				}
			} else {
				openspace=false;
			}
		}
		// draw sand painter
		sp.render(rx,ry,x,y);
	}
}


class SandPainter {

	color c;
	float g;

	SandPainter() {

		c = somecolor();
		g = random(0.01,0.1);
	}
	void render(float x, float y, float ox, float oy) {
		// modulate gain
		g+=random(-0.050,0.050);
		float maxg = 1.0;
		if (g<0) g=0;
		if (g>maxg) g=maxg;

		// calculate grains by distance
		//int grains = int(sqrt((ox-x)*(ox-x)+(oy-y)*(oy-y)));
		int grains = 64;

		// lay down grains of sand (transparent pixels)
		float w = g/(grains-1.0);
		for (int i=0;i<grains;i++) {
			float a = 0.1-i/(grains*10.0);
			stroke(red(c),green(c),blue(c),a*256);
			point(ox+(x-ox)*sin(sin(i*w)),oy+(y-oy)*sin(sin(i*w)));
		}
	}
}

// j.tarbell   June, 2004
// Albuquerque, New Mexico
// complexification.net


float[][] row = new float[2][160];

float mm = 3;
float mx = 4;
float xshift = 1000.0;
void setup(){
	size(800,600,P2D);
	background(255);
	reset();
	smooth();
}

void reset(){
	for(int i =0;i<row[0].length;i++){
		row[0][i] = map(i,0,row[0].length,0,width);
	}

	for(int i =0;i<row[1].length;i++){
		if(i%2==0){
			row[1][i] = height-(mm/2.0);
		}else{
			row[1][i] = height;
		}
	}
	//background(255);
}

void draw(){
	//background(255);

	for(int i =0;i<row[0].length;i++){
		row[0][i] += (random(-100,100)/xshift);//map(i,0,row[0].length,0,width);
	}

	boolean over = false;
	int cnt = 0;

	for(int i =0;i<row[1].length;i++){
		if(frameCount%2==0){
			if(i%2==0)
				row[1][i] -= random(mm,mx);
		}else{
			if((i+1)%2==0)
				row[1][i] -= random(mm,mx);
		}

		if(row[1][i]<0)
			cnt++;

		if(cnt>=row[1].length-1)
			over=true;
	}

	if(over){
		reset();
	}

	stroke(0,120);
	noFill();

	beginShape();
	for(int i=0;i<row[0].length;i++){
		vertex(row[0][i],row[1][i]);
	}
	endShape();
}

boolean rightDown, leftDown, middleDown;
float px = 0;
float px2 = 0;
float scrn[] = {0, 0, 0};
float model[] = new float[3];

/*
void mousePressed(){

	if(mouseButton==LEFT){
		leftDown = true;
		retez.add(new Point(mouseX,mouseY,0));
		
	}else if(mouseButton == RIGHT){
		rightDown = true;
		//px=mouseX;
	}else{
		middleDown = true;
	}
	//println(frameCount+" L:"+leftDown+" R:"+rightDown+" M:"+middleDown);

}*/

void mousePressed(){
	if (mouseButton==LEFT )
	{





		// apply transformation matrices to mouse coords
		scrn[0] = mouseX;
		scrn[1] = mouseY;
		scrn[2] = 0;

		model = new float[3];
		
		screen2Model.mult(scrn, model);
		screen2Model = modvwInv;
		screen2Model.apply(cam);




		retez.add(new Point(model[0],model[1],model[2]));
		/*
		vertexKlicked = vertexMouseOver;
		zModelKlick = zModelMouseOver;

		// calculate transformation matrix for projecting mouse coords
		// to the plane where the current selected vertex is
		// this doesn't work!
		screen2Model = modvwInv;
		screen2Model.apply(cam);
		*/



		//screen2Model.apply(proj);
		//screen2Model.translate(0, 0, zModelKlick);
	}
}

void mouseReleased(){
	vertexKlicked = -1;
}

void mouseDragged() {
	if (mouseButton==LEFT && vertexKlicked>-1) {


		//vertices3D[vertexKlicked] = model[0];
		//vertices3D[vertexKlicked+1] = model[1];
		//vertices3D[vertexKlicked+2] = model[2];
	}
	else {
		// mouse controlled rotation
		float x1 = mouseX-pmouseX;
		float y1 = mouseY-pmouseY;
		rotX += -y1 * 0.01;
		rotY += x1 * 0.01;
	}
}

/*

void mouseReleased(){

	if(mouseButton==LEFT){
		leftDown = false;
		
		

	}else if(mouseButton == RIGHT){

		rightDown = false;
		px2+=mouseX-width/2.0+px;
	}else{
		middleDown = false;
	}
	//println(frameCount+" L:"+leftDown+" R:"+rightDown+" M:"+middleDown);

}


*/
PGraphics3D p3d;
PMatrix3D proj = new PMatrix3D();
PMatrix3D cam = new PMatrix3D();
PMatrix3D modvw = new PMatrix3D();
PMatrix3D modvwInv = new PMatrix3D();
PMatrix3D screen2Model = new PMatrix3D();


// rotation
float rotX, rotY;

// arrays hold the vertices of 3d object
float[] vertices3D = new float[0];
int[] vertices2D = new int[0];

// index of current mouseover / clicked vertex
int vertexMouseOver = -1;
int vertexKlicked= -1;

// z value in model/world space of current vertex
float zModelMouseOver;
float zModelKlick;

class Camera2{
                                           



	Camera2(){
		p3d = (PGraphics3D)g;	
rotX=PI;	
	}


	void preDraw(){

		pushMatrix();

		//apply mouse rotation and translation to center of screen
		translations();

		//get 3d matrices
		proj = p3d.projection.get();
		cam = p3d.camera.get();
		modvw = p3d.modelview.get();
		modvwInv = p3d.modelviewInv.get();
		
		screen2Model.mult(scrn, model);
		
		screen2Model = modvwInv;
		screen2Model.apply(cam);

	}


	void postDraw(){

		//visualize 3d axes for orientation
		//camer.drawAxes3D();

		//visualize vertices
		//camer.drawVertSphere();
		//	camer.drawVert();

		hitDetect();

		// 3d object space end
		popMatrix();

		drawHitDetect();
	}

	void translations() {
		translate(width/2, height/2);
		//mouse rotate
		rotateX(rotX);
		rotateZ(rotY);
	}

	void drawAxes3D() {
		stroke(255,0,0);
		line(0,0,0, 100,0,0);
		stroke(0,255,0);
		line(0,0,0, 0,-100,0);
		stroke(0,0,255);
		line(0,0,0, 0,0,100);
	}

	

	void hitDetect() {
		// mouse hit detection using screnX, screenY
		vertices2D = new int[0];
		vertexMouseOver = -1;

		for(int i=0; i<vertices3D.length; i=i+3) {
			int x = int(screenX(vertices3D[i], vertices3D[i+1], vertices3D[i+2]));
			int y = int(screenY(vertices3D[i], vertices3D[i+1], vertices3D[i+2]));

			vertices2D = append(vertices2D, x);
			vertices2D = append(vertices2D, y);

			if (x > mouseX-5 && x < mouseX+5 && y > mouseY-5 && y < mouseY+5) {
				vertexMouseOver = i;
			}
		}
	}

	void drawHitDetect() {
		if (vertexKlicked > -1) {
			stroke(255, 0, 0);
			noFill();
			ellipse(vertices2D[vertexKlicked/3*2], vertices2D[vertexKlicked/3*2+1], 30, 30);
		} else if (vertexMouseOver > -1) {
			stroke(100, 100, 100);
			noFill();
			ellipse(vertices2D[vertexMouseOver/3*2], vertices2D[vertexMouseOver/3*2+1], 20, 20);
		}
	}





}





import processing.opengl.*;



Camera2 camer;
Retez retez;
Plane pln;



void setup()
{
	size(800,600,P3D);
//	hint(DISABLE_OPENGL_2X_SMOOTH);
noSmooth();

	retez = new Retez();
	camer = new Camera2();
	pln = new Plane(new Point(0,0,0),new Vector(1,0,0),new Vector(1,1,0));
	pln.displaySize = 200;

}

void draw()
{
	background(0);

	camer.preDraw();
	
	
	
	
	noFill();
	stroke(255);
	box(200);
	
	retez.Draw();
	pln.Draw();
	
	pushMatrix();
	translate(100,100,-100);
stroke(255,20,20);
	box(5);
	popMatrix();
	
	camer.postDraw();


	

	// calculate z value of picked vertex in model(world) space
	if (vertexMouseOver > -1) {
		zModelMouseOver = modelZ(vertices3D[vertexMouseOver], vertices3D[vertexMouseOver+1], vertices3D[vertexMouseOver+2]);
	}

}













class Retez{

	Point[] bod = new Point[0];
	int kolikBodu = 0;


	void add(Point _bod){

	/*	if(bod.length>2){
			println("mooc!");
		}else{
*/
			bod = (Point[])expand(bod,bod.length+1);
			bod[bod.length-1] = _bod;
			println(bod[bod.length-1].x+" : "+bod[bod.length-1].y+" : "+bod[bod.length-1].z);
                      
//		}
	}

	void Draw(){
		
		
		
		for(int i = 0 ;i<bod.length;i++){
			bod[i].Draw();
			//bod[i].x = unprojectX(mouseX,bod[0].y,bod[0].z);
			//bod[i].y = modelY(bod[0].x,mouseY,bod[0].z);
			//bod[i].x = modelX(mouseX-width/2.0,mouseY-height/2.0,0);
			//bod[i].y = -modelY(mouseX-width/2.0,mouseY-height/2.0,0);
			//bod[i].z = modelZ(mouseX-width/2.0,mouseY-height/2.0,0);
		}                                                
		
		//println("world coords via modelXYZ = " + mx + ", " + my + ", " + mz);
		
		
	}


}
public class Point
{
	public Point(Point point)
	{
		x = point.x;
		y = point.y;
		z = point.z;
	}
	public Point(float x, float y)
	{
		this.x = x;
		this.y = y;
		this.z = 0;
	}
	public Point(float x, float y, float z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
	public Point(Point origin, Vector direction)
	{
		x = origin.x + direction.x;
		y = origin.y + direction.y;
		z = origin.z + direction.z;
	}
	public float DistanceTo(Point targetPoint)
	{
		float d = 0;
		d = sqrt((targetPoint.x - x) * (targetPoint.x - x) +
		         (targetPoint.y - y) * (targetPoint.y - y) +
		         (targetPoint.z - z) * (targetPoint.z - z));
		return (d);
	}

	public void Plus(Vector direction)
	{
		x += direction.x;
		y += direction.y;
		z += direction.z;
	}

	void Draw()
	{
		pushMatrix();
		translate(x,y,z);
		noFill();
		stroke(255,20,20);
		box(20);
		popMatrix();
	}

	float x, y, z;

}

public class Vector
{
	public Vector(Vector vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
	}
	public Vector(float x, float y, float z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
	public Vector(float x1, float y1, float z1, float x2, float y2, float z2)
	{
		this.x = x2 - x1;
		this.y = y2 - y2;
		this.z = z1 - z2;
	}
	public Vector(Point fromPoint, Point toPoint)
	{
		x = toPoint.x - fromPoint.x;
		y = toPoint.y - fromPoint.y;
		z = toPoint.z - fromPoint.z;
	}

	public void MultipleBy(float koef)
	{
		x *= koef;
		y *= koef;
		z *= koef;
	}

	public void Plus(Vector addVector)
	{
		x += addVector.x;
		y += addVector.y;
		z += addVector.z;
	}

	public void Reverse()
	{
		x *= -1;
		y *= -1;
		z *= -1;
	}

	public void CrossProduct(Vector secondVector)
	{
		float tempX, tempY, tempZ;
		tempX = x;
		tempY = y;
		tempZ = z;

		x = tempY * secondVector.z - tempZ * secondVector.y;
		y = tempZ * secondVector.x - tempX * secondVector.z;
		z = tempX * secondVector.y - tempY * secondVector.x;
	}

	public void Unitize()
	{
		float d = Delka();
		x /=  d;
		y /=  d;
		z /=  d;
	}

	public float Delka()
	{
		float d = 0;
		//length = sqrt((ax * ax) + (ay * ay) + (az * az))
		d = sqrt((x * x) + (y * y) + (z * z));
		return d;
	}

	public boolean IsZero()
	{
		if ((x == 0) && (y == 0) && (z == 0)) return true;
		return false;
	}

	float x, y, z;

}

public class Plane
{
	public Plane(float x, float y, float z)
	{
		this.origin = new Point(x, y, z);

		xAxis = new Vector(1, 0, 0);
		yAxis = new Vector(0, 1, 0);
		zAxis = new Vector(0, 0, 1);

		displaySize = 10;
		numOfGrid = 4;
	}
	public Plane(Point origin)
	{
		this.origin = origin;

		xAxis = new Vector(1, 0, 0);
		yAxis = new Vector(0, 1, 0);
		zAxis = new Vector(0, 0, 1);

		displaySize = 10;
		numOfGrid = 4;
	}
	public Plane(Point origin, Point xVectorPoint, Point yVectorPoint)
	{
		this.origin = origin;
		xAxis = new Vector(origin, xVectorPoint);
		xAxis.Unitize();

		yAxis = new Vector(origin, yVectorPoint);

		yAxis.CrossProduct(xAxis);
		yAxis.Reverse();
		zAxis = new Vector(yAxis);
		zAxis.Unitize();
		zAxis.Reverse();

		yAxis.CrossProduct(xAxis);
		yAxis.Unitize();

		displaySize = 10;
		numOfGrid = 4;
	}
	public Plane(Point origin, Vector xDirection, Vector yDirection)
	{
		this.origin = origin;

		xDirection.Unitize();

		xAxis = xDirection;
		yAxis = yDirection;

		yAxis.CrossProduct(xDirection);
		yAxis.Reverse();
		zAxis = new Vector(yAxis);
		zAxis.Unitize();
		zAxis.Reverse();

		yAxis.CrossProduct(xDirection);
		yAxis.Unitize();

		displaySize = 10;
		numOfGrid = 4;
	}

	public Point PointAt(float u, float v, float w)
	{
		Vector xVec =new Vector(xAxis);
		xVec.MultipleBy(u);

		Vector yVec = new Vector(yAxis);
		yVec.MultipleBy(v);

		Vector zVec = new Vector(zAxis);
		zVec.MultipleBy(w);

		float pozX, pozY, pozZ;
		pozX = origin.x + xVec.x + yVec.x + zVec.x;
		pozY = origin.y + xVec.y + yVec.y + zVec.y;
		pozZ = origin.z + xVec.z + yVec.z + zVec.z;

		return new Point(pozX, pozY, pozZ);
	}

	public void Draw()
	{
		pushMatrix();
		translate(origin.x, origin.y, origin.z);


		stroke (40,40,40,255);

		for (float i = -displaySize / 2; i <= displaySize / 2; i += displaySize / numOfGrid)
		{
			if (i == 0)
			{
				Point ptStart = new Point(PointAt(0, -displaySize / 2, 0));
				line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);

				ptStart = new Point(PointAt(0, displaySize / 2, 0));
				stroke (0, 255, 0, 255);
				line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);
				stroke (40,40,40,255);
			}
			else
			{
				Point ptStart = new Point(PointAt(i, displaySize / 2, 0));
				Point ptEnd = new Point(PointAt(i, -displaySize / 2, 0));

				line(ptStart.x, ptStart.y, ptStart.z,ptEnd.x, ptEnd.y, ptEnd.z);
			}
		}

		for (float i = -displaySize / 2; i <= displaySize / 2; i += displaySize / numOfGrid)
		{
			if (i == 0)
			{
				Point ptStart = new Point(PointAt(-displaySize / 2, 0, 0));
				line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);

				ptStart = new Point(PointAt(displaySize / 2, 0, 0));
				stroke(255, 0, 0, 255);
				line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);
				stroke(40, 40, 40, 255);
			}
			else
			{
				Point ptStart = new Point(PointAt(displaySize / 2, i, 0));
				Point ptEnd = new Point(PointAt(-displaySize / 2, i, 0));

				line(ptStart.x, ptStart.y, ptStart.z,ptEnd.x, ptEnd.y, ptEnd.z);
			}


		}
		Point ptStartZ = new Point(PointAt(0, 0, displaySize / 2));
		stroke(0, 0, 255, 255);
		line(ptStartZ.x, ptStartZ.y, ptStartZ.z,origin.x, origin.y, origin.z);
		stroke(40, 40, 40, 255);

		popMatrix();

	}

	Point origin;
	Vector xAxis, yAxis, zAxis;
	float displaySize;
	int numOfGrid;

}











import codeanticode.gsvideo.*;

int W = 320;
int H = 240;

int cw = W ;
int ch = H;
int depth = 255;
byte tresh = 30;

FileWriter file;
int linesWritten = 0;
GSPipeline cam;

float sc = 2.0;

float[][] temp;

boolean writepos = false;

int mode = 0;

boolean created = false;

void setup() {

	size(W,H,P3D);
	frameRate(30);

	String webcam = "v4l2src ! queue2 ! ffvideoscale ! video/x-raw-rgb,width="+cw+",height="+ch+", bpp=32, depth=24";
	cam = new GSPipeline(this, webcam);


	temp =  new float[cw][ch];
	for(int y = 0;y<ch;y++){
		for(int x = 0;x<cw;x++){
			temp[x][y] = 0;
		}
	}



	//size(350, 200,"hipstersinc.P5Sunflow");
	//noLoop();
	noStroke();
	background(0);
}
void draw() {
	background(0);

	if(mode==0){
		grabData();
	}
	//saveFrame("out/fram####.png");
}

void renderData(){
	try{
		String path = "/home/kof/data/sketchBook/2010/03-brezen/dimmensionalRec/render/";//"./render";//sketchPath++(((int)(50*25*width*height)/256)*2);
		println(path);
		Runtime.getRuntime().exec("xterm -e cd render "+path+" && pp");
		println("rendering");
	}
	catch(java.io.IOException e){
		println(e);
	}

	exit();


}

void grabData(){

	if (cam.available() == true){
		cam.read();
		//cam.loadPixels();



		if(linesWritten>3000)
			writepos = false;

		if(writepos&&!created){

			try
			{
				file = new FileWriter("/home/kof/data/sketchBook/2010/03-brezen/dimmensionalRec/render/positions.dump"); //bool tells to append
				file.write(cw+","+ch+"\n");
				println("file updated");

				created = true;
			}
			catch(Exception e)
			{
				println("Error: Can't open file!");
			}
		}


		for(int y = 0;y<ch;y++){
			for(int x = 0;x<cw;x++){
				temp[x][y] += (brightness(cam.pixels[y*cw+x])-temp[x][y])/8.0;
				//fill(cam.pixels[y*cw+x]);
				//rect(x,y,1,1);
				if(writepos)
					try{
						file.write(temp[x][y]+",");
					}catch(IOException e){
						println("Error: Can't write into a file!");
					}
			}

		}

		if(writepos)
			try{
				file.write("\n");
				linesWritten++;


			}catch(IOException e){
				println("Error: Can't write into a file!");
			}

	}
	float ys = mouseY;

	noFill();
	//stroke(255,50);
	noStroke();

	pushMatrix();
	translate(width/2,height/2+20,-160);
	rotateX(PI/3);
	rotateZ(frameCount/100.0);



	float scl = 2;


	for (int x = 0; x < temp.length-1; x++){
		for (int y = 0; y < temp[x].length-1; y++){
			if(temp[x][y]>tresh){
				pushMatrix();
				beginShape(QUADS);
				translate(x*scl-cw,y*scl-ch,ys);
				// stroke(z[x][y]+127,220);
				stroke(temp[x][y]/sc);

				vertex(0,0,temp[x][y]/sc);
				// stroke(z[x+1][y]+127,220);
				stroke(temp[x][y]);

				vertex(scl,0,temp[x+1][y]/sc);
				// stroke(z[x+1][y+1]+127,220);
				stroke(temp[x][y]);

				vertex(scl,scl,temp[x+1][y+1]/sc);
				// stroke(z[x][y+1]+127,220);
				stroke(temp[x][y]);

				vertex(0,scl,temp[x][y+1]/sc);
				endShape();
				//line(0,scl,z[x][y+1],0,scl,0);
				popMatrix();
			}

		}
	}

	popMatrix();


}

void keyPressed(){

	if(key == 'r'){
		writepos = !writepos;
	}else if(key =='q'){
		renderData();
	}

}

void stop(){

	if(created){
		print("closing dump...");

		try{
			file.close();
			println("CLOSED!");
		}catch(IOException e){
			println("Error: Can't close a file!");
		}
	}

	super.stop();

}

class Surface{

	int scl;
	int w,h;
	int rows, cols;
	float zoff = 0.0;
	float[][] z;


}
import hipstersinc.sunflow.*;
import hipstersinc.sunflow.shader.*;
import hipstersinc.*;

String[] rawData;
String fileName;
float z[];
BufferedReader file;

int W,H;
float tresh = 30.0;

int startFrame = 0;
int currentFrame = startFrame;

boolean oneShot = false;
boolean preview = false;

void setup(){

	fileName = sketchPath("positions.dump") ;

	try{
		file = new BufferedReader (new FileReader (fileName)) ;
		String dimm = file.readLine();
		println(dimm);
		String dimm2[] = splitTokens(dimm,",");
		W = parseInt(dimm2[0]);
		H = parseInt(dimm2[1]);

		println("skipping on frameno "+startFrame);

		for(int i = 0;i<=startFrame;i++){
			String trash = file.readLine();
		}

	}catch (Exception e){
		println ("Error" + e) ;
	}

	if(!preview){
		size(W, H,"hipstersinc.P5Sunflow"); //,"hipstersinc.P5Sunflow"
		if(oneShot)
		noLoop();
	}else{

		size(W, H, P3D);
	}

	noStroke();
	fill(255);
}

void setupCamera() {
	P5Sunflow sunflow = (P5Sunflow) g;
	sunflow.camera.setType(SunflowCamera.THINLENS);
	sunflow.camera.setFocalDistance(450);
	sunflow.camera.setLensRadius(12f);

	// Now we set the Anti-Aliasing sampling.
	sunflow.scene.setAaSamples(12);

}


void draw(){
	if(preview){
		background(0);
	}else{
		background(230);
		//setupCamera();

	}

	try{
		String raw = file.readLine();
		String temp[] = splitTokens(raw,",");

		z = new float[temp.length];
		for(int i = 0;i<z.length;i++){
			z[i] = parseFloat(temp[i]);
		}

	}catch (Exception e){
		println ("Error " + e + " @frame: "+frameCount);

		exit();
	}



	float scl = 2;
	float sc = 2.0;
	float ys = 20.0;

	if(z!=null){

		//pushMatrix();
		translate(width/2,height/2+20,-160);
		rotateX(PI/3);
		//rotateZ(width/2.0/100.0);

		if(preview){
			noStroke();
			for (int x = 0; x < W-1; x++){
				for (int y = 0; y < H-1; y++){
					if(z[y*W+x]>tresh){
						fill(z[y*W+x]);
						beginShape(QUADS);
						//	translate(x*scl-W,y*scl-H,ys);
						// stroke(z[x][y]+127,220);


						vertex(x*scl-W,y*scl-H,ys+z[y*W+x]/sc);
						// stroke(z[x+1][y]+127,220);
						//fill(255,1);

						vertex(scl+x*scl-W,y*scl-H,ys+z[y*W+x+1]/sc);
						// stroke(z[x+1][y+1]+127,220);
						//stroke(255,1);

						vertex(scl+x*scl-W,scl+y*scl-H,ys+z[(y+1)*W+x+1]/sc);
						// stroke(z[x][y+1]+127,220);
						//stroke(255,1);

						vertex(x*scl-W,scl+y*scl-H,ys+z[(y+1)*W+x]/sc);
						endShape();
						//line(0,scl,z[x][y+1],0,scl,0);

					}

				}
			}

		}else{

			fill(255);
			noStroke();

			for (int x = 0; x < W-1; x++){
				for (int y = 0; y < H-1; y++){
					if(z[y*W+x]>tresh){

						beginShape(QUADS);
						//	translate(x*scl-W,y*scl-H,ys);
						// stroke(z[x][y]+127,220);
						//stroke(z[x][y]/sc);

						vertex(x*scl-W,y*scl-H,ys+z[y*W+x]/sc);
						// stroke(z[x+1][y]+127,220);
						//stroke(z[x][y]);

						vertex(scl+x*scl-W,y*scl-H,ys+z[y*W+x+1]/sc);
						// stroke(z[x+1][y+1]+127,220);
						//stroke(z[x][y]);

						vertex(scl+x*scl-W,scl+y*scl-H,ys+z[(y+1)*W+x+1]/sc);
						// stroke(z[x][y+1]+127,220);
						//stroke(z[x][y]);

						vertex(x*scl-W,scl+y*scl-H,ys+z[(y+1)*W+x]/sc);
						endShape();
						//line(0,scl,z[x][y+1],0,scl,0);

					}

				}
			}
		}
		
		fill(230);
		beginShape(QUADS);
		vertex(-W*2,-H*2,0);
		vertex(W*2,-H*2,0);
		vertex(W*2,H*2,0);
		vertex(-W*2,H*2,0);
		endShape();

		//popMatrix();

	}

	if(!preview){
		saveFrame("out/render"+nf(currentFrame,4)+".png");
		currentFrame++;

	}
}
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import org.w3c.dom.Document;

import com.google.code.facebookapi.FacebookWebappHelper;
import com.google.code.facebookapi.FacebookXmlRestClient;
import com.google.code.facebookapi.IFacebookRestClient;


    Log LOG = LogFactory.getLog(FacebookInterceptor.class);

String FACEBOOK_USER_CLIENT = "facebook.user.client";
String fbApiKey;
 String fbSecret;

 
 boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        HttpSession session = request.getSession(true);
        IFacebookRestClient<Document> userClient = FacebookInterceptor.getUserClient(request, fbApiKey, fbSecret);

        FacebookWebappHelper<Document> facebook = new FacebookWebappHelper<Document>(request, response, fbApiKey,
                fbSecret, userClient);
        String nextPage = request.getRequestURI();
        nextPage = nextPage.substring(nextPage.indexOf("/", 1) + 1);
        LOG.debug("NEXT PAGE : " + nextPage);
      
	boolean redirectOccurred = facebook.requireLogin(nextPage);
       
	
	
	if (redirectOccurred) {
            LOG.debug("REDIRECT OCCURRED ");
            return false;
        }

        return true;
    }

    public static FacebookXmlRestClient getUserClient(HttpServletRequest request, String fbApiKey, String fbSecret) {
        LOG.debug("Obtaining user session.");
        HttpSession session = request.getSession(true);
        IFacebookRestClient<Document> userClient = (FacebookXmlRestClient) session.getAttribute(FACEBOOK_USER_CLIENT);
        if (userClient == null) {
            LOG.debug("Creating user session");
            userClient = new FacebookXmlRestClient(fbApiKey, fbSecret);
            session.setAttribute(FACEBOOK_USER_CLIENT, userClient);
        }

        return (FacebookXmlRestClient) userClient;
    }

    public void setFbApiKey(String fbApiKey) {
        this.fbApiKey = fbApiKey;
    }

    public void setFbSecret(String fbSecret) {
        this.fbSecret = fbSecret;
    }
}import codeanticode.gsvideo.*;
import oscP5.*;
import netP5.*;
  
OscP5 oscP5;
NetAddress myRemoteLocation;



int W = 320;
int H = 240;

int cw = W;
int ch = H;



GSPipeline cam;
Senzor s[];
Graph g;

void setup(){
	size(W,H,P2D);

	frameRate(25);
	
	oscP5 = new OscP5(this,12000);
	myRemoteLocation = new NetAddress("127.0.0.1",12000);

	reset();

	String webcam = "v4l2src ! queue2 ! ffvideoscale ! "+"video/x-raw-rgb,width="+cw+",height="+ch+", bpp=32, depth=24";
	String dv = "dv1394src ! queue ! dvdemux ! ffdec_dvvideo ! ffmpegcolorspace ! ffvideoscale ! video/x-raw-rgb,width = "+cw+", height = "+ch+", bpp=32, depth=24";
	
	cam = new GSPipeline(this, webcam);
	loadPixels();

	textFont(createFont("FreeSans",9,false));
	textMode(SCREEN);
	rectMode(CENTER);
	
	noFill();
	stroke(255);
	noSmooth();
}

void draw(){

	if (cam.available() == true){
		cam.read();
		cam.loadPixels();

		for(int y = 0;y<ch;y++){
			for(int x = 0;x<cw;x++){
				pixels[y*cw+x] = cam.pixels[y*cw+x];
			}
		}

	}

	for(int i =0;i<s.length;i++)
		s[i].compute();

	for(int i =0;i<s.length;i++)
		s[i].draw();
	
	//g.draw();
	//image(g.p,0,0);
	
	sendAll();
}



void reset(){
	s = new Senzor[0];
	g = new Graph();
}

void mousePressed(){
	s = (Senzor[])append(s,new Senzor(mouseX,mouseY,s.length));

}

void keyPressed(){
	if(keyCode==BACKSPACE){
		reset();
	}else if(keyCode==LEFT){
		s[s.length-1].x--;
	}else if(keyCode==RIGHT){
		s[s.length-1].x++;
	}else if(keyCode==DOWN){
		s[s.length-1].y++;
	}else if(keyCode==UP){
		s[s.length-1].y--;
	}

}

void sendAll(){
  /* in the following different ways of creating osc messages are shown by example */
  OscMessage myMessage = new OscMessage("/cam");
  
  for(int i =0;i<s.length;i++)
  myMessage.add(s[i].sval); /* add an int to the osc message */

  /* send the message */
  oscP5.send(myMessage, myRemoteLocation); 


}

class Senzor{
	int x,y,id,bx,by;
	float val,sval,sval2;
	float speed = 10.0;
	float krouz;
	float r;

	Senzor(int _x,int _y,int _id){
		bx=x=_x;
		by=y=_y;
		id=_id;
		krouz = random(5,60);
		r = 30.0;
	}

	void draw(){
		stroke(255-sval);
		rect(x,y,3,3);
		pushStyle();
		fill(255-sval);
		text(id+":"+((int)sval),x+10,y);
		popStyle();
	}

	void compute(){
		
		val = getVal();
		sval2 = sval;
		sval += (val-sval) / speed;
		
		x=(int)(bx+(cos(frameCount/krouz)+1.0)*r);
		y=(int)(by+(sin(frameCount/krouz))*r);
		
		x = constrain(x,2,width-2);
		y = constrain(y,2,height-2);
	}

	float getVal(){
		float tmp = 0;
		for(int Y = -1;Y<=1;Y++){
			for(int X = -1;X<=1;X++){
				tmp += brightness(pixels[(y+Y)*W+(x+X)])/9.0;
			}
		}

		return(tmp);
	}
}

class Graph{
	PGraphics p;
	int xx = 0;
	
	Graph(){
		p = createGraphics(width,height,P2D);
	}
	
	void draw(){
		p.beginDraw();
		
		for(int i = 0;i<s.length;i++){
			p.stroke(255-s[i].sval);
			p.line(xx-1,map(s[i].sval,0,255,height,0),xx,map(s[i].sval2,0,255,height,0));		
		}
		p.endDraw();
		
		
		
		if(xx>width){
			xx=0;
			p = createGraphics(width,height,P2D);
	
		}
		
		
		xx++;
	
	}
	
	


}
import codeanticode.gsvideo.*;

Neuron n[][] = new Neuron[240][320];
import krister.Ess.*;
GSPipeline cam;
AudioStream myStream;
float[] streamBuffer;
int y  = 0;

float bluramount = 0.5;

void setup(){
	size(n[0].length,n.length,P3D);
	background(0);

	frameRate(25);

	noSmooth();

	Ess.start(this);

	myStream=new AudioStream();
	myStream.sampleRate(44100/4);
	myStream.bufferSize(width);
	streamBuffer=new float[myStream.size];
	myStream.start();


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii] = new Neuron(i,ii);
		}
	}

	noFill();


	
	String webcam = "v4l2src ! queue2 ! ffvideoscale ! "+"video/x-raw-rgb,width="+width+",height="+height+", bpp=32, depth=24";
	cam = new GSPipeline(this, webcam);


}

void keyPressed()
{
	if(keyCode==UP){
		bluramount+=0.1;
	}else if(keyCode==DOWN){
		bluramount-=0.1;
	}

	bluramount=constrain(bluramount,0.5,40);

}


void fillAudioBufferL(){
	
	loadPixels();

	
	int cnt =0;
	for(int X=0; X<width; X++) {
		streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9)+sin(noise(frameCount/2.0)*255);
		cnt++;
	}
	/*
	for(int X=width-1; X>=0; X--) {
		streamBuffer[X] = map(brightness(pixels[y*width+X]),0,255,-0.9,0.9);
		cnt++;
}*/

	//y=(int)((sin(frameCount/30.0)+1.0)*height/2.0);// width/3;//mouseY;
	y=height/2;//y%height;

}

void fillAudioBuffer(){
	loadPixels();


	for(int Y=0; Y<height; Y++) {
		if(Y%2==0){
			for(int X=0; X<width; X++) {

				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}

		}else{
			for(int X=width-1; X>=0; X--) {

				streamBuffer[Y*width+X] = map(brightness(pixels[Y*width+X]),0,255,-0.9,0.9);
			}
		}
	}



	//myLowPass=new LowPass(220,-80,4);

	//myLowPass.filter(myStream);
}
void audioStreamWrite(AudioStream theStream) {
	System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
}

void draw(){
	//background(0);

	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].cycle();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			n[i][ii].update();
		}
	}


	for(int i =0;i<n.length;i++){
		for(int ii =0;ii<n[i].length;ii++){
			pushMatrix();
			translate(ii,i);
			n[i][ii].draw();
			popMatrix();
		}
	}

	if(bluramount>0.5)
		filter(BLUR,bluramount);

	fillAudioBufferL();
	
	if (cam.available() == true){
		cam.read();
		cam.loadPixels();
		for(int i =0;i<pixels.length;i++)
		pixels[i]=color(brightness(cam.pixels[i]+pixels[i])/2.0);
	}
	
	
	stroke(255,0,0);
	//line(0,y,width,y);




}

public void stop() {
	Ess.stop();
	super.stop();
}


class Neuron{

	int lay,id;
	float vibra,val,val2;
	//float tresh = 240.0;
	//float prum[] = new float[3];

	float tone = 0,amount = 0;
	float[] w;

	Neuron(int _lay,int _id){
		lay = _lay;
		id = _id;
		w = new float[8];
		for(int i =0;i<w.length;i++){
			w[i] = random(400)/100.0;
		}
		vibra = random(800,1000)/10000.0;


		val = random(255);

	}

	void cycle(){

		tone+=vibra;
		amount = (sin(tone)+1.0)/2.0;

		val2 = 0.0;



		val2 += n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[0];
		val2 += n[(lay+n.length-0)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[1];
		val2 += n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];

		//val2 += n[(lay+n.length)%n.length][(id+n[0].length-1)%n[0].length].val*amount*w[2];
		//val2 += n[(lay+n.length)%n.length][(id+n[0].length+1)%n[0].length].val*amount*w[3];

		/*

				float Rprum = 0.0;
				prum[(frameCount)%prum.length] = val;
				for(int i = 0;i<prum.length;i++){
					Rprum += prum[i];
				}
				Rprum/=prum.length;

				if(Rprum>=tresh){
					assimilate(0.01,0.00,0.001);
					//val = 1;

					//n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].val = 255-val;
				}

		*/
		val2 /= (3.0);
		
		if(val<50||val>200)
		stochaist(470.0);


	}
	/*
		void assimilate(float kolik,float kolik2,float kolik3){

			-1,-1 0,-1 1,-1
			-1,0 x,x 1,0
			-1,1 0,1 1,1

			

			// synchronize to vibra val
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[lay][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[lay][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[lay][(id+n[0].length+1)%n[0].length].vibra)*kolik;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].vibra)*kolik;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra += (vibra-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].vibra)*kolik;



			// approx. counter weights
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7] += (w[0]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[7])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6] += (w[1]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[6])*kolik2;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5] += (w[2]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[lay][(id+n[0].length-1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length-1)%n[0].length].w[4])*kolik2;
			n[lay][(id+n[0].length+1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length+1)%n[0].length].w[5])*kolik2;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[2].length].w[2] += (w[5]-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].w[2])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[1].length].w[1] += (w[6]-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].w[1])*kolik2;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0] += (w[7]-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].w[0])*kolik2;


			// (experimental) approx. tones
			n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].w[0] += (w[7]-n[(lay+n.length-1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].w[1] += (w[6]-n[(lay+n.length-1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].w[2] += (w[5]-n[(lay+n.length-1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[lay][(id+n[0].length-1)%n[0].length].w[3] += (w[4]-n[lay][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[lay][(id+n[0].length+1)%n[0].length].w[4] += (w[3]-n[lay][(id+n[0].length+1)%n[0].length].tone)*kolik3;

			n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length-1)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length)%n[0].length].tone)*kolik3;
			n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone += (tone-n[(lay+n.length+1)%n.length][(id+n[0].length+1)%n[0].length].tone)*kolik3;
		}
	*/
	void update(){
		val += (val2-val)/1.0;
		val = constrain(val,1,254);
	}

	void draw(){
		stroke(noise(frameCount/20.0)*255+val);//lerpColor(#000000,#f7fd58,val/(255.0)),30.0);
		point(0,0);


	}

	void sync(float kolik){
		n[(lay+n.length+1)%n.length][id].amount += (amount-n[(lay+n.length+1)%n.length][id].amount)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].vibra += (vibra-n[(lay+n.length+1)%n.length][id].vibra)*(map(val,0,255,0,kolik));
		n[(lay+n.length+1)%n.length][id].tone += (tone-n[(lay+n.length+1)%n.length][id].tone)*(map(val,0,255,0,kolik));


	}

	void stochaist(float kolik){
		for(int i =0;i<w.length;i++){
			w[i]+=random(-kolik,kolik)/1000.0;
			//vibra+=random(-kolik,kolik)/1000.0;
			w[i] = constrain(w[i],0.01,5.0);
		}
	}




}

int sel =0;
Container c[] = new Container[0];
CN cn[] = new CN[0];

void setup(){
	size(640,480,P2D);

	textFont(createFont("Veranda",9));
	textMode(SCREEN);
	background(255);
}

void draw(){

	background(255);

	for(int i = 0;i<c.length;i++){
		c[i].draw();
	}

	
	for(int i = 0;i<cn.length;i++){
		cn[i].draw();
	}

}

void mousePressed(){
	boolean someOver = false;
	int ID = 0;
	for(int i = 0;i<c.length;i++){
		someOver = c[i].over();
		if(someOver){
			ID=i;
			break;

		}
	}

	if(someOver){
		c[ID].tx = c[ID].x-mouseX;
		c[ID].ty = c[ID].y-mouseY;
		c[ID].startDrag();

	}
}

void keyPressed(){
	if(key=='1'){
		c = (Container[])append(c,new Container(mouseX,mouseY,c.length,""));
	}else if(key<='a'&&key<='z'){
		if(c[sel].opened)
		c[sel].addText(key));
	}


}

void mouseReleased(){
	for(int i = 0;i<c.length;i++){
		c[i].stopDrag();
	}
}


class CN{
	int a = 0;
	int b = 0;

	CN(int _a){
		a = _a;
	}

	void draw(){
		stroke(0);
		line(c[a].x,c[b].x,c[a].y,c[b].y);
	}
}


class Container{
	int x,y;
	int tx,ty;
	int id;
	int w;
	String name;
	boolean dragging = false;
	In in[];
	Out out[];


	Container(int _x, int _y,int _id,String _name){
		x=_x;
		y=_y;
		id=_id;
		name=_name;
		w = name.length()*6;
		in = new In[1];
		out = new Out[2];

		for(int i = 0;i<in.length;i++)
			in[i] = new In(this,i);


		for(int i = 0;i<out.length;i++)
			out[i] = new Out(this,i);
		
		sel = id;
	}

	void draw(){

		if(dragging){
			x = mouseX+tx;
			y = mouseY+ty;

		}

		boolean over = over();

		if(over)
			stroke(#ffcc00);
		else
			stroke(0);

		fill(255);
		rect(x,y,w,12);

		if(over())
			fill(#ffcc00);
		else
			fill(0);

		text(name,x+2,y+10);

		for(int i = 0;i<in.length;i++){
			in[i].draw();
		}

		for(int i = 0;i<out.length;i++){
			out[i].draw();
		}


	}
	
	void addText(char _ch){
		name+= _ch="";
	}

	void startDrag(){
		dragging = true;
	}

	void stopDrag(){
		dragging = false;
	}

	boolean over(){
		if(mouseX>x&&mouseX<x+w&&mouseY>y&&mouseY<y+12){
			sel = id;
			return true;
		}else{
			return false;
		}
	}
}




class In{
	Container parent;
	int id,pos;

	In(Container _parent,int _id){
		parent = _parent;
		id = _id;
		pos = (int)map(id,0,parent.in.length-1,0,parent.w-4);
	}

	void draw(){
		stroke(0);
		fill(0);
		rect(parent.x+pos,parent.y-2,4,2);
	}

	

}

class Out{
	Container parent;
	int id,pos;

	Out(Container _parent,int _id){
		parent = _parent;
		id = _id;
		pos = (int)map(id,0,parent.out.length-1,0,parent.w-4);
	}

	void draw(){
		if(over()){
			fill(#ffcc00);
			stroke(#ffcc00);

		}else{
			fill(0);
			stroke(0);

		}

		rect(parent.x+pos,parent.y+12,4,2);
	}

	boolean over(){
		if(mouseX>parent.x+pos-2&&
		                mouseX<parent.x+pos+6&&
		                mouseY>parent.y+10&&
		                mouseY<parent.y+16){
			return true;
		}else{
			return false;
		}
	}
}

PGraphics p;

void setup(){
	size(800,800,P2D);
	background(0);
	
	p = createGraphics(width,height,P2D);
}


void draw(){
	p.beginDraw();
	p.pushMatrix();
	p.translate(width/2,height/2.0);
	
	p.pushMatrix();
	p.rotate(radians(frameCount));
	p.stroke(255,25);
	p.line(cos(frameCount/100.0)*width/2.0,noise(frameCount/10.0)*400,cos(frameCount/100.0)*width/2.0,-40);
	p.popMatrix();

	p.popMatrix();
	p.endDraw();
	
	pushMatrix();
	translate(width/2,height/2.0);
	scale(sin(frameCount/300.0));
	pushMatrix();
	rotate(radians(-frameCount));
	image(p,-p.width/2,-p.height/2.0);
	
	popMatrix();
	popMatrix();
}
float i,r,a,t;
void setup(){
	size(800,400,P3D);
	

}

void  draw(){

	stroke(-1);
	tint(#fffffd);
	image(g,.5,.5);
	
	line(mouseX-10,mouseY,mouseX+10,mouseY);

}
import codeanticode.gsvideo.*;
import oscP5.*;
import netP5.*;

OscP5 oscP5;
NetAddress myRemoteLocation;

boolean full = false;
int X = 0;
int Y = 0;
Tonenode t[] = new Tonenode[0];

int siz = 10;



void setup(){
	size(640,20,P2D);
	rectMode(CENTER);


	int cw = width;
	int ch = height;
	oscP5 = new OscP5(this,12000);
	myRemoteLocation = new NetAddress("127.0.0.1",12000);
	frameRate(30);

	int cnt = 0;
	while(!full){
		t = (Tonenode[])append(t,new Tonenode(cnt));
		cnt++;
	}

	textFont(createFont("FreeSans",9,false));
	textMode(SCREEN);
	rectMode(CENTER);
	noFill();
	noStroke();
	noSmooth();


}


void draw(){
	background(0);

	for(int i  = 0 ;i<t.length;i++)
		t[i].setval(noise((frameCount+i)/100.0)*255);


	//set(0,0,cam);

	for(int i  = 0 ;i<t.length;i++){
		t[i].draw();

	}

	sendAll();



}

void sendAll(){
	/* in the following different ways of creating osc messages are shown by example */
	OscMessage myMessage = new OscMessage("/cam");

	for(int i =0;i<t.length;i++)
		myMessage.add(t[i].val2); /* add an int to the osc message */

	/* send the message */
	oscP5.send(myMessage, myRemoteLocation);


}

class Tonenode{

	int id;
	int x,y;
	int state;
	float val = 0,val2 = 0;

	Tonenode(int _id){
		id = _id;
		x=X;
		y=Y;

		X+=siz;
		if(X>=width){
			X=0;
			Y+=siz;

		}

		if(Y>=height)
			full = true;
	}


	void draw(){

		val2 = (t[(id+t.length-1)%(t.length-1)].val+t[(id+t.length+1)%(t.length-1)].val+val)/3.0;
		fill(val2);
		rect(x,y,siz,siz);



	}

	void setval(float _val){
		val = _val;
	}

}

class Link{

	Link(){


	}

}
import krister.Ess.*;

int numSines = 5; // Number of oscillators to use
AudioStream myStream; // Audio stream to write into
SineWave[] myWave; // Array of sines
FadeOut myFadeOut; // Amplitude ramp function
FadeIn myFadeIn; // Amplitude ramp function

void setup()
{
	size(256, 200);
	Ess.start(this); // Start Ess
	myStream = new AudioStream(); // Create a new AudioStream
	myStream.smoothPan = true;
	myWave = new SineWave[numSines]; // Initialize the oscillators
	for (int i = 0; i < myWave.length; i++) {
		float sinVolume = (1.0 / myWave.length) / (i + 1);
		myWave[i] = new SineWave(0, sinVolume);
	}
	myFadeOut = new FadeOut(); // Create amplitude ramp
	myFadeIn = new FadeIn(); // Create amplitude ramp
	myStream.start(); // Start audio
}

void draw()
{
	noStroke();
	fill(0, 20);
	rect(0, 0, width, height); // Draw the background
	float offset = millis() - myStream.bufferStartTime;
	int interp = int((offset / myStream.duration) * myStream.size);
	stroke(255);
	for (int i = 0; i < width; i++) {
		float y1 = mouseY;
		float y2 = y1;
		if (i + interp + 1 < myStream.buffer2.length) {
			y1 -= myStream.buffer2[i+interp] * height / 2;
			y2 -= myStream.buffer2[i+interp+1] * height / 2;
		}
		line(i, y1, i + 1, y2); // Draw the waves
	}
}

void keyPressed(){
	audioStreamWrite()

}

void audioStreamWrite(AudioStream s)
{
	// Figure out frequencies and detune amounts from the mouse
	// using exponential scaling to approximate pitch perception
	float yoffset = (height - mouseY) / float(height);
	float frequency = pow(1000, yoffset) + 150;
	float detune = float(mouseX) / width - 0.5;
	myWave[0].generate(myStream); // Generate first sine, replace Stream
	myWave[0].phase += myStream.size; // Increment the phase
	myWave[0].phase %= myStream.sampleRate;
	for (int i = 1; i < myWave.length; i++) { // Add remaining sines into the Stream
		myWave[i].generate(myStream, Ess.ADD);
		myWave[i].phase = myWave[0].phase;
	}
	myFadeOut.filter(myStream); // Fade down the audio
	for (int i = 0; i < myWave.length; i++) { // Set the frequencies
		myWave[i].frequency = round(frequency * (i + 1 + i * detune));
		myWave[i].phase = 0;
	}
	myFadeIn.filter(myStream); // Fade up the audio
}

/**
* Ellipses by Krystof Pesek (Kof), licensed under Creative Commons Attribution-Share Alike 3.0 license.
* Work: http://openprocessing.org/visuals/?visualID= 10478
* License: http://creativecommons.org/licenses/by-sa/3.0/
*
* visit more @ http://vimeo.com/kof
* if you leave this header, bend, share, spread the code, it is a freedom!
*
*   ,dPYb,                  ,dPYb,
*   IP'`Yb                  IP'`Yb
*   I8  8I                  I8  8I
*   I8  8bgg,               I8  8'
*   I8 dP" "8    ,ggggg,    I8 dP
*   I8d8bggP"   dP"  "Y8ggg I8dP
*   I8P' "Yb,  i8'    ,8I   I8P
*  ,d8    `Yb,,d8,   ,d8'  ,d8b,_
*  88P      Y8P"Y8888P"    PI8"8888
*                           I8 `8,
*                           I8  `8,
*                           I8   8I
*                           I8   8I
*                           I8, ,8'
*                            "Y8P'
*
*/

int num = 60;
Ellipse e[] = new Ellipse[num];

//char[] chars = {'0','1','2','3','4','5','6','7','8','9','-','<'};

void setup(){

	size(400,300,P3D);
	for(int i = 0;i<num;i++)
		e[i] = new Ellipse(width/2,height/2,0,i);

	noFill();//(255,0,0,40);
	noSmooth();


       // textFont(createFont("Veranda",14,true,chars));
      //  textMode(SCREEN);
        
         

}

void draw(){
	background(0);
	for(int i = 0;i<num;i++)
		e[i].draw();
}

class Ellipse{

	float x,y,z;
	PVector rot;
	int id;
	float dens = 0.1;
	float r = 100.0;

	float rate = 100.0;
	float speed = 0.02;
        int segno;

	Ellipse(float _x,float _y,float _z,int _id){
		x=_x;
		y=_y;
		z=_z;
		id=_id;
                segno = (int)random(40);

		rot = new PVector(random(-1,1),random(-1,1),random(-1,1));
	}
	
	void follow(){
		x+=(mouseX-x)/(20.0);
		
		y+=(mouseY-y)/(20.0);
	}

	void draw(){
		//follow();
		
		rot.add(
		        noise((id+frameCount)/rate)*speed,
		        noise((id+34.0+frameCount)/rate)*speed,
		        noise((id+409.0+frameCount)/rate)*speed
		);

		pushMatrix();
		translate(x,y,z);

		pushMatrix();
		rotateX(rot.x);
		rotateY(rot.y);
		rotateZ(rot.z);

                int cnt = 0;
                
		beginShape();
		for(float f = -PI;f<PI;f+=dens){
                        float X = cos(f)*r;
			float Y = sin(f)*r;
			                      
  
                        if(abs(cnt-segno)<5){
                         // pushStyle();
                         // fill(255,map(modelZ(X,Y,0),-r,r,0,255));
                         // text("<-"+segno,modelX(X,Y,0),modelY(X,Y,0));
                         // popStyle();
                          stroke(#ffdddd,map(modelZ(X,Y,0),-r,r,1,180-abs(cnt-segno)*30));
                        
                        }else{
                          
                         stroke(#ffffff,map(modelZ(X,Y,0),-r,r,1,60)); 
                        
                        }
                        
			 strokeWeight(map(modelZ(X,Y,0),-r,r,5,1.8));
			
			vertex(X,Y,0);
                        cnt++;
		}
		endShape(CLOSE);
                
                 if(frameCount%2==0)
                segno++;
                if(segno>=cnt){
                 segno=0; 
                }
/*
                cnt = 0;
                for(float f = -PI;f<PI;f+=dens){
                   if(cnt==segno){
                      stroke(#ff0000,map(modelZ(X,Y,0),-r,r,0,200));  
                       float X = cos(f)*r;
			float Y = sin(f)*r;
                        strokeWeight(map(modelZ(X,Y,0),-r,r,5,1.8));
                        line(X,Y,lerp(X,0,0.1),lerp(Y,0,0.1));
                        }
                         cnt++;
                }
                */
		popMatrix();
		popMatrix();

                
	}
}

/**
* Ellipses by Krystof Pesek (Kof), licensed under Creative Commons Attribution-Share Alike 3.0 license.
* Work: http://openprocessing.org/visuals/?visualID= 10478
* License: http://creativecommons.org/licenses/by-sa/3.0/
*
* visit more @ http://vimeo.com/kof
* if you leave this header, bend, share, spread the code, it is a freedom!
*
*   ,dPYb,                  ,dPYb,
*   IP'`Yb                  IP'`Yb
*   I8  8I                  I8  8I
*   I8  8bgg,               I8  8'
*   I8 dP" "8    ,ggggg,    I8 dP
*   I8d8bggP"   dP"  "Y8ggg I8dP
*   I8P' "Yb,  i8'    ,8I   I8P
*  ,d8    `Yb,,d8,   ,d8'  ,d8b,_
*  88P      Y8P"Y8888P"    PI8"8888
*                           I8 `8,
*                           I8  `8,
*                           I8   8I
*                           I8   8I
*                           I8, ,8'
*                            "Y8P'
*
*/

int num = 60;
Ellipse e[] = new Ellipse[num];

//char[] chars = {'0','1','2','3','4','5','6','7','8','9','-','<'};

void setup(){

	size(400,300,P3D);
	for(int i = 0;i<num;i++)
		e[i] = new Ellipse(width/2,height/2,0,i);

	noFill();//(255,0,0,40);
	noSmooth();


       // textFont(createFont("Veranda",14,true,chars));
      //  textMode(SCREEN);
        
         

}

void draw(){
	background(0);
	for(int i = 0;i<num;i++)
		e[i].draw();
}

class Ellipse{

	float x,y,z;
	PVector rot;
	int id;
	float dens = 0.1;
	float r = 100.0;

	float rate = 100.0;
	float speed = 0.02;
        int segno;

	Ellipse(float _x,float _y,float _z,int _id){
		x=_x;
		y=_y;
		z=_z;
		id=_id;
                segno = (int)random(40);

		rot = new PVector(random(-1,1),random(-1,1),random(-1,1));
	}
	
	void follow(){
		x+=(mouseX-x)/(20.0);
		
		y+=(mouseY-y)/(20.0);
	}

	void draw(){
		//follow();
		
		rot.add(
		        noise((id+frameCount)/rate)*speed,
		        noise((id+34.0+frameCount)/rate)*speed,
		        noise((id+409.0+frameCount)/rate)*speed
		);

		pushMatrix();
		translate(x,y,z);

		pushMatrix();
		rotateX(rot.x);
		rotateY(rot.y);
		rotateZ(rot.z);

                int cnt = 0;
                
		beginShape();
		for(float f = -PI;f<PI;f+=dens){
                        float X = cos(f)*r;
			float Y = sin(f)*r;
			                      
  
                        if(abs(cnt-segno)<5){
                         // pushStyle();
                         // fill(255,map(modelZ(X,Y,0),-r,r,0,255));
                         // text("<-"+segno,modelX(X,Y,0),modelY(X,Y,0));
                         // popStyle();
                          stroke(#ffdddd,map(modelZ(X,Y,0),-r,r,1,180-abs(cnt-segno)*30));
                        
                        }else{
                          
                         stroke(#ffffff,map(modelZ(X,Y,0),-r,r,1,60)); 
                        
                        }
                        
			 strokeWeight(map(modelZ(X,Y,0),-r,r,5,1.8));
			
			vertex(X,Y,0);
                        cnt++;
		}
		endShape(CLOSE);
                
                 if(frameCount%2==0)
                segno++;
                if(segno>=cnt){
                 segno=0; 
                }
/*
                cnt = 0;
                for(float f = -PI;f<PI;f+=dens){
                   if(cnt==segno){
                      stroke(#ff0000,map(modelZ(X,Y,0),-r,r,0,200));  
                       float X = cos(f)*r;
			float Y = sin(f)*r;
                        strokeWeight(map(modelZ(X,Y,0),-r,r,5,1.8));
                        line(X,Y,lerp(X,0,0.1),lerp(Y,0,0.1));
                        }
                         cnt++;
                }
                */
		popMatrix();
		popMatrix();

                
	}
}

color colRed = #FF0000;
color colBlue = #0000FF;
color colYellow = #FFFF00;
color colWhite = #FFFFFF;
color colBlack = #000000;

void drawAlpha(float x, float y, float w, float h) {
  //base
  fill(colBlue);
  rect(x, y, w, h);
  //details
  fill(colWhite);
  rect(x, y, w*0.5, h);
  triangle(x+w*0.75, y+h/2, x+w, y+h, x+w, y);
}

void drawBravo(float x, float y, float w, float h) {
  //base
  fill(colRed);
  rect(x, y, w, h);
  //detail
  fill(colWhite);
  triangle(x+w*0.75, y+h/2, x+w, y+h, x+w, y);
}

void drawCharlie(float x, float y, float w, float h) {
  //base
  fill(colBlue);
  rect(x, y, w, h);
  //detail
  fill(colWhite);
  rect(x, y+h/5, w, 3*h/5);
  fill(colRed);
  rect(x, y+2*h/5, w, h/5);
}

void drawDelta(float x, float y, float w, float h) {
  //base
  fill(colYellow);
  rect(x, y, w, h);
  //detail
  fill(colBlue);
  rect(x, y+h/5, w, 3*h/5);
}

void drawEcho(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colRed);
  rect(x, y+h/2, w, h/2);
}

void drawFoxtrot(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colRed);
  beginShape();
    vertex(x, y+h/2);
    vertex(x+w/2, y+h);
    vertex(x+w, y+h/2);
    vertex(x+w/2, y);
  endShape(CLOSE);
}

void drawGolf(float x, float y, float w, float h) {
  //base
  fill(colYellow);
  rect(x, y, w, h);
  //detail
  fill(colBlue);
  rect(x+1*w/6, y, w/6, h);
  rect(x+3*w/6, y, w/6, h);
  rect(x+5*w/6, y, w/6, h);
}

void drawHotel(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colRed);
  rect(x+w/2, y, w/2, h);
}

void drawIndia(float x, float y, float w, float h) {
  //base
  fill(colYellow);
  rect(x, y, w, h);
  //detail
  fill(colBlack);
  ellipse(x+w/2, y+h/2, w/2, h/2);
}

void drawJuliet(float x, float y, float w, float h) {
  //base
  fill(colBlue);
  rect(x, y, w, h);
  //detail
  fill(colWhite);
  rect(x, y+h/3, w, h/3);
}

void drawKilo(float x, float y, float w, float h) {
  //base
  fill(colYellow);
  rect(x, y, w, h);
  //detail
  fill(colBlue);
  rect(x+w/2, y, w/2, h);
}

void drawLima(float x, float y, float w, float h) {
  //base
  fill(colYellow);
  rect(x, y, w, h);
  //detail
  fill(colBlack);
  rect(x+w/2, y, w/2, h/2);
  rect(x, y+h/2, w/2, h/2);
}

void drawMike(float x, float y, float w, float h) {
  //base
  fill(colBlue);
  rect(x, y, w, h);
  //detail
  fill(colWhite);
  beginShape();
    vertex(x, y);
    vertex(x, y+1*h/8);
    vertex(x+7*w/8, y+h);
    vertex(x+w, y+h);
    vertex(x+w, y+7*h/8);
    vertex(x+1*w/8, y);
  endShape(CLOSE);
  beginShape();
    vertex(x, y+h);
    vertex(x+1*w/8, y+h);
    vertex(x+w, y+1*h/8);
    vertex(x+w, y);
    vertex(x+7*w/8, y);
    vertex(x, y+7*h/8);
  endShape(CLOSE);
}

void drawNovember(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colBlue);
  rect(x, y, w/4, h/4);
  rect(x, y+h/2, w/4, h/4);
  rect(x+w/2, y, w/4, h/4);
  rect(x+w/2, y+h/2, w/4, h/4);
  rect(x+w/4, y+h/4, w/4, h/4);
  rect(x+w/4, y+3*h/4, w/4, h/4);
  rect(x+3*w/4, y+h/4, w/4, h/4);
  rect(x+3*w/4, y+3*h/4, w/4, h/4);
}

void drawOscar(float x, float y, float w, float h) {
  //base
  fill(colRed);
  rect(x, y, w, h);
  //detail
  fill(colYellow);
  triangle(x, y, x, y+h, x+w, y+h);
}

void drawPapa(float x, float y, float w, float h) {
  //base
  fill(colBlue);
  rect(x, y, w, h);
  //detail
  fill(colWhite);
  rect(x+w/3, y+h/3, w/3, h/3);
}

void drawQuebec(float x, float y, float w, float h) {
  //base
  fill(colYellow);
  rect(x, y, w, h);
}

void drawRomeo(float x, float y, float w, float h) {
  //base
  fill(colRed);
  rect(x, y, w, h);
  //detail
  fill(colYellow);
  rect(x+2*w/5, y, w/5, h);
  rect(x, y+2*h/5, w, h/5);
}

void drawSierra(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colBlue);
  rect(x+w/3, y+h/3, w/3, h/3);
}

void drawTango(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colRed);
  rect(x, y, w/3, h);
  fill(colBlue);
  rect(x+2*w/3, y, w/3, h);
}

void drawUniform(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colRed);
  rect(x, y, w/2, h/2);
  rect(x+w/2, y+h/2, w/2, h/2);
}

void drawVictor(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colRed);
  beginShape();
    vertex(x, y);
    vertex(x, y+1*h/8);
    vertex(x+7*w/8, y+h);
    vertex(x+w, y+h);
    vertex(x+w, y+7*h/8);
    vertex(x+1*w/8, y);
  endShape(CLOSE);
  beginShape();
    vertex(x, y+h);
    vertex(x+1*w/8, y+h);
    vertex(x+w, y+1*h/8);
    vertex(x+w, y);
    vertex(x+7*w/8, y);
    vertex(x, y+7*h/8);
  endShape(CLOSE);
}

void drawWhiskey(float x, float y, float w, float h) {
  //base
  fill(colBlue);
  rect(x, y, w, h);
  //detail
  fill(colWhite);
  rect(x+w/5, y+h/5, 3*w/5, 3*h/5);
  fill(colRed);
  rect(x+2*w/5, y+2*h/5, w/5, h/5);
}

void drawXray(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colBlue);
  rect(x+2*w/5, y, w/5, h);
  rect(x, y+2*h/5, w, h/5);
}
void drawYankee(float x, float y, float w, float h) {
  //base
  fill(colYellow);
  rect(x, y, w, h);
  //details
  fill(colRed);
  beginShape();
    vertex(x, y+1*h/5);
    vertex(x, y+2*h/5);
    vertex(x+2*w/5, y);
    vertex(x+1*w/5, y);
  endShape(CLOSE);
  beginShape();
    vertex(x, y+3*h/5);
    vertex(x, y+4*h/5);
    vertex(x+4*w/5, y);
    vertex(x+3*w/5, y);
  endShape(CLOSE);
  beginShape();
    vertex(x, y+h);
    vertex(x+1*w/5, y+h);
    vertex(x+w, y+1*h/5);
    vertex(x+w, y);
  endShape(CLOSE);
  beginShape();
    vertex(x+2*w/5, y+h);
    vertex(x+3*w/5, y+h);
    vertex(x+w, y+3*h/5);
    vertex(x+w, y+2*h/5);
  endShape(CLOSE);
  beginShape();
    vertex(x+4*w/5, y+h);
    vertex(x+w, y+h);
    vertex(x+w, y+4*h/5);
  endShape(CLOSE);
}

void drawZulu(float x, float y, float w, float h) {
  //base
  fill(colBlue);
  rect(x, y, w, h);
  //detail
  fill(colBlack);
  triangle(x, y, x, y+h, x+w/2, y+h/2);
  fill(colYellow);
  triangle(x, y, x+w/2, y+h/2, x+w, y);
  fill(colRed);
  triangle(x, y+h, x+w, y+h, x+w/2, y+h/2);
}

void drawSpace(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
}

void drawPeriod(float x, float y, float w, float h) {
  //base
  fill(colBlack);
  rect(x, y, w, h);
}

void drawComma(float x, float y, float w, float h) {
  //base
  fill(colBlack);
  rect(x, y, w, h);
  //detail
  fill(colWhite);
  rect(x, y+h/2, w/4, h/2);
}

void drawApos(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colBlack);
  rect(x+w/2, y, w/8, h/4);
}

void drawQuote(float x, float y, float w, float h) {
  //base
  fill(colWhite);
  rect(x, y, w, h);
  //detail
  fill(colBlack);
  rect(x, y, w/8, h/4);
  rect(x+w/2, y, w/8, h/4);
}
class Flag {
  
  float side; //the width and height of the flag
  float x, y, w, h; //coordinates for the flag
  char glyph; //the glyph for the flag

  Flag(float tempX, float tempY, float tempSide) {   
    setPosition(tempX, tempY, tempSide);
    setGlyph(' ');
  }
  
  void setPosition(float tempX, float tempY, float tempS) {
    x = tempX;
    y = tempY;
    w = tempS;
    h = tempS;
  }
  
  void setGlyph(char tempG) {
    glyph = tempG;
  }
  
  void draw() {
    switch(glyph) {
      case 'a':
        drawAlpha(x, y, w, h);
        break;
      case 'b':
        drawBravo(x, y, w, h);
        break;
      case 'c':
        drawCharlie(x, y, w, h);
        break;
      case 'd':
        drawDelta(x, y, w, h);
        break;
      case 'e':
        drawEcho(x, y, w, h);
        break;
      case 'f':
        drawFoxtrot(x, y, w, h);
        break;
      case 'g':
        drawGolf(x, y, w, h);
        break;
      case 'h':
        drawHotel(x, y, w, h);
        break;
      case 'i':
        drawIndia(x, y, w, h);
        break;
      case 'j':
        drawJuliet(x, y, w, h);
        break;
      case 'k':
        drawKilo(x, y, w, h);
        break;
      case 'l':
        drawLima(x, y, w, h);
        break;
      case 'm':
        drawMike(x, y, w, h);
        break;
      case 'n':
        drawNovember(x, y, w, h);
        break;
      case 'o':
        drawOscar(x, y, w, h);
        break;
      case 'p':
        drawPapa(x, y, w, h);
        break;
      case 'q':
        drawQuebec(x, y, w, h);
        break;
      case 'r':
        drawRomeo(x, y, w, h);
        break;
      case 's':
        drawSierra(x, y, w, h);
        break;
      case 't':
        drawTango(x, y, w, h);
        break;
      case 'u':
        drawUniform(x, y, w, h);
        break;
      case 'v':
        drawVictor(x, y, w, h);
        break;
      case 'w':
        drawWhiskey(x, y, w, h);
        break;
      case 'x':
        drawXray(x, y, w, h);
        break;
      case 'y':
        drawYankee(x, y, w, h);
        break;
      case 'z':
        drawZulu(x, y, w, h);
        break;
      case ' ':
        drawSpace(x, y, w, h);
        break;
      case '.':
        drawPeriod(x, y, w, h);
        break;
      case ',':
        drawComma(x, y, w, h);
        break;
      case '\'':
        drawPeriod(x, y, w, h);
        break;
      case '"':
        drawQuote(x, y, w, h);
        break;
      default:
        println("chararcter not mapped yet");
        break;
    }
  }
  
}
int dimension = 50;
int horCount = 10;
int verCount = 10;

Flag flag = new Flag(0, 0, dimension);

void setup() {
  size(dimension*horCount, dimension*verCount,P2D);
  noStroke();
  smooth();
  
  colRed = #F52C4B; //#FF0000;
  colBlue = #2281F2; //#0000FF;
  colYellow = #FFE621; //#FFFF00;
  colWhite = #ECF2EB; //#FFFFFF;
  colBlack = #252726; //#000000;
}

void draw() {
}

int horCoor, verCoor = 0;

void keyTyped() {
  println("pressed — keycode:" + int(key) + ", character:" + key + " and horCoor:" + horCoor);
  
  flag.setGlyph(key);
  flag.draw();
  
  if(horCoor != width-dimension) {
    horCoor += dimension;
  }
  else {
    horCoor = 0;
    if(verCoor != height-dimension) {
      verCoor += dimension;
    }
    else {
      verCoor = 0;
    }
  }
  
  flag.setPosition(horCoor, verCoor, dimension);
  
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
boolean rec = true;
Recorder r;

ArrayList agents;
ArrayList attrPoints;
ArrayList repPoints;

int agentsAmount=100000;
int attrAmount=40;
int repAmount=40;

void setup(){
  size(640,480,P2D);
  stroke(0);
  agents=new ArrayList();
  attrPoints=new ArrayList();
  repPoints=new ArrayList();

  for(int i=0;i<attrAmount;i++){
    attrPoints.add(new PVector(round(random(10,width-10)),round(random(10,height-10))));//create attraction points    
  }
  for(int i=0;i<repAmount;i++){
    repPoints.add(new PVector(round(random(10,width-10)),round(random(10,height-10))));//create repulsion points      
  }

  for(int i=0;i<agentsAmount;i++){
    agents.add(new Agent(round(random(10,width-10)),round(random(10,height-10))));//create agents 
  }


	if(rec)
	r = new Recorder("out","gravity.mp4");
}

void draw(){
  background(0);
  for(int i=0;i<agents.size();i++){
    Agent a =(Agent)agents.get(i);
    a.move();
    a.display();

  }  

  for(int i=0;i<attrPoints.size();i++){//display attraction points
    PVector aPt=(PVector)attrPoints.get(i);
    fill(#ccff00);
  //  ellipse(aPt.x,aPt.y,10,10);
  } 

  for(int i=0;i<repPoints.size();i++){//display repulsion points
    PVector rPt=(PVector)repPoints.get(i);
    fill(#FFCC00);
//    ellipse(rPt.x,rPt.y,10,10);
  }  

	if(rec)
	r.add();

}


void keyPressed(){
	if(key=='q'){
		if(rec){
			r.finish();
			exit();	
		}
	}

}



class Agent{
  PVector pos, vel, followSum, escapeSum;
  color c;

  Agent(int _x, int _y){
    pos=new PVector(_x,_y);  
    vel=new PVector(0,0);
    followSum=new PVector(0,0);
    escapeSum=new PVector(0,0);
    c=color(255);
  }

  void move(){
    vel.add(follow());
    vel.add(escape());
    vel.limit(1); 
    pos.add(vel);  
  }

  void display(){
    stroke(follow().mag()*25500,escape().mag()*25500,0,80);
    line(pos.x,pos.y,pos.x+vel.x*10,pos.y+vel.y*10);
  }

  PVector follow(){///////////attraction force
    followSum.mult(0);
    int count=0;
    for(int i=0; i<attrPoints.size();i++){
      PVector aPt=(PVector)attrPoints.get(i);
      float d=pos.dist(aPt);
      if (d<450){//attraction distance
        PVector dir = PVector.sub(aPt,pos);
        dir.normalize();
        dir.div(d);
        followSum.add(dir);
        count++;  
      }
    }  
    if (count > 0) {
      followSum.div(count);
    }
    return followSum;
  }

  PVector escape(){///////////repulsion force
    escapeSum.mult(0);
    int count=0;
    for(int i=0; i<repPoints.size();i++){
      PVector rPt=(PVector)repPoints.get(i);
      float d=pos.dist(rPt);
      if (d<450){//repulsion distance
        PVector dir = PVector.sub(rPt,pos);
        dir.normalize();
        dir.div(d);
        escapeSum.sub(dir);
        count++;  
      }
    }  
    if (count > 0) {
      escapeSum.div(count);
    }
    return escapeSum;
  }
}


class tree{
  float x1,y1,x2,y2; //position
  float theta;
  float branchWidth;
  float branchWidth0;
  float totalBranchLength;//length this branch can be.
  int nBranchDivisions; //the length of each line segment
  float percentBranchless; //it grows  at least this amount before branching more
  float branchSizeFraction;  //the branches are this much of the size at the split
  float dThetaGrowMax;
  float dThetaSplitMax;
  float oddsOfBranching; //the odds of branching at a given location.
  color myColor;

//constructor
  tree(float xI, float yI, float thetaI, float branchWidth0I,
  float totalBranchLengthI, int nBranchDivisionsI, 
  float percentBranchlessI, float branchSizeFractionI, 
  float dThetaGrowMaxI, float dThetaSplitMaxI,
  float oddsOfBranchingI, color colorI){
    x1 = xI;
    y1 = yI;
    x2 = xI;
    y2 = yI;
    theta = thetaI;
    branchWidth0 = branchWidth0I;
    branchWidth = branchWidth0;
    totalBranchLength =totalBranchLengthI;
    nBranchDivisions =nBranchDivisionsI;
    percentBranchless = percentBranchlessI;
    branchSizeFraction = branchSizeFractionI;
    dThetaGrowMax = dThetaGrowMaxI;
    dThetaSplitMax = dThetaSplitMaxI;
    oddsOfBranching = oddsOfBranchingI;
    myColor = colorI;
  }

//this does the drawing/growing!
  float lengthSoFar = 0;
  float nextSectionLength;
  void draw(){
    if(branchWidth<.5)//stop growing if it's too thin to render
      lengthSoFar = totalBranchLength;
    while(lengthSoFar<totalBranchLength){
      branchWidth =branchWidth0*(1-lengthSoFar/totalBranchLength);
      //do I need to split?
      if(lengthSoFar/totalBranchLength > percentBranchless){//if i can branch
        if(random(0,1)<oddsOfBranching){//and i randomly choose to
          stroke(myColor);
          //make a new branch there!
            (new tree(x1, y1, theta+randomSign()*dThetaSplitMax, branchWidth,
                      totalBranchLength*branchSizeFraction, nBranchDivisions, 
                      percentBranchless, branchSizeFraction, 
                      dThetaGrowMax, dThetaSplitMax,
                      oddsOfBranching, myColor)).draw();
        }
      }

      //change directions, grow forward 
      nextSectionLength = totalBranchLength/nBranchDivisions;
      lengthSoFar+=nextSectionLength;
      theta += randomSign()*random(0,dThetaGrowMax);
      x2 = x1+nextSectionLength*cos(theta);
      y2 = y1+nextSectionLength*sin(theta);
      //scale thickness by the distance it's traveled.
      strokeWeight(abs(branchWidth));
      stroke(myColor);
      line(x1,y1,x2,y2);
      if(addSnow){
        //initially, just a line on the upper half
        stroke(255);

        float dx =0;
        float dy =0;
        float overlapScaling = 1.2;
        if(theta <-PI/2){
          if(abs(PI+theta)<maxSnowTheta){
//            stroke(255,0,0);
            float snowThickness = constrain(abs(branchWidth)/2*(1-abs(theta+PI)/HALF_PI),0,abs(branchWidth)/2);
            if(snowThickness>0){
              strokeWeight(snowThickness);
              dx = (abs(branchWidth)-snowThickness)/2*cos(theta+PI/2)*overlapScaling;
              dy = (abs(branchWidth)-snowThickness)/2*sin(theta+PI/2)*overlapScaling;
              line(x1+dx-abs(branchWidth)*cos(theta)/4,y1+dy-abs(branchWidth)*sin(theta)/4,
                              x2+dx,y2+dy);
            }
          }
        }
        if(theta >-PI/2){
          if(abs(theta)<maxSnowTheta){
//            stroke(0,255,0);
            float snowThickness = constrain(abs(branchWidth)/2*(1-abs(theta)/HALF_PI),0,abs(branchWidth)/2);
            if(snowThickness>0){
              strokeWeight(snowThickness);
              dx = (abs(branchWidth)-snowThickness)/2*cos(theta-PI/2)*overlapScaling;
              dy = (abs(branchWidth)-snowThickness)/2*sin(theta-PI/2)*overlapScaling;
              line(x1+dx-abs(branchWidth)*cos(theta)/4,y1+dy-abs(branchWidth)*sin(theta)/4,
                              x2+dx,y2+dy);
            }
          }
        }
      }
      x1 = x2;
      y1 = y2;
    }
  }
}


void mouseClicked(){
  fadeScreen();
  newTrees();
  for(int i=0; i<nTrees; i++)
    trees[i].draw();
}

void keyTyped(){
  if(key=='=' || key=='+'){
    nTrees++;
    newTrees();
  }
  if(key=='-' || key=='_'){
    if(nTrees>1)
    {
      nTrees--;
      newTrees();
    }
  }
  if(key=='s'){
    addSnow = !addSnow;
  }
  if(key==' '){
    blankScreen();
  }
}
int width = 900;
int height = 500;

boolean addSnow = false;
float maxSnowTheta = HALF_PI*4/5;

int nTrees = 2;
tree[] trees;
color backgroundCol = color(222);
//color treeColor = color(0,255,0);

void setup(){
  smooth();
  size(width, height,P2D);
  background(backgroundCol);
  noFill();
  newTrees();
}

void draw(){
	if(frameCount%50==0){
fadeScreen();
  newTrees();
  for(int i=0; i<nTrees; i++)
    trees[i].draw();
	}
}

void newTrees(){
/* tree(x, y, theta, branchWidth0,
       totalBranchLength, nBranchDivisions, 
       percentBranchless, branchSizeFraction, 
       dThetaGrowMax, dThetaSplitMax,
       oddsOfBranching, color)
*/

//  background(backgroundCol);
//  noFill();
  trees = new tree[nTrees];
  for(int i=0; i<nTrees; i++)
    trees[i] = new tree(random(width), height, -HALF_PI, 10,
                   300, 30, 
                   .3, .5, 
                   PI/15, PI/6,
                   .3, color(random(0,30)));
                   
  for(int i=0; i<nTrees; i++)
    trees[i].draw();
}



void blankScreen(){
  fill(backgroundCol);
  noStroke();
  rect(0,0,width,height);
}

void fadeScreen(){
  fill(backgroundCol,5);
  noStroke();
  rect(0,0,width,height);
}


int randomSign(){ //returns +1 or -1
  float num = random(-1,1);
  if(num==0)
    return -1;
  else
    return (int)(num/abs(num));
}
class GLSL
{
  int programObject;
  GL gl;
  boolean vertexShaderEnabled;
  boolean vertexShaderSupported; 
  int vs;
  int fs;
  
  GLSL()
  {
    gl=((PGraphicsOpenGL)g).gl;
    String extensions = gl.glGetString(GL.GL_EXTENSIONS);
    vertexShaderSupported = extensions.indexOf("GL_ARB_vertex_shader") != -1;
    vertexShaderEnabled = true;    
    programObject = gl.glCreateProgramObjectARB(); 
    vs=-1;
    fs=-1;
  }
  
  void loadVertexShader(String file)
  {
    String shaderSource=join(loadStrings(file),"\n");
    vs = gl.glCreateShaderObjectARB(GL.GL_VERTEX_SHADER_ARB);
    gl.glShaderSourceARB(vs, 1, new String[]{shaderSource},(int[]) null, 0);
    gl.glCompileShaderARB(vs);
    checkLogInfo(gl, vs);
    gl.glAttachObjectARB(programObject, vs); 
  }

  void loadFragmentShader(String file)
  {
    String shaderSource=join(loadStrings(file),"\n");
    fs = gl.glCreateShaderObjectARB(GL.GL_FRAGMENT_SHADER_ARB);
    gl.glShaderSourceARB(fs, 1, new String[]{shaderSource},(int[]) null, 0);
    gl.glCompileShaderARB(fs);
    checkLogInfo(gl, fs);
    gl.glAttachObjectARB(programObject, fs); 
  }

  int getAttribLocation(String name)
  {
    return(gl.glGetAttribLocationARB(programObject,name));
  }
  
  int getUniformLocation(String name)
  {
    return(gl.glGetUniformLocationARB(programObject,name));
  }
    
  void useShaders()
  {
    gl.glLinkProgramARB(programObject);
    gl.glValidateProgramARB(programObject);
    checkLogInfo(gl, programObject);
  }
  
  void startShader()
  {
    gl.glUseProgramObjectARB(programObject); 
  }
  
  void endShader()
  {
    gl.glUseProgramObjectARB(0); 
  }
  
  void checkLogInfo(GL gl, int obj)  
  {
    IntBuffer iVal = BufferUtil.newIntBuffer(1);
    gl.glGetObjectParameterivARB(obj, GL.GL_OBJECT_INFO_LOG_LENGTH_ARB, iVal);
 
    int length = iVal.get();
    if (length <= 1)  
    {
      return;
    }
    ByteBuffer infoLog = BufferUtil.newByteBuffer(length);
    iVal.flip();
    gl.glGetInfoLogARB(obj, length, iVal, infoLog);
    byte[] infoBytes = new byte[length];
    infoLog.get(infoBytes);
    println("GLSL Validation >> " + new String(infoBytes));
  } 
}
//import hardcorepawn.opengl.*;
import processing.opengl.*;
import java.nio.*;
import javax.media.opengl.*;
import javax.media.opengl.glu.*;
import com.sun.opengl.util.*;

PImage tex0,tex1,nulltex;
float a,b;

GL gl;
GLU glu;
GLSL glsl;
int[] tex;
int[] shaderimgloc;

int tangentLoc;
int binormalLoc;
int uir;
int cbs;

void setup()
{
	//  size(800,600,"hardcorepawn.opengl.HCPGL");
	size(800,600,OPENGL);
	gl=((PGraphicsOpenGL)g).gl;
	glu=((PGraphicsOpenGL)g).glu;
	gl.glEnable(GL.GL_CULL_FACE);
	gl.glCullFace(GL.GL_FRONT);

	tex0=loadImage("img.png");
	tex1=loadImage("bump.png");
	nulltex=loadImage("img2.png");
	perspective(PI/3.0,4.0/3.0,1,1000);
	camera(0,0,-800,0,0,1,0,1,0);
	tex=new int[2];
	gl.glGenTextures(2,tex,0);
	gl.glBindTexture(GL.GL_TEXTURE_2D,tex[0]);
	gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, 4,tex0.width, tex0.height,
	                0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE,
	                IntBuffer.wrap(tex0.pixels));
	gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);	// Linear Filtering
	gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);	// Linear Filtering
	gl.glBindTexture(GL.GL_TEXTURE_2D,tex[1]);
	gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, 4,tex1.width, tex1.height,
	                0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE,
	                IntBuffer.wrap(tex1.pixels));
	gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);	// Linear Filtering
	gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);	// Linear Filtering
	glsl=new GLSL();
	//  glsl.loadVertexShader("textureSimple.vert");
	//  glsl.loadFragmentShader("textureSimple.frag");
	glsl.loadVertexShader("shiny.vert");
	glsl.loadFragmentShader("shiny.frag");
	glsl.useShaders();
	shaderimgloc=new int[2];
	//  shaderimgloc[0]=glsl.getUniformLocation("Tex");
	shaderimgloc[0]=glsl.getUniformLocation("Base");
	shaderimgloc[1]=glsl.getUniformLocation("NormalHeight");
	tangentLoc=glsl.getAttribLocation("tangent");
	binormalLoc=glsl.getAttribLocation("binormal");
	uir=glsl.getUniformLocation("u_invRad");
	cbs=glsl.getUniformLocation("cBumpSize");
	a=0;
	b=0;
	//  printCamera();
	textureMode(NORMALIZED);
	gl.glEnable(GL.GL_LIGHTING);
}

void draw()
{
	float mx=(frameCount-width/2.0)/(width/2.0);
	float my=(mouseY-height/2.0)/(height/2.0);
	a+=0.003;
	b+=0.00063;
	//  pointLight(255,255,255,0,0,-400);
	//  camera(0,0,-400,0,0,0,0,1,0);
	//  glu.gluLookAt(0,0,400,0,0,0,0,1,0);
	//  glu.
	background(50,0,0);
	glsl.startShader();
	fill(255,255,255);
	//  specular(0,0,0);
	ambient(250,250,250);
	//  shininess(2.0);
	gl.glActiveTexture(GL.GL_TEXTURE0+2);
	gl.glBindTexture(GL.GL_TEXTURE_2D, tex[0]);
	gl.glActiveTexture(GL.GL_TEXTURE0+1);
	gl.glBindTexture(GL.GL_TEXTURE_2D, tex[1]);

	gl.glUniform1i(shaderimgloc[0],2);
	gl.glUniform1i(shaderimgloc[1],1);
	gl.glVertexAttrib3f(tangentLoc,-1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	//  pointLight(220,220,250,40,0,-400);
	camera(400*sin(mx),0,-400*cos(mx),0,0,0,0,1,0);
	perspective(PI/3.0,4.0/3.0,1,1000);

	pointLight(255,255,255,0,0,-100);
	((PGraphicsOpenGL)g).beginGL();
	gl.glPushMatrix();
	rotateY(a);
	//  gl.glRotatef(360*a,0,1,0);

	gl.glBegin(GL.GL_QUADS);
	gl.glNormal3f(0,0,-1);
	gl.glVertexAttrib3f(tangentLoc,1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(-100,100,-100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(-100,-100,-100);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(100,-100,-100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(100,100,-100);
	//  gl.glEnd();
	//  gl.glBegin(GL.GL_QUADS);
	gl.glNormal3f(1,0,0);
	gl.glVertexAttrib3f(tangentLoc,0,0,1);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(100,-100,100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(100,100,100);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(100,100,-100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(100,-100,-100);

	gl.glNormal3f(0,0,1);
	gl.glVertexAttrib3f(tangentLoc,-1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(-100,-100,100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(-100,100,100);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(100,100,100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(100,-100,100);

	gl.glNormal3f(-1,0,0);
	gl.glVertexAttrib3f(tangentLoc,0,0,-1);
	gl.glVertexAttrib3f(binormalLoc,0,-1,0);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(-100,100,100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(-100,-100,100);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(-100,-100,-100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(-100,100,-100);

	gl.glNormal3f(0,1,0);
	gl.glVertexAttrib3f(tangentLoc,1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,0,-1);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(100,100,100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(-100,100,100);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(-100,100,-100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(100,100,-100);

	gl.glNormal3f(0,-1,0);
	gl.glVertexAttrib3f(tangentLoc,1,0,0);
	gl.glVertexAttrib3f(binormalLoc,0,0,-1);
	gl.glTexCoord2f(0,0);
	gl.glVertex3f(-100,-100,100);
	gl.glTexCoord2f(0,1);
	gl.glVertex3f(100,-100,100);
	gl.glTexCoord2f(1,1);
	gl.glVertex3f(100,-100,-100);
	gl.glTexCoord2f(1,0);
	gl.glVertex3f(-100,-100,-100);

	gl.glEnd();
	gl.glPopMatrix();
	/*  gl.glBegin(GL.GL_QUADSS);
	  gl.glVertexAttrib3f(tangentLoc,1,0,0);
	  gl.glVertexAttrib3f(binormalLoc,0,1,0);
	  gl.glNormal3f(0,0,-1);
	  gl.glTexCoord2f(1,0);
	  gl.glVertex3f(100,100,-100);
	  gl.glTexCoord2f(0,0);
	  gl.glVertex3f(-100,100,-100);
	  gl.glTexCoord2f(0,1);
	  gl.glVertex3f(-100,-100,-100);
	  gl.glTexCoord2f(1,1);
	  gl.glVertex3f(100,-100,-100);
	  gl.glEnd();*/



	glsl.endShader();
	((PGraphicsOpenGL)g).endGL();
}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}


PImage logo;


Recorder r;
boolean rec = true;

void setup(){
	
	logo = loadImage("logo.gif");
	size(logo.width,logo.height,P2D);
	
	frameRate(30);
	
	
	if(rec)
	r = new Recorder("out","banner.mp4");



}


void draw(){
	image(logo,0,0);

	noStroke();
	fill(255);
	for(int i = 0;i<width;i+=(int)random(1,5)){
		rect(i,height-5,random(1,2),5);
	}
	
	for(int i = 0;i<width;i+=(int)random(1,5)){
		rect(i,0,random(1,2),65);
	}

	fill(255);
	int res = (int)random(2,6);
	kosticka(0,0,width,height,res,res);
	
		if(rec)
		r.add();

}


void kosticka(int _x,int _y,int w,int h,int rx,int ry){

	noStroke();
	for(int x  = 0;x<w;x+=rx){
		for(int y  = 0;y<h;y+=ry){
			if(random(255)>128)
				rect(_x+x*rx,_y+y*ry,rx,ry);
		}
	}


}

void noiser(int mn,int mx){

for(int x = 0;x<width;x++){

		for(int y = 0;y<height;y++){
			stroke(0,random(mn,mx));
			point(x,y);
		}
	}

}

/**
*  Genome flock algorithm by Krystof Pesek alias Kof, licensed under Creative Commons Attribution-Share Alike 3.0 license.
*  Work: http://openprocessing.org/visuals/?visualID=7626
*  License: http://creativecommons.org/licenses/by-sa/3.0/
*
* visit more @ http://vimeo.com/kof
* if you leave this header, bend, share, spread the code, it is a freedom!
*
*   ,dPYb,                  ,dPYb,
*   IP'`Yb                  IP'`Yb
*   I8  8I                  I8  8I
*   I8  8bgg,               I8  8'
*   I8 dP" "8    ,ggggg,    I8 dP
*   I8d8bggP"   dP"  "Y8ggg I8dP
*   I8P' "Yb,  i8'    ,8I   I8P
*  ,d8    `Yb,,d8,   ,d8'  ,d8b,_
*  88P      Y8P"Y8888P"    PI8"8888
*                           I8 `8,
*                           I8  `8,
*                           I8   8I
*                           I8   8I
*                           I8, ,8'
*                            "Y8P'
*
*/


Bytost alfa[];
Bytost global,vzorek;
int num = 400;
boolean blurring = false;
float counter[][] = new float[8][8];
float counterG[][] = new float[8][8];


Recorder r;
boolean rec = false;

void setup(){

	size(640,480,P3D);

	for(int Y = 0;Y<8;Y++){
		for(int X = 0;X<8;X++){
			counter[X][Y] = 0;
			counterG[X][Y] = 0;
		}
	}

	alfa = new Bytost[num];

	global = new Bytost(536,10,true);
	//vzorek = new Bytost(width-28,54,false);

	for(int i =0;i<alfa.length;i++)
		alfa[i] = new Bytost();

	//println(PFont.list());
	textFont(loadFont("NimbusSanL-Bold-10.vlw"));
        //createFont("DejaVu Sans",9));
	textMode(SCREEN);

	noCursor();

	if(rec)
		r = new Recorder("rec","genomeWar.mp4");
}


void draw(){
	background(0);


	for(int i =0;i<alfa.length;i++){
		alfa[i].draw();


		for(int Y = 0;Y<8;Y++){
			for(int X = 0;X<8;X++){
				if( alfa[i].col[Y].dna.charAt(X) == '1')
					counterG[X][Y] += (1-counterG[X][Y])/(num+0.0);
				else
					counterG[X][Y] -= counterG[X][Y]/(num+0.0);
			}
		}

	}


	if(blurring)
		filter(BLUR,2);


	fill(0);
	rect(width-32-20,0,52,52);
	rect(0,0,width,20);

	for(int Y = 0;Y<8;Y++){
		for(int X = 0;X<8;X++){
			fill(counter[X][Y]*255,160);
			rect(mouseX+X*4-16,mouseY+Y*4-16,4,4);
		}

	}

	for(int Y = 0;Y<8;Y++){
		for(int X = 0;X<8;X++){
			fill(counterG[X][Y]*255,255);
			rect(width-32-10+X*4,10+Y*4,4,4);
		}

	}

	fill(255);

	text("avg. genome: ",width-180,12);


	global.draw();
	//vzorek.draw();


	if(rec)
		r.add();


}

void mousePressed(){

	for(int i =0;i<num;i++){
		if(alfa[i].over()){
			float tmpx = alfa[i].x;
			float tmpy = alfa[i].y;
			alfa[i] = new Bytost(tmpx,tmpy);
		}
	}

}



void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();

		exit();
	}
}


class Bytost{


	Genome[] col;
	float x,y,tx,ty,r,g,b,a,velikost = 0,radius = 0;
	float speed = 40;
	int kadence;
	float mmn = 30;
	float mmx = 80;
	float blink;
	boolean fixed = false;
	boolean glob = false;

	int att = 14;
	int mut = 0;

	float bizarreKoeficient,bizSUM = 0;

	boolean deviant = false;

	Bytost(){

		if(random(100)<95)
			deviant = true;

		col = new Genome[8];

		for(int i = 0 ;i<col.length;i++){
			col[i] = new Genome(8);

			//println(col[i].getDna()+" = "+unbinary(col[i].getDna()));
		}

		x = tx = map(rowInt(0),0,255,0,width);
		y = ty = map(rowInt(1),0,255,20,height);


		kadence =  (int)random(3,2000);//rowInt(3)+1;

		r = colInt(0);
		g = colInt(1);
		b = colInt(2);
		a = rowInt(6);

		blink = revdiagInt(6)/4.0;
		//g = random(255);
		//b = random(255);
		//a = random(255);





		//col[3].setDna(120);
	}
	
	Bytost(float _x,float _y){

		if(random(100)<95)
			deviant = true;

		col = new Genome[8];

		for(int i = 0 ;i<col.length;i++){
			col[i] = new Genome(8);

			//println(col[i].getDna()+" = "+unbinary(col[i].getDna()));
		}

		x = _x;//tx = map(rowInt(0),0,255,0,width);
		y = _y; // = map(rowInt(1),0,255,20,height);


		kadence =  (int)random(3,2000);//rowInt(3)+1;

		r = colInt(0);
		g = colInt(1);
		b = colInt(2);
		a = rowInt(6);

		blink = revdiagInt(6)/4.0;
		//g = random(255);
		//b = random(255);
		//a = random(255);





		//col[3].setDna(120);
	}

	Bytost(float _x,float _y,boolean _glob){
		fixed = true;
		glob=_glob;

		col = new Genome[8];


		for(int i = 0 ;i<col.length;i++){
			col[i] = new Genome(8);

			//println(col[i].getDna()+" = "+unbinary(col[i].getDna()));
		}

		if(!fixed){
			x = tx = map(rowInt(0),0,255,0,width);
			y = ty = map(rowInt(1),0,255,0,height);
		}else{
			x=tx=_x;
			y=ty=_y;
		}

		kadence =  (int)random(3,20);//rowInt(3)+1;

		r = colInt(0);
		g = colInt(1);
		b = colInt(2);
		a = rowInt(6);

		blink = revdiagInt(6)/4.0;
		//g = random(255);
		//b = random(255);
		//a = random(255);





		//col[3].setDna(120);
	}

	void compute(){

		//for(int i = 0 ;i<col.length;i++){


		//}


		if(!fixed){
			tx = map(rowInt(0)^revdiagInt(6),0,255,0,width);
			ty = map(rowInt(2)^diagInt(7),0,255,0,height);
		}

		speed += ((diagInt(3)^revdiagInt(3))*3.0-speed)/40.0;

		kadence = (int)((colInt(4)^diagInt(6))*3.0+3);

		speed = constrain(speed,30,255);
		kadence = constrain(kadence,1,255);


		if(!fixed){
			x += (tx-x)/speed;
			y += (ty-y)/speed;
		}

		r += ((diagInt(2))-r)/speed;
		g += ((diagInt(3))-g)/speed;
		b += ((diagInt(4))-b)/speed;
		a += ((rowInt(6))-a)/speed;

		//att = revdiagInt(7)&diagInt(0);

		velikost += (rowInt(5)-velikost)/speed;

		radius += ((diagInt(5)^revdiagInt(4)^revdiagInt(3))-radius)/speed;

		blink += (diagInt(6)-blink)/speed;


		if(!fixed){
			bizarreKoeficient = 0;

			for(int i =0;i<col.length;i++){
				for(int q =0;q<col[i].dna.length();q++){
					float myGen = (float)parseInt(col[i].dna.charAt(q)+"");
					bizarreKoeficient += (abs(myGen-counterG[q][i])-bizarreKoeficient)/(num+0.0);
				}
			}


			//if(frameCount%(kadence/4.0)==0){
			for(int i = 0;i<att;i++)
				income(1,mut);
			//}





		}else if(glob){

			for(int i =0;i<col.length;i++){

				int tmp[] = new int[col.length];

				for(int q =0;q<col[i].dna.length();q++){
					if(counterG[q][i]>0.5){
						tmp[q] = 1;
					}else{
						tmp[q] = 0;
					}


				}
				col[i].setDna(tmp);

			}
		}else{
			for(int i =0;i<col.length;i++){

				int tmp[] = new int[col.length];

				for(int q =0;q<col[i].dna.length();q++){
					if(counter[q][i]>0.5){
						tmp[q] = 1;
					}else{
						tmp[q] = 0;
					}


				}
				col[i].setDna(tmp);

			}

		}



		//attract((int)(colInt(4)/10.0),diagInt(4));
		//detract((int)((colInt(6)^revdiagInt(1))/10.0),(diagInt(6)^colInt(5)));

		//detract(2,200.0);


	}

	void income(int jakMoc,int degenerace){


		Bytost next = alfa[(int)random(alfa.length)];


		/*
		bizSUM = bizarreKoeficient;
		//prefer others genes
		for(int i =0;i<col.length;i++){
			for(int q =0;q<col[i].dna.length();q++){
				float myGen = (float)parseInt(col[i].dna.charAt(q)+"");
				float nextGene = (float)parseInt(next.col[i].dna.charAt(q)+"");
				bizSUM += abs(nextGene-myGen);
			}
	}




		if(!deviant){
		*/
		//gene of dominance .. majority
		//	if(bizarreKoeficient<next.bizarreKoeficient){


		if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){


			if(!fixed){

				if(frameCount%kadence==0){

					//deviant=!deviant;


					next.col[(int)random(col.length)].degen(1);
					next.col[(int)random(col.length)].degen(3);
					next.col[(int)random(col.length)].degen(5);


				}
			}

			for(int i = 0;i<jakMoc;i++){
				int wh = (int)random(col.length);
				col[wh].dna = next.col[wh].dna+"";
				//if(i==0)

			}

			for(int i = 0;i<degenerace;i++){
				col[(int)random(col.length)].degen(1);
			}

		}
		//	}

		/*
	}else{
		//gene of dominance .. minority
		if(bizarreKoeficient<next.bizarreKoeficient){
			if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
				for(int i = 0;i<jakMoc;i++){
					int wh = (int)random(col.length);
					col[wh].dna = next.col[wh].dna+"";
					//if(i==0)

				}

				for(int i = 0;i<degenerace;i++){
					col[(int)random(col.length)].degen(1);
				}

			}
	}

	}
		*/


	}


	void draw(){

		compute();

		noStroke();
		//fill(lerpColor(color(r,g,b),0xFFFFFFFF,(sin(frameCount/blink)+1)/2.0),a);
		stroke(r,g,b,constrain(a/12.0+((sin(frameCount/(blink*.1))+1)*40.0),0,255));
		noFill();
		//ellipse(x,y,map(radius,0,255,16,20),map(radius,0,255,16,20));

		//ellipse(x,y,map(radius,0,255,16,30),map(radius,0,255,16,30));

		ellipse(x,y,map(radius,0,255,16,40),map(radius,0,255,16,40));
		//rect(x-8,y-8,16,16);

		noStroke();
		//drawText();
		drawHex();

	}

	boolean over(){

		if((dist(mouseX,mouseY,x,y)<map(radius,0,255,16,190))&&!fixed){
			for(int Y = 0;Y<8;Y++){
				for(int X = 0;X<8;X++){
					if( col[Y].dna.charAt(X) == '1')
						counter[X][Y] += (1-counter[X][Y])/(40.0);
					else
						counter[X][Y] += (-counter[X][Y])/(40.0);
				}
			}
			return true;
		}else{
			return false;
		}


	}

	void attract(int kolik,float jakMoc){

		for(int i = 0;i<kolik;i++){
			Bytost next = alfa[(int)random(alfa.length)];
			if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
				x+=(next.x-x)/jakMoc;
				y+=(next.y-y)/jakMoc;
			}
		}

	}

	void detract(int kolik,float jakMoc){

		for(int i = 0;i<kolik;i++){
			Bytost next = alfa[(int)random(alfa.length)];
			if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
				tx-=(next.x-tx)/jakMoc;
				ty-=(next.y-ty)/jakMoc;
			}
		}

	}


	void drawText(){
		fill(255,120);

		for(int i = 0 ;i<col.length;i++){
			text(col[i].dna,x+7,y+2+i*9);
		}

	}

	void drawHex(){
		if(over())
			fill(255);
		else
			fill(r,g,b,120);
		//fill(0);
		pushMatrix();
		translate(x-4,y-4);
		for(int Y = 0 ;Y<col.length;Y++){
			for(int X = 0 ;X<col.length;X++){
				if(col[Y].dna.charAt(X) == '1')
					rect(X,Y,1,1);
			}
		}
		popMatrix();

	}

	String row(int which){

		String a = "";
		for(int i =0;i<col.length;i++){
			a += col[i].dna.charAt(which)+"";

		}

		return a;

	}

	int rowInt(int which){

		String a = "";
		for(int i =0;i<col.length;i++){
			a += col[i].dna.charAt(which)+"";

		}

		return unbinary(a);

	}

	int colInt(int which){

		return unbinary(col[which].dna);

	}

	int diagInt(int which){

		String a = "";

		a += col[0].dna.charAt(which)+"";
		a += col[1].dna.charAt((which+1)%col[0].dna.length())+"";
		a += col[2].dna.charAt((which+2)%col[0].dna.length())+"";
		a += col[3].dna.charAt((which+3)%col[0].dna.length())+"";

		a += col[4].dna.charAt((which+4)%col[0].dna.length())+"";
		a += col[5].dna.charAt((which+5)%col[0].dna.length())+"";
		a += col[6].dna.charAt((which+6)%col[0].dna.length())+"";
		a += col[7].dna.charAt((which+7)%col[0].dna.length())+"";

		return unbinary(a);

	}

	int revdiagInt(int which){

		String a = "";

		a += col[0].dna.charAt(which)+"";
		a += col[1].dna.charAt((which-1+col[0].dna.length())%col[0].dna.length())+"";
		a += col[2].dna.charAt((which-2+col[0].dna.length())%col[0].dna.length())+"";
		a += col[3].dna.charAt((which-3+col[0].dna.length())%col[0].dna.length())+"";

		a += col[4].dna.charAt((which-4+col[0].dna.length())%col[0].dna.length())+"";
		a += col[5].dna.charAt((which-5+col[0].dna.length())%col[0].dna.length())+"";
		a += col[6].dna.charAt((which-6+col[0].dna.length())%col[0].dna.length())+"";
		a += col[7].dna.charAt((which-7+col[0].dna.length())%col[0].dna.length())+"";

		return unbinary(a);

	}


}

class Genome{
	String dna;
	int mn,mx;

	Genome(int strict){
		dna = "";

		regen(strict);
	}

	Genome(int _mn, int _mx){
		dna = "";

		mn = _mn;
		mx = _mx;

		regen();
	}





	void regen(){
		generateDna((int)random(mn,mx));
	}

	void regen(int _in){
		generateDna(_in);
	}

	void degen(int kolik){


		for(int i = 0;i<kolik;i++){

			int which = (int)random(dna.length());
			String stremp = "";

			if(dna.charAt(which)=='1'){
				stremp = dna+"";
				dna = stremp.substring(0,which)+"0"+stremp.substring(which+1,stremp.length());

			}else{

				stremp = dna+"";
				dna = stremp.substring(0,which)+"1"+stremp.substring(which+1,stremp.length());
			}

		}
		//println(dna+" = "+unbinary(dna));


	}




	int[] decode(){
		String temp = getDna();
		int[] answ = new int[temp.length()];

		for(int i =0;i<answ.length;i++){
			answ[i] = parseInt(temp.charAt(i));
		}
		return answ;
	}

	int getInt(){
		return unbinary(dna);

	}

	String encode(int[] in){
		String temp = "";

		for(int i =0;i<in.length;i++){
			temp += in[i]+"";
		}
		return temp;
	}

	void generateDna(int in){
		for(int i =0;i<in;i++)
		if(random(50) <= 25){ dna+="0"; }else{ dna+="1"; }
	}

	String getDna(){
		return dna;
	}

	void setDna(String a){
		dna = "";
		dna = a;
	}


	void setDna(int[] a){
		String tmp = "";

		for (int i = 0 ;i<a.length;i++){
			tmp += a[i]+"";
		}

		dna = tmp+"";
	}
}


class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
/**
*  Genome flock algorithm by Krystof Pesek alias Kof, licensed under Creative Commons Attribution-Share Alike 3.0 license.
*  Work: http://openprocessing.org/visuals/?visualID=7626
*  License: http://creativecommons.org/licenses/by-sa/3.0/
*
* visit more @ http://vimeo.com/kof
* if you leave this header, bend, share, spread the code, it is a freedom!
*
*   ,dPYb,                  ,dPYb,
*   IP'`Yb                  IP'`Yb
*   I8  8I                  I8  8I
*   I8  8bgg,               I8  8'
*   I8 dP" "8    ,ggggg,    I8 dP
*   I8d8bggP"   dP"  "Y8ggg I8dP
*   I8P' "Yb,  i8'    ,8I   I8P
*  ,d8    `Yb,,d8,   ,d8'  ,d8b,_
*  88P      Y8P"Y8888P"    PI8"8888
*                           I8 `8,
*                           I8  `8,
*                           I8   8I
*                           I8   8I
*                           I8, ,8'
*                            "Y8P'
*
*/


Bytost alfa[];
Bytost global,vzorek;
int num = 500;
boolean blurring = false;
float counter[][] = new float[8][8];
float counterG[][] = new float[8][8];


Recorder r;
boolean rec = false;

void setup(){

	size(640,480,P3D);

	for(int Y = 0;Y<8;Y++){
		for(int X = 0;X<8;X++){
			counter[X][Y] = 0;
			counterG[X][Y] = 0;
		}
	}

	alfa = new Bytost[num];

	global = new Bytost(536,10,true);
	//vzorek = new Bytost(width-28,54,false);

	for(int i =0;i<alfa.length;i++)
		alfa[i] = new Bytost();

	//println(PFont.list());
	textFont(loadFont("NimbusSanL-Bold-10.vlw"));
        //createFont("DejaVu Sans",9));
	textMode(SCREEN);

	noCursor();

	if(rec)
		r = new Recorder("rec","genomeWar.mp4");
}


void draw(){
	background(0);


	for(int i =0;i<alfa.length;i++){
		alfa[i].draw();


		for(int Y = 0;Y<8;Y++){
			for(int X = 0;X<8;X++){
				if( alfa[i].col[Y].dna.charAt(X) == '1')
					counterG[X][Y] += (1-counterG[X][Y])/(num+0.0);
				else
					counterG[X][Y] -= counterG[X][Y]/(num+0.0);
			}
		}

	}


	if(blurring)
		filter(BLUR,2);


	fill(0);
	rect(width-32-20,0,52,52);
	rect(0,0,width,20);

	for(int Y = 0;Y<8;Y++){
		for(int X = 0;X<8;X++){
			fill(counter[X][Y]*255,160);
			rect(mouseX+X*4-16,mouseY+Y*4-16,4,4);
		}

	}

	for(int Y = 0;Y<8;Y++){
		for(int X = 0;X<8;X++){
			fill(counterG[X][Y]*255,255);
			rect(width-32-10+X*4,10+Y*4,4,4);
		}

	}

	fill(255);

	text("avg. genome: ",width-180,12);


	global.draw();
	//vzorek.draw();


	if(rec)
		r.add();


}

void mousePressed(){

	for(int i =0;i<num;i++){
		if(alfa[i].over()){
			float tmpx = alfa[i].x;
			float tmpy = alfa[i].y;
			alfa[i] = new Bytost(tmpx,tmpy);
		}
	}

}



void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();

		exit();
	}
}


class Bytost{


	Genome[] col;
	float x,y,tx,ty,r,g,b,a,velikost = 0,radius = 0;
	float speed = 40;
	int kadence;
	float mmn = 30;
	float mmx = 80;
	float blink;
	boolean fixed = false;
	boolean glob = false;

	int att = 14;
	int mut = 0;

	float bizarreKoeficient,bizSUM = 0;

	boolean deviant = false;

	Bytost(){

		if(random(100)<95)
			deviant = true;

		col = new Genome[8];

		for(int i = 0 ;i<col.length;i++){
			col[i] = new Genome(8);

			//println(col[i].getDna()+" = "+unbinary(col[i].getDna()));
		}

		x = tx = map(rowInt(0),0,255,0,width);
		y = ty = map(rowInt(1),0,255,20,height);


		kadence =  (int)random(3,2000);//rowInt(3)+1;

		r = colInt(0);
		g = colInt(1);
		b = colInt(2);
		a = rowInt(6);

		blink = revdiagInt(6)/4.0;
		//g = random(255);
		//b = random(255);
		//a = random(255);





		//col[3].setDna(120);
	}
	
	Bytost(float _x,float _y){

		if(random(100)<95)
			deviant = true;

		col = new Genome[8];

		for(int i = 0 ;i<col.length;i++){
			col[i] = new Genome(8);

			//println(col[i].getDna()+" = "+unbinary(col[i].getDna()));
		}

		x = _x;//tx = map(rowInt(0),0,255,0,width);
		y = _y; // = map(rowInt(1),0,255,20,height);


		kadence =  (int)random(3,2000);//rowInt(3)+1;

		r = colInt(0);
		g = colInt(1);
		b = colInt(2);
		a = rowInt(6);

		blink = revdiagInt(6)/4.0;
		//g = random(255);
		//b = random(255);
		//a = random(255);





		//col[3].setDna(120);
	}

	Bytost(float _x,float _y,boolean _glob){
		fixed = true;
		glob=_glob;

		col = new Genome[8];


		for(int i = 0 ;i<col.length;i++){
			col[i] = new Genome(8);

			//println(col[i].getDna()+" = "+unbinary(col[i].getDna()));
		}

		if(!fixed){
			x = tx = map(rowInt(0),0,255,0,width);
			y = ty = map(rowInt(1),0,255,0,height);
		}else{
			x=tx=_x;
			y=ty=_y;
		}

		kadence =  (int)random(3,20);//rowInt(3)+1;

		r = colInt(0);
		g = colInt(1);
		b = colInt(2);
		a = rowInt(6);

		blink = revdiagInt(6)/4.0;
		//g = random(255);
		//b = random(255);
		//a = random(255);





		//col[3].setDna(120);
	}

	void compute(){

		//for(int i = 0 ;i<col.length;i++){


		//}


		if(!fixed){
			tx = map(rowInt(0)^revdiagInt(6),0,255,0,width);
			ty = map(rowInt(2)^diagInt(7),0,255,0,height);
		}

		speed += ((diagInt(3)^revdiagInt(3))*3.0-speed)/40.0;

		kadence = (int)((colInt(4)^diagInt(6))*3.0+3);

		speed = constrain(speed,30,255);
		kadence = constrain(kadence,1,255);


		if(!fixed){
			x += (tx-x)/speed;
			y += (ty-y)/speed;
		}

		r += ((diagInt(2))-r)/speed;
		g += ((diagInt(3))-g)/speed;
		b += ((diagInt(4))-b)/speed;
		a += ((rowInt(6))-a)/speed;

		//att = revdiagInt(7)&diagInt(0);

		velikost += (rowInt(5)-velikost)/speed;

		radius += ((diagInt(5)^revdiagInt(4)^revdiagInt(3))-radius)/speed;

		blink += (diagInt(6)-blink)/speed;


		if(!fixed){
			bizarreKoeficient = 0;

			for(int i =0;i<col.length;i++){
				for(int q =0;q<col[i].dna.length();q++){
					float myGen = (float)parseInt(col[i].dna.charAt(q)+"");
					bizarreKoeficient += (abs(myGen-counterG[q][i])-bizarreKoeficient)/(num+0.0);
				}
			}


			//if(frameCount%(kadence/4.0)==0){
			for(int i = 0;i<att;i++)
				income(1,mut);
			//}





		}else if(glob){

			for(int i =0;i<col.length;i++){

				int tmp[] = new int[col.length];

				for(int q =0;q<col[i].dna.length();q++){
					if(counterG[q][i]>0.5){
						tmp[q] = 1;
					}else{
						tmp[q] = 0;
					}


				}
				col[i].setDna(tmp);

			}
		}else{
			for(int i =0;i<col.length;i++){

				int tmp[] = new int[col.length];

				for(int q =0;q<col[i].dna.length();q++){
					if(counter[q][i]>0.5){
						tmp[q] = 1;
					}else{
						tmp[q] = 0;
					}


				}
				col[i].setDna(tmp);

			}

		}



		//attract((int)(colInt(4)/10.0),diagInt(4));
		//detract((int)((colInt(6)^revdiagInt(1))/10.0),(diagInt(6)^colInt(5)));

		//detract(2,200.0);


	}

	void income(int jakMoc,int degenerace){


		Bytost next = alfa[(int)random(alfa.length)];


		/*
		bizSUM = bizarreKoeficient;
		//prefer others genes
		for(int i =0;i<col.length;i++){
			for(int q =0;q<col[i].dna.length();q++){
				float myGen = (float)parseInt(col[i].dna.charAt(q)+"");
				float nextGene = (float)parseInt(next.col[i].dna.charAt(q)+"");
				bizSUM += abs(nextGene-myGen);
			}
	}




		if(!deviant){
		*/
		//gene of dominance .. majority
		//	if(bizarreKoeficient<next.bizarreKoeficient){


		if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){


			if(!fixed){

				if(frameCount%kadence==0){

					//deviant=!deviant;


					next.col[(int)random(col.length)].degen(1);
					next.col[(int)random(col.length)].degen(3);
					next.col[(int)random(col.length)].degen(5);


				}
			}

			for(int i = 0;i<jakMoc;i++){
				int wh = (int)random(col.length);
				col[wh].dna = next.col[wh].dna+"";
				//if(i==0)

			}

			for(int i = 0;i<degenerace;i++){
				col[(int)random(col.length)].degen(1);
			}

		}
		//	}

		/*
	}else{
		//gene of dominance .. minority
		if(bizarreKoeficient<next.bizarreKoeficient){
			if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
				for(int i = 0;i<jakMoc;i++){
					int wh = (int)random(col.length);
					col[wh].dna = next.col[wh].dna+"";
					//if(i==0)

				}

				for(int i = 0;i<degenerace;i++){
					col[(int)random(col.length)].degen(1);
				}

			}
	}

	}
		*/


	}


	void draw(){

		compute();

		noStroke();
		//fill(lerpColor(color(r,g,b),0xFFFFFFFF,(sin(frameCount/blink)+1)/2.0),a);
		stroke(r,g,b,constrain(a/12.0+((sin(frameCount/(blink*.1))+1)*40.0),0,255));
		noFill();
		//ellipse(x,y,map(radius,0,255,16,20),map(radius,0,255,16,20));

		//ellipse(x,y,map(radius,0,255,16,30),map(radius,0,255,16,30));

		ellipse(x,y,map(radius,0,255,16,40),map(radius,0,255,16,40));
		//rect(x-8,y-8,16,16);

		noStroke();
		//drawText();
		drawHex();

	}

	boolean over(){

		if((dist(mouseX,mouseY,x,y)<map(radius,0,255,16,190))&&!fixed){
			for(int Y = 0;Y<8;Y++){
				for(int X = 0;X<8;X++){
					if( col[Y].dna.charAt(X) == '1')
						counter[X][Y] += (1-counter[X][Y])/(40.0);
					else
						counter[X][Y] += (-counter[X][Y])/(40.0);
				}
			}
			return true;
		}else{
			return false;
		}


	}

	void attract(int kolik,float jakMoc){

		for(int i = 0;i<kolik;i++){
			Bytost next = alfa[(int)random(alfa.length)];
			if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
				x+=(next.x-x)/jakMoc;
				y+=(next.y-y)/jakMoc;
			}
		}

	}

	void detract(int kolik,float jakMoc){

		for(int i = 0;i<kolik;i++){
			Bytost next = alfa[(int)random(alfa.length)];
			if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
				tx-=(next.x-tx)/jakMoc;
				ty-=(next.y-ty)/jakMoc;
			}
		}

	}


	void drawText(){
		fill(255,120);

		for(int i = 0 ;i<col.length;i++){
			text(col[i].dna,x+7,y+2+i*9);
		}

	}

	void drawHex(){
		if(over())
			fill(255);
		else
			fill(r,g,b,120);
		//fill(0);
		pushMatrix();
		translate(x-4,y-4);
		for(int Y = 0 ;Y<col.length;Y++){
			for(int X = 0 ;X<col.length;X++){
				if(col[Y].dna.charAt(X) == '1')
					rect(X,Y,1,1);
			}
		}
		popMatrix();

	}

	String row(int which){

		String a = "";
		for(int i =0;i<col.length;i++){
			a += col[i].dna.charAt(which)+"";

		}

		return a;

	}

	int rowInt(int which){

		String a = "";
		for(int i =0;i<col.length;i++){
			a += col[i].dna.charAt(which)+"";

		}

		return unbinary(a);

	}

	int colInt(int which){

		return unbinary(col[which].dna);

	}

	int diagInt(int which){

		String a = "";

		a += col[0].dna.charAt(which)+"";
		a += col[1].dna.charAt((which+1)%col[0].dna.length())+"";
		a += col[2].dna.charAt((which+2)%col[0].dna.length())+"";
		a += col[3].dna.charAt((which+3)%col[0].dna.length())+"";

		a += col[4].dna.charAt((which+4)%col[0].dna.length())+"";
		a += col[5].dna.charAt((which+5)%col[0].dna.length())+"";
		a += col[6].dna.charAt((which+6)%col[0].dna.length())+"";
		a += col[7].dna.charAt((which+7)%col[0].dna.length())+"";

		return unbinary(a);

	}

	int revdiagInt(int which){

		String a = "";

		a += col[0].dna.charAt(which)+"";
		a += col[1].dna.charAt((which-1+col[0].dna.length())%col[0].dna.length())+"";
		a += col[2].dna.charAt((which-2+col[0].dna.length())%col[0].dna.length())+"";
		a += col[3].dna.charAt((which-3+col[0].dna.length())%col[0].dna.length())+"";

		a += col[4].dna.charAt((which-4+col[0].dna.length())%col[0].dna.length())+"";
		a += col[5].dna.charAt((which-5+col[0].dna.length())%col[0].dna.length())+"";
		a += col[6].dna.charAt((which-6+col[0].dna.length())%col[0].dna.length())+"";
		a += col[7].dna.charAt((which-7+col[0].dna.length())%col[0].dna.length())+"";

		return unbinary(a);

	}


}

class Genome{
	String dna;
	int mn,mx;

	Genome(int strict){
		dna = "";

		regen(strict);
	}

	Genome(int _mn, int _mx){
		dna = "";

		mn = _mn;
		mx = _mx;

		regen();
	}





	void regen(){
		generateDna((int)random(mn,mx));
	}

	void regen(int _in){
		generateDna(_in);
	}

	void degen(int kolik){


		for(int i = 0;i<kolik;i++){

			int which = (int)random(dna.length());
			String stremp = "";

			if(dna.charAt(which)=='1'){
				stremp = dna+"";
				dna = stremp.substring(0,which)+"0"+stremp.substring(which+1,stremp.length());

			}else{

				stremp = dna+"";
				dna = stremp.substring(0,which)+"1"+stremp.substring(which+1,stremp.length());
			}

		}
		//println(dna+" = "+unbinary(dna));


	}




	int[] decode(){
		String temp = getDna();
		int[] answ = new int[temp.length()];

		for(int i =0;i<answ.length;i++){
			answ[i] = parseInt(temp.charAt(i));
		}
		return answ;
	}

	int getInt(){
		return unbinary(dna);

	}

	String encode(int[] in){
		String temp = "";

		for(int i =0;i<in.length;i++){
			temp += in[i]+"";
		}
		return temp;
	}

	void generateDna(int in){
		for(int i =0;i<in;i++)
		if(random(50) <= 25){ dna+="0"; }else{ dna+="1"; }
	}

	String getDna(){
		return dna;
	}

	void setDna(String a){
		dna = "";
		dna = a;
	}


	void setDna(int[] a){
		String tmp = "";

		for (int i = 0 ;i<a.length;i++){
			tmp += a[i]+"";
		}

		dna = tmp+"";
	}
}


class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import promidi.*;

MidiIO midiIO;
MidiOut midiOut;


//int notes[][] = {{60},{62},{64},{65},{67},{69},{71},{72,4.0}};

int lo = 50,hi = 380;


String[] txt = new String[0];
int ln = 0;

PGraphics effect;

void setup(){

	size(640,480,P2D);
	
	frameRate(30);
	
	midiIO = MidiIO.getInstance(this);
	println("printPorts of midiIO");
	midiIO.printDevices();
	println();

	println("printDevices recoded 1");
	midiIO.printInputDevices();
	midiIO.printOutputDevices();
	println("<<<<<<<<<   >>>>>>>>>>>>>>>>>>>>>");
	println();

	textFont(createFont("Veranda",12));
	textMode(SCREEN);

	effect = createGraphics(128,128,P2D);
	
	
	/*
	 * Does the same like printDevices by iterating
	 * over the devices and print out their names
	 
	println("printDevices recoded 2");
	println("<< inputs: >>>>>>>>>>>>>>>>>>>>>>");
	for(int i = 0; i < midiIO.numberOfInputDevices();i++){
		println("input  "+nf(i,2)+": "+midiIO.getInputDeviceName(i));
}
	println("<< outputs: >>>>>>>>>>>>>>>>>>>>>");
	for(int i = 0; i < midiIO.numberOfOutputDevices();i++){
		println("output "+nf(i,2)+": "+midiIO.getOutputDeviceName(i));
}
	println("<<<<<<<<<   >>>>>>>>>>>>>>>>>>>>>");

	 */

	initMidi();
	txt = (String[])expand(txt,txt.length+1);
	txt[txt.length-1] = " ";






}

void draw(){
	background(0);

	fill(255);
	
	


	for(int i = 0;i<=ln;i++)
		text(txt[i],20,i*12+20);

	fill((sin(frameCount/3.0)+1)*127);
	text("_");


}

void makeEffect(char input){



}


boolean samohlaska(){
	if(key == 97 ||key == 101 ||key == 105 ||key == 111 ||key == 117 ||
	        key == 105 ||key == 283 ||key == 253 ||key == 225 ||key == 237 ||
	        key == 233 ||key == 250 ||key == 367){
		return true;
	}else{
		return false;
	}

}

void keyPressed(){

	if(keyCode == BACKSPACE){
		if(txt[ln].length()>=2)
			txt[ln] = txt[ln].substring(0,txt[ln].length()-1);


		try{
			Note test = new Note(100, 127, (int)random(400));
			midiOut.sendNote(test);
		}catch(java.lang.NullPointerException e){
			println("moc not najednou!");
		}


	}else if(keyCode == ENTER){
		txt = (String[])expand(txt,txt.length+1);
		txt[txt.length-1] = " ";
		ln++;

	}else if( samohlaska() ){


		float tone = 10;

		char tmp = (char)key;

		switch (tmp){

		case 'a': tone = 1; break;
		case 'e': tone = 2; break;
		case 'i': tone = 3; break;
		case 'o': tone = 5; break;
		case 'u': tone = 8; break;
		case 'y': tone = 13; break;

		case 'á': tone = 21; break;
		case 'é': tone = 33; break;
		case 'í': tone = 54; break;
		case 'ó': tone = 87; break;
		case 'ú': tone = 141%127; break;
		case 'ý': tone = 228%127; break;

		case 'ů': tone = 369%127; break;

		case 'A': tone = 3; break;
		case 'E': tone = 4; break;
		case 'I': tone = 7; break;
		case 'O': tone = 11; break;
		case 'U': tone = 28; break;
		case 'Y': tone = 39; break;

		}

		txt[ln] += (char)key;




		try{
			Note test = new Note( (int)(((tone) )%127), 127, (int)random(400));
			midiOut.sendNote(test);
		}catch(java.lang.NullPointerException e){
			println("moc not najednou!");
		}

	}else if(key < 400){


		float tone = 10;

		char tmp = (char)key;

		switch (tmp){

		case 'b': tone = 1; break;
		case 'c': tone = 2; break;
		case 'd': tone = 3; break;
		case 'f': tone = 5; break;
		case 'g': tone = 8; break;
		case 'h': tone = 13; break;
		case 'j': tone = 21; break;
		case 'k': tone = 33; break;
		case 'l': tone = 54; break;
		case 'm': tone = 87%127; break;
		case 'n': tone = 141%127; break;
		case 'p': tone = 228%127; break;
		case 'q': tone = 369%127; break;
		case 'r': tone = 597%127; break;
		case 's': tone = 966%127; break;
		case 't': tone = 1563%127; break;
		case 'v': tone = 2529%127; break;
		case 'w': tone = 4092%127; break;
		case 'x': tone = 6621%127; break;
		case 'z': tone = 10713%127; break;

		case 'š': tone = 1; break;
		case 'č': tone = 2; break;
		case 'ř': tone = 3; break;
		case 'ž': tone = 5; break;
		         
		case '0': tone = 13; break;
		case '1': tone = 21; break;
		case '2': tone = 33; break;
		case '3': tone = 54; break;
		case '4': tone = 87%127; break;
		case '5': tone = 141%127; break;
		case '6': tone = 228%127; break;
		case '7': tone = 369%127; break;
		case '8': tone = 597%127; break;
		case '9': tone = 966%127; break;   
		          
		


		}

		txt[ln] += (char)key;




		try{
			Note test = new Note( (int)((tone)%127), 127, (int)random(400));
			midiOut.sendNote(test);
		}catch(java.lang.NullPointerException e){
			println("moc not najednou!");
		}
	}
}


void initMidi(){
	midiIO = MidiIO.getInstance(this);
	//idiOut = MidiIO.getMidiOut(0,0);
	midiOut = midiIO.getMidiOut(0,0);



}








class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
PImage a;
PGraphics ram;
String txt = "CAS / Centrum audiovizuálních studií";

PFont Font1,Font2;

Recorder r;
boolean rec = true;

void setup(){
	size(268,97,P2D);
	frameRate(30);
	background(0);
	println(PFont.list());

	Font1 = createFont("DejaVu Sans Mono Bold",10);
	Font2 = createFont("DejaVu Sans Mono Bold",32);

	textMode(SCREEN);
	background(#FFaa00);

	ram = createGraphics(width+20,height+20,P2D);
	ram.beginDraw();
	ram.stroke(0);
	ram.strokeWeight(30);
	ram.noFill();
	ram.rect(0,0,width+20,height+20);
	ram.filter(BLUR,5);

	ram.endDraw();
	
	
	if(rec)
	r = new Recorder("out","banner.mp4");

}


void draw(){
	background(lerpColor(#aaaaaa,#000000,random(40,60)/100.0) );

	
/*	
	drawSign(15,(int)random(65,67),(int)random(77,79),#000000);
	filter(BLUR,random(1,3));

	
	fill(0,150);
	int res = (int)random(2,6);
	kosticka(0,0,width,height,res,res);

	fill(255,150);
	res = (int)random(2,6);
	kosticka(0,0,width,height,res,res);

	fill(#FF1100,150);
	res = (int)random(2,6);
	kosticka(0,0,width,height,res,res);
	
	fill(0,150);
	res = (int)random(2,6);
	kosticka(0,0,width,height,res,res);

	fill(255,150);
	res = (int)random(2,6);
	kosticka(0,0,width,height,res,res);

	fill(#FF1100,150);
	res = (int)random(2,6);
	kosticka(0,0,width,height,res,res);

	//drawSign(15,(int)random(55,57),(int)random(75,77));

	filter(BLUR,random(1,2));
*/
	
	

	//drawSign();

	fill(255,50);
	kosticka((int)random(-30,0),(int)random(-30,0),width*2,height*2,(int)random(2,6),(int)random(2,30));

	kosticka((int)random(-30,0),(int)random(-30,0),width*2,height*2,(int)random(2,6),(int)random(2,30));

	kosticka((int)random(-30,0),(int)random(-30,0),width*2,height*2,(int)random(2,6),(int)random(2,30));
	
	noiser(60,80);
	drawSign(15,(int)random(63,65),(int)random(75,77),#ffffff);
	image(ram,-10+random(-2,2),-10+random(-2,2));
	
	if(rec)
		r.add();




}

void drawSign(float _x,int y1, int y2,color c){

	for(int i = 0;i<txt.length();i++){


		for(int q = 0;q<height;q++){


			if(i<4){

				fill(c,random(1,3));
				textFont(Font2);

				if(q==y1){
					fill(c,random(100,130));
					text(txt.charAt(i),10+i*18+_x,q);

				}else{

					text(txt.charAt(i),10+i*18+random(-2,2)+_x,q);
				}
			}else{

				fill(c,random(1,3));
				textFont(Font1);

				if(q==y2){
					fill(c,random(80,150));
					text(txt.charAt(i),10+i*7-30+_x,q);
				}else{
					text(txt.charAt(i),10+i*7-30+random(-2,2)+_x,q);
				}
			}
		}
	}



}

void kosticka(int _x,int _y,int w,int h,int rx,int ry){

	noStroke();
	for(int x  = 0;x<w;x+=rx){
		for(int y  = 0;y<h;y+=ry){
			if(random(255)>128)
				rect(_x+x*rx,_y+y*ry,rx,ry);
		}
	}


}

void noiser(int mn,int mx){

for(int x = 0;x<width;x++){

		for(int y = 0;y<height;y++){
			stroke(0,random(mn,mx));
			point(x,y);
		}
	}

}


import javax.media.opengl.*;
import com.sun.opengl.util.FPSAnimator;

GLCanvas canvas;

void setup() {
 size(400, 300);
 
 canvas = new GLCanvas();
 canvas.setSize(200, 200);
 canvas.addGLEventListener(new GLRenderer());
 FPSAnimator animator = new FPSAnimator(canvas, 60);
 animator.start();
 
 add(canvas);
 
}

void draw() {
 background(50);
 fill(255);
 rect(10,10,frameCount%100,10);
}

class GLRenderer implements GLEventListener {
 GL gl;

 public void init(GLAutoDrawable drawable) {
   this.gl = drawable.getGL();
   gl.glClearColor(1, 0, 0, 0);  
   canvas.setLocation(100, 80);    
 }

 public void display(GLAutoDrawable drawable) {
   gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT );
   gl.glColor3f(1, 1, 1);
   gl.glRectf(-0.8, 0.8, frameCount%100/100f -0.8, 0.7);
 }
 
 public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
 }

 public void displayChanged(GLAutoDrawable drawable, boolean modeChanged, boolean deviceChanged) {
 }
}

Bytost alfa[];
int num = 500;
boolean blurring = false;
float counter[][] = new float[8][8];
float counterG[][] = new float[8][8];


void setup(){

	size(640,480,P2D);

	for(int Y = 0;Y<8;Y++){
		for(int X = 0;X<8;X++){
			counter[X][Y] = 0;
		}
	}

	alfa = new Bytost[num];

	for(int i =0;i<alfa.length;i++)
		alfa[i] = new Bytost();

	//println(PFont.list());
	textFont(createFont("DejaVu Sans",9));
	textMode(SCREEN);
}


void draw(){
	background(0);


	for(int i =0;i<alfa.length;i++){
		alfa[i].draw();
		
		
	for(int Y = 0;Y<8;Y++){
				for(int X = 0;X<8;X++){
					if( alfa[i].col[Y].dna.charAt(X) == '1')
						counterG[X][Y] += (1-counterG[X][Y])/(100.0);
					else
						counterG[X][Y] += (-counterG[X][Y])/(100.0);
				}
			}
		
	}


	if(blurring)
		filter(BLUR,2);

	for(int Y = 0;Y<8;Y++){
		for(int X = 0;X<8;X++){
			fill(counter[X][Y]*255,120);
			rect(mouseX+X*8,mouseY+Y*8,8,8);
		}

	}
	
	
	for(int Y = 0;Y<8;Y++){
				for(int X = 0;X<8;X++){
					if( col[Y].dna.charAt(X) == '1')
						counter[X][Y] += (1-counter[X][Y])/(100.0);
					else
						counter[X][Y] += (-counter[X][Y])/(100.0);
				}
			}

}


/*
void keyPressed(){
	if(key == 'q'){
		alfa.col[0].degen(1);
	}else if(key == 'w'){
		alfa.col[1].degen(1);
	}else if(key == 'e'){
		alfa.col[2].degen(1);
	}else if(key == 'r'){
		alfa.col[3].degen(1);
	}


}*/


class Bytost{


	Genome[] col;
	float x,y,tx,ty,r,g,b,a,velikost = 0,radius = 0;
	float speed = 40;
	int kadence;
	float mmn = 25;
	float mmx = 150;
	float blink;

	Bytost(){
		col = new Genome[8];

		for(int i = 0 ;i<col.length;i++){
			col[i] = new Genome(8);

			//println(col[i].getDna()+" = "+unbinary(col[i].getDna()));
		}

		x = tx = map(rowInt(0),0,255,0,width);
		y = ty = map(rowInt(1),0,255,0,height);


		kadence =  (int)random(20,200);//rowInt(3)+1;

		r = colInt(0);
		g = colInt(1);
		b = colInt(2);
		a = rowInt(6);

		blink = revdiagInt(6)/4.0;
		//g = random(255);
		//b = random(255);
		//a = random(255);





		//col[3].setDna(120);
	}

	void compute(){

		//for(int i = 0 ;i<col.length;i++){
		if(frameCount%kadence==0){
			col[(int)random(col.length)].degen(1);
			col[(int)random(col.length)].degen(1);
			col[(int)random(col.length)].degen(1);

		}
		//}

		tx = map(rowInt(0),0,255,0,width);
		ty = map(rowInt(1),0,255,0,height);

		speed += (diagInt(7)*2-speed)/40.0;

		//kadence = (int)(rowInt(4)/3.0+30+random(-5,5));

		speed = constrain(speed,30,255);
		kadence = constrain(kadence,1,255);



		x += (tx-x)/speed;
		y += (ty-y)/speed;


		r += (diagInt(2)-r)/speed;
		g += (diagInt(3)-g)/speed;
		b += (diagInt(4)-b)/speed;
		a += (rowInt(6)-a)/speed;

		velikost += (rowInt(5)-velikost)/speed;

		radius += (revdiagInt(4)-radius)/speed;

		blink += (diagInt(6)-blink)/speed;

		for(int i = 0;i<15;i++)
			income(1,0);

		//attract((int)(colInt(4)/10.0),diagInt(4));
		//detract((int)(colInt(6)/10.0),diagInt(6));

		//detract(2,200.0);


	}

	void income(int jakMoc,int degenerace){


		Bytost next = alfa[(int)random(alfa.length)];
		if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
			for(int i = 0;i<jakMoc;i++){
				int wh = (int)random(col.length);
				col[wh].dna = next.col[wh].dna+"";
				//if(i==0)

			}

			for(int i = 0;i<degenerace;i++){
				col[(int)random(col.length)].degen(1);
			}

		}

	}


	void draw(){

		compute();

		noStroke();
		//fill(lerpColor(color(r,g,b),0xFFFFFFFF,(sin(frameCount/blink)+1)/2.0),a);
		stroke(r,g,b,constrain(a/12.0+((sin(frameCount/(blink*.1))+1)*40.0),0,255));
		noFill();
		//ellipse(x,y,map(radius,0,255,16,20),map(radius,0,255,16,20));

		//ellipse(x,y,map(radius,0,255,16,30),map(radius,0,255,16,30));

		ellipse(x,y,map(radius,0,255,16,40),map(radius,0,255,16,40));
		//rect(x-8,y-8,16,16);

		noStroke();
		//drawText();
		drawHex();

	}

	boolean over(){

		if(dist(mouseX,mouseY,x,y)<map(radius,0,255,16,190)){
			for(int Y = 0;Y<8;Y++){
				for(int X = 0;X<8;X++){
					if( col[Y].dna.charAt(X) == '1')
						counter[X][Y] += (1-counter[X][Y])/(100.0);
					else
						counter[X][Y] += (-counter[X][Y])/(100.0);
				}
			}
			return true;
		}else{
			return false;
		}


	}

	void attract(int kolik,float jakMoc){

		for(int i = 0;i<kolik;i++){
			Bytost next = alfa[(int)random(alfa.length)];
			if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
				x+=(next.x-x)/jakMoc;
				y+=(next.y-y)/jakMoc;
			}
		}

	}

	void detract(int kolik,float jakMoc){

		for(int i = 0;i<kolik;i++){
			Bytost next = alfa[(int)random(alfa.length)];
			if(dist(x,y,next.x,next.y)<map(radius,0,255,mmn,mmx)){
				x-=(next.x-x)/jakMoc;
				y-=(next.y-y)/jakMoc;
			}
		}

	}


	void drawText(){
		fill(255,120);

		for(int i = 0 ;i<col.length;i++){
			text(col[i].dna,x+7,y+2+i*9);
		}

	}

	void drawHex(){
		if(over())
			fill(255);
		else
			fill(r,g,b,120);
		//fill(0);
		pushMatrix();
		translate(x-4,y-4);
		for(int Y = 0 ;Y<col.length;Y++){
			for(int X = 0 ;X<col.length;X++){
				if(col[Y].dna.charAt(X) == '1')
					rect(X,Y,1,1);
			}
		}
		popMatrix();

	}

	String row(int which){

		String a = "";
		for(int i =0;i<col.length;i++){
			a += col[i].dna.charAt(which)+"";

		}

		return a;

	}

	int rowInt(int which){

		String a = "";
		for(int i =0;i<col.length;i++){
			a += col[i].dna.charAt(which)+"";

		}

		return unbinary(a);

	}

	int colInt(int which){

		return unbinary(col[which].dna);

	}

	int diagInt(int which){

		String a = "";

		a += col[0].dna.charAt(which)+"";
		a += col[1].dna.charAt((which+1)%col[0].dna.length())+"";
		a += col[2].dna.charAt((which+2)%col[0].dna.length())+"";
		a += col[3].dna.charAt((which+3)%col[0].dna.length())+"";

		a += col[4].dna.charAt((which+4)%col[0].dna.length())+"";
		a += col[5].dna.charAt((which+5)%col[0].dna.length())+"";
		a += col[6].dna.charAt((which+6)%col[0].dna.length())+"";
		a += col[7].dna.charAt((which+7)%col[0].dna.length())+"";

		return unbinary(a);

	}

	int revdiagInt(int which){

		String a = "";

		a += col[0].dna.charAt(which)+"";
		a += col[1].dna.charAt((which-1+col[0].dna.length())%col[0].dna.length())+"";
		a += col[2].dna.charAt((which-2+col[0].dna.length())%col[0].dna.length())+"";
		a += col[3].dna.charAt((which-3+col[0].dna.length())%col[0].dna.length())+"";

		a += col[4].dna.charAt((which-4+col[0].dna.length())%col[0].dna.length())+"";
		a += col[5].dna.charAt((which-5+col[0].dna.length())%col[0].dna.length())+"";
		a += col[6].dna.charAt((which-6+col[0].dna.length())%col[0].dna.length())+"";
		a += col[7].dna.charAt((which-7+col[0].dna.length())%col[0].dna.length())+"";

		return unbinary(a);

	}


}

class Genome{
	String dna;
	int mn,mx;

	Genome(int strict){
		dna = "";

		regen(strict);
	}

	Genome(int _mn, int _mx){
		dna = "";

		mn = _mn;
		mx = _mx;

		regen();
	}





	void regen(){
		generateDna((int)random(mn,mx));
	}

	void regen(int _in){
		generateDna(_in);
	}

	void degen(int kolik){


		for(int i = 0;i<kolik;i++){

			int which = (int)random(dna.length());
			String stremp = "";

			if(dna.charAt(which)=='1'){
				stremp = dna+"";
				dna = stremp.substring(0,which)+"0"+stremp.substring(which+1,stremp.length());

			}else{

				stremp = dna+"";
				dna = stremp.substring(0,which)+"1"+stremp.substring(which+1,stremp.length());
			}

		}
		//println(dna+" = "+unbinary(dna));


	}




	int[] decode(){
		String temp = getDna();
		int[] answ = new int[temp.length()];

		for(int i =0;i<answ.length;i++){
			answ[i] = parseInt(temp.charAt(i));
		}
		return answ;
	}

	int getInt(){
		return unbinary(dna);

	}

	String encode(int[] in){
		String temp = "";

		for(int i =0;i<in.length;i++){
			temp += in[i]+"";
		}
		return temp;
	}

	void generateDna(int in){
		for(int i =0;i<in;i++)
		if(random(50) <= 25){ dna+="0"; }else{ dna+="1"; }
	}

	String getDna(){
		return dna;
	}

	void setDna(String a){
		dna = "";
		dna = a;
	}


	void setDna(int a){

		dna = binary(a)+"";
	}
}


// Daniel Shiffman
// The Nature of Code
// http://www.shiffman.net/teaching/nature
// Simple Perceptron Example
// See: http://en.wikipedia.org/wiki/Perceptron

// A class to describe a training point
// Has an x and y, a "bias" (1) and known output
// Could also add a variable for "guess" but not required here

class Point {
  
  float[] vals;
  int output; 
  
  Point(float x_, float y_, int output_) {
    vals = new float[3];
    vals[0] = x_;
    vals[1] = y_;
    vals[2] = 1;
    output = output_;
  }
}
// Daniel Shiffman
// The Nature of Code
// http://www.shiffman.net/teaching/nature
// Simple Perceptron Example
// See: http://en.wikipedia.org/wiki/Perceptron

// Perceptron Class

class Perceptron {
  float[] weights;  // Array of weights for inputs
  float c;          // learning constant

  // Perceptron is created with n weights and learning constant
  Perceptron(int n, float c_) {
    weights = new float[n];
    // Start with random weights
    for (int i = 0; i < weights.length; i++) {
      weights[i] = random(-1,1); 
    }
    c = c_;
  }

  // Function to train the Perceptron
  // Weights are adjusted based on "desired" answer
  void train(float[] vals, int desired) {
    // Guess the result
    int result = guess(vals);
    // Compute the factor for changing the weight based on the error
    // Error = desired output - guessed output
    // Note this can only be 0, -2, or 2
    // Multiply by learning constant
    float weightChange = c*(desired - result);
    // Adjust weights based on weightChange * input
    for (int i = 0; i < weights.length; i++) {
      weights[i] += weightChange * vals[i];         
    }
  }

  // Guess -1 or 1 based on input values
  int guess(float[] vals) {
    // Sum all values
    float sum = 0;
    for (int i = 0; i < weights.length; i++) {
      sum += vals[i]*weights[i];
    }
    // Result is sign of the sum, -1 or 1
    int result = 1;
    if (sum < 0) result = -1;
    return result;
  }

  // Return weights
  float[] getWeights() {
    return weights; 
  }
}
// Daniel Shiffman
// The Nature of Code
// http://www.shiffman.net/teaching/nature
// Simple Perceptron Example
// See: http://en.wikipedia.org/wiki/Perceptron

// Code based on text "Artificial Intelligence", George Luger

// A list of points we will use to "train" the perceptron
Point[] training = new Point[2000];
// A Perceptron object
Perceptron ptron;

// We will train the perceptron with one "Point" object at a time
int count = 0;

// Scale (note we are living in a space -2 < y < 2, -2 < x < 2)
float scl;

// The function to describe a line 
float f(float x) {
  return x*0.9-0.2; 
}

void setup() {
  size(400,400,P2D);
  scl = width/2.0;  // Scale based on width
  
  // The perceptron has 3 inputs -- x, y, and bias
  // Second value is "Learning Constant"
  ptron = new Perceptron(3,0.002);  // Learning Constant is low just b/c it's fun to watch, this is not optimal
  // ptron = new Perceptron(3,0.1);  // A bit better, perhaps

  // Create a random set of training points and calculate the "known" answer
  for (int i = 0; i < training.length; i++) {
    float x = random(-2,2);
    float y = random(-2,2);
    int answer = 1;
    if (y < f(x)) answer = -1;
    training[i] = new Point(x,y,answer);
  }
  smooth();
  //frameRate(5);
}


void draw() {
  background(255);
  
  float[] weights = ptron.getWeights();
  // Debug the weights
  // println("weights: " + weights[0] + " " + weights[1] + " " + weights[2]);

  // Draw the line based on the current weights
  // Formula is weights[0]*x + weights[1]*y + weights[2] = 0
  stroke(0);
  beginShape();
  for (int x = -2; x <= 2; x++) {
    float y = (-weights[2] - weights[0]*x)/weights[1]; // solve for Y
    vertex(x*scl+scl,y*scl+scl);  // scale up for pixels
  }
  endShape();

  // Draw the line for the "correct" answer 
  beginShape();
  stroke(255,200,100);
  for (float x = -2; x <= 2; x+=0.1) {
    float y = f(x);  
    vertex(x*scl+scl,y*scl+scl); // scale up for pixels
  }
  endShape();

  
  // Train the Perceptron with one "training" point at a time
  ptron.train(training[count].vals,training[count].output);
  count = (count + 1) % training.length;
  
  // Draw all the points based on what the Perceptron would "guess"
  // Does not use the "known" correct answer
  for (int i = 0; i < count; i++) {
    noStroke();
    fill(255);
    int guess = ptron.guess(training[i].vals);
    if (guess > 0) fill(200,100,200);
    else fill(100,200,200);
    ellipse(training[i].vals[0]*200+200,training[i].vals[1]*200+200,8,8);
  }
}
// Daniel Shiffman
// The Nature of Code
// http://www.shiffman.net/teaching/nature

// XOR Multi-Layered Neural Network Example
// Neural network code is all in the "code" folder

//import processing.opengl.*;
//import nn.*;

ArrayList inputs;  // List of training input values
Network nn;        // Neural Network Object
int count;         // Total training interations
Landscape land;    // Solution space
float theta = 0.0; // Angle of rotation
PFont f;           // Font


void setup() {

  size(400,400,OPENGL);

  // Create a landscape object
  land = new Landscape(20,300,300);

  f = createFont("Courier",12,true);

  nn = new Network(2,4);

  // Create a list of 4 training inputs
  inputs = new ArrayList();
  float[] input = new float[2];
  input[0] = 1; 
  input[1] = 0;  
  inputs.add((float []) input.clone());
  input[0] = 0; 
  input[1] = 1;  
  inputs.add((float []) input.clone());
  input[0] = 1; 
  input[1] = 1;  
  inputs.add((float []) input.clone());
  input[0] = 0; 
  input[1] = 0;  
  inputs.add((float []) input.clone());
}

void draw() {

  int trainingIterationsPerFrame = 50;

  for (int i = 0; i < trainingIterationsPerFrame; i++) {
    // Pick a random training input
    int pick = int(random(inputs.size()));
    // Grab that input
    float[] inp = (float[]) inputs.get(pick); 
    // Compute XOR
    float known = 1;
    if ((inp[0] == 1.0 && inp[1] == 1.0) || (inp[0] == 0 && inp[1] == 0)) known = 0;
    // Train that sucker!
    float result = nn.train(inp,known);
    count++;
  }

  // Ok, visualize the solution space
  background(175);
  pushMatrix();
  translate(width/2,height/2+20,-160);
  rotateX(PI/3);
  rotateZ(theta);

  // Put a little BOX on screen
  pushMatrix();
  stroke(50);
  noFill();
  translate(-10,-10,0);
  box(280);

  // Draw the landscape
  popMatrix();
  land.calculate(nn);
  land.render(); 
  theta += 0.0025;
  popMatrix();

  // Display overal neural net stats
  networkStatus();

}


void networkStatus() {
  float mse = 0.0;

  textFont(f);
  fill(0);
  text("Your friendly neighborhood neural network solving XOR.",10,20);
  text("Total iterations: " + count,10,40);

  for (int i = 0; i < inputs.size(); i++) {
    float[] inp = (float[]) inputs.get(i); 
    float known = 1;
    if ((inp[0] == 1.0 && inp[1] == 1.0) || (inp[0] == 0 && inp[1] == 0)) known = 0;
    float result = nn.feedForward(inp);
    //System.out.println("For: " + inp[0] + " " + inp[1] + ":  " + result);
    mse += (result - known)*(result - known);
  }

  float rmse = sqrt(mse/4.0);
  DecimalFormat df = new DecimalFormat("0.000");
  text("Root mean squared error: " + df.format(rmse), 10,60);

}

// Daniel Shiffman
// The Nature of Code, Fall 2006
// Neural Network

// Class to describe a connection between two neurons

public class Connection {

    private Neuron from;     // Connection goes from. . .
    private Neuron to;       // To. . .
    private float weight;   // Weight of the connection. . .

    // Constructor  builds a connection with a random weight
    public Connection(Neuron a_, Neuron b_) {
        from = a_;
        to = b_;
        weight = (float) Math.random()*2-1;
    }
    
    // In case I want to set the weights manually, using this for testing
    public Connection(Neuron a_, Neuron b_, float w) {
        from = a_;
        to = b_;
        weight = w;
    }

    public Neuron getFrom() {
        return from;
    }
    
    public Neuron getTo() {
        return to;
    }  
    
    public float getWeight() {
        return weight;
    }

    // Changing the weight of the connection
    public void adjustWeight(float deltaWeight) {
        weight += deltaWeight;
    }


}


public class HiddenNeuron extends Neuron {
    
    public HiddenNeuron() {
        super();
    }
    
    public HiddenNeuron(int i) {
        super(i);
    }
    
}

//Daniel Shiffman
//The Nature of Code, Fall 2006
//Neural Network

// Input Neuron Class
// Has additional functionality to receive beginning input


public class InputNeuron extends Neuron {
    public InputNeuron() {
        super();
    }
    
    public InputNeuron(int i) {
        super(i);
    }

    public void input(float d) {
        output = d;
    }

}

// Daniel Shiffman
// The Nature of Code, Fall 2006
// Neural Network

// Class to describe the entire network
// Arrays for input neurons, hidden neurons, and output neuron

// Need to update this so that it would work with an array out outputs
// Rather silly that I didn't do this initially

// Also need to build in a "Layer" class so that there can easily
// be more than one hidden layer


public class Network {

    // Layers
    InputNeuron[] input;
    HiddenNeuron[] hidden;
    OutputNeuron output;
    
    public static final float LEARNING_CONSTANT = 0.5f;

    // Only One output now to start!!! (i can do better, really. . .)
    // Constructor makes the entire network based on number of inputs & number of neurons in hidden layer
    // Only One hidden layer!!!  (fix this dood)

    public Network(int inputs, int hiddentotal) {

        input = new InputNeuron[inputs+1];  // Got to add a bias input
        hidden = new HiddenNeuron[hiddentotal+1];

        // Make input neurons
        for (int i = 0; i < input.length-1; i++) {
            input[i] = new InputNeuron();
        }
        
        // Make hidden neurons
        for (int i = 0; i < hidden.length-1; i++) {
            hidden[i] = new HiddenNeuron();
        }

        // Make bias neurons
        input[input.length-1] = new InputNeuron(1);
        hidden[hidden.length-1] = new HiddenNeuron(1);

        // Make output neuron
        output = new OutputNeuron();

        // Connect input layer to hidden layer
        for (int i = 0; i < input.length; i++) {
            for (int j = 0; j < hidden.length-1; j++) {
                // Create the connection object and put it in both neurons
                Connection c = new Connection(input[i],hidden[j]);
                input[i].addConnection(c);
                hidden[j].addConnection(c);
            }
        }
        
        // Connect the hidden layer to the output neuron
        for (int i = 0; i < hidden.length; i++) {
            Connection c = new Connection(hidden[i],output);
            hidden[i].addConnection(c);
            output.addConnection(c);
        }

    }


    public float feedForward(float[] inputVals) {
        
        // Feed the input with an array of inputs
        for (int i = 0; i < inputVals.length; i++) {
            input[i].input(inputVals[i]);  
        }
        
        // Have the hidden layer calculate its output
        for (int i = 0; i < hidden.length-1; i++) {
            hidden[i].calcOutput();
        }

        // Calculate the output of the output neuron
        output.calcOutput();
        
        // Return output
        return output.getOutput();
    }

    public float train(float[] inputs, float answer) {
        float result = feedForward(inputs);
        
        
        // This is where the error correction all starts
        // Derivative of sigmoid output function * diff between known and guess
        float deltaOutput = result*(1-result) * (answer-result);

        
        // BACKPROPOGATION
        // This is easier b/c we just have one output
        // Apply Delta to connections between hidden and output
        ArrayList connections = output.getConnections();
        for (int i = 0; i < connections.size(); i++) {
            Connection c = (Connection) connections.get(i);
            Neuron neuron = c.getFrom();
            float output = neuron.getOutput();
            float deltaWeight = output*deltaOutput;
            c.adjustWeight(LEARNING_CONSTANT*deltaWeight);
        }
        
        // ADJUST HIDDEN WEIGHTS
        for (int i = 0; i < hidden.length; i++) {
            connections = hidden[i].getConnections();
            float sum  = 0;
            // Sum output delta * hidden layer connections (just one output)
            for (int j = 0; j < connections.size(); j++) {
                Connection c = (Connection) connections.get(j);
                // Is this a connection from hidden layer to next layer (output)?
                if (c.getFrom() == hidden[i]) {
                    sum += c.getWeight()*deltaOutput;
                }
            }    
            // Then adjust the weights coming in based:
            // Above sum * derivative of sigmoid output function for hidden neurons
            for (int j = 0; j < connections.size(); j++) {
                Connection c = (Connection) connections.get(j);
                // Is this a connection from previous layer (input) to hidden layer?
                if (c.getTo() == hidden[i]) {
                    float output = hidden[i].getOutput();
                    float deltaHidden = output * (1 - output);  // Derivative of sigmoid(x)
                    deltaHidden *= sum;   // Would sum for all outputs if more than one output
                    Neuron neuron = c.getFrom();
                    float deltaWeight = neuron.getOutput()*deltaHidden;
                    c.adjustWeight(LEARNING_CONSTANT*deltaWeight);
                }
            } 
        }

        return result;
    }
}

//Daniel Shiffman
//The Nature of Code, Fall 2006
//Neural Network

//Generic Neuron Class
//Can be a bias neuron (true or false)


public class Neuron {

    protected float output;
    protected ArrayList connections; 
    protected boolean bias = false;

    // A regular Neuron
    public Neuron() {
        output = 0;
        // Using an arraylist to store list of connections to other neurons
        connections = new ArrayList();  
        bias = false;
    }

    // Constructor for a bias neuron
    public Neuron(int i) {
        output = i;
        connections = new ArrayList();
        bias = true;
    }

    // Function to calculate output of this neuron
    // Output is sum of all inputs*weight of connections
    public void calcOutput() {
        if (bias) {
            // do nothing
        } else {
            float sum = 0;
            float bias = 0;
            //System.out.println("Looking through " + connections.size() + " connections");
            for (int i = 0; i < connections.size(); i++) {
                Connection c = (Connection) connections.get(i);
                Neuron from = c.getFrom();
                Neuron to = c.getTo();
                // Is this connection moving forward to us
                // Ignore connections that we send our output to
                if (to == this) {
                    // This isn't really necessary
                    // But I am treating the bias individually in case I need to at some point
                    if (from.bias) {
                        bias = from.getOutput()*c.getWeight();
                    } else {
                        sum += from.getOutput()*c.getWeight();
                    }
                }
            }
            // Output is result of sigmoid function
            output = f(bias+sum);
        }
    }

    void addConnection(Connection c) {
        connections.add(c);
    }

    float getOutput() {
        return output;
    }

    // Sigmoid function
    public float f(float x) {
        return 1.0f / (1.0f + (float) Math.exp(-x));
    }

    public ArrayList getConnections() {
        return connections;
    }


}


public class OutputNeuron extends Neuron {
    public OutputNeuron() {
        super();
    }
}


// Daniel Shiffman
// <http://www.shiffman.net>
// "Landscape" example

class Landscape {

  int scl;           // size of each cell
  int w,h;           // width and height of thingie
  int rows, cols;    // number of rows and columns
  float zoff = 0.0;  // perlin noise argument
  float[][] z;       // using an array to store all the height values 

  Landscape(int scl_, int w_, int h_) {
    scl = scl_;
    w = w_;
    h = h_;
    cols = w/scl;
    rows = h/scl;
    z = new float[cols][rows];
  }


  // Calculate height values (based off a neural netork)
  void calculate(Network nn) {
    float x = 0;
    float dx = (float) 1.0 / cols;
    for (int i = 0; i < cols; i++)
    { 
      float y = 0;
      float dy = (float) 1.0 / rows;
      for (int j = 0; j < rows; j++)
      {
        float[] input = new float[2];
        input[0] = x; 
        input[1] = y;
        float result = nn.feedForward(input);
        z[i][j] = z[i][j]*0.95 + 0.05*(float)(result*280.0f-140.0);
        y += dy;
      }
      x += dx;
    }

  }

  // Render landscape as grid of quads
  void render() {
    // Every cell is an individual quad
    // (could use quad_strip here, but produces funny results, investigate this)
    for (int x = 0; x < z.length-1; x++)
    {
      for (int y = 0; y < z[x].length-1; y++)
      {
        // one quad at a time
        // each quad's color is determined by the height value at each vertex
        // (clean this part up)
        noStroke();
        pushMatrix();
        beginShape(QUADS);
        translate(x*scl-w/2,y*scl-h/2,0);
        fill(z[x][y]+127,220);
        vertex(0,0,z[x][y]);
        fill(z[x+1][y]+127,220);
        vertex(scl,0,z[x+1][y]);
        fill(z[x+1][y+1]+127,220);
        vertex(scl,scl,z[x+1][y+1]);
        fill(z[x][y+1]+127,220);
        vertex(0,scl,z[x][y+1]);
        endShape();
        popMatrix();
      }
    }
  }
}
// Daniel Shiffman
// The Nature of Code
// http://www.shiffman.net/teaching/nature

// Using a Neural Network to recognize pixels of an input image
// Neural network code is all in the "code" folder

import nn.*;

// The pixel data from each image file will be our training set
ArrayList pixelData;

// The size of our image data
int w = 18;
int h = 24;

// How many numbers are we going to try to guess
int total = 2; // Just doing 0's and 1's, but this will sort of work for more.
// Here are the training images
PImage[] trainingImages = new PImage[total];

// The Neural Network
Network nn;         

// How many training cycles have we done
int trainingCount;  

// We will train 5,000 iterations
int maxTrainingIterations = 15000;

// A submit button
Button submit;

// The points a user has drawn
ArrayList points;

// The input image from the user
PImage inputImage;

// Some booleans to keep track of what is going on
boolean welcome = true;
boolean training = false;
boolean trainingComplete = false;
boolean guessing = false;

PFont f;

// What is the neural network's guess
float guess = 0;

void setup() {
  size(360,480,P2D);
  background(255);
  points = new ArrayList();

  // Load all the images
  loadTrainingImages();

  // Setup network
  nn = new Network(w*h,16);
  f = createFont("Georgia",16,true);

  // Make a blank input image
  inputImage = createImage(w,h,RGB);

  // Submit button
  submit = new Button(100,440,160,25, "submit");

}

void draw() {
  background(255);

  // Welcome screen
  if (welcome) {
    welcome();
    // Training screen
  } 
  else if (training) {
    if (!trainingComplete) {
      train();
    }
    showTraining();
    // Guessing screen
  } 
  else {
    userDraw();
    guess();
  }


  // Draw the guessing image and training images
  noFill();
  stroke(0);
  strokeWeight(1);
  image(inputImage,0,0);
  rect(0,0,w,h);
  for (int i = 0; i < trainingImages.length; i++) {
    image(trainingImages[i],(i+1)*w,0);
    rect((i+1)*w,0,w,h);
  }
}





class Point {

  float x,y;

  Point(float x_, float y_) {
    x = x_;
    y = y_;
  }

}


// Deal with button release
void mouseReleased() {
  submit.released();
}

void mousePressed() {
  // Clicking the mouse exits the welcome screen
  if (welcome) {
    welcome = false;
    training = true;
    // Deal with the submit button
  } 
  else if (submit.clicked(mouseX,mouseY)) {
    // Time to guess!
    guessing = true;
    float[] binaryPixels = getPixels(inputImage);
    float result = nn.feedForward(binaryPixels);
    // Here is the result
    guess = result * total;
  }
}

void keyPressed() {
  // Quit training
  if (training && trainingComplete) {
    training = false;
    // If guessing
  } 
  else if (guessing) {
    // No longer guessing
    guessing = false;
    // What number did user  type
    int num = Integer.parseInt("" + key);
    float[] binaryPixels = getPixels(inputImage);
    // Retrain the network according to those pixels
    nn.train(binaryPixels, (float)num/total);
    // Clear what user has drawn for next time
    points.clear();
  }
}


class Button {
  Rectangle r;      // Button's rectangle
  String txt;       // Button's text
  boolean clicked;  // Did i click on it?
  boolean rollover; // Did i rollover it?

  Button(int x, int y, int w, int h, String s) {
    r = new Rectangle(x,y,w,h);
    txt = s;
  }

  void render() {
    // Draw rectangle and text based on whether rollover or clicked
    rectMode(PConstants.CORNER);
    strokeWeight(1);
    stroke(0); 
    fill(255);
    if (rollover) fill(127);
    if (clicked) fill(0);
    rect(r.x,r.y,r.width,r.height);
    int b = 0;
    if (clicked) b = 255;
    else if (rollover) b = 50;
    else b = 0;
    fill(b);
    textAlign(PConstants.CENTER);
    text(txt,r.x+r.width/2,r.y+r.height-6);
  }

  // Methods to check rollover, clicked, or released (must be called from appropriate
  // places in draw, mousePressed, mouseReleased
  boolean rollover(int mx, int my) {
    if (r.contains(mx,my)) rollover = true;
    else rollover = false;
    return rollover;
  }

  boolean clicked(int mx, int my) {
    if (r.contains(mx,my)) clicked = true;
    return clicked;
  }

  void released() {
    clicked = false;
  }

}



// A little welcome message
void welcome() {
  textFont(f);
  textAlign(CENTER);
  fill(0);
  text("Hello.  I am a very simple neural network. \n" + 
    "I can recognize 0's and 1's. \n" + 
    "Click the mouse and I'll start training.",width/2,height/2);
}


// Train the network
void train() {
  // Adjust this number to make training appear to be faster / slower
  int cyclesPerFrame = 50;

  for (int i = 0; i < cyclesPerFrame; i++) {
    // Pick a number 
    int num = (int) random(total);
    // Look at the pixels for that number
    float[] pixies = (float[]) pixelData.get(num);  
    // Train the network according to those pixels
    nn.train(pixies, (float)num/total);
    // Increase the training iteration count
    trainingCount++;
  }
}

// Display info about the training
void showTraining() {
  pushMatrix();
  translate(20,150);
  textFont(f);
  textAlign(LEFT);

  // How much training is complete
  float percentage = (float) trainingCount / maxTrainingIterations;
  // Draw status bar
  float statusBar = percentage*width/2;
  stroke(0);
  noFill();
  rect(5,5,width/2,10);
  fill(0);
  rect(5,5,statusBar,10);
  text("Training. . .",5,30);

  // Now we'll show what the network is currently guessing for each input image
  fill(0);
  float mse = 0;
  for (int i = 0; i < pixelData.size(); i++) {
    float[] inp = (float[]) pixelData.get(i); 
    float known = (float) i/total;
    float result = nn.feedForward(inp);
    text("My guess for image # " + i + " is " + nf((float)result * total,1,2),5,100+i*20);
    mse += (result - known)*(result - known);
  }
  // How many interations
  text("Total iterations: " + trainingCount,5,60);
  // Root mean squarted error
  float rmse = sqrt(mse/pixelData.size());
  text("Root mean squared error: " + nf(rmse,1,4), 5,80);
  // If we've finished training
  if (percentage >= 1.0) {
    trainingComplete = true;
    text("I'm done training!  Press the space bar\nto draw a shape for me to guess.",5,-50);
  }
  popMatrix();
}

// Load all the images
void loadTrainingImages() {
  pixelData = new ArrayList();
  for (int i = 0; i < total; i++) {
    trainingImages[i] = loadImage("numbers/"+i+".tif");
    float[] binaryPixels = getPixels(trainingImages[i]);
    pixelData.add(binaryPixels);
  }
}

void userDraw() {
  // Keep a list of all mouse locations
  if (mousePressed && !submit.clicked && !guessing) {
    points.add(new Point(mouseX,mouseY));
  }

  // Draw those mouse locations as really wide continous line
  // This could really be improved
  noFill();
  stroke(0);
  strokeWeight(50);
  beginShape();
  for (int i = 0; i < points.size(); i++) {
    Point p = (Point) points.get(i);
    vertex(p.x,p.y);
  }
  endShape();
  // copy what was drawn onto the neural network's input image
  inputImage.copy(this.g,0, 0,width,height,0,0,w,h);
  inputImage.updatePixels();
}

// What to do with the user's input image
void guess() {
  // If it's not time to guess yet just give the user some instructions
  // and show submit button
  if (!guessing) {
    textFont(f);
    fill(50);
    textAlign(CENTER);
    text("Draw something and submit!",width/2,20);
    submit.rollover(mouseX,mouseY);
    submit.render();
    // Otherwise, show the result of the guess!
  } 
  else {
    noStroke();
    fill(255);
    rect(0,400,width,height);
    fill(0);
    textAlign(CENTER);
    textSize(14);
    text("My output is " + nf(guess,1,2) + " so I guess " + (int)(round(guess)) + 
      "\n Please type the correct # to help train me.",width/2,420);
  }
}

// Get an array of floats 0 to 1 from an input image
float[] getPixels(PImage img) {
  // This isn't terribly optimized, making floating point arrays for pixels that are 1 or 0
  // However, this would theoretically work with grayscale pixels mapped from 0 to 1
  float[] binaryPixels = new float[w*h];
  for (int pix = 0; pix < w*h; pix++) {
    float b = brightness(img.pixels[pix]);
    // Each pixel is back or what (1 or 0)
    if (b > 0) binaryPixels[pix] = 1;
    else binaryPixels[pix] = 0;
  }
  return binaryPixels;
}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import codeanticode.gsvideo.*;

int W = 320;
int H = 240;
int depth = H;

GSPipeline cam;
Recorder r;

byte[][][] mem = new byte[depth][H][W];

boolean rec = true;

void setup(){


	size(W,H,P2D);
	frameRate(25);
	if(rec)
		r = new Recorder("out","slitScan2.mp4");
		//pipe = new GSPipeline(this, "v4l2src ! ffmpegcolorspace ! video/x-raw-yuv, width="+width+", height="+height+", bpp=32, depth=24 ! queue ! videorate ! video/x-raw-yuv, framerate=25/1 ! xvidenc ! queue ! avimux ! queue ! filesink location=/desk/test.avi");
	
	String webcam = "v4l2src ! queue2 ! ffvideoscale ! "+"video/x-raw-rgb,width="+W+",height="+H;
	cam = new GSPipeline(this, webcam);

	

	for(int i = 0;i<mem.length;i++){
		for(int ii = 0;ii<mem[i].length;ii++){
			for(int iii = 0;iii<mem[i][ii].length;iii++){
				mem[i][ii][iii] = 0;
			}
		}
	}

	background(0);
}

int qua = 0;

void draw(){

	if (cam.available() == true){
		cam.read();
		cam.loadPixels();


		for(int y = 0;y<height;y++){
			for(int i = 0;i<width;i++){
				mem[0][y][i] = byte(brightness(cam.pixels[y*W+i]));

			}
		}


		for(int pos = depth-1;pos>0;pos--){

			for(int y = 0;y<height;y++){
				for(int i = 0;i<width;i++){
					mem[pos][y][i] = mem[pos-1][y][i]; //(byte)(brightness(cam.pixels[y*W+i]));
				}
			}
		}

		loadPixels();

		/*
		for(int Y = 0;Y<H;Y++){
			for(int X = 0;X<W;X++){
				pixels[Y*W+X] = pixels[Y*W+X];
			}
	}
		*/

		for(int Y = 0;Y<H;Y++){
			for(int X = 0;X<W;X++){
				pixels[Y*W+X] = color(int(mem[H-Y-1][Y][X]));
			}
		}

	
	
	if(rec)
		r.add();

	}
}

void keyPressed() {
	if (key == 'q') {
		// Finish the movie if space bar is pressed
		if(rec)
			r.finish();  
		// Quit running the sketch once the file is written
		exit();
	}
}


//import processing.opengl.*;
import javax.media.opengl.*;
import java.nio.*;
import com.sun.opengl.util.BufferUtil;


float phase;
float div;
String shaderSource;
GL gl;
int programObject;
int vsPhase;
boolean vertexShaderEnabled;
boolean vertexShaderSupported;

void setup()
{
 size(800,600,OPENGL);
 gl=((PGraphicsGL)g).gl;
 div=50;
 
 String extensions = gl.glGetString(GL.GL_EXTENSIONS);
 vertexShaderSupported = extensions.indexOf("GL_ARB_vertex_shader") != -1;
 vertexShaderEnabled = true;

 if (vertexShaderSupported)
 {
   String[] lines=loadStrings("wave.glsl");
   shaderSource=join(lines,"\n");

   if (shaderSource != null)
   {
     int shader = gl.glCreateShaderObjectARB(GL.GL_VERTEX_SHADER_ARB);

     gl.glShaderSourceARB(shader, 1, new String[]{shaderSource},(int[]) null, 0);
     gl.glCompileShaderARB(shader);
     checkLogInfo(gl, shader);

     programObject = gl.glCreateProgramObjectARB();

     gl.glAttachObjectARB(programObject, shader);
     gl.glLinkProgramARB(programObject);
     gl.glValidateProgramARB(programObject);
     checkLogInfo(gl, programObject);

     vsPhase=gl.glGetAttribLocationARB(programObject, "phase");
   }
 }
}

void checkLogInfo(GL gl, int obj)
{
 IntBuffer iVal = BufferUtil.newIntBuffer(1);
 gl.glGetObjectParameterivARB(obj, GL.GL_OBJECT_INFO_LOG_LENGTH_ARB, iVal);

 int length = iVal.get();
 if (length <= 1)
 {
   return;
 }
 ByteBuffer infoLog = BufferUtil.newByteBuffer(length);
 iVal.flip();
 gl.glGetInfoLogARB(obj, length, iVal, infoLog);
 byte[] infoBytes = new byte[length];
 infoLog.get(infoBytes);
 println("GLSL Validation >> " + new String(infoBytes));
}

void draw()
{
 phase-=0.01;
 if(phase<0)
   phase+=TWO_PI;
 if(phase>TWO_PI)
   phase-=TWO_PI;
 
 stroke(0,255,30);
//  fill(255,0,0);
 noFill();
 background(0);
 camera(1800,600,600,600,0,600,0,-1,0);
 if (vertexShaderEnabled)
 {
   gl.glUseProgramObjectARB(programObject);
   gl.glVertexAttrib1fARB(vsPhase, phase);
 }
  beginShape(QUADS);
  for (int x = 0; x < div; x++)
  {
    for (int z = 0; z < div; z++)
    {
       
      vertex((x)*20.0, 0, (z)*20.0);        // Draw Vertex
      vertex(((x+1))*20.0,0 , (z)*20.0);        // Draw Vertex
      vertex((x+1)*20.0, 0, ((z+1))*20.0);        // Draw Vertex
      vertex((x)*20.0, 0, ((z+1))*20.0);        // Draw Vertex
    }
  }
  endShape();
  if (vertexShaderEnabled) {
    gl.glUseProgramObjectARB(0);
  }
 if(frameCount%30==29)
   println(framerate);
} 
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import codeanticode.gsvideo.*;

int W = 1620;
int H = 480;

int cw = 320 ;
int ch = H;
int depth = 255;

GSPipeline cam;
Recorder r;

//byte[][][] mem = new byte[depth][H][W];
byte tresh = 30;

boolean rec = false;
boolean printout = false;

void setup(){
	size(W,H,P2D);
	frameRate(30);
	if(rec)
		r = new Recorder("out","slitScan2.mp4");
	//pipe = new GSPipeline(this, "v4l2src ! ffmpegcolorspace ! video/x-raw-yuv, width="+width+", height="+height+", bpp=32, depth=24 ! queue ! videorate ! video/x-raw-yuv, framerate=25/1 ! xvidenc ! queue ! avimux ! queue ! filesink location=/desk/test.avi");

	String webcam = "v4l2src ! queue2 ! ffvideoscale ! "+"video/x-raw-rgb,width="+cw+",height="+ch+", bpp=32, depth=24";
	cam = new GSPipeline(this, webcam);

	/*

		for(int i = 0;i<mem.length;i++){
			for(int ii = 0;ii<mem[i].length;ii++){
				for(int iii = 0;iii<mem[i][ii].length;iii++){
					mem[i][ii][iii] = 0;
				}
			}
		}
		
		*/
	background(0);
}


class Saver implements Runnable {
	// This method is called when the thread runs
	public void run() {
		save("strip"+nf(no,4)+".png");
	}
}

int qua = 0;
int cntr = 0;
int no =0;

void draw(){
	if (cam.available() == true){
		cam.read();
		cam.loadPixels();

		cntr++;

		if(cntr%W==0){

			// Create the object with the run() method
			Saver saver = new Saver();

			// Create the thread supplying it with the runnable object
			Thread thread = new Thread(saver);

			// Start the thread
			thread.start();
			no++;
		}


		/*
		for(int y = 0;y<height;y++){
			for(int i = 0;i<width;i++){
				mem[0][y][i] = byte(brightness(cam.pixels[y*W+i]));
			}
	}
		*/
		loadPixels();

		int x = cw/2;
		for(int y = 0;y<height;y++){
			pixels[y*width+width-2] = color(brightness(cam.pixels[y*cw+x]));
			if(printout){
				if(y%2==0){
					if(brightness(cam.pixels[y*cw+x])>15)
						print(1);
					else
						print(0);
				}
			}
		}
		if(printout)
		println("");


		/*
		for(int pos = depth-1;pos>0;pos--){

			for(int y = 0;y<height;y++){
				for(int i = 0;i<width;i++){
					//if(abs(mem[pos][y][i]-mem[pos-1][y][i])>tresh)
					mem[pos][y][i] = mem[pos-1][y][i]; //(byte)(brightness(cam.pixels[y*W+i]));
				}
			}
	}

		*/



		/*
		for(int Y = 0;Y<H;Y++){
			for(int X = 0;X<W;X++){
				pixels[Y*W+X] = pixels[Y*W+X];
			}
	}
		*/


		for(int X = 0;X<width-1;X++){
			for(int Y = 0;Y<H;Y++){
				pixels[Y*W+X] = pixels[Y*W+(X+1)];//color(int(mem[0][Y][X]));
			}
		}

		if(rec)
			r.add();

	}
}

void keyPressed() {
	if (key == 'q') {
		// Finish the movie if space bar is pressed
		if(rec)
			r.finish();
		// Quit running the sketch once the file is written
		exit();
	}
}
import processing.opengl.*;
import javax.media.opengl.GL;
import ddf.minim.*;
import sms.*;


PGraphicsOpenGL pgl; //need to use this to stop screen tearing
GL gl;

Minim minim;
AudioInput in;


float sc = 1.5;
float rovno = 0;
int[] vals;

void setup()
{
  size(screen.width, screen.height, OPENGL);
// size(720,576, OPENGL);

  frameRate(50);

  pgl = (PGraphicsOpenGL) g; //processing graphics object
  gl = pgl.beginGL(); //begin opengl
  gl.setSwapInterval(1); //set vertical sync on
  pgl.endGL(); //end opengl

  minim = new Minim(this);
  minim.debugOn();

  noCursor();

  // get a line in from Minim, default bit depth is 16
  in = minim.getLineIn(Minim.STEREO, (int)(width*sc));
  smooth();
}

int start = 0;

void draw()
{
 // background(0);
  // stroke(255);


  float trsh = 0.012;
  noStroke();

  //start = 0;

  for(int i = 0; i < 200 ; i++)
  {


    if(in.right.get(i)<0.01) {
      if(in.right.get(i+1)<0.01) {

        for(int q = 2;q<100;q++) {
          if(abs(in.right.get(i+q)-0)>trsh) {
            start = i;
            break;
          }
        }
        break;
      }
    }
  }
  
   vals = Unimotion.getSMSArray();
 // println(vals[0] + " " + vals[1] + " " + vals[2]);

 pushMatrix();
 translate(width/2,height/2);
 
 rotate(radians(map(vals[0]+rovno,255,-255,90,-90)));
// println(vals[0]);
 
  // draw the waveforms
  for(int i = 0; i < in.bufferSize() - 1; i++)
  {
    stroke(map(in.right.get(int(i)),0.01,.04,0,255),map(in.right.get(int(i)),0.01,.04,0,255),0);
    pushMatrix();
    translate(-start,0);
    line(i-width/1.5,-height,i-width/2,height+height/2);
    //line(0,i,width,i);
    popMatrix();
    //stroke(2550*in.right.get(int(i)),120);
    //line(0,map(i,0,in.bufferSize(),start,height), width,map(i,0,in.bufferSize(),start,height));
    //in.left.get(i)*50, i+1, 50 + in.left.get(i+1)*50);
    //  stroke(255,in.left.get(i)*5000);
    // line(0,map(i,0,width,0,height),width,map(i,0,width,0,height));
    //line(i, 150 + in.right.get(i)*50, i+1, 150 + in.right.get(i+1)*50);
  }
  
  popMatrix();
}


void stop()
{
  // always close Minim audio classes when you are done with them
  in.close();
  minim.stop();

  super.stop();
}

void keyPressed(){
 rovno = -vals[0]; 
}


PImage bck;
Person hero;
PGraphics canvas;

int cx,cy;

void setup() {
  size(400,300,P2D);
  bck = loadImage("street.gif");


  hero = new Person(0,1);

   // p[i] = new Person(i,band);
  

  canvas = createGraphics(width*2,height*2+35*2,P2D);

  noSmooth();

  noFill();
  stroke(0);

  cy = cx = 0;
}


void draw() {
  background(bck);
  image(canvas,0,0,width,height);
  
  
  hero.draw();
/*



  Arrays.sort(p);
  for(int i = 0 ;i<p.length;i++) {

    p[i].draw();
  }*/
}

void world() {
  translate(width/2,height/2,-height/2);
  rotateX(radians(60));
  rotateZ(radians(-45));
  ortho(-width/2, width/2, -height/2, height/2, -width/2, width/2);
  // translate(-190,-160,0);
}

void keyPressed() {
  if(keyCode==LEFT) {
    hero.x-=2;
  }
  else if(keyCode==RIGHT) {
    hero.x+=2;
  }
  else if(keyCode==UP) {
    hero.y-=2;
  }
  else if(keyCode==DOWN) {
    hero.y+=2;
  }
  //println(cx + " und "+cy);
}


class Splat {
  float x[],y[];
  color c[];
  float bx,by;
  int num = 10;
  float time = 1;

  Splat(int _num,float _x,float _y) {
    num = _num;
    x = new float[num];
    y =  new float[num];
    c = new color[num];


    bx = _x;
    by = _y; 
    time = 1;

    for(int i = 0;i<x.length;i++) {
      x[i] = bx+random(-2,2);
      y[i] = by+random(-2,2);
      c[i] = color(random(255),10,10);
    }
  }

  void animate() {
    if(time<10) {
      for(int i = 0;i<x.length;i++) {
        x[i] += (x[i]-bx)/(time);
        y[i] += (y[i]-by)/(time);

        // strokeWeight(4);

        stroke(c[i],map(time,1,300,255,0));
        point(x[i],y[i]);
      }

      time*=1.43;
    }
  }
}

class Person implements Comparable {
  Splat s;
  String nameSkin = "genericB.gif";
  PGraphics face;
  PImage skin[] = new PImage[8];
  float x,y,ty,tx,px,py,lx,ly;
  int id;
  boolean msk[];
  int blood = 0;
  boolean bleeding = false;
  boolean dead = false;
  float deadAng = 0;
  int band = 0;
  // int target = (int)random(p.length);
  boolean once = true;
  color shirtC,hairC,trousC;
  
  float heading;
  int faze = 0;

  Person(int _id) {
    for(int i = 0;i<skin.length;i++) {
      skin[i] = loadTrans(nameSkin,i);
    }
    id =_id;
    x = width/2;
    y = height/2;
  }

  Person(int _x,int _y,String _skin,int _id) {
    id = _id;

    for(int i = 0;i<skin.length;i++) {
      skin[i] = loadTrans(nameSkin,i);
    }
    face = createGraphics(skin[faze].width,skin[faze].height,P2D);



    tx = x = _x;//(int)random(-60,60);
    ty = y = _y;//(int)random(-60,60);
  }

  Person(int _id,int _band) {
    id = _id;
    band = _band;

    String nameSkin;

    if(band==-1) {
      nameSkin = "generic.gif";
    }
    else {
      nameSkin = "genericB.gif";
      
        hairC = color(#270D06);
      shirtC = color(#DEDFE0);
    
      trousC = color(#444F95);
    }



    s = new Splat(10,x,y);
    s.time = 100;

    for(int i = 0;i<skin.length;i++) {
      skin[i] = loadTrans(nameSkin,i);
    }

    face = createGraphics(skin[faze].width,skin[faze].height,P2D);

    lx = tx = x = width/2;//band*200-(int)random(-60,60);
    ly = ty = y = height/2;//band*200-(int)random(-60,60);
  }

  void draw() {
    faze = getFaze();
    
    
    
  x+=(mouseX-x)/30.0;
  y+=(mouseY-y)/30.0;
    
    
    
    if(dist(lx,ly,x,y)>=1){
      heading = degrees(atan2((y-ly),(x-lx))+QUARTER_PI);
      lx = x;
      ly = y;
    }
    
    image(skin[faze],(int)x,(int)y);
  }




  int compareTo(Object o)
  {
    Person other = (Person)o;
    if(other.py>py)  
      return -1;
    if(other.py==py)
      return 0;
    else
      return 1;
  }

  PImage loadTrans(String name,int q)
  {
    PImage src = loadImage(name);
    msk = new boolean[src.width*src.height];
    PImage out = createImage(src.width/8,src.height,ARGB);
    PImage coll = createImage(src.width,src.height,ARGB);


    /*
    if (id ==0) {
     
     for(int i = 0;i<src.pixels.length;i++)
     println(src.pixels[i]);
     }*/

    src.loadPixels();


    for(int i = 0;i<src.pixels.length;i++) {
      if((src.pixels[i]!=-65321)) {


        if(src.pixels[i]==-16776961) {
          coll.pixels[i] = shirtC;
        }


        else if(src.pixels[i]==-65536) {
          coll.pixels[i] = hairC;
        }

        else if(src.pixels[i]==-16711936) {
          coll.pixels[i] = trousC;
        }


        else {
          coll.pixels[i] = src.pixels[i];
        }


        msk[i] = true;
      }
      else {
        msk[i] = false;
      }
    }

    out.loadPixels();
    coll.loadPixels();

    for(int Y = 0;Y<src.height;Y++) {
      for(int X = 0;X<out.width;X++) {
        
        int idx = Y*out.width+X;
        int idx2 = Y*(src.width)+(X+(q*12));
        if(msk[idx2])
        out.pixels[idx] = coll.pixels[idx2];
      }
    }



    return out;
  }
  
  
  int getFaze(){
    int wh = 0;
    
    
    float a = heading;
    
    if(a>=0 && a<45){
     wh = 2; 
    }else if(a>=45 && a<90){
     wh = 3; 
    }else if(a>=90 && a<135){
     wh = 4; 
    }else if(a>=135 && a<180){
     wh = 5; 
    }else if(a>=180 && a<225){
     wh = 6; 
    }else if(a>=225 && a<270){
     wh = 7; 
    }else if(a>=270 && a<315){
     wh = 0; 
    }else if(a>=315 && a<360){
     wh = 1; 
    }
    
   // wh = constrain((int)(heading%45),0,skin.length-1);
    
    if(heading<0)
    heading=359;
    else
    
    heading = heading%360;
    
    
   // println(heading+" : "+wh);
    
   return wh; 
  }
}

import processing.opengl.*;
import javax.media.opengl.GL;
import ddf.minim.*;

PGraphicsOpenGL pgl; //need to use this to stop screen tearing
GL gl;

Minim minim;
AudioInput in;

float sc = 1.5;

void setup()
{
  size(640,300, OPENGL);

  frameRate(50);

  pgl = (PGraphicsOpenGL) g; //processing graphics object
  gl = pgl.beginGL(); //begin opengl
  gl.setSwapInterval(1); //set vertical sync on
  pgl.endGL(); //end opengl

  minim = new Minim(this);
  minim.debugOn();

  noCursor();

  // get a line in from Minim, default bit depth is 16
  in = minim.getLineIn(Minim.STEREO, (int)(width*sc));
  noSmooth();
}

int start = 0;

void draw()
{
 // background(0);
  // stroke(255);


  float trsh = 0.012;
  noStroke();

  //start = 0;

  for(int i = 0; i < 200 ; i++)
  {

    if(in.right.get(i)<0.01) {
      if(in.right.get(i+1)<0.01) {

        for(int q = 2;q<100;q++) {
          if(abs(in.right.get(i+q)-0)>trsh) {
            start = i;
            break;
          }
        }
        break;
      }
    }
  }

  // draw the waveforms
  for(int i = 0; i < in.bufferSize() - 1; i++)
  {
    stroke(map(in.right.get(int(i)),0.01,.04,0,255),200);
    pushMatrix();
    translate(-start,0);
    line(i,0,i,height);
    popMatrix();
    //stroke(2550*in.right.get(int(i)),120);
    //line(0,map(i,0,in.bufferSize(),start,height), width,map(i,0,in.bufferSize(),start,height));
    //in.left.get(i)*50, i+1, 50 + in.left.get(i+1)*50);
    //  stroke(255,in.left.get(i)*5000);
    // line(0,map(i,0,width,0,height),width,map(i,0,width,0,height));
    //line(i, 150 + in.right.get(i)*50, i+1, 150 + in.right.get(i+1)*50);
  }
}


void stop()
{
  // always close Minim audio classes when you are done with them
  in.close();
  minim.stop();

  super.stop();
}

/*void keyPressed(){
 save("screen.png"); 
  
}*/
//import processing.opengl.*;
//import javax.media.opengl.GL;
import ddf.minim.*;


//PGraphicsOpenGL pgl; //need to use this to stop screen tearing
//GL gl;

Minim minim;
AudioInput in;

float sc = 1.5;

void setup()
{
  size(640,300, P2D);

  frameRate(50);

 // pgl = (PGraphicsOpenGL) g; //processing graphics object
 // gl = pgl.beginGL(); //begin opengl
 // gl.setSwapInterval(1); //set vertical sync on
 // pgl.endGL(); //end opengl

  minim = new Minim(this);
  minim.debugOn();

  noCursor();

  // get a line in from Minim, default bit depth is 16
  in = minim.getLineIn(Minim.STEREO, (int)(width*sc));
  noSmooth();
}

int start = 0;

void draw()
{
 // background(0);
  // stroke(255);


  float trsh = 0.012;
  noStroke();

  //start = 0;

  for(int i = 0; i < 200 ; i++)
  {


    if(in.right.get(i)<0.01) {
      if(in.right.get(i+1)<0.01) {

        for(int q = 2;q<100;q++) {
          if(abs(in.right.get(i+q)-0)>trsh) {
            start = i;
            break;
          }
        }
        break;
      }
    }
  }

  // draw the waveforms
  for(int i = 0; i < in.bufferSize() - 1; i++)
  {
    stroke(map(in.right.get(int(i)),0.01,.04,0,255),200);
    pushMatrix();
    translate(-start,0);
    line(i,0,i,height);
    popMatrix();
    //stroke(2550*in.right.get(int(i)),120);
    //line(0,map(i,0,in.bufferSize(),start,height), width,map(i,0,in.bufferSize(),start,height));
    //in.left.get(i)*50, i+1, 50 + in.left.get(i+1)*50);
    //  stroke(255,in.left.get(i)*5000);
    // line(0,map(i,0,width,0,height),width,map(i,0,width,0,height));
    //line(i, 150 + in.right.get(i)*50, i+1, 150 + in.right.get(i+1)*50);
  }
}


void stop()
{
  // always close Minim audio classes when you are done with them
  in.close();
  minim.stop();

  super.stop();
}

/*void keyPressed(){
 save("screen.png"); 
  
}*/
/* this code may damage your brain use at your own risk only
*  kof 2010
*/

float len = 1;
float uhel = 30;
int cnt = 0;

boolean neg = false;
float fw = 1;

void setup() {
  int W = (int)(PI*100);
  size(W*2,W,P2D);
 // len = W*2;
  noFill();
  smooth();
  background(255);
  
}

/*
void keyPressed(){
  save("screen.png"); 
}*/

void draw() {
  
  
  uhel -= (noise(frameCount/(PI*100.0))/(PI*500.0))*fw;
  
  if(abs(uhel%90)<0.1 && cnt>30){
    neg=!neg;
    cnt=0;
  }
  
  
    if(uhel>90||uhel<-90){
      fw*=-1;
    }
  
  cnt++;
  
  
  if(neg){
  stroke(255,map(abs(uhel),0,90,120,20));
  
    background(0);
  }else{
  stroke(0,map(abs(uhel),0,90,120,20));
  
    background(255);
  }
  pushMatrix();
  
  
  translate(width/2,height/2);
  
  len = 1;
  for(int i = 0;i<10000;i++){

    //background(255);
  
  translate(len,0);
  rotate(radians(uhel));  
  
  line(0,0,len,0);
  
  
  
  len += len/1000.0;
  
  }
  
  popMatrix();
  
  
}

/* this code may damage your brain use at your own risk only
*  kof 2010
*/

float len = 1;
float uhel = 30;
int cnt = 0;

boolean neg = false;
float fw = 1;

void setup() {
  int W = (int)(PI*100);
  size(W*2,W,P2D);
 // len = W*2;
  noFill();
  smooth();
  background(255);
  
}


void draw() {
  
  
  uhel -= (noise(frameCount/(PI*100.0))/(PI*500.0))*fw;
  
  if(abs(uhel%90)<0.1 && cnt>30){
    neg=!neg;
    cnt=0;
  }
  
  
    if(uhel>90||uhel<-90){
      fw*=-1;
    }
  
  cnt++;
  
  
  if(neg){
  stroke(255,map(abs(uhel),0,90,120,20));
  
    background(0);
  }else{
  stroke(0,map(abs(uhel),0,90,120,20));
  
    background(255);
  }
  pushMatrix();
  
  
  translate(width/2,height/2);
  
  len = 1;
  for(int i = 0;i<10000;i++){

    //background(255);
  
  translate(len,0);
  rotate(radians(uhel));  
  
  line(0,0,len,0);
  
  
  
  len += len/1000.0;
  
  }
  
  popMatrix();
  
  
}


// this signal uses the mouseX and mouseY position to build a signal
class Data implements AudioSignal
{
  /*void generate(float[] samp)
  {
    float range = 1;
    float peaks = 1;
    float inter = float(samp.length) / peaks;
    
    for ( int i = 0; i < samp.length; i += inter )
    {
      for ( int j = 0; j < inter && (i+j) < samp.length; j++ )
      {
        samp[i + j] = map(j, 0, inter, -range, range);
      }
    }
    
  }*/
 
 
   void generate(int id,float[] samp){
     for ( int i = 0; i < samp.length; i += 1 )
    {
     samp[i] = samp[i]+random(-.1,.1);
    } 
   }

  // this is a stricly mono signal
  void generate(float[] left, float[] right)
  {
    generate(left);
    generate(right);
  }
}


class AV {

  Data d;
  PImage img;
  String fileName;
  float buff[];
  float x,y,w,h;
  int id;
  float a;

  AV(String _fileName,int _id) {
    fileName = _fileName;
    id = _id;



    x = width/2;//random(width);
    y = height/2;
    //random(height);
    
    regenerate();

    d = new Data();
    d.generate(id,buff);
    


    // adds the signal to the output
    out.addSignal(d);

  }
  
  void regenerate(){
    w = random(1,10)*22;
    h = random(1,10)*22;

    
    img = createImage((int)w,(int)h,ARGB);
    PGraphics tmp = regen();
    tmp.loadPixels();    
    img.loadPixels();
    
    for(int i =0;i<tmp.pixels.length;i++)
      img.pixels[i] = tmp.pixels[i];
    

    buff = new float[img.pixels.length];
    for(int i = 0;i<img.pixels.length;i++) {
      buff[i] = map(brightness(img.pixels[i]),0,255,-1,1);
    }


  }

  PGraphics regen() {
    PGraphics tmp = createGraphics((int)w,(int)h,JAVA2D);
    
    tmp.beginDraw();
    tmp.smooth();
    tmp.background(random(120,255));
    
    tmp.stroke(0);
    tmp.fill(0);
    tmp.strokeWeight(5);
    for(int i = 0;i<5;i++){
     tmp.line(random(w),random(h),random(w),random(h)); 
    }
    tmp.endDraw();
    
    
    
    return tmp;
  }

  AudioSignal getBuff() {
    return d;
  }

  void draw() {
    image(img,(int)(x-w/2),(int)(y-h/2));
  }
}

import krister.Ess.*;

AudioStream myStream;
float[] streamBuffer;

ArrayList av = new ArrayList(0);

void setup()
{
  size(512, 200, P2D);

  Ess.start(this);
 myStream=new AudioStream();
 streamBuffer=new float[myStream.size];
 fillAudioBuffer();
 myStream.start();

  AV tmp = new AV("0.png",0);
  av.add(tmp);
}

void fillAudioBuffer(){

 int freq = 200;
 float a = 0.0; 
 float inc = TWO_PI*(freq/myStream.sampleRate); 
 for(int i=0; i<streamBuffer.length; i++) { 
   streamBuffer[i] = (sin(a)*.33);  
   a = a + inc;    
 } 
}

void audioStreamWrite(AudioStream theStream) {
 System.arraycopy(streamBuffer,0,myStream.buffer,0,streamBuffer.length);
}

public void stop() {
 Ess.stop();
 super.stop();
}


void draw() {
  background(0);

  for(int i = 0;i<av.size();i++) {
    AV tmp  = (AV)av.get(i);
    tmp.draw();
  }
}


void mousePressed(){
 
  for(int i = 0;i<av.size();i++) {
    AV tmp  = (AV)av.get(i);
    tmp.regenerate();
  } 
}




/////////////////////////////////////////////////
//                                             //
//    The Secret Life of Turing Patterns       //
//                                             //
/////////////////////////////////////////////////
 
// Inspired by the work of Jonathan McCabe
// (c) Martin Schneider 2010
 
 
int scl = 4, dirs = 9, rdrop = 8, lim = 128;
int res = 2, palette = 0, pattern = 2, soft = 2;
int dx, dy, w, h, s;
boolean border, invert;
float[] pat;
PImage img;
  
void setup() {
  size(200, 200,P2D);
  colorMode(HSB);
  reset();
}
 
void reset() {
  w = width/res;
  h = height/res;
  s = w*h;
  img = createImage(w, h, RGB);
  pat = new float[s];
  // random init
  for(int i=0; i<s; i++) 
    pat[i] = floor(random(256));
}
 
void draw() {
   
  // constrain the mouse position
  if(border) {
    mouseX = constrain(mouseX,0,width-1);
    mouseY = constrain(mouseY,0,height-1);
  }
     
  // add a circular drop of chemical
  if(mousePressed) {
      if(mouseButton != CENTER) {
      int x0 = mod((mouseX-dx)/res, w);
      int y0 = mod((mouseY-dy)/res, h);
      int r = rdrop * scl / res ;
      for(int y=y0-r; y<y0+r;y++)
        for(int x=x0-r; x<x0+r;x++) {
          int xwrap = mod(x,w), ywrap = mod(y,w);
          if(border && (x!=xwrap || y!=ywrap)) continue;         
          if(dist(x,y,x0,y0) < r)
            pat[xwrap+w*ywrap] = mouseButton == LEFT ? 255 : 0;
        }
    }
  }
 
  // calculate a single pattern step
  pattern();
   
  // draw chemicals to the canvas
  img.loadPixels();
  for(int x=0; x<w; x++)
    for(int y=0; y<h; y++) {
      int c = (x+dx/res)%w + ((y+dy/res)%h)*w;
      int i = x+y*w;
      float val = invert ? 255-pat[i]: pat[i];
      switch(palette) {
        case 0: img.pixels[c] = color(0, 0, val); break;
        case 1: img.pixels[c] = color(64+val/4, val, val); break;
        case 2: img.pixels[c] = color(val,val,255-val); break;
        case 3: img.pixels[c] = color(val,128,255); break;
      }
    }
  img.updatePixels();
   
  // display the canvas
  if(soft>0) smooth(); else noSmooth();
  image(img, 0, 0, res*w, res*h);
  if(soft==2) filter(BLUR);
   
  //println(frameRate);
     
}
 
void keyPressed() {
  switch(key) {
    case 'r': reset(); break;
    case 'p': pattern = (pattern + 1) % 3; break;
    case 'c': palette = (palette + 1) % 4; break;
    case 'b': border = !border; dx=0; dy=0; break;
    case 'i': invert = !invert; break;
    case 's': soft = (soft + 1) % 3; break;
    case '+': lim = min(lim+8, 255); break;
    case '-': lim = max(lim-8, 0); break;
    case CODED:
      switch(keyCode) {
        case LEFT: scl = max(scl-1, 2); break;
        case RIGHT:scl = min(scl+1, 6); break;
        case UP:   res = min(res+1, 5); reset(); break;
        case DOWN: res = max(res-1, 1); reset(); break;
      }
      break;
  }
}
 
// moving the canvas
void mouseDragged() {
  if(mouseButton == CENTER && !border) {
    dx = mod(dx + mouseX - pmouseX, width);
    dy = mod(dy + mouseY - pmouseY, height);
  }
}
 
// floor modulo
final int mod(int a, int n) {
  return a>=0 ? a%n : (n-1)-(-a-1)%n;
}

 
void pattern() {
   
  // random angular offset
  float R = random(TWO_PI);
 
  // copy chemicals
  float[] pnew = new float[s];
  for(int i=0; i<s; i++) pnew[i] = pat[i];
 
  // create matrices
  float[][] pmedian = new float[s][scl];
  float[][] prange = new float[s][scl];
  float[][] pvar = new float[s][scl];
 
  // iterate over increasing distances
  for(int i=0; i<scl; i++) {
    float d = (2<<i) ;
     
    // update median matrix
    for(int j=0; j<dirs; j++) {
      float dir = j*TWO_PI/dirs + R;
      int dx = int (d * cos(dir));
      int dy = int (d * sin(dir));
      for(int l=0; l<s; l++) { 
        // coordinates of the connected cell
        int x1 = l%w + dx, y1 = l/w + dy;
        // skip if the cell is beyond the border or wrap around
        if(x1<0) if(border) continue; else x1 = w-1-(-x1-1)% w; else if(x1>=w) if(border) continue; else x1 = x1%w;
        if(y1<0) if(border) continue; else y1 = h-1-(-y1-1)% h; else if(y1>=h) if(border) continue; else y1 = y1%h;
        // update median
        pmedian[l][i] += pat[x1+y1*w] / dirs;
         
      }
    }
     
    // update range and variance matrix
    for(int j=0; j<dirs; j++) {
      float dir = j*TWO_PI/dirs + R;
      int dx = int (d * cos(dir));
      int dy = int (d * sin(dir));
      for(int l=0; l<s; l++) { 
        // coordinates of the connected cell
        int x1 = l%w + dx, y1 = l/w + dy;
        // skip if the cell is beyond the border or wrap around
        if(x1<0) if(border) continue; else x1 = w-1-(-x1-1)% w; else if(x1>=w) if(border) continue; else x1 = x1%w;
        if(y1<0) if(border) continue; else y1 = h-1-(-y1-1)% h; else if(y1>=h) if(border) continue; else y1 = y1%h;
        // update variance
        pvar[l][i] += abs( pat[x1+y1*w]  - pmedian[l][i] ) / dirs;
        // update range
         
        prange[l][i] += pat[x1+y1*w] > (lim + i*10) ? +1 : -1;   
    
      }
    }    
  }
 
  for(int l=0; l<s; l++) { 
     
    // find min and max variation
    int imin=0, imax=scl;
    float vmin = MAX_FLOAT;
    float vmax = -MAX_FLOAT;
    for(int i=0; i<scl; i+=1) {
      if (pvar[l][i] <= vmin) { vmin = pvar[l][i]; imin = i; }
      if (pvar[l][i] >= vmax) { vmax = pvar[l][i]; imax = i; }
    }
     
    // turing pattern variants
    switch(pattern) {
      case 0: for(int i=0; i<=imin; i++)    pnew[l] += prange[l][i]; break;
      case 1: for(int i=imin; i<=imax; i++) pnew[l] += prange[l][i]; break;
      case 2: for(int i=imin; i<=imax; i++) pnew[l] += prange[l][i] + pvar[l][i]/2; break;
    }
       
  }
 
  // rescale values
  float vmin = MAX_FLOAT;
  float vmax = -MAX_FLOAT;
  for(int i=0; i<s; i++)  {
    vmin = min(vmin, pnew[i]);
    vmax = max(vmax, pnew[i]);
  }      
  float dv = vmax - vmin;
  for(int i=0; i<s; i++)
    pat[i] = (pnew[i] - vmin) * 255 / dv;
    
}

import fullscreen.*;

FullScreen fs;

boolean change = false;

void setup(){
  
  size(640,480,P2D);
  
  frameRate(40);
  
  fs = new FullScreen(this);
  
  fs.enter();
  
}

void keyPressed(){
 fs.enter(); 
}

void draw(){
  
  if(frameCount%(mouseX+1)==0){
   change = !change; 
  }
  
  
  if(change){
   background(0); 
  }else{
   background(255); 
  }
  
}

import processing.opengl.*;
import javax.media.opengl.GL;
import ddf.minim.*;

PGraphicsOpenGL pgl; //need to use this to stop screen tearing
GL gl;



Minim minim;
AudioInput in;

int fr = 80;
float trsh = 0.01;

void setup()
{
  size(640,300, OPENGL);

  frameRate(fr);

  pgl = (PGraphicsOpenGL) g; //processing graphics object
  gl = pgl.beginGL(); //begin opengl
  gl.setSwapInterval(1); //set vertical sync on
  pgl.endGL(); //end opengl

  minim = new Minim(this);
  minim.debugOn();


  // get a line in from Minim, default bit depth is 16
  in = minim.getLineIn(Minim.STEREO, fr);
  noSmooth();
}



void draw() {

  trsh+=(in.right.get(frameCount%fr)/1.01-trsh)/1000.0;

  if(in.right.get(frameCount%fr)>trsh) {
    background(255);

    /*
    for(int i = 0; i < in.bufferSize() - 1; i++)
     {
     stroke(0,map(in.right.get(int(i)),0.01,.04,0,255));
     pushMatrix();
     //  translate(-start,0);
     line(i,0,i,height);
     popMatrix();
     }*/
  }
  else {
    background(0) ;
    /*
  for(int i = 0; i < in.bufferSize() - 1; i++)
     {
     stroke(255,map(in.right.get(int(i)),0.01,.04,0,255));
     pushMatrix();
     // translate(-start,0);
     line(i,0,i,height);
     popMatrix();
     }*/
  }
}



void stop()
{
  // always close Minim audio classes when you are done with them
  in.close();
  minim.stop();

  super.stop();
}



static int[] DX = {
  -1,0,1,-1,1,-1,0,1,-2,-1,0,1,2,-2,2,-2,2,-2,2,-2,1,0,1,2
};
static int[] DY = {
  -1,-1,-1,0,0,1,1,1,-2,-2,-2,-2,-2,-1,-1,0,0,1,1,2,2,2,2,2
};

int idx = 0;
int mod = 0;

int w = 320,h = 240;

PImage store;

int s;
float pat[];


int dirs = 40;

boolean border;

void setup() {

  size(w,h,P2D);
  s = w*h;
  rectMode(CENTER);
  noStroke();
  fill(0);
  
  noSmooth();
  
  store = createImage(w, h, RGB);

  colorMode(HSB);

  pat = new float[s];

  for(int i=0; i<s; i++) 
    pat[i] = map(i,0,s,0,255);
}

void draw() {


  loadPixels();


  process();

store.loadPixels();

  for(int i = 0;i<s;i++) {
    store.pixels[i] = lerpColor(color(pat[i]%255),store.pixels[i],0.1);
  }





  tint(255,20);
  image(store,0,0);
 
}


void process() {
  idx += frameCount%93;
  idx = idx%DX.length;// floor(random(DX.length));

  float newPat[] = new float[s];
  mod = (int)(((noise(frameCount)))*DX.length);

  for(int j=0; j<s; j++) {


    if(((j+frameCount)%abs(DX[idx]*20+1) | (j*frameCount)%abs(DY[idx]*20+1)) < 12) {
      newPat[j] = pat[j]; 
      continue;
    }

    int x1 = j%w + DX[mod%DX.length], y1 = j/w + DY[mod%DX.length];

    if(x1<0) x1 = w-1-(-x1-1)% w;
    else if(x1>=w) x1 = x1%w;    

    if(y1<0) y1 = h-1-(-y1-1)% h;
    else if(y1>=h) y1 = y1%h;

    int newIdx = y1*width+x1;

    newPat[j] += (pat[newIdx]);
  }

  for(int j=0; j<s; j++) {
    pat[j] = newPat[j];
  }
}


color bck = color(0);

PImage src[];

String name = "test2.gif";
int faze = 10;
int interval = 2;

int sc = 4;
int cntr = 0;

void setup() {

  reload();

  size(src[0].width*sc,src[0].height*sc);

  frameRate(30);

  noSmooth();
}

void draw() {

  if(frameCount%interval==0) {

    background(bck);
    image(src[cntr++],0,0,width,height);
    //cntr++;
    if(cntr>=faze){cntr=0;reload();}
  }
}

void reload() {
  src = new PImage[faze];
  for(int i  = 0;i<faze;i++) {
    src[i] = loadTrans(name,i);
  }
}

void keyPressed() {
  reload();
}


PImage loadTrans(String name,int q)
{
  PImage src = loadImage(name);
  boolean msk[] = new boolean[src.width*src.height];
  PImage out = createImage(src.width/faze,src.height,ARGB);
  PImage coll = createImage(src.width,src.height,ARGB);


  /*
    if (id ==0) {
   
   for(int i = 0;i<src.pixels.length;i++)
   println(src.pixels[i]);
   }*/

  src.loadPixels();

  int al = src.pixels[0];
  for(int i = 0;i<src.pixels.length;i++) {
    if((src.pixels[i]!=al)) {

      /*
        if(src.pixels[i]==-16776961) {
       coll.pixels[i] = shirtC;
       }
       
       
       else if(src.pixels[i]==-65536) {
       coll.pixels[i] = hairC;
       }
       
       else if(src.pixels[i]==-16711936) {
       coll.pixels[i] = trousC;
       }
       
       
       else {
       */

      coll.pixels[i] = src.pixels[i];

      //}


      msk[i] = true;
    }
    else {
      msk[i] = false;
    }
  }

  out.loadPixels();
  coll.loadPixels();

  for(int Y = 0;Y<src.height;Y++) {
    for(int X = 0;X<out.width;X++) {

      int idx = Y*out.width+X;
      int idx2 = Y*(src.width)+(X+(q*(src.width/faze)));
      if(msk[idx2])
        out.pixels[idx] = coll.pixels[idx2];
    }
  }



  return out;
}

void setup() {
  size(320,320,P2D);
  loadPixels();
  colorMode(HSB,MAX_INT);

  for(int i = 0;i<pixels.length;i++)
    pixels[i] = color(120);//color(random(255));
}

int z;

void draw() {
 // tint(255,0,255,20);  
  image(g,1,0);
 
  
  
  loadPixels();
  for(int y = 0;y<height;y++) {
    for(int x = 0;x<width;x++) {
      int idx = y*width+x;
      
       if(((x^y)|(x&y))%((frameCount%((frameCount%90)+1)+1))==(frameCount%2)){
        pixels[idx] = ((x&y)+1)-MAX_INT;// (pixels[idx] >> 2 & 0xff0000) / 100.0; 
       }
       
    }
  }
  updatePixels();
}

import processing.opengl.*;
import javax.media.opengl.GL;
import ddf.minim.*;

import processing.video.*;

PGraphicsOpenGL pgl; //need to use this to stop screen tearing
GL gl;


Minim minim;
AudioInput in;
MovieMaker mm;

float sc = 1.5;

void setup()
{
  size(720, 480, P2D);

  frameRate(30);


  
   mm = new MovieMaker(this, width, height, "drawing.mov");

 // pgl = (PGraphicsOpenGL) g; //processing graphics object
 // gl = pgl.beginGL(); //begin opengl
 // gl.setSwapInterval(1); //set vertical sync on
 // pgl.endGL(); //end opengl

  minim = new Minim(this);
  minim.debugOn();

  noCursor();

  // get a line in from Minim, default bit depth is 16
  in = minim.getLineIn(Minim.STEREO, (int)(width*sc));
  noSmooth();
  
}

int start = 0;

void draw()
{
 // background(0);
  // stroke(255);


  float trsh = 0.012;
  noStroke();

  //start = 0;

  for(int i = 0; i < 200 ; i++)
  {


    if(in.right.get(i)<0.01) {
      if(in.right.get(i+1)<0.01) {

        for(int q = 2;q<100;q++) {
          if(abs(in.right.get(i+q)-0)>trsh) {
            start = i;
            break;
          }
        }
        break;
      }
    }
  }

  // draw the waveforms
  for(int i = 0; i < in.bufferSize() - 1; i++)
  {
    stroke(map(in.right.get(int(i)),0.01,.04,0,255),200);
    pushMatrix();
    translate(-start,0);
    line(i,0,i,height);
    popMatrix();
    //stroke(2550*in.right.get(int(i)),120);
    //line(0,map(i,0,in.bufferSize(),start,height), width,map(i,0,in.bufferSize(),start,height));
    //in.left.get(i)*50, i+1, 50 + in.left.get(i+1)*50);
    //  stroke(255,in.left.get(i)*5000);
    // line(0,map(i,0,width,0,height),width,map(i,0,width,0,height));
    //line(i, 150 + in.right.get(i)*50, i+1, 150 + in.right.get(i+1)*50);
  }

  mm.addFrame();
}


void stop()
{
  // always close Minim audio classes when you are done with them
  in.close();
  minim.stop();
 mm.finish();
  super.stop();
}

/**
FFTOfflineRendererMinim.pde
June 2009 Dave Bollinger (for Processing 1.0+)
to demonstrate non-real-time fft analysis and rendering
*/

import processing.opengl.*;
import ddf.minim.*;
import ddf.minim.analysis.*;
import codeanticode.gsvideo.*;

GSMovieMaker mm;

String audioFilename = "LightAHungry.mp3";

static final int RENDER_MODE_REALTIME = 0; // use this when dev'ing your viz
static final int RENDER_MODE_OFFLINE = 1; // use this for final render
int renderMode = RENDER_MODE_OFFLINE; // change this as desired

static final int OUTPUT_TYPE_NONE = 0; // use this when dev'ing
static final int OUTPUT_TYPE_IMAGE = 1; // use this..
static final int OUTPUT_TYPE_MOVIE = 2; // ..or this, for final render
int outputType = OUTPUT_TYPE_IMAGE; // change this as desired

Minim minim;
AudioSample audio;
FFT fft;

int frameNumber = 0;
float [] audioBuffer; // will hold the entire audio file
float [] fftBuffer; // will hold just a portion for fft analysis
// sync math:
float sampleRate; // we'll query the audio file for this later
float framesPerSecond = 30.0;
float samplesPerFrame; // ==sampleRate/framesPerSecond
int fftBufferSize; // total size of the fft buffer
int fftMixSize; // occupied size of the fft buffer
float exactFramesToRender; // exactly how many (fractional) video frames == audio duration
int wholeFramesToRender; // no such thing as a fractional video frame, so round up

void setup() {
  size(320,240,P2D);
  if (renderMode==RENDER_MODE_REALTIME)
    frameRate(framesPerSecond); // won't be perfect sync, but we try our best anyway
  if (outputType==OUTPUT_TYPE_MOVIE)
  mm = new GSMovieMaker(this, width, height, "drawing.ogg", GSMovieMaker.THEORA, GSMovieMaker.MEDIUM, (int)framesPerSecond);
  minim = new Minim(this);
  audio = minim.loadSample(audioFilename);
  if (audio == null) {
    println("oops, failed to load audio file");
    exit();
    return;
  }
  audioBuffer = audio.getChannel(BufferedAudio.LEFT);
  if ((audioBuffer==null) || (audioBuffer.length==0)) {
    println("oops, failed to acquire sample data");
    // try using a mono and/or lower samplerate version
    // to reduce size of file used for analysis
    exit();
    return;
  }
  // calc values
  sampleRate = audio.sampleRate();
  samplesPerFrame = sampleRate / framesPerSecond;
  fftMixSize = (int)ceil(samplesPerFrame);
  if (renderMode == RENDER_MODE_REALTIME) {
    fftBufferSize = audio.bufferSize();
  } else { // offline
    fftBufferSize = nextPowerOfTwo(fftMixSize);
  }
  exactFramesToRender = audioBuffer.length * framesPerSecond / sampleRate;
  wholeFramesToRender = (int)ceil(exactFramesToRender);
  fft = new FFT(fftBufferSize, sampleRate);
  fftBuffer = new float[fftBufferSize];
  if (renderMode == RENDER_MODE_REALTIME) {
    audio.trigger();
  }
  // report values:
  println("INFO:");
  println("audio length = " + audioBuffer.length);
  println("sampleRate = " + sampleRate);
  println("audio duration = " + sec2hms(audioBuffer.length/sampleRate));
  println("framesPerSecond = " + framesPerSecond);
  println("samplesPerFrame = " + samplesPerFrame);
  println("fftMixSize = " + fftMixSize);
  println("fftBufferSize = " + fftBufferSize);
  println("exactFramesToRender = " + exactFramesToRender);
  println("wholeFramesToRender = " + wholeFramesToRender);
  println("video duration = " + sec2hms(wholeFramesToRender/framesPerSecond));
  println("-----");
}

String sec2hms(float seconds) {
  int hours = (int)floor(seconds / 3600.0);
  seconds -= (float)(hours * 3600);
  int minutes = (int)floor(seconds / 60.0);
  seconds -= (float)(minutes * 60);
  return hours + ":" + minutes + ":" + seconds;
}

int nextPowerOfTwo(int target) {
  int powtwo = 1;
  while (powtwo < target) powtwo<<=1;
  return powtwo;
}

public void stop() {
  println("stop()");
  if (mm != null) mm.finish();
  if (audio != null) audio.close();
  if (minim != null)  minim.stop();
  super.stop();
}

void draw() {
  if (finished()) {
    exit();
  } else {
    progress();
    analyze();
    render();
    store();
    advance();
  }
}

boolean finished() {
  // this only works properly when offline rendering
  // (unfortunately AudioSample doesn't indicate when done playing realtime)
  return (frameNumber >= wholeFramesToRender);
}

void progress() {
  if ((frameNumber%100) == 0) {
    println("Working on frame " + frameNumber + " of " + wholeFramesToRender);
  }
}

void analyze() {
  switch(renderMode) {
    case RENDER_MODE_REALTIME:
      analyzeRealtime();
      break;
    case RENDER_MODE_OFFLINE:
      analyzeOffline();
      break;
  }
}

void analyzeRealtime() {
  fft.forward(audio.mix);
}

void analyzeOffline() {
  int pos = (int)(frameNumber * sampleRate / framesPerSecond);
  if (pos >= audioBuffer.length) {
    // hmm, finished() should've caught this, why are we here?
    exit();
    return;
  }
  int mixlen = fftMixSize;
  // handle last partial frame
  if (pos+mixlen >= audioBuffer.length) {
    mixlen = audioBuffer.length - pos;
  }
  arraycopy(audioBuffer, pos, fftBuffer, 0, mixlen);
  // zero remainder (really only need to zero up to fftMixSize, 
  // since rest is never used, but we do the whole thing jic...)
  for (int i=mixlen; i<fftBufferSize; i++)
    fftBuffer[i] = 0f;
  fft.forward(fftBuffer);
}

void render() {
  background(0);
  stroke(255);
  for (int i = 0; i < fft.specSize(); i++) {
    line(i, height, i, height - fft.getBand(i) * 4);
  }
}

void store() {
  switch(outputType) {
    case OUTPUT_TYPE_NONE :
      break;
    case OUTPUT_TYPE_IMAGE :
      saveFrame("out/frame_"+nf(frameNumber,6)+".png"); // or jpg, tif, etc.
      break;
    case OUTPUT_TYPE_MOVIE :
       loadPixels();
        // Add window's pixels to movie
      mm.addFrame(pixels);
      break;
  }
}

void advance() {
  frameNumber++;
}


ArrayList a;
int alp = 500;
int maxCyc = 100000;

int W = 128;
int H = 96;

import codeanticode.gsvideo.*;

GSPipeline cam;
Recorder r;

boolean rec = false;

PGraphics mmsk;

void setup(){
	size(720,576,P2D);

	a = new ArrayList(0);


	frameRate(25);



	//println(PFont.list());
	textFont(loadFont("Fruc-8.vlw"),8);
	textMode(SCREEN);

	mmsk = createGraphics(W,H,P2D);
	mmsk.beginDraw();
	mmsk.background(0);
	mmsk.fill(255);
	mmsk.noStroke();
	mmsk.ellipse(mmsk.width/2.0,mmsk.height/2.0,H-40,H-40);
	mmsk.filter(BLUR,4);
	mmsk.endDraw();

	//videofilp method=2
	String webcam = "v4l2src ! queue2 ! ffvideoscale ! "+"video/x-raw-rgb,width="+W+",height="+H;
	cam = new GSPipeline(this, webcam);

	if(rec)
		r= new Recorder("okoNeuro","jineSvety.mp4");

	background(0);
}

void draw(){

	//background(0);
	fill(0,5);
	noStroke();
	rect(0,0,width,height);

	for(int i = 0;i < (int)random(maxCyc);i++)
		a.add(new Snake(random(4,333),width/2,height/2,a.size()));

	for(int i = 0;i<a.size();i++){
		Snake tmp = (Snake)a.get(i);
		//tmp.modX(screenX(tmp.x,tmp.y),200.0);
		//tmp.modY(screenY(tmp.x,tmp.y),200.0);
		tmp.move(12);
		//println(i);
	}


	/*pushMatrix();

	translate(width/2, height/2);
	rotate(frameCount*6*TWO_PI/360.0);
	translate(-width/2, -height/2);
	*/

	for(int i = 0;i<a.size();i++){
		Snake tmp = (Snake)a.get(i);
		//tmp.modX(screenX(tmp.x,tmp.y),200.0);
		//tmp.modY(screenY(tmp.x,tmp.y),200.0);
		//tmp.move(12);
		tmp.draw();
		//println(i);
	}


	fill(0);
	noStroke();
	rect(0,0,width,18);
	fill(255);
	text(a.size(),10,14);

	/*
	popMatrix();
	*/


	if (cam.available() == true){
		cam.read();
		cam.filter(GRAY);
		cam.mask(mmsk);
		image(cam, (int)(width/2.0-W/2.0)+random(-1,1) , (int)(height/2.0-H/2.0)+random(-1,1) );
		//neuroFeed();
	}

	if(rec)
		r.add();

}

void keyPressed(){
	if(key == 'q'){
		if(rec)
			r.finish();
		exit();

	}

}



public class Morpher{

	public float x,y,xx,yy,lx,ly;
	int id;
	int type;
	int bttl,ttl = 160;
	float zivo;

	public Morpher(int _type){
		this.type = _type;
		x = random(width);
		y = random(height);


	}

	public Morpher(float _zivo,float _x, float _y,int _type,int _id){
		type = _type;
		lx = xx = x = _x;
		ly = yy = y = _y;
		id = _id;
		bttl = ttl = (int)random(255);
		zivo = _zivo;
	}

	void draw(){
		stroke(lerpColor(#FFFFFF,#FFFFFF,norm(zivo,333,0)),map(ttl,0,bttl,0,128));
		noFill();

		line(lx,ly,x,y);



	}

	void move(float howMuch){

		lx = x;
		ly = y;

		xx+= random(-howMuch,howMuch);

		yy+= random(-howMuch,howMuch);

		xx = constrain(xx,3,width-3);
		yy = constrain(yy,3,height-3);



		x+=(xx-x)/zivo;
		y+=(yy-y)/zivo;


		//float smer = atan2(ly-y,lx-x);
		//x+=cos(smer*ttl*TWO_PI/360.0)*5;
		//y+=sin(smer*ttl*TWO_PI/360.0)*5;

		ttl--;

		if(ttl<=0)
			destroy();
	}

	void destroy(){

		int q = a.indexOf(this);
		a.remove(q);
	}

	void modX(float _x,float sp){
		xx+=(_x-x)/sp;

	}


	void modY(float _y,float sp){
		yy+=(_y-y)/sp;

	}




}


public class Snake extends Morpher{

	public Snake(){
		super(0);
	}

	public Snake(float _zivo, float _x,float _y,int _id){
		super(_zivo,_x,_y,0,_id);
	}

}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
import processing.serial.*;

XBee xbee;

XBee xbee2;

String one,two;


void setup(){

	size(200,120,P2D);
	frameRate(30);
	println(Serial.list());

	one = Serial.list()[1];
	//two = Serial.list()[0];
	
	xbee = new XBee(this,one);
	//xbee2 = new XBee(this,two);

}

void draw(){
	background(0);
	
	xbee.signal();

}

void keyReleased(){

	if(key==' '){


		xbee.setMode();

	}else if(key=='a'){

		xbee.getAddress();
	}else if(key=='d'){
		println("detekuji ostatni XBee.. ");
		xbee.detect();
	}else if(key=='s'){
		xbee.setup(3333,3334);	
	}else if(key=='r'){
		xbee.reset();	
	}

}


void serialEvent (Serial myPort) {
	String inString = myPort.readStringUntil('\r');

	if (inString != null) {

		println("XBee response: "+inString);
	}

}

class XBee{

	Serial port;
	boolean emit = true;

	XBee(PApplet _parent,String _portName){

		port = new Serial(_parent, _portName, 9600);
		port.clear();

		//myPort.bufferUntil('\n');
		
		
		

	}

	void setup(int loc, int dest){
		
		
		/*
		println("nastavuji XBee dest add na: "+dest);
		port.write("ATDL"+dest+"\r"); // Set XBee destination address
		println("nastavuji XBee local add na: "+loc);
		port.write("ATMY"+loc+"\r"); // Set XBee address
		println("ukladam zmeny.. ");
		port.write("ATWR\r"); // Save changes to XBee
		println("XBee zpet na data mode!");
		*/
		
		//listener settings		
		port.write("ATID1111,");
		port.write("MY1,");
		port.write("DH0,");
		port.write("DL2,");
		//port.write("IA1");
		port.write("CN\r");
		
		//port.write("ATCN\r"); // Return XBee to data mode
		
		//emit = true;

	}
	
	void reset(){
		println("resseting XBee ...");
		port.write("ATRE,");
		port.write("WR,");
		port.write("CN\r");
	
	}

	void setMode(){
		println("nastavuji XBee do program modu.. ");
		port.write("X");
		delay(1100);
		
		port.write("+++");
		delay(1100);
		
		

	}

	void getAddress(){
		println("ziskavam XBee adresu.. ");
		port.write("ATID\r");

	}

	void detect(){
		port.write("ATND\r");

	}
	
	void signal(){
		if(emit){
		
		delay(100);
	xbee.port.write("I\r");
	
	delay(100);
	xbee.port.write("O\r");
		
		}
	}

	//serial.write("ATDH"+destinationHigh+", DL"+destinationLow+"\r");
	//serial.write("ATMY"+myAddress+"\r");
	//serial.write("ATID"+panId+"\r");
	//serial.write("ATCN\r");


}
class GLSL
{
  int programObject;
  GL gl;
  boolean vertexShaderEnabled;
  boolean vertexShaderSupported; 
  int vs;
  int fs;
  
  GLSL()
  {
    gl=((PGraphicsOpenGL)g).gl;
    String extensions = gl.glGetString(GL.GL_EXTENSIONS);
    vertexShaderSupported = extensions.indexOf("GL_ARB_vertex_shader") != -1;
    vertexShaderEnabled = true;    
    programObject = gl.glCreateProgramObjectARB(); 
    vs=-1;
    fs=-1;
  }
  
  void loadVertexShader(String file)
  {
    String shaderSource=join(loadStrings(file),"\n");
    vs = gl.glCreateShaderObjectARB(GL.GL_VERTEX_SHADER_ARB);
    gl.glShaderSourceARB(vs, 1, new String[]{shaderSource},(int[]) null, 0);
    gl.glCompileShaderARB(vs);
    checkLogInfo(gl, vs);
    gl.glAttachObjectARB(programObject, vs); 
  }

  void loadFragmentShader(String file)
  {
    String shaderSource=join(loadStrings(file),"\n");
    fs = gl.glCreateShaderObjectARB(GL.GL_FRAGMENT_SHADER_ARB);
    gl.glShaderSourceARB(fs, 1, new String[]{shaderSource},(int[]) null, 0);
    gl.glCompileShaderARB(fs);
    checkLogInfo(gl, fs);
    gl.glAttachObjectARB(programObject, fs); 
  }

  int getAttribLocation(String name)
  {
    return(gl.glGetAttribLocationARB(programObject,name));
  }
  
  int getUniformLocation(String name)
  {
    return(gl.glGetUniformLocationARB(programObject,name));
  }
    
  void useShaders()
  {
    gl.glLinkProgramARB(programObject);
    gl.glValidateProgramARB(programObject);
    checkLogInfo(gl, programObject);
  }
  
  void startShader()
  {
    gl.glUseProgramObjectARB(programObject); 
  }
  
  void endShader()
  {
    gl.glUseProgramObjectARB(0); 
  }
  
  void checkLogInfo(GL gl, int obj)  
  {
    IntBuffer iVal = BufferUtil.newIntBuffer(1);
    gl.glGetObjectParameterivARB(obj, GL.GL_OBJECT_INFO_LOG_LENGTH_ARB, iVal);
 
    int length = iVal.get();
    if (length <= 1)  
    {
      return;
    }
    ByteBuffer infoLog = BufferUtil.newByteBuffer(length);
    iVal.flip();
    gl.glGetInfoLogARB(obj, length, iVal, infoLog);
    byte[] infoBytes = new byte[length];
    infoLog.get(infoBytes);
    println("GLSL Validation >> " + new String(infoBytes));
  } 
}
//import hardcorepawn.opengl.*;
import processing.opengl.*;
import java.nio.*;
import javax.media.opengl.*;
import javax.media.opengl.glu.*;
import com.sun.opengl.util.*;

PImage tex0,tex1,nulltex;
float a,b;

GL gl;
GLU glu;
GLSL glsl;
int[] tex;
int[] shaderimgloc;

int tangentLoc;
int binormalLoc;
int uir;
int cbs;

void setup()
{
//  size(800,600,"hardcorepawn.opengl.HCPGL");
  size(800,600,OPENGL);
  gl=((PGraphicsOpenGL)g).gl;
  glu=((PGraphicsOpenGL)g).glu;
  gl.glEnable(GL.GL_CULL_FACE);
  gl.glCullFace(GL.GL_FRONT);

  tex0=loadImage("img.png");
  tex1=loadImage("bump.png");
  nulltex=loadImage("img2.png");
  perspective(PI/3.0,4.0/3.0,1,1000);
  camera(0,0,-800,0,0,1,0,1,0);
  tex=new int[2];
  gl.glGenTextures(2,tex,0);
  gl.glBindTexture(GL.GL_TEXTURE_2D,tex[0]);
  gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, 4,tex0.width, tex0.height,
                          0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE,
                          IntBuffer.wrap(tex0.pixels));
  gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);	// Linear Filtering
  gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);	// Linear Filtering
  gl.glBindTexture(GL.GL_TEXTURE_2D,tex[1]);
  gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, 4,tex1.width, tex1.height,
                          0, GL.GL_BGRA, GL.GL_UNSIGNED_BYTE,
                          IntBuffer.wrap(tex1.pixels));
  gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);	// Linear Filtering
  gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);	// Linear Filtering
  glsl=new GLSL();
//  glsl.loadVertexShader("textureSimple.vert");
//  glsl.loadFragmentShader("textureSimple.frag");
  glsl.loadVertexShader("shiny.vert");
  glsl.loadFragmentShader("shiny.frag");
  glsl.useShaders();
  shaderimgloc=new int[2];
//  shaderimgloc[0]=glsl.getUniformLocation("Tex");
  shaderimgloc[0]=glsl.getUniformLocation("Base");
  shaderimgloc[1]=glsl.getUniformLocation("NormalHeight");
  tangentLoc=glsl.getAttribLocation("tangent");
  binormalLoc=glsl.getAttribLocation("binormal");
  uir=glsl.getUniformLocation("u_invRad");
  cbs=glsl.getUniformLocation("cBumpSize");
  a=0;
  b=0;
//  printCamera();
  textureMode(NORMALIZED);
  gl.glEnable(GL.GL_LIGHTING);
}

void draw()
{
  float mx=(mouseX-width/2.0)/(width/2.0);
  float my=(mouseY-height/2.0)/(height/2.0);
  a+=0.003;
  b+=0.00063;
//  pointLight(255,255,255,0,0,-400);
//  camera(0,0,-400,0,0,0,0,1,0);
//  glu.gluLookAt(0,0,400,0,0,0,0,1,0);
//  glu.
  background(50,0,0);
  glsl.startShader();
  fill(255,255,255);
//  specular(0,0,0);
  ambient(250,250,250);
//  shininess(2.0);
  gl.glActiveTexture(GL.GL_TEXTURE0+2);
  gl.glBindTexture(GL.GL_TEXTURE_2D, tex[0]);
  gl.glActiveTexture(GL.GL_TEXTURE0+1);
  gl.glBindTexture(GL.GL_TEXTURE_2D, tex[1]);
  
  gl.glUniform1i(shaderimgloc[0],2);
  gl.glUniform1i(shaderimgloc[1],1);
  gl.glVertexAttrib3f(tangentLoc,-1,0,0);
  gl.glVertexAttrib3f(binormalLoc,0,-1,0);
//  pointLight(220,220,250,40,0,-400);
  camera(400*sin(mx),0,-400*cos(mx),0,0,0,0,1,0);
  perspective(PI/3.0,4.0/3.0,1,1000);

  pointLight(255,255,255,0,0,-100);
  ((PGraphicsOpenGL)g).beginGL();
  gl.glPushMatrix();
  rotateY(a);
//  gl.glRotatef(360*a,0,1,0);
  
  gl.glBegin(GL.GL_QUADS);
  gl.glNormal3f(0,0,-1);
  gl.glVertexAttrib3f(tangentLoc,1,0,0);
  gl.glVertexAttrib3f(binormalLoc,0,-1,0);
  gl.glTexCoord2f(0,0);
  gl.glVertex3f(-100,100,-100);
  gl.glTexCoord2f(0,1);
  gl.glVertex3f(-100,-100,-100);
  gl.glTexCoord2f(1,1);
  gl.glVertex3f(100,-100,-100);
  gl.glTexCoord2f(1,0);
  gl.glVertex3f(100,100,-100);
//  gl.glEnd();
//  gl.glBegin(GL.GL_QUADS);
  gl.glNormal3f(1,0,0);
  gl.glVertexAttrib3f(tangentLoc,0,0,1);
  gl.glVertexAttrib3f(binormalLoc,0,-1,0);
  gl.glTexCoord2f(1,1);
  gl.glVertex3f(100,-100,100);
  gl.glTexCoord2f(1,0);
  gl.glVertex3f(100,100,100);
  gl.glTexCoord2f(0,0);
  gl.glVertex3f(100,100,-100);
  gl.glTexCoord2f(0,1);
  gl.glVertex3f(100,-100,-100);

  gl.glNormal3f(0,0,1);
  gl.glVertexAttrib3f(tangentLoc,-1,0,0);
  gl.glVertexAttrib3f(binormalLoc,0,-1,0);
  gl.glTexCoord2f(1,1);
  gl.glVertex3f(-100,-100,100);
  gl.glTexCoord2f(1,0);
  gl.glVertex3f(-100,100,100);
  gl.glTexCoord2f(0,0);
  gl.glVertex3f(100,100,100);
  gl.glTexCoord2f(0,1);
  gl.glVertex3f(100,-100,100);
  
  gl.glNormal3f(-1,0,0);
  gl.glVertexAttrib3f(tangentLoc,0,0,-1);
  gl.glVertexAttrib3f(binormalLoc,0,-1,0);
  gl.glTexCoord2f(0,0);
  gl.glVertex3f(-100,100,100);
  gl.glTexCoord2f(0,1);
  gl.glVertex3f(-100,-100,100);
  gl.glTexCoord2f(1,1);
  gl.glVertex3f(-100,-100,-100);
  gl.glTexCoord2f(1,0);
  gl.glVertex3f(-100,100,-100);

  gl.glNormal3f(0,1,0);
  gl.glVertexAttrib3f(tangentLoc,1,0,0);
  gl.glVertexAttrib3f(binormalLoc,0,0,-1);
  gl.glTexCoord2f(0,0);
  gl.glVertex3f(100,100,100);
  gl.glTexCoord2f(0,1);
  gl.glVertex3f(-100,100,100);
  gl.glTexCoord2f(1,1);
  gl.glVertex3f(-100,100,-100);
  gl.glTexCoord2f(1,0);
  gl.glVertex3f(100,100,-100);
  
  gl.glNormal3f(0,-1,0);
  gl.glVertexAttrib3f(tangentLoc,1,0,0);
  gl.glVertexAttrib3f(binormalLoc,0,0,-1);
  gl.glTexCoord2f(0,0);
  gl.glVertex3f(-100,-100,100);
  gl.glTexCoord2f(0,1);
  gl.glVertex3f(100,-100,100);
  gl.glTexCoord2f(1,1);
  gl.glVertex3f(100,-100,-100);
  gl.glTexCoord2f(1,0);
  gl.glVertex3f(-100,-100,-100);
    
  gl.glEnd();
  gl.glPopMatrix();
/*  gl.glBegin(GL.GL_QUADSS);
  gl.glVertexAttrib3f(tangentLoc,1,0,0);
  gl.glVertexAttrib3f(binormalLoc,0,1,0);
  gl.glNormal3f(0,0,-1);
  gl.glTexCoord2f(1,0);
  gl.glVertex3f(100,100,-100);
  gl.glTexCoord2f(0,0);
  gl.glVertex3f(-100,100,-100);
  gl.glTexCoord2f(0,1);
  gl.glVertex3f(-100,-100,-100);
  gl.glTexCoord2f(1,1);
  gl.glVertex3f(100,-100,-100);
  gl.glEnd();*/
  
  
  
  glsl.endShader();
    ((PGraphicsOpenGL)g).endGL();
}

import processing.opengl.*;


void setup(){
	size(320,240,OPENGL);
	background(0);

}

void draw(){
	background(255);
	println(frameCount);
}



PImage wormImg, wormTexture;
int[] reg = new int[15];

void setup() {
  size(640, 360, P2D);
  noSmooth();

  // Reference image used to transpose texture 
  wormImg = loadImage("wormhole.png");
  wormImg.resize(width, height);
  wormImg.loadPixels();

  // Texture image array
  wormTexture = loadImage("texture.gif");
  wormTexture.loadPixels();
}

// Moves the bottom row of pixels to the top and shifting remaining pixels 1 over
void shiftup() {
  for (int k = 0; k < 15; k++) {
    reg[k] = wormTexture.pixels[k];
  }

  for (int k = 15; k < 225; k++) {
    wormTexture.pixels[k-15] = wormTexture.pixels[k];
  }
  for (int k = 0; k < 15; k++) {
    wormTexture.pixels[k+210] = reg[k];
  }
}

// Moves left column of pixels to the right and shifting remaining pixels 1 over
void shiftright() {
  for(int k = 0; k < 15; k++) {
    reg[k] = wormTexture.pixels[15*k+14];
    for(int i = 14;i > 0; i--) {
        wormTexture.pixels[15*k+i] = wormTexture.pixels[15*k+(i-1)];
    }
    wormTexture.pixels[15*k] = reg[k];
  }
}

void draw() {
  // Load pixel data array
  loadPixels();

  // Loop through all pixels
  for (int i = 0; i < pixels.length; i++){
    // Map texture to wormhole in a bit shift blue 
    pixels[i] = wormTexture.pixels[constrain(wormImg.pixels[i] & 0xFF, 0, 224)];
  }  

  updatePixels();

  shiftright();
  shiftup();
}

import processing.opengl.*;

int a = 0;
ArrayList fonts;


void setup(){
  size(320,240,OPENGL);


  fonts = new ArrayList(0); //(PFont.list().length);
  
  Filler fontFiller = new Filler(this);
  fontFiller.start();

  textMode(SCREEN); 
  
  noStroke();   


  background(0);

}


void draw(){

  PFont q = (PFont)fonts.get((int)random(fonts.size()));
  textFont(q);

  fill(255,50);
  text("kof",random(width),a);

  //stroke(0);
  //line(0,a,width,a);

  a+=8;
  if(a>height){
    a = 0;//a % height;
    fill(0,5);
    rect(0,0,width,height);
  }

}

void keyPressed(){
  if(key == ' ')
    save("kofFsude.png");


}

public class Filler implements Runnable{

  public Filler(PApplet parent){
    parent.registerDispose(this);

    }

    public void start(){
      thread = new Thread(this);
      thread.start();    
    }

  public void run(){
    int n = 0;

    for(int q = 0 ;q<PFont.list().length; q++){
      println(PFont.list()[q]);
      fonts.add((PFont) createFont(PFont.list()[q],24));
      n++;
    }  
    println(n+" fonts created");
  }

  public void stop(){
    thread = null; 

  }

  public void dispose(){
    stop(); 

  }



}

class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("gnome-terminal -x png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
Recorder r;
boolean rec = true;

int al = 250;
float val = 0;

int s = 200;
int v = 120;

void setup(){
	size(320,240,P2D);
	frameRate(25);
	noStroke();

	if(rec)
		r = new Recorder("out","strobo.mp4");
	
	colorMode(HSB);
}

void draw(){
	
	if(frameCount % 128 == 0){
		v+=33;//random(255);
		v=v%255;		
	}
	
	if(frameCount % ((int)(sin(frameCount/30.0)+2)*3) == 0){
		
	val = random(255);
		fill(255-v,s,255-val,al);
		rect(0,0,width,height);
		fill(v,s,val);
	}else{

		fill(v,s,val,al);
		rect(0,0,width,height);
		fill(255-v,s,255-val);
	}

	rect(40+random(-100,100)*0.02,40+random(-100,100)*0.02,width-80,height-80);

	filter(BLUR,1);
	
	for(int y = 0 ; y < height ; y++){
		for(int x = 0 ; x < width ; x++){
			stroke(0,random(40));
			point(x,y);

		}
	}
	noStroke();

	

	if(rec)
		r.add();

}

void keyPressed(){
	if(key =='q'){
		if(rec)
			r.finish();
		exit();
	}
}

ArrayList a;
int alp = 500;
int maxCyc = 100000;

void setup(){
	size(400,300,P2D);

	a = new ArrayList(0);

	
	frameRate(60);
	
	//println(PFont.list());
	textFont(loadFont("Fruc-8.vlw"),8);
	textMode(SCREEN);

        background(0);
}

void draw(){

	//background(0);
	fill(0,5);
	noStroke();
	rect(0,0,width,height);
	
	for(int i = 0;i < (int)random(maxCyc);i++)
		a.add(new Snake(random(4,333),width/2,height/2,a.size()));
	
	for(int i = 0;i<a.size();i++){
		Snake tmp = (Snake)a.get(i);
		//tmp.modX(screenX(tmp.x,tmp.y),200.0);
		//tmp.modY(screenY(tmp.x,tmp.y),200.0);
		tmp.move(12);
		//println(i);
	}


	/*pushMatrix();

	translate(width/2, height/2);
	rotate(frameCount*6*TWO_PI/360.0);
	translate(-width/2, -height/2);
	*/

	for(int i = 0;i<a.size();i++){
		Snake tmp = (Snake)a.get(i);
		//tmp.modX(screenX(tmp.x,tmp.y),200.0);
		//tmp.modY(screenY(tmp.x,tmp.y),200.0);
		//tmp.move(12);
		tmp.draw();
		//println(i);
	}
	
	
	fill(0);
	noStroke();
	rect(0,0,width,18);
	fill(255);
	text(a.size(),10,14);

	/*
	popMatrix();
*/
	

}



public class Morpher{

	public float x,y,xx,yy,lx,ly;
	int id;
	int type;
	int bttl,ttl = 160;
	float zivo;

	public Morpher(int _type){
		this.type = _type;
		x = random(width);
		y = random(height);
		

	}

	public Morpher(float _zivo,float _x, float _y,int _type,int _id){
		type = _type;
		lx = xx = x = _x;
		ly = yy = y = _y;
		id = _id;
		bttl = ttl = (int)random(255);
		zivo = _zivo;
	}

	void draw(){
		stroke(lerpColor(#FFFFFF,#FFCC00,norm(zivo,333,0)),map(ttl,0,bttl,0,55));
		noFill();
		
		line(lx,ly,x,y);
		
		

	}

	void move(float howMuch){
		
		lx = x;
		ly = y;
		
		xx+= random(-howMuch,howMuch);

		yy+= random(-howMuch,howMuch);

		xx = constrain(xx,3,width-3);
		yy = constrain(yy,3,height-3);
		
		
		
		x+=(xx-x)/zivo;
		y+=(yy-y)/zivo;
		
		border();
		
		
		//float smer = atan2(ly-y,lx-x);
		//x+=cos(smer*ttl*TWO_PI/360.0)*5;
		//y+=sin(smer*ttl*TWO_PI/360.0)*5;
		
		ttl--;

		if(ttl<=0)
			destroy();
	}

	void destroy(){

		int q = a.indexOf(this);
		a.remove(q);
	}
	
	void modX(float _x,float sp){
		xx+=(_x-x)/sp;
	
	}
	
	
	void modY(float _y,float sp){
		yy+=(_y-y)/sp;
	
	}
	
	void border(){
		x = constrain(x,0,width);
		y = constrain(y,12,height);
	
	
	}




}


public class Snake extends Morpher{

	public Snake(){
		super(0);
	}

	public Snake(float _zivo, float _x,float _y,int _id){
		super(_zivo,_x,_y,0,_id);
	}

}

ArrayList a;


void setup(){
	size(400,300,P2D);

	a = new ArrayList(0);

	
	frameRate(60);

	
	//println(PFont.list());
	textFont(loadFont("Fruc-8.vlw"),8);
	textMode(SCREEN);

        background(0);

}

void draw(){

	//background(0);
	fill(0,5);
	noStroke();
	rect(0,0,width,height);
	
	for(int i = 0;i < (int)random(10);i++)
		a.add(new Snake(random(40,333),width/2,height/2,a.size()));
	
	for(int i = 0;i<a.size();i++){
		Snake tmp = (Snake)a.get(i);
		//tmp.modX(screenX(tmp.x,tmp.y),200.0);
		//tmp.modY(screenY(tmp.x,tmp.y),200.0);
		tmp.move(12);
		//println(i);
	}


	/*pushMatrix();

	translate(width/2, height/2);
	rotate(frameCount*6*TWO_PI/360.0);
	translate(-width/2, -height/2);
	*/

	for(int i = 0;i<a.size();i++){
		Snake tmp = (Snake)a.get(i);
		//tmp.modX(screenX(tmp.x,tmp.y),200.0);
		//tmp.modY(screenY(tmp.x,tmp.y),200.0);
		//tmp.move(12);
		tmp.draw();
		//println(i);
	}
	
	
	fill(0);
	noStroke();
	rect(0,0,width,18);
	fill(255);
	text(a.size(),10,14);

	/*
	popMatrix();
*/
	

}



public class Morpher{

	public float x,y,xx,yy,lx,ly;
	int id;
	int type;
	int bttl,ttl = 160;
	float zivo;

	public Morpher(int _type){
		this.type = _type;
		x = random(width);
		y = random(height);
		

	}

	public Morpher(float _zivo,float _x, float _y,int _type,int _id){
		type = _type;
		lx = xx = x = _x;
		ly = yy = y = _y;
		id = _id;
		bttl = ttl = (int)random(255);
		zivo = _zivo;
	}

	void draw(){
		stroke(lerpColor(#FFFFFF,#FFCC00,norm(zivo,333,0)),map(ttl,0,bttl,0,128));
		noFill();
		
		line(lx,ly,x,y);
		
		

	}

	void move(float howMuch){
		
		lx = x;
		ly = y;
		
		xx+= random(-howMuch,howMuch);

		yy+= random(-howMuch,howMuch);

		xx = constrain(xx,3,width-3);
		yy = constrain(yy,3,height-3);
		
		
		
		x+=(xx-x)/zivo;
		y+=(yy-y)/zivo;
		
		
		//float smer = atan2(ly-y,lx-x);
		//x+=cos(smer*ttl*TWO_PI/360.0)*5;
		//y+=sin(smer*ttl*TWO_PI/360.0)*5;
		
		ttl--;

		if(ttl<=0)
			destroy();
	}

	void destroy(){

		int q = a.indexOf(this);
		a.remove(q);
	}
	
	void modX(float _x,float sp){
		xx+=(_x-x)/sp;
	
	}
	
	
	void modY(float _y,float sp){
		yy+=(_y-y)/sp;
	
	}




}


public class Snake extends Morpher{

	public Snake(){
		super(0);
	}

	public Snake(float _zivo, float _x,float _y,int _id){
		super(_zivo,_x,_y,0,_id);
	}

}
import guru.ttslib.*;

TTS tts;

void setup() {
  tts = new TTS();
}

void draw() {
	background(0);
}

void mousePressed() {
  tts.speak("Hi! I am a speaking Processing sketch");
}
int velikost = 300;
int sc = 1;

BX bx;

int shiftx = 2;
int shifty = 0;

boolean matix[][];

color c1 = color(255,128,0);
color c2 = color(0);

void setup(){
  matix = new boolean[velikost*2][velikost];
  size(600,300,P2D);

  frameRate(60);

  for(int y = 0;y<matix[0].length;y++) {

    for(int x = 0;x<matix.length;x++) {
      matix[x][y] = (random(20)>10) ? true : false;
    }
  }

  noStroke();
  noSmooth();

  bx = new BX(width/2,height);
}

void draw(){

  c1 = color(255);
  shiftx = (int)((noise(-frameCount/3003.12)-0.5)*width);
  shifty = (int)((noise(frameCount/3000.0)-0.5)*height);
  for(int y = 0;y<matix[0].length;y++) {
    for(int x = 0;x<matix.length;x++) {
      fill((matix[x][y])?c1:c2,80);
      rect(x*sc,y*sc,sc,sc);
    }

    /* for(int x = 0;x<matix.length/2;x++) {
     fill((matix[x][y])?c1:c2,80);
     rect(x*sc,y*sc,sc,sc);
     }
     
     for(int x = matix.length/2;x<matix.length;x++) {
     fill((matix[matix.length-x][y])?c1:c2,80);
     rect(x*sc,y*sc,sc,sc);
     }*/
  }

  pushStyle();
  noFill();
  strokeWeight(5);
  stroke(0);
  rect(0,0,width,height);
  popStyle();  

  /*  bx.update();
   bx.pix.loadPixels();
   
   for(int y = 0;y<bx.h;y++) {
   for(int x = 0;x<bx.w;x++) {
   if(brightness(bx.pix.pixels[y*bx.w+x])>20){
   matix[x+width/2][y] = false;
   }
   }
   
   }*/

  randomize((int)(noise(frameCount/230.2)*20));
}



void randomize(int kolik) {
  for(int y = 0;y<matix[0].length;y++) {
    for(int x = 0;x<matix.length;x++) {


      if((random(1000))<kolik) {
        matix[x][y] = !matix[x][y];
      }
      else if(matix[(x+width-shiftx)%(width/sc-1)][y]) {
        matix[x][y] = matix[(x+width+2)%(width/sc-1)][y];
      }
      else {
        matix[x][y] = matix[x][(y+height-shifty)%(height/sc-1)];
      }
    }
  }
}
/*

 void keyPressed(){
 save("screen.png"); 
 }*/
class BX {
  PGraphics pix;
  int w,h;

  BX(int _w,int _h) {
    w=_w;
    h=_h;
    pix = createGraphics(w,h,P3D);
  }

  void update() {
    pix.beginDraw();
    pix.ortho(-w/2, w/2, -h/2, h/2, -w/2, h/2);
    pix.background(0);
    pix.stroke(255);
    pix.strokeWeight(22);
    pix.noFill();
    pix.pushMatrix();
    pix.translate(pix.width/2,pix.height/2);
    pix.rotateY(radians(frameCount*2));
    pix.rotateX(radians(frameCount*2.3231));
    pix.box(pix.width);
    pix.popMatrix();
    pix.endDraw();
  }

  void draw() {
    image(pix,0,0);
  }
}
int velikost = 300;
int sc = 1;



int shiftx = 2;
int shifty = 0;

boolean matix[][];

color c1 = color(255,128,0);
color c2 = color(0);

void setup() {
  matix = new boolean[velikost*2][velikost];
  size(600,300,P2D);

  frameRate(60);

  for(int y = 0;y<matix[0].length;y++) {

    for(int x = 0;x<matix[0].length;x++) {
      matix[x][y] = (random(20)>10) ? true : false;
    }
  }
  noStroke();
  noSmooth();
}

void draw() {
   c1 = color(255);
  shiftx = (int)((noise(-frameCount/33.12)-0.5)*width);
  shifty = (int)((noise(frameCount/300.0)-0.5)*height);
  for(int y = 0;y<matix[0].length;y++) {

    for(int x = 0;x<matix.length/2;x++) {
      fill((matix[x][y])?c1:c2,80);
      rect(x*sc,y*sc,sc,sc);
    }

    for(int x = matix.length/2;x<matix.length;x++) {
      fill((matix[matix.length-x][y])?c1:c2,80);
      rect(x*sc,y*sc,sc,sc);
    }
  }

  pushStyle();
  noFill();
  strokeWeight(5);
  stroke(0);
  rect(0,0,width,height);
  popStyle();  

  randomize((int)(noise(frameCount/230.2)*20));
}


int cnt = 0;
void randomize(int kolik) {
  for(int y = 0;y<matix[0].length;y++) {
    for(int x = 0;x<matix[0].length;x++) {


      if((random(1000))<kolik) {
        matix[x][y] = !matix[x][y];
      }
      else if(matix[(x+width-shiftx)%(width/sc-1)][y]) {
        matix[x][y] = matix[(x+width+2)%(width/sc-1)][y];
      }
      else {
        matix[x][y] = matix[x][(y+height-shifty)%(height/sc-1)];
      }
    }
  }
}

import prohtml.*;

HtmlList htmlList;

String dotaz = "http://www.vimeo.com/kof/videos";

HtmlImageFinder finder;


String response;
ArrayList links;
ArrayList imgAdds;
ArrayList imgs;

PFont font;
ArrayList data;
int cr = (int)('\n');

void setup(){
  size(500, 680, P2D);
  background(50);
  fill(200);
  //enter your url here
 
 
   getNew(dotaz);
  
  /*
  finder = new HtmlImageFinder(dotaz);
  int numOfImg = finder.getNumbOfImages();
  
  
  imgAdds = new ArrayList(0);
  imgs = new ArrayList(0);
  for(int i = 0;i<numOfImg;i++){
    imgAdds.add((String)finder.getImageLink(i));
    println((String)finder.getImageLink(i));
    imgs.add(loadImage((String)imgAdds.get(i)));
  }
  
  
  
  
  */
  
  //for(int i = 0;i<links.size();i++){
  //  println(((Url)(links.get(i))).toString());
  //}
  
  font= createFont("Verdana",11);
  textFont(font);
  textMode(SCREEN);
  data = new ArrayList(0);
}

void getNew(String _dotaz){
  htmlList = new HtmlList(dotaz); 
  links = new ArrayList(htmlList.getLinks());
}


int last = 12;
boolean gotit = false;

void draw() {
  background(50);

    
    boolean once = false;
    
  for(int i = 0 ; i< links.size();i++){
    
    if(mouseY>i*11-11&&mouseY<i*11){
     fill(255,0,0); 
    }else{
     fill(255); 
    }
    
    String tmp  = (String)(((Url)(links.get(i))).getUrl());
    text(tmp,0,i*11);
    
    if(mousePressed && !once){
      println(tmp);
      once = true;
      
    }
    
    
  }
  
  
  //println(data.size());
  
}

class Entit {
  float x = 256;
  float y = 256;
  float tx,ty;
  int diameter = 3;
  float lx,ly;
  float prum;
  int tahy = 2;
  color c;
  float speed = 1.0;
  int counter = 0;
  
  String A,B;

  int roz = 1;


  Entit() {

    A = solvers[(int)random(solvers.length)];
    B = solvers[(int)random(solvers.length)];
    
    ly=x=width/2;
    lx=y=height-10;
    
    tx=width/2;
    ty=height/2;
    
   

    prum = 1.1;
    
    speed = 2.0;//random(10,100)/500.0;
    
    c = color(random(255),random(255),random(255));
  }

  void update() {
    float len = dist(x,y,lx,ly);

    for(float f =0;f<len;f+=roz) {
      float tempx = lerp(lx,x,f/len);
      float tempy = lerp(ly,y,f/len);



      pushMatrix();
      translate(tempx,tempy);
      rotate(atan2(ly-y,lx-x));
      prum+=(dist(lx,ly,x,y)/2.0-prum)/30.0;

      stroke(255,200);
      line(0,-prum/8.0*speed,0,-prum/2*speed);

      stroke(c,200);
      line(0,prum/8.0*speed,0,prum/2*speed);


      popMatrix();
    }

    lx=x;
    ly=y;
    
    
    /*filter(BLUR,1.1);
     
     for(int y=0;y<width;y++) {
     for(int x=0;x<height;x++) {
     stroke(random(20),random(25));
     point(x,y);
     }
     }
     
     saveFrame("vid/blbost####.png");
     */

    if(dist(x,y,tx,ty)<1.0||counter==0) {
      tx=mouseX;//random(width);
      ty=mouseY;//random(height);
     // speed = 0.2;//random(10,100)/500.0;
      reach();
      counter++;
    }
  }


  void reach() {


    Ani.to(this, speed, "x", tx, A);
    Ani.to(this, speed, "y", ty, B);
  }
}

/**
 * shows how to set a specific easing (character of movment)
 * list of all easing styles below:
 *
 * Ani.LINEAR
 * Ani.QUAD_IN
 * Ani.QUAD_OUT
 * Ani.QUAD_IN_OUT
 * Ani.CUBIC_IN
 * Ani.CUBIC_IN_OUT
 * Ani.CUBIC_OUT
 * Ani.QUART_IN
 * Ani.QUART_OUT
 * Ani.QUART_IN_OUT
 * Ani.QUINT_IN
 * Ani.QUINT_OUT
 * Ani.QUINT_IN_OUT
 * Ani.SINE_IN
 * Ani.SINE_OUT
 * Ani.SINE_IN_OUT
 * Ani.CIRC_IN
 * Ani.CIRC_OUT
 * Ani.CIRC_IN_OUT
 * Ani.EXPO_IN
 * Ani.EXPO_OUT
 * Ani.EXPO_IN_OUT
 * Ani.BACK_IN
 * Ani.BACK_OUT
 * Ani.BACK_IN_OUT
 * Ani.BOUNCE_IN
 * Ani.BOUNCE_OUT
 * Ani.BOUNCE_IN_OUT
 * Ani.ELASTIC_IN
 * Ani.ELASTIC_OUT
 * Ani.ELASTIC_IN_OUT
 * 
 * MOUSE
 * click           : set end position of the animations and trigger new one
 */

import de.looksgood.ani.*;

ArrayList entities = new ArrayList(0);
String solvers[] = {
  Ani.LINEAR,Ani.QUAD_IN,Ani.QUAD_OUT,Ani.QUAD_IN_OUT,Ani.CUBIC_IN,Ani.CUBIC_IN_OUT,Ani.CUBIC_OUT,Ani.QUART_IN,Ani.QUART_OUT,Ani.QUART_IN_OUT,Ani.QUINT_IN,Ani.QUINT_OUT,Ani.QUINT_IN_OUT,Ani.SINE_IN,Ani.SINE_OUT,Ani.SINE_IN_OUT,Ani.CIRC_IN,Ani.CIRC_OUT,Ani.CIRC_IN_OUT,Ani.EXPO_IN,Ani.EXPO_OUT,Ani.EXPO_IN_OUT,Ani.BACK_IN,Ani.BACK_OUT,Ani.BACK_IN_OUT,Ani.BOUNCE_IN,Ani.BOUNCE_OUT,Ani.BOUNCE_IN_OUT,Ani.ELASTIC_IN,Ani.ELASTIC_OUT,Ani.ELASTIC_IN_OUT
};

void setup() {
  size(480,300,P2D);
  smooth();
  noStroke();


for(int i =0;i<10;i++)
  entities.add(new Entit());


  strokeWeight(2);

  // you have to call always Ani.init() first!
  Ani.init(this);
  background(0);


  textFont(createFont("Vernada",9));
  textMode(SCREEN);
}

void draw() {


  if(frameCount%2==0) {
    tint(12,128,255,5);


    image(g,noise(frameCount%5)*10-1.5,noise(frameCount%4)*4-.5);
  }
  else {

    tint(255,128,12,13);
    image(g,-noise(frameCount%6)*10+1.5,noise(frameCount%4)*4-.5);
  }

  for(int i = 0;i<entities.size();i++) {
    Entit tmp = (Entit)entities.get(i);
    tmp.update();
  }
  


/*
  pushStyle();
  strokeWeight(1);
  for(int i =0;i<10000;i++) {
    stroke(random(25),random(3,10));
    point(random(width),random(height));
  }
  popStyle();
*/
  pushStyle();
  strokeWeight(noise(frameCount%5)*10+3);
  noFill();
  stroke(0);


  rect(3,3,width-6,height-6);

  popStyle();

  pushStyle();
  fill(255);
  textAlign(RIGHT);
  text(millis(),width-9,height);
  popStyle();

}



void mouseReleased() {
  entities.add(new Entit());
}

class Entit {
  float x = 256;
  float y = 256;
  float tx,ty;
  int diameter = 3;
  float lx,ly;
  float prum;
  int tahy = 2;
  color c;
  float speed = 1.0;
  int counter = 0;
  
  String A,B;

  int roz = 1;


  Entit() {

    A = solvers[(int)random(solvers.length)];
    B = solvers[(int)random(solvers.length)];
    
    ly=x=width/2;
    lx=y=height-10;
    
    tx=width/2;
    ty=height/2;
    
   

    prum = 1.1;
    
    speed = 2.0;//random(10,100)/500.0;
    
    c = color(random(255),random(255),random(255));
  }

  void update() {
    float len = dist(x,y,lx,ly);

    for(float f =0;f<len;f+=roz) {
      float tempx = lerp(lx,x,f/len);
      float tempy = lerp(ly,y,f/len);



      pushMatrix();
      translate(tempx,tempy);
      rotate(atan2(ly-y,lx-x));
      prum+=(dist(lx,ly,x,y)/2.0-prum)/30.0;

      stroke(255,200);
      line(0,-prum/8.0*speed,0,-prum/2*speed);

      stroke(c,200);
      line(0,prum/8.0*speed,0,prum/2*speed);


      popMatrix();
    }

    lx=x;
    ly=y;
    
    
    /*filter(BLUR,1.1);
     
     for(int y=0;y<width;y++) {
     for(int x=0;x<height;x++) {
     stroke(random(20),random(25));
     point(x,y);
     }
     }
     
     saveFrame("vid/blbost####.png");
     */

    if(dist(x,y,tx,ty)<1.0||counter==0) {
      tx=mouseX;//random(width);
      ty=mouseY;//random(height);
     // speed = 0.2;//random(10,100)/500.0;
      reach();
      counter++;
    }
  }


  void reach() {


    Ani.to(this, speed, "x", tx, A);
    Ani.to(this, speed, "y", ty, B);
  }
}

/**
 * shows how to set a specific easing (character of movment)
 * list of all easing styles below:
 *
 * Ani.LINEAR
 * Ani.QUAD_IN
 * Ani.QUAD_OUT
 * Ani.QUAD_IN_OUT
 * Ani.CUBIC_IN
 * Ani.CUBIC_IN_OUT
 * Ani.CUBIC_OUT
 * Ani.QUART_IN
 * Ani.QUART_OUT
 * Ani.QUART_IN_OUT
 * Ani.QUINT_IN
 * Ani.QUINT_OUT
 * Ani.QUINT_IN_OUT
 * Ani.SINE_IN
 * Ani.SINE_OUT
 * Ani.SINE_IN_OUT
 * Ani.CIRC_IN
 * Ani.CIRC_OUT
 * Ani.CIRC_IN_OUT
 * Ani.EXPO_IN
 * Ani.EXPO_OUT
 * Ani.EXPO_IN_OUT
 * Ani.BACK_IN
 * Ani.BACK_OUT
 * Ani.BACK_IN_OUT
 * Ani.BOUNCE_IN
 * Ani.BOUNCE_OUT
 * Ani.BOUNCE_IN_OUT
 * Ani.ELASTIC_IN
 * Ani.ELASTIC_OUT
 * Ani.ELASTIC_IN_OUT
 * 
 * MOUSE
 * click           : set end position of the animations and trigger new one
 */

import de.looksgood.ani.*;

ArrayList entities = new ArrayList(0);
String solvers[] = {
  Ani.LINEAR,Ani.QUAD_IN,Ani.QUAD_OUT,Ani.QUAD_IN_OUT,Ani.CUBIC_IN,Ani.CUBIC_IN_OUT,Ani.CUBIC_OUT,Ani.QUART_IN,Ani.QUART_OUT,Ani.QUART_IN_OUT,Ani.QUINT_IN,Ani.QUINT_OUT,Ani.QUINT_IN_OUT,Ani.SINE_IN,Ani.SINE_OUT,Ani.SINE_IN_OUT,Ani.CIRC_IN,Ani.CIRC_OUT,Ani.CIRC_IN_OUT,Ani.EXPO_IN,Ani.EXPO_OUT,Ani.EXPO_IN_OUT,Ani.BACK_IN,Ani.BACK_OUT,Ani.BACK_IN_OUT,Ani.BOUNCE_IN,Ani.BOUNCE_OUT,Ani.BOUNCE_IN_OUT,Ani.ELASTIC_IN,Ani.ELASTIC_OUT,Ani.ELASTIC_IN_OUT
};

void setup() {
  size(480,300,P2D);
  smooth();
  noStroke();


for(int i =0;i<10;i++)
  entities.add(new Entit());


  strokeWeight(2);

  // you have to call always Ani.init() first!
  Ani.init(this);
  background(0);


  textFont(createFont("Vernada",9));
  textMode(SCREEN);
}

void draw() {


  if(frameCount%2==0) {
    tint(12,128,255,5);


    image(g,noise(frameCount%5)*10-1.5,noise(frameCount%4)*4-.5);
  }
  else {

    tint(255,128,12,13);
    image(g,-noise(frameCount%6)*10+1.5,noise(frameCount%4)*4-.5);
  }

  for(int i = 0;i<entities.size();i++) {
    Entit tmp = (Entit)entities.get(i);
    tmp.update();
  }
  


/*
  pushStyle();
  strokeWeight(1);
  for(int i =0;i<10000;i++) {
    stroke(random(25),random(3,10));
    point(random(width),random(height));
  }
  popStyle();
*/
  pushStyle();
  strokeWeight(noise(frameCount%5)*10+3);
  noFill();
  stroke(0);


  rect(3,3,width-6,height-6);

  popStyle();

  pushStyle();
  fill(255);
  textAlign(RIGHT);
  text(millis(),width-9,height);
  popStyle();

}



void mouseReleased() {
  entities.add(new Entit());
}


class Splat {
  float x[],y[];
  color c[];
  float bx,by;
  int num = 10;
  float time = 1;

  Splat(int _num,float _x,float _y) {
    num = _num;
    x = new float[num];
    y =  new float[num];
    c = new color[num];
   
    
    bx = _x;
    by = _y; 
    time = 1;

    for(int i = 0;i<x.length;i++) {
      x[i] = bx+random(-2,2);
      y[i] = by+random(-2,2);
      c[i] = color(random(255),10,10);      
    }
  }

  void animate() {
     if(time<10){
    for(int i = 0;i<x.length;i++) {
      x[i] += (x[i]-bx)/(time);
      y[i] += (y[i]-by)/(time);
      
     // strokeWeight(4);
    
      stroke(c[i],map(time,1,300,255,0));
      point(x[i],y[i]);
     }
   
    time*=1.43;
    
     }
    
    
  }
}


class Person implements Comparable {
  Splat s;
  PGraphics face;
  PImage skin;
  float x,y,ty,tx,px,py;
  int id;
  boolean msk[];
  int blood = 0;
  boolean bleeding = false;
  boolean dead = false;
  float deadAng = 0;
  int band = 0;
  int target = (int)random(p.length);
  boolean once = true;
  color shirtC,hairC,trousC;

  Person(int _id) {
    skin = loadTrans("generic.gif");
    id =_id;
    x = width/2;
    y = height/2;
  }

  Person(String _skin,int _id) {
    id = _id;

    skin = loadTrans(_skin);
    face = createGraphics(skin.width,skin.height,P2D);

    tx = x = (int)random(-60,60);
    ty = y = (int)random(-60,60);
  }

  Person(int _id,int _band) {
    id = _id;
    band = _band;

    String nameSkin;

    if(band==-1) {
      nameSkin = "generic.gif";
    }
    else {
      nameSkin = "genericB.gif";
      shirtC = color(random(120),random(130),random(110));
      hairC = color(random(30),random(20),random(10));
      trousC = color(random(130),random(130),random(130));
    }



    s = new Splat(10,x,y);
    s.time = 100;

    skin = loadTrans(nameSkin);


    face = createGraphics(skin.width,skin.height,P2D);

    tx = x = band*200-(int)random(-60,60);
    ty = y = band*200-(int)random(-60,60);
  }

  void draw() {

    int r =0;

    if(!dead) {



      tx += (int)random(-1.9,2);
      ty += (int)random(-1.9,2);
      
      tx += (-tx)/200.0;
ty += (-ty)/200.0;

      x += (tx-x)/3.0;
      y += (ty-y)/3.0;

      px = x;
      py = y;
      
      


      for(int q = 0;q<p.length;q++) {

        r = (int)random(p.length);

        if((p[r].band!=band) && 
          (!p[r].dead) && (abs(x - p[r].x)<1.0) &&
          (abs(y - p[r].y)<1.0) && 
          (p[r].id!=id)) {

          s = new Splat((int)random(80),0,0);
          
          tx -= (p[r].x-tx)/((dist(x,y,p[r].x,p[r].y)+1.1)*30.0);
          ty -= (p[r].y-ty)/((dist(x,y,p[r].x,p[r].y)+1.1)*3.0);

          for(int i = 0;i<200;i++) {
            int xx = (int)random(skin.width);
            int yy = (int)random(skin.height);

            if(msk[yy*skin.width+xx]) {
              face.beginDraw();
              face.stroke(random(255),10,10);
              face.point(xx,yy);
              face.endDraw();
              blood ++;
            }
          }
        }
      }

      if(blood>170) {
        bleeding = true;

        canvas.beginDraw();
        canvas.noSmooth();
        canvas.pushMatrix();
        canvas.noFill();
        canvas.stroke(random(255),10,10,30);
        canvas.translate(canvas.width/2,canvas.height/2);    
        for(int i = 0;i<blood/10;i++) {
          canvas.point(x*2+random(-2,2),y*2+random(-2,2));
        }
        canvas.popMatrix();
        canvas.endDraw();
      }
    }

    if(blood>200 && !dead) {
      dead = true;
      deadAng = atan2(y-p[r].y,x-p[r].x);
      px = x;
      py = -2000;
    }
    //y = (int)(sin(frameCount/10.0)*30);
    //resetMatrix();


/*
    if(blood > 100){
      if(band==1){
     target = (int)random(p.length/2,p.length-1);
     // x-=2;y-=2; 
      }else{
      //  x+=2;y+=2;
        target = (int)random(0,p.length/2);      
      }*/
      //tx += (p[target].x-tx)/230.0;
     //ty += (p[target].y-ty)/300.0;
    //}
    
    

    if(p[target].dead || p[target].band==band || (frameCount%(id+3) == 0)){
      target = (int)(random(p.length));
      
    }
      
     

    

    tx += (p[target].x-x)/150.0;
    ty += (p[target].y-y)/150.0;
    
    for(int i = 0 ;i<40;i++){
      tx -= (p[i].x-tx)/((dist(x,y,p[i].x,p[i].y)+1.1)*30.0);
      ty -= (p[i].y-ty)/((dist(x,y,p[i].x,p[i].y)+1.1)*60.0);
    }



    pushMatrix();
    rotateX(radians(-90));
    rotateY(radians(-45));

    translate(x-(int)(skin.width/2),y+skin.height,-50);

    pushMatrix();
    if(dead && once) {
      canvas.beginDraw();
      canvas.noSmooth();
      canvas.pushMatrix();
      canvas.noFill();

      canvas.translate(canvas.width/2,canvas.height/2);    

      for(int i = 0;i<450;i++) {
        canvas.stroke(random(255),10,10,65);
        canvas.point(x*2+random(-80,80),y*2+random(-80,80));
      }
      canvas.popMatrix();
      canvas.endDraw();
      once = false;
    }
    else if (dead) {

      if((random(11)<10)) {

        canvas.beginDraw();
        canvas.pushMatrix();
        canvas.stroke(random(255),10,10,5);
        canvas.translate(canvas.width/2,canvas.height/2);    
        canvas.point(x*2, y*2);
        canvas.popMatrix();
        canvas.endDraw();
        y += (-90-y) / 10.0;
        x += (-62-x) / 22.0;
      }
    }
    else if(!dead) {

      //rotateX(radians(-90));
      // rotateZ(radians(mouseX)-QUARTER_PI);

      //rotateY(radians(random(-20,20)));
      image(skin,0,0);
      image(face,0,0);


      s.animate();
    }

    popMatrix();

    popMatrix();
    // line(0,0,0,width);
  }


  int compareTo(Object o)
  {
    Person other = (Person)o;
    if(other.py>py)  
      return -1;
    if(other.py==py)
      return 0;
    else
      return 1;
  }

  PImage loadTrans(String name) {
    PImage src = loadImage(name);
    msk = new boolean[src.width*src.height];
    PImage out = createImage(src.width,src.height,ARGB);


    if (id ==0) {
      src.loadPixels();
      for(int i = 0;i<src.pixels.length;i++)
        println(src.pixels[i]);
    }

    src.loadPixels();
    for(int i = 0;i<src.pixels.length;i++)
      if((src.pixels[i]!=-65321)) {


        if(src.pixels[i]==-16776961) {
          out.pixels[i] = shirtC;
        }


        else if(src.pixels[i]==-65536) {
          out.pixels[i] = hairC;
        }

        else if(src.pixels[i]==-16711936) {
          out.pixels[i] = trousC;
        }


        else {
          out.pixels[i] = src.pixels[i];
        }


        msk[i] = true;
      }
      else {
        msk[i] = false;
      }

    return out;
  }
}

//import processing.opengl.*;

PImage bck;
Person p[];
PGraphics canvas;



int cx,cy;

void setup() {
  size(400,300,P3D);
  bck = loadImage("street.gif");


  p = new Person[120];

  for(int i = 0 ;i<p.length;i++) {
    int band = (random(100)>=50)?-1:1;
    p[i] = new Person(i,band);
  }

  canvas = createGraphics(width*2,height*2+35*2,P2D);

  noSmooth();

  noFill();
  stroke(0);

  cy = cx = 0;
}

void keyPressed() {
  if(keyCode==LEFT) {
    cx-=10;
  }
  else if(keyCode==RIGHT) {
    cx+=10 ;
  }
  else if(keyCode==UP) {
    cy-=10 ;
  }
  else if(keyCode==DOWN) {
    cy+=10;
  }
  println(cx + " und "+cy);
}


void draw() {
  background(bck);
  image(canvas,0,12,width,height);
  world(); 
  /*
  translate(
   map(mouseX,0,width,-width/2,width/2),
   map(mouseY,0,height,-height/2,height/2),
   -100);
   */

  // box(10);


  Arrays.sort(p);

  for(int i = 0 ;i<p.length;i++) {

    if(i==0 || i == p.length-1)
      p[i].target=(int)random(p.length);


    p[i].draw();
  }
}

void world() {


  translate(width/2,height/2,-height/2);
  rotateX(radians(60));
  rotateZ(radians(-45));
  ortho(-width/2, width/2, -height/2, height/2, -width/2, width/2);
  // translate(-190,-160,0);
}

void mousePressed() {
  println((mouseX-width/2) +" : "+(mouseY-height/2)) ;
}



class Hero {
}

class Bullet {
}



String s = "Software  Is  A  Process,  Not  A  Product.";
String s2 = "kof";
float uhly[];

int siz = 24;

PFont f,f2;

void setup() {
  size(640,120);
  
  f = createFont("Monospace",siz);
  f2 = createFont("Monospace",siz/2);
 
  fill(0);

  uhly = new float[s.length()];

  for(int i = 0;i<uhly.length;i++) {
     uhly[i] = -noise(i+frameCount/100.0)*360;
  }
}


void draw() {
  background(255);


 textFont(f);
  pushMatrix();
  translate(20,20);
  for(int i = 0;i<s.length();i++) {
    pushMatrix();
    translate(i*map(siz,0,10,0,6),20);
    rotate(radians(uhly[i]));
    uhly[i] = -noise(i+frameCount/40.0)*360;
    text(s.charAt(i),(map(siz,0,30,0,-11.4)),(map(siz,0,30,0,8.2)));
    popMatrix();
  } 



 textFont(f2);
  popMatrix();

  pushMatrix();
  
  for(int i = 0;i<s2.length();i++) {
    pushMatrix();
    translate(width-100+i*map(siz,0,10,0,6/2),height-20);
    rotate(radians(uhly[i]));
    uhly[i*3] = -noise(i+frameCount/100.0)*360;
    text(s2.charAt(i),(map(siz,0,30,0,-11.4/2)),(map(siz,0,30,0,8.2/2)));
    popMatrix();
  }

  popMatrix();
}

void mousePressed(){
  link("http://freesoftwareart.org/readme100/manifesto/", "_new");
}





String s = "Software  Is  A  Process,  Not  A  Product.";
String s2 = "kof";
float uhly[];

int siz = 24;

PFont f,f2;

void setup() {
  size(640,120);
  
  f = createFont("Monospace",siz);
  f2 = createFont("Monospace",siz/2);
 
  fill(0);

  uhly = new float[s.length()];

  for(int i = 0;i<uhly.length;i++) {
     uhly[i] = -noise(i+frameCount/100.0)*360;
  }
}


void draw() {
  background(255);


 textFont(f);
  pushMatrix();
  translate(20,20);
  for(int i = 0;i<s.length();i++) {
    pushMatrix();
    translate(i*map(siz,0,10,0,6),20);
    rotate(radians(uhly[i]));
    uhly[i] = -noise(i+frameCount/40.0)*360;
    text(s.charAt(i),(map(siz,0,30,0,-11.4)),(map(siz,0,30,0,8.2)));
    popMatrix();
  } 



 textFont(f2);
  popMatrix();

  pushMatrix();
  
  for(int i = 0;i<s2.length();i++) {
    pushMatrix();
    translate(width-100+i*map(siz,0,10,0,6/2),height-20);
    rotate(radians(uhly[i]));
    uhly[i*3] = -noise(i+frameCount/100.0)*360;
    text(s2.charAt(i),(map(siz,0,30,0,-11.4/2)),(map(siz,0,30,0,8.2/2)));
    popMatrix();
  }

  popMatrix();
}

void mousePressed(){
  link("http://freesoftwareart.org/readme100/manifesto/", "_new");
}

import ddf.minim.*;

AudioPlayer player;
Minim minim;



PImage pozadi,ruce,meridlo,buh;
float delta;

void setup() {
  size(254,330);
  
  pozadi = loadImage("200804182209_god_geometry.png");

  


  minim = new Minim(this);

  ruce = loadImage("ruce.png");
  meridlo = loadImage("meridlo.png");
  buh = loadImage("bozidilo.png");

  delta = map(width - 50,width-50,width-40,0.8,0.7)-0.57;

  player = minim.loadFile("measureDeMeasure.mp3", 2048);
  // play the file
  player.loop();

  smooth();
}


void draw() {
  background(pozadi);

  pushMatrix();
  translate(174,240);
  rotate(radians(frameCount));
  image(buh,-buh.width/2,-buh.height/2);
  popMatrix();

  loadPixels();
  float it = 0;
  int wh = 0;
  int y = 235;
  for(int i = width-50;i<width-40;i++) {

    if(brightness(pixels[y*width+i])>it) {
      it = brightness(pixels[y*width+i]);
      wh = i;
    }

    if(i%2==0)
      y--;
  }

  delta += (wh-delta)/3.0;

  image(ruce,0,0);

  pushMatrix();
  translate(180,147);
  rotate(map(delta,width-50,width-40,0.8,0.7)-0.57);
  image(meridlo,-44,-3);
  popMatrix();
}


void stop()
{
  // always close Minim audio classes when you are done with them
  player.close();
  minim.stop();

  super.stop();
}

import ddf.minim.*;

AudioPlayer player;
Minim minim;



PImage pozadi,ruce,meridlo,buh;
float delta;

void setup() {
  size(254,330);
  
  pozadi = loadImage("200804182209_god_geometry.png");

  


  minim = new Minim(this);

  ruce = loadImage("ruce.png");
  meridlo = loadImage("meridlo.png");
  buh = loadImage("bozidilo.png");

  delta = map(width - 50,width-50,width-40,0.8,0.7)-0.57;

  player = minim.loadFile("measureDeMeasure.mp3", 2048);
  // play the file
  player.loop();

  smooth();
}


void draw() {
  background(pozadi);

  pushMatrix();
  translate(174,240);
  rotate(radians(frameCount));
  image(buh,-buh.width/2,-buh.height/2);
  popMatrix();

  loadPixels();
  float it = 0;
  int wh = 0;
  int y = 235;
  for(int i = width-50;i<width-40;i++) {

    if(brightness(pixels[y*width+i])>it) {
      it = brightness(pixels[y*width+i]);
      wh = i;
    }

    if(i%2==0)
      y--;
  }

  delta += (wh-delta)/3.0;

  image(ruce,0,0);

  pushMatrix();
  translate(180,147);
  rotate(map(delta,width-50,width-40,0.8,0.7)-0.57);
  image(meridlo,-44,-3);
  popMatrix();
}


void stop()
{
  // always close Minim audio classes when you are done with them
  player.close();
  minim.stop();

  super.stop();
}

/**
 * oscP5sendreceive by andreas schlegel
 * example shows how to send and receive osc messages.
 * oscP5 website at http://www.sojamo.de/oscP5
 */
 
import oscP5.*;
import netP5.*;
  
OscP5 oscP5;
NetAddress myRemoteLocation;

void setup() {
  size(400,400,P2D);
  frameRate(25);
  /* start oscP5, listening for incoming messages at port 12000 */
  oscP5 = new OscP5(this,12000);
  
  /* myRemoteLocation is a NetAddress. a NetAddress takes 2 parameters,
   * an ip address and a port number. myRemoteLocation is used as parameter in
   * oscP5.send() when sending osc packets to another computer, device, 
   * application. usage see below. for testing purposes the listening port
   * and the port of the remote location address are the same, hence you will
   * send messages back to this sketch.
   */
  myRemoteLocation = new NetAddress("10.0.0.4",1234);
}


void draw() {
  background(0);  


  /* in the following different ways of creating osc messages are shown by example */
  OscMessage myMessage = new OscMessage("/test/x");
  
  
  myMessage.add(noise(frameCount/20.0)); /* add an int to the osc message */

  /* send the message */
  oscP5.send(myMessage, myRemoteLocation); 

  myMessage = new OscMessage("/test/y");
  
  
  myMessage.add(noise(frameCount/24.3)); /* add an int to the osc message */

  oscP5.send(myMessage, myRemoteLocation); 


}

void mousePressed() {
}


/* incoming osc message are forwarded to the oscEvent method. */
void oscEvent(OscMessage theOscMessage) {
  /* print the address pattern and the typetag of the received OscMessage */
  print("### received an osc message.");
  print(" addrpattern: "+theOscMessage.addrPattern());
  println(" typetag: "+theOscMessage.typetag());
}

PImage src;
PImage cak[] = new PImage[10];

color c[] = new color[16];


void setup(){
	size(1024,768,P2D);
	
	src = loadImage("one.gif");
	src.loadPixels();
	
	
	for(int i = 0 ;i < c.length;i++)
		c[i] = src.pixels[(int)random(src.pixels.length)];
			
	for(int i = 0 ;i < 10;i++)
		cak[i] = loadImage(i+".png");
			
			
			noStroke();
			
			background(0);
	

}



void draw(){
	tint(c[(int)random(c.length)],135);
	
	float x = 10,y;
	for(int i = 0 ; i < (int)random(5,50);i++){
		pushMatrix();
		
		x = random(width);
		y = random(height);
		translate(x,y);
		rotate(random(-PI,PI));
		float scale = random(0.25,2);
		int id = (int)random(10);
		image(cak[id],0,0,scale*cak[id].width,scale*cak[id].height);
		popMatrix();
	}
	//rect(random(width),random(height),random(-width,width),random(-height,height));
	
	fill(0,12);
	ellipse(width/2,height/2,x,x);


}

void setup(){
	size(800,600,OPENGL);
	frameRate(25);

}


void draw(){
	if(frameCount%5==0){
		background(0);
	}else{
		background(255);
	}


}

int velikost = 300;
int sc = 1;
 
 
 
int shiftx = 2;
int shifty = 0;
 
boolean matix[][];
 
color c1 = color(255,128,0);
color c2 = color(0);
 
void setup() {
  matix = new boolean[720][576];
  size(matix.length*sc,matix[0].length*sc,P2D);
 
  frameRate(25);
 
  for(int y = 0;y<matix[0].length;y++) {
 
    for(int x = 0;x<matix[0].length;x++) {
      matix[x][y] = (random(20)>10) ? true : false;
    }
  }
  noStroke();
  noSmooth();
}
 
void draw() {
   c1 = color(255);
  shiftx = (int)((noise(-frameCount/33.12)-0.5)*width);
  shifty = (int)((noise(frameCount/300.0)-0.5)*height);
  for(int y = 0;y<matix[0].length;y++) {
 
    for(int x = 0;x<matix.length/2;x++) {
      fill((matix[x][y])?c1:c2,80);
      rect(x*sc,y*sc,sc,sc);
    }
 
    for(int x = matix.length/2;x<matix.length;x++) {
      fill((matix[matix.length-x][y])?c1:c2,80);
      rect(x*sc,y*sc,sc,sc);
    }
  }
 
  pushStyle();
  noFill();
  strokeWeight(5);
  stroke(0);
  rect(0,0,width,height);
  popStyle(); 
 
  randomize((int)(noise(frameCount/230.2)*20));
  
  saveFrame("video/nf####.png");
  
}
 
 
int cnt = 0;
void randomize(int kolik) {
  for(int y = 0;y<matix[0].length;y++) {
    for(int x = 0;x<matix[0].length;x++) {
 
 
      if((random(1000))<kolik) {
        matix[x][y] = !matix[x][y];
      }
      else if(matix[(x+width-shiftx)%(width/sc-1)][y]) {
        matix[x][y] = matix[(x+width+2)%(width/sc-1)][y];
      }
      else {
        matix[x][y] = matix[x][(y+height-shifty)%(height/sc-1)];
      }
    }
  }
}

import processing.opengl.*;

ArrayList body = new ArrayList(0);
ArrayList cestovatele = new ArrayList(0);

int ID = 0;

void setup(){
	size(640,420,OPENGL);
	
	background(0);	
	

}


void draw(){
//	noStroke();
//	fill(0,15);
//	rect(0,0,width,height);


background(0);	

	for(int i  = 0; i< cestovatele.size();i++){
		Cestovatel tmp = (Cestovatel)cestovatele.get(i);	
		tmp.move();
		tmp.draw();
	}
	
	cursor(CROSS);


}

class Cestovatel{
	float x,y,lx,ly;
	float nx,ny;
	int idm,target;
	float speed = 10.0;

	Cestovatel(){
		Bod tmp = (Bod)body.get(0);
		nx = x = tmp.x;
		ny = y = tmp.y;
	}

	void skip(){
		target++;
		if(target>=body.size()){

			target = 0;
			Bod tmp = (Bod)body.get(target);
			nx = x = tmp.x;
			ny = y = tmp.y;
			
			
		
		}	
		
		Bod tmp = (Bod)body.get(target);
		nx = tmp.x;
		ny = tmp.y;

	}

	void move(){

		lx=x;
		ly=y;

		x += (nx-x) / speed;
		y += (ny-y) / speed;

		if(dist(nx,ny,x,y)<1){
			skip();
		}

	}


	void draw(){
		fill(255,100);
		//strokeWeight(3);
		rect(x,y,5,5);

	}


}

class Bod{
	float x,y;
	int id;

	Bod(float _x,float _y,int _id){
		x = _x;
		y = _y;
		id = _id;
	}
}


void mousePressed(){
	body.add(new Bod(mouseX,mouseY,ID++));

}

void keyPressed(){
	if (key == ' ' && body.size() > 0){
		cestovatele.add(new Cestovatel());
	}else if(key == ' '){
		println("zadne body nebyly definovany");

	}


}
String dates[];
PFont font;


void setup() {

  size(320,240,P2D);
  background(50);

  font = createFont("Anivers",9);
  textFont(font);
  textMode(SCREEN);



  println(dates); 

  dates = generate(20);
}

void draw() {
  if(frameCount%5==0) {
    dates = generate(1);
    saveResult();  
}

  background(50);
  fill(200);

  for(int i = 0 ;i<dates.length;i++)
    text(dates[i],10,i*11+11);
}

String[] generate(int kolik) {

  int yea[] = new int[kolik];
  int mont[] = new int[kolik];
  int minu[] = new int[kolik];
  int hou[] = new int[kolik];
  int da[] = new int[kolik];
  int sec[] = new int[kolik];
  String[] result = new String[kolik];


  for(int i = 0 ;i < kolik;i++) {
    yea[i] = 2010;
    da[i] = (int)random(1,30);
    mont[i] = (int)random(0,12);
    hou[i] = (int)random(0,24);
    minu[i]  = (int)random(0,60);
    sec[i] = (int)random(0,60);
    result[i] = yea[i]+
      "_"+nf(da[i],2)+
      "_"+nf(mont[i],2)+
      "_"+nf(hou[i],2)+
      "_"+nf(minu[i],2)+
      "_"+nf(sec[i],2);
  }

  return result;
}

void keyPressed() {
  if(key == ' ') {
    saveResult();
  }
}

void saveResult() {

  for (int i = 0 ; i < dates.length; i++) {
    saveStrings(sketchPath+"/videa/"+dates[i]+".mov",new String[] {
      "data","data","data"
    }
    );
  }
}

import processing.opengl.*;

int q ;

int step = 30;

float [] rnd;
color [] c;
void setup() {
  size(1024,768,OPENGL);  
  stroke(255);
  noFill();
  //noCursor();
  smooth();

  
  q = 0;
  for(int i = 10 ; i< height ; i += step){
   q++; 
  }
  
  rnd = new float[q];
  c = new color[q];
  
  
  for(int i = 0 ; i< rnd.length ; i += 1){
   rnd[i] = random(-500,500)/300000.0; 
   c[i] = color(random(255));
  }
  
}

void draw() {
  background(0);
  
  strokeWeight(5);
 // translate(width/2,height/2);

  stroke(255);
  /*
  q = 0;
  for(int i = 30 ; i< height ; i += step){
    stroke(c[q]);
    arc(0, 0, i, i, radians(noise(frameCount*rnd[q])*width) , radians(noise(frameCount*rnd[q])*width+rnd[q])+PI-1.2);
    q++;  
}
  */
  
  q = 0;
  for(int i = 30 ; i< height ; i += step){
  
  float base = (sin(frameCount/15.0)+1)*50+i;
  rect(base,base,width-2*base,height-2*base);
  }
  //if(frameCount%50==0)
 // q = (int)((sin(frameCount/6.0)+1)*50)+4;
  //for(int i = 0;i<width;i+=q){
    //line(i,0,i,height);
    
  //}

}





public void init() {
 frame.removeNotify();
 frame.setUndecorated(true);
 frame.setAlwaysOnTop(true);
 
 
 frame.addNotify();
 // call PApplet.init() to take care of business
 super.init();  
} 

int x = 0;

void setup(){
	size(320,240,P2D);
	background(0);
	stroke(255);
	noSmooth();
}

void draw(){
	background(0);
	stroke(255,30);
		
	
	for(int i = 0 ; i< 10 ;i++){
		float shift = random(0,noise(frameCount/50.0)*40.0);
		line(x+shift,0,shift+x,height);
		
	}
	x++;
	x=x%width;

}/**
 * shows how to set a specific easing (character of movment)
 * list of all easing styles below:
 *
 * Ani.LINEAR
 * Ani.QUAD_IN
 * Ani.QUAD_OUT
 * Ani.QUAD_IN_OUT
 * Ani.CUBIC_IN
 * Ani.CUBIC_IN_OUT
 * Ani.CUBIC_OUT
 * Ani.QUART_IN
 * Ani.QUART_OUT
 * Ani.QUART_IN_OUT
 * Ani.QUINT_IN
 * Ani.QUINT_OUT
 * Ani.QUINT_IN_OUT
 * Ani.SINE_IN
 * Ani.SINE_OUT
 * Ani.SINE_IN_OUT
 * Ani.CIRC_IN
 * Ani.CIRC_OUT
 * Ani.CIRC_IN_OUT
 * Ani.EXPO_IN
 * Ani.EXPO_OUT
 * Ani.EXPO_IN_OUT
 * Ani.BACK_IN
 * Ani.BACK_OUT
 * Ani.BACK_IN_OUT
 * Ani.BOUNCE_IN
 * Ani.BOUNCE_OUT
 * Ani.BOUNCE_IN_OUT
 * Ani.ELASTIC_IN
 * Ani.ELASTIC_OUT
 * Ani.ELASTIC_IN_OUT
 * 
 * MOUSE
 * click           : set end position of the animations and trigger new one
 */

import de.looksgood.ani.*;

float x = 256;
float y = 256;
float tx,ty;
int diameter = 3;
float lx,ly;
float prum;
int tahy = 2;

int counter = 0;

int roz = 1;

void setup() {
  size(320,254,P2D);
  smooth();
  noStroke();

  lx=tx=x;
  ly=ty=y;

  strokeWeight(3);

  // you have to call always Ani.init() first!
  Ani.init(this);
  background(128);
  prum = 0;
}

void draw() {

  tint(255,0,0,254);
  image(g,0.5,1);
  //background(255);
  //stroke(0,200);
  // line(x,y,lx,ly);

  float len = dist(x,y,lx,ly);

  for(float f =0;f<len;f+=roz) {
    float tempx = lerp(lx,x,f/len);
    float tempy = lerp(ly,y,f/len);



    pushMatrix();
    translate(tempx,tempy);
    rotate(atan2(ly-y,lx-x));
    prum+=((dist(lx,ly,x,y))-prum)/3.0;

    stroke(100,200);
    line(0,-prum/4.0,0,-prum);

    stroke(255,200);
    line(0,prum/4.0,0,prum);


    popMatrix();
  }

  lx=x;
  ly=y;

  /*filter(BLUR,1.1);

  for(int y=0;y<width;y++) {
    for(int x=0;x<height;x++) {
      stroke(random(20),random(25));
      point(x,y);
    }
  }

  saveFrame("vid/blbost####.png");
*/

  if(dist(x,y,tx,ty)<1.0||frameCount==1) {
    tx=random(width);
    ty=random(height);
    reach();



  }
}


void reach() {


  Ani.to(this, 0.3, "x", tx, Ani.CIRC_IN);
  Ani.to(this, 0.3, "y", ty, Ani.CIRC_OUT);
}

void mouseReleased() {
}

import processing.opengl.*;

ArrayList d;
int ID = 0;

int [][] change;

void setup(){
	size(800,600,OPENGL);

	change = new int[width][height];

	for(int y = 0; y < height; y++){
		for(int x = 0; x < width; x++){
			int q = 0;//(int)random(11);			
			change[x][y] = q;
		}
	}

	
	d = new ArrayList(0);

	for(int i = 0 ; i< 5000;i++)
	d.add(new Dupliciter((int)random(width-1),(int)random(height-1)));


}



void draw(){

noStroke();
fill(0,50);
rect(0,0,width,height);

	for(int i = 0;i<d.size();i++){
		Dupliciter tmp = (Dupliciter)d.get(i);
		if(tmp.ignore){

		change[constrain(tmp.cx,0,width-1)][constrain(tmp.cy,0,height-1)] = (int)(random(100));
		}else{

		switch(change[tmp.cx][tmp.cy]){
				case 0:
				tmp.x = -1;
				tmp.y = -1;
				break;
  				case 1:
                                tmp.x = 0;
                                tmp.y = -1;
                                break;
  				case 2:
                                tmp.x = 1;
                                tmp.y = -1;
                                break;
  				case 3:
                                tmp.x = -1;
                                tmp.y = 0;
                                break;
  				case 4:
                                tmp.x = 1;
                                tmp.y = 0;
                                break;
  				case 5:
                                tmp.x = -1;
                                tmp.y = 1;
                                break;
 				case 6:
                                tmp.x = 0;
                                tmp.y = 1;
                                break;
				case 7:
                                tmp.x = 1;
                                tmp.y = 1;
                                break;
 				case 9:
				tmp.cloneit();
                                break;
  				case 10:
                                tmp.deleteit();
                                break;

		}
		tmp.ignore = true;
		tmp.life = 0;
}
		tmp.draw();
	}
}

class Dupliciter{

	int x,y,cx,cy;
	int id;
	boolean ignore = true;
	int timer,life = 0;

	Dupliciter(){
		cx = width / 2;
		cy = height / 2;
		id = ID++;
		timer = (int)random(30);
	}

	 Dupliciter(int _x,int _y){
                cx = _x;
                cy = _y;
                id = ID++;
		timer = (int)random(30);

        }


	void move(){
		life ++;

		if(life>timer){
			ignore = false;
		}

		cx+=x;
		cy+=y;
		
		if(cx>=width)cx=0;
		if(cx<0)cx=width-1;

		if(cy>=height)cy=0;
		if(cy<0)cy=height-1;

	}
	
	void draw(){
		move();
		pushStyle();
		strokeWeight(2);
		stroke(255,100);
		point(cx,cy);
		popStyle();
	}

	void cloneit(){
		d.add(new Dupliciter(cx+1,cy));

	}
	
	void deleteit(){
                d.remove(this);

        }

}
import processing.net.*;
Client myClient;
int dataIn;

String data;

void setup() {
	size(800, 600,P2D);
	background(50);
	
	//c = new Client(this, "http://www.volbyhned.cz", 80);
	myClient = new Client(this, "194.228.52.94", 80);


	textFont(createFont("Veranda",12,true));
	textMode(SCREEN);
	fill(255);
}


void draw() {
	
	if (myClient.available() > 0) { // If there's incoming data from the client...
		data = myClient.readString(); // ...then grab it and print it
		println(data);
		text(data,10,10);
		myClient.clear();

	}
}

void refresh(){

	//try{

		myClient.write("GET ps2010/ps_celk.html \n"); // Use the HTTP "GET" command to ask for a Web page
		myClient.write("Host: datagrabber.cz\n\n"); // Be polite and say who we are

	//}catch(Exception e){
	//	println(e);

	//}

}

void keyPressed(){

	refresh();

}
/*
* Demonstrates the use of the GifAnimation library.
 * Exports a GIF-File to the sketch folder if space
 * bar is pressed. Wow, feels like 90's! ;)
 */

import gifAnimation.*;
import processing.opengl.*;

GifMaker gifExport;
PImage logo;
float rotation = 0.0;

color [] palette = new color[3];

public void setup() {
	size(600, 100, P2D);
	frameRate(12);

	println("gifAnimation " + Gif.version());
	gifExport = new GifMaker(this, "export.gif");
	gifExport.setRepeat(0); // make it an "endless" animation
	//gifExport.setTransparent(0,0,0); // make black the transparent color. every black pixel in the animation will be transparent
	// GIF doesn't know have alpha values like processing. a pixel can only be totally transparent or totally opaque.
	// set the processing background and the transparent gif color to the same value as the gifs destination background color
	// (e.g. the website bg-color). Like this you can have the antialiasing from processing in the gif.
	fill(255);
	noStroke();
	
	for(int i = 0;i<palette.length;i++)
		palette[i] = color(random(10,255),random(10,255),random(10,255));

	textFont(createFont("Sans",25,false));
	textMode(SCREEN);
	textAlign(CENTER);
}

void draw() {
	background(0);


	//rect(x,y,4,4);

	for(int i =0;i<100;i++){

		int x = (int)random(0,width);
		int y = (int)random(0,height);

		fill(palette[(int)random(palette.length)],140);
		text("FAMU - CAS",x,y);
	}

	gifExport.setDelay(1);
	gifExport.addFrame();
	
	if(frameCount==4)
		endIt();
}

void endIt(){
gifExport.finish();

	exit();
}

void keyPressed() {
	
}
import processing.pdf.*;
PGraphicsPDF pdf ;
PFont font;

String outFont = "Liberation";
int fontHeight = 12;

void setup(){

	size(600,800,P2D);

	println(PFont.list());
	BeginSavePDF("/desk/");


}

void draw(){

	background(0);
	fill(0);
	
	int cnt = 0;
	
	fill(200);
	
	for(int i = 0 ;i<height;i+=fontHeight){
		

		
		fontHeight = (int)random(9,90);
		font = createFont(outFont, fontHeight ,true);//("Arial",10,true);
		pdf.textMode(SHAPE);// = SHAPE;
		pdf.textFont(font);


		text(i+" = "+outFont,10,i+fontHeight);
		
		cnt++;

	}
	EndSavePDF();
	exit();

}


void BeginSavePDF(String _path)
{
	String path = _path+"";//"/desk/pdfOut/";

font = createFont(outFont, fontHeight ,true);//("Arial",10,true);
	textFont(font);
	textMode(SCREEN);
	pdf = (PGraphicsPDF) createGraphics(width ,height, PDF, path + outFont + ".pdf");
	beginRecord(pdf);
	
	pdf.textMode(SHAPE);// = SHAPE;
	pdf.textFont(font);


}
void EndSavePDF()
{
	endRecord();
	println("exporting pdf..");
}

int freq = 1;

String places[] = {"Praha","Kladno","Kralupy%20nad%20vltavou","Ricany","Cernosice","Benesov","Rakovnik","Louny","Mlada%20Boleslav","Pardubice","Prachatice","Brno","Ostrava","Olomouc","Plzen","Znojmo"};
Location loc[];

int minrun = 0;

int minute ,minuteLast;

void setup() {
  size(1680, 700, P2D);
  
  textFont(createFont("Helvetica",9,true));
  textMode(SCREEN);  
  frameRate(25);

  minute = minuteLast = minute();
  stroke(255);
  noFill();


  loc = new Location[places.length];

  for(int i = 0 ;i<loc.length;i++)
    loc[i] = new Location(places[i],this);

}


void draw(){
  
  minute = minute();
  if(minute!=minuteLast){    
    if(minrun%freq == 0){
     for(int i = 0 ;i<loc.length;i++)
      loc[i].update(); 
    }
    minrun++;

  background(0);

  for(int i = 0 ;i<loc.length;i++)
    loc[i].draw();// = new Loc(places[i]);

  line(0,height/2,width,height/2);

  }
  

  minuteLast = minute;

    
  
    
}

void keyPressed(){
  for(int i = 0 ;i<loc.length;i++)
      loc[i].update();
}









class Location{
  XMLElement xml;
  float tempr;
  float hum;

  float temps[] = new float[0];
  float hums[] = new float[0];
  String place;
  
  color c;
  
  PApplet parent;

  Location(String _place,PApplet _parent){
    parent = _parent;
    place = ""+_place;
    c = color(random(100,255),random(100,255),random(100,255));
    update();

  }

  void update(){
    try{
    xml = new XMLElement(parent, "http://www.google.com/ig/api?weather="+place);    
    
    tempr = xml.getChild(0).getChild(1).getChild(2).getFloatAttribute("data");
    String _hum = xml.getChild(0).getChild(1).getChild(3).getStringAttribute("data");
    String _hums[] = splitTokens(_hum," %");
    hum = parseFloat(_hums[1]);

    println(place+" -> "+"temp: "+tempr+"   humidity: "+hum);

    hums = (float[])append(hums,hum);
    temps = (float[])append(temps,tempr);  
    
    }catch(Exception e){
      println("problems during parsing data: "+e); 
    }
  }
  
  void draw(){
   

  float y = map(temps[0], 0,30,height,height/2);
  fill(c);
  text(place,width-40,y);
  noFill();
  
//  for(int q = 1;q<30;q++){
    beginShape(POLYGON);
    vertex(0,y);
    for(int i = 0;i<temps.length;i++){
      y = (map(temps[i], 0,30,height,height/2));// / (q+0.0);
      stroke(c,100);
      curveVertex( map(i,0,temps.length-1,0,width) , y );
    } 
    vertex(width,y);
    endShape();
 // }


  y = map(hums[0], 0,100,height/2,0);
  
  fill(c);
  text(place,width-40,y);
  noFill();
  
//  for(int q = 1;q<30;q++){
    beginShape(POLYGON);
    vertex(0,y);
    for(int i = 0;i<hums.length;i++){
      y = ( map(hums[i], 0,100,height/2,0) );// / (q+0.0);
      stroke(c,100);
      curveVertex( map(i,0,hums.length-1,0,width) , y );
    }
    vertex(width,y);
    endShape();
 // } 
    
  }

}




int CONN = 3;
NeuroMesh nm;
float prum = 1;

void setup(){

	size(320,240,P2D);
	nm = new NeuroMesh(width*height);

	rectMode(CENTER);



}

void draw(){

	background(127);


	nm.draw();


}

void mousePressed(){
	nm.resetV();
}



class NeuroMesh{

	Node[] n;
	int len;

	NeuroMesh(int _len){
		len = _len;
		n = new Node[len];

		int X = 0;
		int Y = 0;

		for(int i =0 ;i<len;i++){
			n[i] = new Node(X,Y,i,this);
			X++;
			if(X>=width){
				X=0;
				Y++;
			}
		}

		for(int i =0 ;i<len;i++){
			n[i].createConnections();
		}

	}

	void draw(){

		for(int i =0 ;i<n.length;i++){
			n[i].compute();
			
			if(dist(mouseX,mouseY,n[i].x,n[i].y)<sin(frameCount/5.0)*200.0)
				n[i].setW(0.1);

		}

		for(int i =0 ;i<n.length;i++){
			n[i].draw();

		}

	}

	void resetV(){

		for(int i =0 ;i<n.length;i++){
			n[i].resetVal();
		}
	}
	
	
}

class Teacher{

	NeuroMesh mesh;

	Teacher(NeuroMesh _mesh){
		mesh = _mesh;

	}



}

class Node{

	float x,y;

	float val;
	int id;
	NeuroMesh parent;

	Connection c[];

	Node(float _x,float _y,int _id, NeuroMesh _parent){
		id = _id;
		x = _x;
		y = _y;
		parent = _parent;


		val = random(0,255);

	}

	void createConnections(){
		c = new Connection[0];

		for(int i =0;i<(int)random(1,CONN);i++){
			int q = id;
			while(q==id){
				q = (int)random(parent.len);
			}
			c = (Connection[])append(c,new Connection(this,parent.n[q]));

		}


	}

	void resetVal(){

		val = random(0,255);
	}

	void compute(){
		for(int i =0;i<c.length;i++){
			c[i].stochaist(0.4);
			val += ((c[i].b.val*c[i].w) - val) / c[i].speed;
		}

		prum += (val-prum)/(width*height+0.0);
	}

	void draw(){


		for(int i =0;i<c.length;i++){
			//noStroke();
			stroke(val);
			point(x,y);

			//	stroke(c[i].w*255,50);
			//line(parent.n[c[i].id2].x,parent.n[c[i].id2].y,x,y);

		}

	}
	
	void setVal(float _tmp){
		val = _tmp;
	}
	
	void setW(float _tmp){
		for(int i = 0 ;i<c.length;i++)
		c[i].w = _tmp;
	}
}

class Connection{
	float w;
	Node a,b;
	float speed;

	Connection(Node _a, Node _b){
		a = _a;
		b = _b;
		//println(id2);
		
		speed = constrain(dist(a.x,a.y,b.x,b.y)/12.0,2,width*2);//random(2,100);
		w = random(0,100)/50.0;
	}

	void stochaist(float va){
		w += random(-va,va);
		w = constrain(w,0.1,map(prum,0,255,3,0.2));
	}
}
color [] cols = {#000000,#ffcc00,#ff0000,#ffffff};

Pix[] p;

void setup(){

	size(320,240,P2D);
	
	frameRate(25);

	p = new Pix[width*height];
	for(int y = 0; y<height;y++){
		for(int x = 0; x<width;x++){
			p[y*width+x] = new Pix(x,y);
		}
	}

	loadPixels();
}

void draw(){
	
	int id;
	for(int y = 0; y<height;y++){
		for(int x = 0; x<width;x++){
			id = y*width+x;
			p[id].draw();//
		}
	}


}


class Pix{
	int x,y;
	int state = 0;

	
	Pix(int _x,int _y){
		x = _x;
		y = _y;
		state = 0;
	}

	void draw(){
	
	
		  if(random(50)<49)   
		                  state += 1;
		                                  else
		pixels[y*width+x] = lerpColor(
		cols[state],
		pixels[y*width+((x+width-2)%width)],
		0.0
		);
		
		
		if(state > cols.length-1){
			state = 0;
		}
	}


}

int freq = 1;

String places[] = {"Lisboa","Madrid","Zaragoza","Toulouse","Lyon","Bern","Zurich","Strasbourg","Bamberg","Bayreuth","Plzen","Praha","Pardubice","Brno","Ostrava","Krakow"};
Location loc[];

int minrun = 0;

int minute ,minuteLast;

void setup() {
  size(1680, 700, P2D);
  
  textFont(createFont("Helvetica",9,true));
  textMode(SCREEN);  
  frameRate(25);

  minute = minuteLast = minute();
  stroke(255);
  noFill();


  loc = new Location[places.length];

  for(int i = 0 ;i<loc.length;i++)
    loc[i] = new Location(places[i],this);

}


void draw(){
  
  minute = minute();
  if(minute!=minuteLast){    
    if(minrun%freq == 0){
     for(int i = 0 ;i<loc.length;i++)
      loc[i].update(); 
    }
    minrun++;

  background(0);

  for(int i = 0 ;i<loc.length;i++)
    loc[i].draw();// = new Loc(places[i]);

  line(0,height/2,width,height/2);

  }
  

  minuteLast = minute;

    
  
    
}

void keyPressed(){
  for(int i = 0 ;i<loc.length;i++)
      loc[i].update();
}









class Location{
  XMLElement xml;
  float tempr;
  float hum;

  float temps[] = new float[0];
  float hums[] = new float[0];
  String place;
  
  color c;
  
  PApplet parent;

  Location(String _place,PApplet _parent){
    parent = _parent;
    place = ""+_place;
    c = color(random(100,255),random(100,255),random(100,255));
    update();

  }

  void update(){
    try{
    xml = new XMLElement(parent, "http://www.google.com/ig/api?weather="+place);    
    
    tempr = xml.getChild(0).getChild(1).getChild(2).getFloatAttribute("data");
    String _hum = xml.getChild(0).getChild(1).getChild(3).getStringAttribute("data");
    String _hums[] = splitTokens(_hum," %");
    hum = parseFloat(_hums[1]);

    println(place+" -> "+"temp: "+tempr+"   humidity: "+hum);

    hums = (float[])append(hums,hum);
    temps = (float[])append(temps,tempr);  
    
    }catch(Exception e){
      println("problems during parsing data: "+e); 
    }
  }
  
  void draw(){
   

  float y = map(temps[0], -10,30,height,height/2);
  fill(c);
  text(place,width-40,y);
  noFill();
  
//  for(int q = 1;q<30;q++){
    beginShape(POLYGON);
    vertex(0,y);
    for(int i = 0;i<temps.length;i++){
      y = (map(temps[i], -10,30,height,height/2));// / (q+0.0);
      stroke(c,100);
      curveVertex( map(i,0,temps.length-1,0,width) , y );
    } 
    vertex(width,y);
    endShape();
 // }


  y = map(hums[0], 0,100,height/2,0);
  
  fill(c);
  text(place,width-40,y);
  noFill();
  
//  for(int q = 1;q<30;q++){
    beginShape(POLYGON);
    vertex(0,y);
    for(int i = 0;i<hums.length;i++){
      y = ( map(hums[i], 0,100,height/2,0) );// / (q+0.0);
      stroke(c,100);
      curveVertex( map(i,0,hums.length-1,0,width) , y );
    }
    vertex(width,y);
    endShape();
 // } 
    
  }

}


import com.google.api.translate.Language;
import com.google.api.translate.Translate;

void setup(){

	try{
      // Set the HTTP referrer to your website address.
          Translate.setHttpReferrer("http://processing.org");
          
              String translatedText = Translate.execute("ahoj tam", Language.CZECH, Language.ENGLISH);
              
                  System.out.println(translatedText);
                  
                  }catch(Exception e){
                  	println(e);
                  }
}

//kof@kLab:~/.evolution/mail/local$ cat Vimeo | grep 'Date'

String[] dates;
String[] plays;
String mesice[] = {"January","February","March","April","May","June","July","August","September","October","November","December"};

int mo = 0;
int ply[];

int TOP = 30;
int SMOOTH = 1;

import processing.pdf.*;


PGraphicsPDF pdf;
boolean PDFing = false;
PFont font,font2;

void setup(){                                                             
	size(1024,400,OPENGL);
	//hint(ENABLE_NATIVE_FONTS);
	grab();
	stroke(255,50);
	noFill();
	smooth();

	//println(PGraphicsPDF.listFonts());
	font = createFont("Sawasdee Bold", 9);
	font2 = createFont("Sawasdee Bold",28);
	textFont(font);                                                        
	//textMode(SHAPE);
	
	println(PFont.list());



}

void draw(){

	if (PDFing) {
	pdf = (PGraphicsPDF) createGraphics(width ,height, PDF,  "/desk/VimeoStat" + "_" + nf(day(),2) + "_"+nf(month(),2)+"_"+year()+".pdf");
	beginRecord(pdf);
	
	pdf.textFont(font);
	pdf.textMode(SHAPE);// = SHAPE;

	}
	background(0);

	int cntr = 0;
	float prum = map(ply[0],0,TOP,height,0);
	noFill();


	int len = 30;

	for(int q = 0;q<len;q++){
		beginShape();

		vertex(0,prum);

		for(int i = 0;i<ply.length;i++){
			float x = map(i,0,ply.length-1,0,width);

			float y = map(ply[i],0,TOP,height,0);

			stroke(lerpColor(#ffcc00,#ffffff,norm(q,0,len)),map(q,0,len,10,100));
			prum += (y-prum)/(SMOOTH+0.0+q);
			curveVertex(x,prum);



		}

		vertex(width,prum);
		endShape();

	}





	
	textFont(font2);
	
	text(year(),20,40);
	textFont(font);
	mo=0;
	fill(255);
	for(int i = 0;i<ply.length;i++){
		float x = map(i,0,ply.length,0,width);
		if(cntr%28==0){
			line(x,0,x,height);
			text(mesice[mo],x+10,height-20);
			mo++;
		}

		cntr++;

	}



	if (PDFing) {
		PDFing = false;
		endRecord();
	}

}
void keyPressed(){
	if(key==' '){
		
		PDFing = true;
	}

}


void grab(){

	String command[] = {"grabDates.sh",sketchPath};
	String command2[] = {"grabPlayed.sh",sketchPath};
	exec(command);
	exec(command2);


	dates = loadStrings(sketchPath+"/dates.txt");
	plays = loadStrings(sketchPath+"/played.txt");

	ply = new int[0];

	for(int i = 0;i<plays.length;i++){
		//dates[i] = dates[i].substring(20,dates[i].length());
		plays[i] = plays[i].substring(23,plays[i].length());
		plays[i] = plays[i].substring(0,plays[i].length()-40);
		ply = (int[])append(ply,parseInt(plays[i].split(" ")[1]));
	}

	//println(ply);


}
import com.twitter.processing.*;


// this stores how many tweets we've gotten
int tweets = 0;
// and this stores the text of the last tweet
String tweetText = "";

int y = 0;
boolean hasNew = false;
int no = 0;

float cnt = 0;
float scal = 0.1;
float lay = 500;
float theta = 0;

import processing.pdf.*;

ArrayList data = new ArrayList(0);

boolean grabbing = false;
boolean rec = false;


void setup(){
	size(1200,1200,P2D);

	background(0);

	TweetStream s = new TweetStream(this, "stream.twitter.com", 80, "1/statuses/sample.json", "rbotara", "cigaro");
	s.go();

	//
	smooth();
	stroke(0,50);
	fill(255,40);

	data.add("start!");

	textFont(createFont("Arial",9,true));
	//textMode(SCREEN);
	//
	hint(ENABLE_NATIVE_FONTS);
}

void draw() {

	if(rec){
		beginRecord(PDF, "/desk/wtf.pdf");
		textFont(createFont("Arial",9,true));
	}

	background(0);
	
	noStroke();

	for(int i =0;i<data.size();i++){
		fill(noise(i)*255,noise(i/2)*255,0,80);
		pushMatrix();
		translate(width/2,height/2);
		rotate(radians(map(i,0,data.size(),0,360)));
		text((String)data.get(i),i/3.0,0);
		popMatrix();
	}

	if(rec){
		endRecord();
		rec = false;
	}
}

// called by twitter stream whenever a new tweet comes in
void tweet(Status tweet) {
	// print a message to the console just for giggles if you like
	// println("got tweet " + tweet.id());

	// store the latest tweet text


	//if(!tweet.text().equals("\n")){
	String tmp = tweet.text().replaceAll("\n","");
	//tmp = ""+tmp.replaceAll("\n"," ");


	/*
	if(tmp.lastIndexOf("love")>-1){
		no = tmp.lastIndexOf("love");
}else if(tmp.lastIndexOf("LOVE")>-1){
		no = tmp.lastIndexOf("LOVE");
}else if(tmp.lastIndexOf("Love")>-1){
		no = tmp.lastIndexOf("Love");
}else{
		no = -1;
}*/


	if(grabbing){
		y += 10;
		hasNew = true;
		tweetText = tmp;
		// bump our tweet count by one
		tweets += 1;
		data.add(tweetText);
		//}
	}

}

void keyPressed(){
	if(key==' '){
		grabbing = !grabbing;
		println("grabbin "+grabbing);
	}else if(keyCode==ENTER){
		rec = true;
	}
}

/*

void draw(){


	for(float i = 0 ; i<360 ; i +=0.3){

		pushMatrix();
		theta += 0.1;

		cnt += scal;

		translate(width/2,height/2);
		rotate(radians(i));
		stroke(((noise(cnt*3.0)*255)>188)?color(255,0,0):0,200);
		line(lay,0,lay-25,0);



		
		if((noise(cnt*3.0)*255)>188){
			fill(255,0,0);
			text((char)(int)random(255),lay,-5);
			stroke(#ffcc00,100);
			noFill();
			beginShape();
			vertex(lay, 0);
			bezierVertex(lay, 0, 80, lay, 20, 0);
			endShape();

		}

		popMatrix();
		noFill();
		//ellipse(0,0,noise(cnt)*600*2,noise(cnt)*600*2);

		//	fill(random(120),random(100),0,random(255));
		//text((char)((int)(random(48,150))),noise(cnt)*600,0);






		//translate(150,150);

		//translate(-150,-150);

	}


	lay -= 30;

	if(lay<=30){

		endRecord();
		exit();
	}

}

*/
Pix [][] pix;
boolean blik = false;

void setup(){
	size(320,240,P2D);
	noSmooth();
	frameRate(40);

	pix = new Pix[width][height];

	for(int y = 0;y<height;y++)
		for(int x = 0;x<width;x++)
			pix[x][y] = new Pix(x,y);
}

void draw(){
//	blik = !blik;
	for(int y = 0;y<height;y++)
		for(int x = 0;x<width;x++)
			pix[x][y].draw(blik);

//		saveFrame("out/frame####.png");
}

class Pix{
	int x,y;
	//float c;
	//float cc,speed;

	Pix(int _x,int _y){
		x = _x;
		y = _y;
		//speed = random(10,1000);
	}

	void draw(boolean onOff){
		//cc+=speed/10.0;
		if(onOff)
			stroke(noise(((cos((noise(x+frameCount/10.0)+x)/44.34)+1)*3*(sin((y*noise(frameCount/300.0))/42.1133)+1)*3+frameCount+(sin(0.5*dist(x,y,mouseX,mouseY)) * 10.0) )/10.0)*255);
		else
			stroke(255-noise(((cos(x/44.34)+1)*3+(sin(y/42.1133)+1)*3+frameCount+(sin(0.05*dist(x,y,mouseX,mouseY)) * 30.0) )/10.0)*255);

		point(x,y);
		
		
	}
}
import com.twitter.processing.*;

// this stores how many tweets we've gotten
int tweets = 0;
// and this stores the text of the last tweet
String tweetText = "";

int y = 0;
boolean hasNew = false;
int no = 0;

void setup() {
	size(1024,1200,P2D);
	// set up fonts
	PFont font = createFont("Veranda",9,false);
	textFont(font, 9);
	textMode(SCREEN);
	// set up twitter stream object
	TweetStream s = new TweetStream(this, "stream.twitter.com", 80, "1/statuses/sample.json", "rbotara", "cigaro");
	s.go();

	fill(255);
	hint(ENABLE_NATIVE_FONTS);
	background(0);
}

void draw() {
	if(y>height){
		y = 0;
		background(0);
	}

	if(hasNew&&tweetText.length()>no+5&&no>-1){
		fill(255);
		text(tweetText.substring(0,no), 10, 10+ y );
		fill(255,0,0);
		text(tweetText.substring(no,no+2));
		fill(255);
		text(tweetText.substring(no+2,tweetText.length()));
		hasNew = false;
	}
}

// called by twitter stream whenever a new tweet comes in
void tweet(Status tweet) {
	// print a message to the console just for giggles if you like
	// println("got tweet " + tweet.id());

	// store the latest tweet text

	String tmp = tweet.text();

	if(tmp.lastIndexOf("do")>-1){
		no = tmp.lastIndexOf("do");
	}else if(tmp.lastIndexOf("DO")>-1){
		no = tmp.lastIndexOf("DO");
	}else if(tmp.lastIndexOf("Do")>-1){
		no = tmp.lastIndexOf("Do");
	}else{
		no = -1;
	}

	if(no > -1){
		y += 10;
		hasNew = true;
		tweetText = tmp;
		// bump our tweet count by one
		tweets += 1;
	}
}


int num = 10; 
Kruzidlo k[];

void setup(){

	size(800,600,P2D);
	
	k = new Kruzidlo[num];

	
	for(int i = 0 ;i<k.length;i++){
		k[i] = new Kruzidlo();
	}
	
	background(255);
	stroke(0,60);
}



void draw(){

	
	
	for(int i = 0 ;i<k.length;i++){
		k[i].compute();
	}
	
	
	for(int i = 0 ;i<k.length;i++){
		k[i].draw();
	}


}

class Kruzidlo{

	float lx,ly,x,y,pol,speed;
	int id;
	
	Kruzidlo(){
		lx = x = random(width);
		ly = y = random(height);
		pol = 1.1;
		speed = random(1,255);
	}
	
	void compute(){
		lx = x;
		ly = y;
		
		x += cos(frameCount/speed+0.321)*pol;
		y += sin(frameCount/speed)*pol;
		
		pol = noise(frameCount/30.0)*10;
		
		
	}
	
	void draw(){
		line(x,y,lx,ly);
	
	}
	


}


/*
*
*
*
*/

Mesh m[] = new Mesh[30];

void setup(){

	size(300,300,P3D);

	background(255);

	stroke(0,30);
	noFill();



	for(int i = 0;i<m.length;i++)
		m[i] = new Mesh(i,(int)random(2550));

	noSmooth();
}





void draw(){


	background(255);

	pushMatrix();

	translate(width/2,height/2,-width);
	rotateY(radians(frameCount));
	for(int i = 0;i<m.length;i++){
		m[i].compute();
		m[i].draw();
	}


	popMatrix();
}


class Mesh{
	int id,len;
	float[] x,y,z;
	float move = 50.0;
	float speed = 1.2;
	float rx,ry,rz;

	Mesh(int _id,int _len){
		id = _id;
		len = _len;

		rx = random(10000);
		ry = random(10000);
		rz = random(10000);



		x = new float[len];
		y = new float[len];
		z = new float[len];

		for(int i = 0;i<len;i++){
			x[i] = 0;
			y[i] = 0;
			z[i] = 0;
		}
	}

	void compute(){

		if(id==0){
			x[0] += (noise(rx+frameCount/10.0+id)-0.49)*move;
			y[0] += (noise(ry+frameCount/10.0+id)-0.49)*move;
			z[0] += (noise(rz+frameCount/10.0+id)-0.49)*move;



			x[0] -= x[0]/30.0;
			y[0] -= y[0]/30.0;
			z[0] -= z[0]/30.0;


		}else{
			x[0] += (m[0].x[0]-x[0])/speed;// += (noise(rx+frameCount+id)-0.49)*move;
			y[0] += (m[0].y[0]-y[0])/speed;
			z[0] += (m[0].z[0]-z[0])/speed;
			
			
			x[0] += (noise(rx+frameCount/10.0+id)-0.49)*move*10.0;
			y[0] += (noise(ry+frameCount/10.0+id)-0.49)*move*10.0;
			z[0] += (noise(rz+frameCount/10.0+id)-0.49)*move*10.0;
		}

		for(int i = 1;i<len;i++){
			
			x[i] += (x[i-1]-x[i]) / speed;
			y[i] += (y[i-1]-y[i]) / speed;
			z[i] += (z[i-1]-z[i]) / speed;
		}

	}

	void draw(){

		beginShape();
		//vertex(x[0],y[0],z[0]);

		for(int i = 1;i<len-1;i++){
			vertex(x[i],y[i],z[i]);
		}

		vertex(x[len-1],y[len-1],z[len-1]);

		endShape();


	}






}


// Example by Tom Igoe

import processing.serial.*;

// The serial port:
Serial myPort;

int lf = 10;

void setup(){
	// List all the available serial ports:
	println(Serial.list());

	size(200,200,P2D);
	/*  I know that the first port in the serial list on my mac
	is always my  Keyspan adaptor, so I open Serial.list()[0].
	Open whatever port is the one you're using.
	*/                                  
	myPort = new Serial(this, Serial.list()[0], 115200);

	// Send a capital A out the serial port:
	myPort.write(65);
	stroke(255);
}

float sm[] = new float[8];
float m[] = new float[8];
byte[] q;
void draw(){
	background(0);

	while (myPort.available() > 0) {
		q = myPort.readBytesUntil('\n');



		/*
		if(a!=null){
			//sm[] = parseInt(a.substring(1,a.length()));		
			String parse = (parseInt(a.charAt(0))-48)+" "+a.substring(3,a.length());
			//if(!parse.equals("\r")){
			//String tmp[] = splitTokens(parse," ");
			//m[parseInt(tmp[0])] = parseInt(tmp[1]);
		//	println(parse);
			}
	}*/

		//println(a);
	}

	String msg = "";
	
	if(q!=null)
		for(int i = 0;i<q.length;i++){
		//	msg = "";
			//if(i!=1&&i!=2)
			msg += char(q[i])+"";
		
			if(i==0)
				msg += " ";
		}
		
		String parse[] = splitTokens(msg," ");
		//println(parse[0]+":"+parse[1]);


	for(int i = 0;i<sm.length;i++){
		line(0,map(sm[i],0,1024,height,0),width,map(sm[i],0,1024,height,0));
	}




}

import java.net.*;
import java.io.*;


/*
Authorization: OAuth realm="",
oauth_consumer_key="c1f5add1d34817a6775d10b3f6821268",
oauth_version="1.0",
oauth_signature_method="HMAC-SHA1",
oauth_timestamp="1273015230",
oauth_nonce="033508fdbd7ba9edf2aec63c19f9e7ca",
oauth_token="baf0a5ea862f5d47680ad99c3f9d3336",
oauth_signature="eOfPn9jA4OgN%2B0ZaU6VwARAax%2Fw%3D"


http://vimeo.com/api/rest/v2?method=vimeo.videos.getLikes
*/

String data[];


XMLElement xml;

float temp,humidity;
Wind wind;


void setup(){

	size(200, 200,P2D);

	update();



}

void update(){

	try{
		//URL vimeo = new URL("http://www.wunderground.com/global/CZ.html");
		URL google = new URL("http://www.google.com/ig/api?weather=Prague");
		BufferedReader in = new BufferedReader(
		                            new InputStreamReader(
		                                    google.openStream()));

		data = new String[0];
		String inputLine;

		while ((inputLine = in.readLine()) != null){
			//System.out.println(inputLine);
			data = (String[])append(data,inputLine);
		}

		in.close();

	}catch(Exception e){
		println(e);
	}

	saveStrings("current.xml",data);


	xml = new XMLElement(this, sketchPath+"/current.xml");

	XMLElement root = xml.getChild(0).getChild(1);

	temp = root.getChild(2).getFloatAttribute("data");

	String parse =  root.getChild(3).getStringAttribute("data");
	humidity = parseInt(parse.substring(10,parse.length()-1));

	String w = root.getChild(5).getStringAttribute("data");
	wind = new Wind(w.substring(6,w.length()-4));


	println(temp + " : " + humidity + " : " + wind.strength);

}

void keyPressed(){

	update();
}


void draw(){

	background(0);

	stroke(#ff0000);

	line(0,map(temp,-10,40,height,0),width,map(temp,-10,40,height,0));
	stroke(#ffff00);
	line(0,map(humidity,0,100,height,0),width,map(humidity,0,100,height,0));

	stroke(#0000ff);
	line(0,map(wind.strength,0,50,height,0),width,map(wind.strength,0,50,height,0));



}

class Wind{
	float angle;
	float strength;

	Wind(String s){
		String tmp[] = s.split(" ");
		strength = parseFloat(tmp[2]);
	}
}








boolean rightDown, leftDown, middleDown;
boolean shiftDown, ctrlDown = false;
boolean drag = false;


void mousePressed()
{
	if (mouseButton==LEFT)
	{
		leftDown = true;
		tool.Calculate();
	}

}

//mys odkliknuta
void mouseReleased()
{



	if (mouseButton==RIGHT)
	{
		rightDown = true;
		tool.Calculate();
	}


	leftDown = rightDown = middleDown = false;
	drag = false;
}


//mys tazena
void mouseDragged()
{
	rightDown = false;
	drag = true;

	if (mouseButton==RIGHT && !shiftDown)
	{
		// mouse controlled rotation
		float x1 = mouseX-pmouseX;
		float y1 = mouseY-pmouseY;

		//add to global rotation
		rotX += -y1 * 0.01;
		rotY += x1 * 0.01;
	}

	if (mouseButton==RIGHT && shiftDown)
	{
		float x1 = mouseX-pmouseX;
		float y1 = mouseY-pmouseY;

		panY += y1*2;
		panX += x1*2;
	}
}

void keyPressed()
{
	if (keyCode == ENTER)
	{

	}

	else if(keyCode == DELETE)
	{
		for(int i = 0; i < area.length; i++)
		{
			if(! area[i].isSelected)
			{
				area[i].Kill();
			}
		}
	}
	else if(keyCode == UP)
	{

	}
	else if(keyCode == DOWN)
	{

	}
	else if( key == 32) // SPACE
	{
		if(speed == 1) speed = 3;
		else if(speed == 3) speed = 10;
		else if(speed == 10) speed = 1;
	}
	else if( keyCode == CONTROL)
	{
		ctrlDown = true;
	}
	else if( keyCode == SHIFT)
	{
		shiftDown = true;
	}
	else if(key == 'S' || key == 's')
	{
		cam.SaveScreen();
	}
	else if(key == 'r'){
		rec = !rec;
		println("exporting pdf..");

	}


}


//klavesa odkliknuta
void keyReleased()
{
	shiftDown = false;
}

































Spray[] S = new Spray[0];
static int numberOfSpray = 0;

class Spray
{
            int id;
            int produceTime;
            Point origin;
            Vector dir;

            boolean isOver, isSelected;


            Spray(float x, float y, float z)
            {
                        id = numberOfSpray;
                        numberOfSpray++;
                        produceTime = 150;

                        origin = new Point(x,y,z);
                        dir = new Vector (0.1,0,0);
                        S = (Spray[]) append (S, this);
            }

            void Direction (Vector dir)
            {
                        this.dir = dir;
                        this.dir.Unitize();
            }

            void Calculate()
            {
                        if(time % produceTime == 0) 
                        {
                                    for (int i = 0; i < S.length; i++)
                                    {
                                                if(i != id)  new Ant(this, S[i]);
                                    }
                        }
            }

            void ProduceAnt()
            {

            }

            boolean IsOver()
            {
                        int scx,scy;
                        int tolerance = 10;
                        // mouse hit detection using screnX, screenY
                        scx = int(screenX(origin.x, origin.y, origin.z));
                        scy = int(screenY(origin.x, origin.y, origin.z));

                        if (scx > mouseX-tolerance && scx < mouseX+tolerance && scy > mouseY-tolerance && scy < mouseY+tolerance) return true;
                        else	return false;
            }

            void Draw()
            {
                        isOver = IsOver();

                        if(isSelected) stroke(232,120,20);
                        else if(isOver) stroke(26,120,200);
                        else stroke(120);

                        origin.Draw(15);           
                        
                        fill(255,0,0);
                        text(id,screenX(origin.x, origin.y, origin.z)+10, screenY(origin.x, origin.y, origin.z)-10);
            }

}

void PolozSpray()
{
            Point temp = new Point(cam.Picking());
            new Spray(temp.x, temp.y, temp.z);           
}









Area[] area = new Area[0];
static int numberOfArea = 0;

class Area
{
            int id;
            Point minP, maxP;
            Line ln1, ln2, ln3, ln4;
            int segX, segY;
            Sensor[] sensors;

            color fromColor, toColor;

            boolean isOver, isSelected;

            Area(Point p1, Point p2)
            {
                        id = numberOfArea;
                        numberOfArea ++;

                        Point minPoint, maxPoint;
                        minPoint = new Point(0,0,0);
                                             maxPoint = new Point(0,0,0);
                        if(p1.x < p2.x)
                        {
                                    minPoint.x = p1.x ;
                                                maxPoint.x = p2.x ;
                        }
                        else
                        {
                                    minPoint.x = p2.x;
                                    maxPoint.x = p1.x;
                        }
                        if(p1.y < p2.y)
                        {
                                    minPoint.y = p1.y ;
                                                maxPoint.y = p2.y ;
                        }
                        else
                        {
                                    minPoint.y = p2.y;
                                    maxPoint.y = p1.y;
                        }


                        minP = minPoint;
                        maxP = maxPoint;

                        ln1 = new Line(new Point(minP.x, minP.y, minP.z), new Point(maxP.x, minP.y, minP.z));
                        ln2 = new Line(new Point(maxP.x, minP.y, minP.z), new Point(maxP.x, maxP.y, minP.z));
                        ln3 = new Line(new Point(maxP.x, maxP.y, minP.z), new Point(minP.x, maxP.y, minP.z));
                        ln4 = new Line(new Point(minP.x, maxP.y, minP.z), new Point(minP.x, minP.y, minP.z));

                        sensors = new Sensor[0];

                        segX = 100;
                        segY = 100;
                        fromColor = color(200, 190, 0);
                        toColor = color(0, 102, 153);

                        float last_i, last_k;
                        last_i = minP.x;
                        last_k = minP.y;


                        for(float i = minP.x; i <= maxP.x ; i += (maxP.x-minP.x) / segX)
                        {
                                    for(float k = minP.y; k <= maxP.y ; k += (maxP.y-minP.y) / segY)
                                    {
                                                Sensor tempS = new Sensor(new Point(last_i, last_k, 0), new Point(i, k, 0));
                                                sensors = (Sensor[]) append(sensors,tempS);
                                                last_k = k;
                                    }      
                                    last_k = minP.y;
                                    last_i = i;
                        }


            }

            void AddArea()
            {
                        area = (Area[]) append (area, this);
            }

            void Calculate()
            {

                        for(int i = 0 ; i < sensors.length; i++)
                        {
                                    sensors[i].Calculate();
                        }
            }

            boolean IsOver()
            {
                        Point mouseProj = cam.Picking();
                        Point tempPoint1 = ln1.GetClosestPoint(mouseProj);
                        Point tempPoint2 = ln2.GetClosestPoint(mouseProj);
                        Point tempPoint3 = ln3.GetClosestPoint(mouseProj);
                        Point tempPoint4 = ln4.GetClosestPoint(mouseProj);
                        if(mouseProj.DistanceTo(tempPoint1) < 10) return true; 
                        if(mouseProj.DistanceTo(tempPoint2) < 10) return true; 
                        if(mouseProj.DistanceTo(tempPoint3) < 10) return true; 
                        if(mouseProj.DistanceTo(tempPoint4) < 10) return true; 

                        return false;
            }

            String[] GetInfo()
            {
                        String[] answ = new String[0];
                        answ = append(answ,"Name : Area " + id);

                        answ = append(answ,"");
                        answ = append(answ, "BBox min : " );
                        answ = append(answ, " " + minP.ToString());
                        answ = append(answ,"");
                        answ = append(answ, "BBox max : " );
                        answ = append(answ, " " + maxP.ToString());

                        return answ;
            }

            void Kill()
            {                        
                        Area[] temp = new Area[0];
                        int noAnt = 0;
                        if(area.length > 0)
                        {
                                    for(int i = 0 ; i < area.length; i++)
                                    {
                                                if(i != id)
                                                {
                                                            temp = (Area[]) append(temp,area[i]);
                                                }            
                                    }
                                    numberOfArea --;
                        }
                        area = temp;
            }

            void Draw()
            {
                        isOver = IsOver();
                        int nejValue = 1;

                        for(int i = 0; i < sensors.length; i ++)
                        {
                                    if(sensors[i].value > nejValue) nejValue = sensors[i].value;
                        }

                        

                         noStroke();
                        //stroke(200);
                        rectMode(CORNERS);
                        for(int i = 0; i < sensors.length; i ++)
                        {
                                    fill(lerpColor(fromColor,toColor,sensors[i].value/(float)nejValue));
                                    rect(sensors[i].minP.x, sensors[i].minP.y, sensors[i].maxP.x, sensors[i].maxP.y);       
                        }
                        rectMode(CORNER);
                        
                        if(isSelected)  stroke(232,120,20);
                        else if(isOver) stroke(26,120,200);
                        else stroke(120);
                        ln1.Draw();
                        ln2.Draw();
                        ln3.Draw();
                        ln4.Draw();

            }
}

class Sensor
{
            Point minP, maxP;
            int value;

            Sensor(Point minPoint, Point maxPoint)
            {
                        minP = minPoint;
                        maxP = maxPoint;    
                        value = 0;
            }

            void Calculate()
            {
                        for (int i = 0; i < A.length; i ++)
                        {
                                    if(IsInBBox(A[i].origin)) value++;
                        }
            }

            boolean IsInBBox(Point test)
            {
                        if(test.x >= minP.x && test.x <= maxP.x)
                        {
                                    if(test.y >= minP.y && test.y <= maxP.y)
                                    {
                                                if(test.z >= minP.z && test.z <= maxP.z)
                                                {
                                                            return true;
                                                }
                                    }
                        }
                        return false;
            }

}

Point tmpFirstArea = null;
void PolozArea()
{
            if(tmpFirstArea == null)
            {
                        tmpFirstArea = cam.Picking();
            }
            else
            {
                        Point tmpSecondArea =  cam.Picking();
                        Area area = new Area(tmpFirstArea,tmpSecondArea);
                        area.AddArea();
                        tmpFirstArea = null;
                        tmpSecondArea = null;
            }
}






























Feromon[] F = new Feromon[0];
static int numberOfFeromon = 0;


class Feromon
{
            int id;
            float maxLife, life, parentLife;
            Point origin, moveWay;
            int parentID, parentFrom, parentTo;
            float[] parentVidel;

            boolean isOver, isSelected;

            Feromon(Ant parent)
            {
                        id = numberOfFeromon;
                        numberOfFeromon ++;
                        maxLife = 5000;
                        life = maxLife;
                        origin = new Point (parent.origin);

                        parentID = parent.id;
                        parentFrom =  parent.parentSpray.id;
                        parentTo =  parent.targetSpray.id;
                        parentVidel = parent.videlID;
                        parentLife =  parent.life;

                        F = (Feromon[]) append (F, this);
            }

            void Calculate()
            {
                        if(life <= 0) Kill();
                        life--;           
            }

            void Kill()
            {                  
                        id = -1;
            }

            boolean IsOver()
            {
                        int scx,scy;
                        int tolerance = 5;
                        // mouse hit detection using screnX, screenY
                        scx = int(screenX(origin.x, origin.y, origin.z));
                        scy = int(screenY(origin.x, origin.y, origin.z));

                        if (scx > mouseX-tolerance && scx < mouseX+tolerance && scy > mouseY-tolerance && scy < mouseY+tolerance) return true;
                        else	return false;
            }

String[] GetInfo()
            {
                        String[] answ = new String[0];
                        answ = append(answ,"Name : Feromon " + id);

                        answ = append(answ,"");
                        answ = append(answ, "Life : " + life);
                        answ = append(answ, "FromID : " + parentFrom);
                        answ = append(answ,"");

                        for(int i = 0; i < parentVidel.length; i++)
                        {
                                    answ = append(answ, "VidelID " + i + " : " + parentVidel[i]);
                        }
                        return answ;
            }
            
            void Draw()
            {
                        isOver = IsOver();

                        if(isSelected) stroke(232,120,20);                                                      
                        else if(isOver) stroke(26,120,200);
                        else  stroke(lerp(0,255,life/maxLife));

                        if(id != -1) 
                        {
                                    origin.Draw(1);      
                        }
            }


}

void ClearFeromons()
{
            Feromon[] temp = new Feromon[0];
            int noFeromon = 0;
            if(F.length > 0)
            {
                        for(int i = 0 ; i < F.length; i++)
                        {
                                    if(F[i].id != -1)
                                    {
                                                F[i].id = noFeromon;
                                                temp = (Feromon[]) append(temp,F[i]);
                                                noFeromon ++;
                                    }            
                        }

            }
            numberOfFeromon = noFeromon-1;
            F = new Feromon[0];
            F = temp;    
}














class ExternalData
{
  String path;
  float scaleKoef = 0.007;

  ExternalData()
  {
    this.path = sketchPath;
  }

  void Import()
  {
    int noPt, noLine;
    noPt = noLine = 0;
    while(true)
    {
      try{

        String radek[] = loadStrings(path + "/data/import.txt");
        for (int i=0; i < radek.length; i++)
        {
          String[] data = split(radek[i], " ");

          if(data[0].equals("pt"))
          {
            new Spray(float(data[1])*scaleKoef,float(data[2])*scaleKoef,float(data[3])*scaleKoef);
            noPt++;
          }
          if(data[0].equals("ln"))
          {
            Wall w = new Wall(new Point(float(data[1])*scaleKoef,float(data[2])*scaleKoef,0) , new Point(float(data[4])*scaleKoef,float(data[5])*scaleKoef,0));
            w.AddWall();
            noLine++;
          }
        }    
        println("nactena data ze souboru import.txt : " + noPt + " Spray; " + noLine + " Wall" ); 

        break;
      }
      catch(NullPointerException e) 
      {
        continue;
      }
    }

  }

  void Export()
  {
    int noPt =0;
    int noPolyline = 0;
    int noSeg;

    while(true)
    {
      try{

        String[] radek = new String[0];

        // zapis kotev
        for (int i = 0; i < F.length ; i++)
        {
          radek = (String[]) append(radek, "pt "+ noPt + " " + F[i].origin.x*1/scaleKoef + " " + F[i].origin.y*1/scaleKoef + " " + F[i].origin.z*1/scaleKoef + "\t");
          noPt++;
        }
        /*
                         // zapis retezu
         for(int i = 0 ; i < R.length; i++)
         {
         String temp = "polyline "+ noPolyline +  " " + R[i].noSegment + " ";
         noSeg = 0;
         for(int j = 0; j < R[i].seg.length; j++)
         {
         temp += R[i].seg[j].origin.x*1/scaleKoef + " " + R[i].seg[j].origin.y*1/scaleKoef + " " + R[i].seg[j].origin.z*1/scaleKoef + " ";           
         noSeg++;
         }
         temp += "\t";
         radek = (String[]) append(radek,temp);
         noPolyline++;
         }
         
         for(int i = 0 ; i < Konz.length; i++)
         {
         String temp = "polyline "+ noPolyline +  " " + 2 + " ";
         
         temp += Konz[i].ptStart.origin.x*1/scaleKoef + " " + Konz[i].ptStart.origin.y*1/scaleKoef + " " + Konz[i].ptStart.origin.z*1/scaleKoef + " ";           
         temp += Konz[i].ptEnd.origin.x*1/scaleKoef + " " + Konz[i].ptEnd.origin.y*1/scaleKoef + " " + Konz[i].ptEnd.origin.z*1/scaleKoef + " ";   
         
         temp += "\t";
         radek = (String[]) append(radek,temp);
         noPolyline++;
         }
         */

        saveStrings(path + "/data/export.txt", radek);
        println("zapsana data do souboru export.txt"); 

        break;
      }
      catch(NullPointerException e) 
      {
        createOutput(path + "/data/export.txt");
      }
    }

  }

  void Load()
  {
    // DOPSAT VYBER SOUBORU K NACTENI

    int noPt =0;
    /*
                        while(true)
     {
     try{
     // pri loadu smaze Kotvay na scene
     // NEFUNGUJE DOBRE            
     for (int i = 0; i<K.length; i++)
     {
     K[i].Destroy();           
     }
     
     // nacitani souboru
     String radek[] = loadStrings(path + "/save.txt");
     for (int i=0; i < radek.length; i++)
     {
     String[] data = split(radek[i], " ");
     
     if(data[0].equals("pt"))
     {
     new Kotva(new Point(float(data[1]),float(data[2]),float(data[3])));
     noPt++;
     }
     }    
     println("nactena data ze souboru save.txt : " + noPt + " Kotev" ); 
     
     break;
     }
     catch(NullPointerException e) 
     {
     continue;
     }
     }
     */
  }

  void Save()
  {
    // DOPSAT VYBER SOUBORU K ULOZENI

    int noPt =0;
    /*
                        while(true)
     {
     try{
     
     String[] radek = new String[K.length];
     for (int i = 0; i < K.length ; i++)
     {
     radek[i] = "pt " + K[i].origin.x + " " + K[i].origin.y + " " + K[i].origin.z + "\t";
     noPt++;
     }
     saveStrings(path + "/save.txt", radek);
     println("uspesne ulozeni do souboru save.txt : " + noPt + " Kotev" ); 
     
     break;
     }
     catch(NullPointerException e) 
     {
     createOutput(path + "/save.txt");
     }
     }
     */
  }

}




































float scrn[] = {
                       0, 0, 0};
float model[] = new float[3];

// translation
float rotX, rotY;
float panX, panY;
float ZOOM;

class Camera
{
	PGraphics3D p3d;
	PMatrix3D mat = new PMatrix3D();
	PMatrix3D proj = new PMatrix3D();
	PMatrix3D camMatrix = new PMatrix3D();
	PMatrix3D modvw = new PMatrix3D();
	PMatrix3D modvwInv = new PMatrix3D();
	PMatrix3D screen2Model = new PMatrix3D();

	Vector xAxis, yAxis, zAxis;
	Plane cPLN;
	boolean transWorld;

	float ZOOM2 = 10;

	Camera()
	{
		addMouseWheelListener(
		        new java.awt.event.MouseWheelListener()
		        {
			        public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt)
			        {
				        int notches = evt.getWheelRotation();
				        if(notches!=0)
				        {
					        ZOOM2+=notches*2.5;
				        }
			        }
		        }
		);

		p3d = (PGraphics3D)g;
		p3d.getMatrix(mat);


		xAxis = new Vector(1,0,0);
		yAxis = new Vector(0,1,0);
		zAxis = new Vector(0,0,1);


		// konstrukcni rovina
		cPLN = new Plane(0,0,0);
		cPLN.displaySize = 100;
		cPLN.numOfGrid = 4;
	}


	void preDraw()
	{
		ZOOM += (ZOOM2*70-ZOOM)/10.0;

		pushMatrix();

		//apply mouse rotation and translation to center of screen
		translations();
		getMatrices();
		applyMatrices();

		if(!rec)
			cPLN.Draw();
	}

	void translations()
	{

		translate((panX+width/2)*1, (panY+height/2)*1,-ZOOM);
		transWorld = true;

		if(!rec){
			rotateX(-rotX);
			rotateZ(rotY);
		}
		//mouse rotate
		//   rotateX(-rotX);
		//    rotateZ(rotY);
	}

	void getMatrices()
	{
		p3d.getMatrix(mat);

		// otoceni yAxis podle standartu
		mat.m10 = -mat.m10;
		mat.m11 = -mat.m11;
		mat.m12 = -mat.m12;
		// mat.m03 = panX+width/2;
		//              mat.m13 =panY+height/2;
		p3d.setMatrix(mat);

		//get 3d matrices
		proj = p3d.projection.get();

		camMatrix = p3d.camera.get();
		modvw = p3d.modelview.get();
		modvwInv = p3d.modelviewInv.get();

		xAxis = new Vector(mat.m00,mat.m01,mat.m02);
		yAxis = new Vector(mat.m10,mat.m11,mat.m12);
		zAxis = new Vector(mat.m20,mat.m21,mat.m22);
	}

	void applyMatrices()
	{
		screen2Model.mult(scrn, model);
		screen2Model =  modvwInv;
		screen2Model.apply(camMatrix);
	}

	void postDraw()
	{
		popMatrix();
		transWorld = false;
	}



	Point GetCamera()
	{
		//   PMatrix3D mat = new PMatrix3D();
		//    p3d.getMatrix(mat);

		//   if (! transWorld) preDraw();

		Vector vX = xAxis;
		Vector vY = yAxis;
		Vector vZ = zAxis;

		vX.MultipleBy(-mat.m03);
		vY.MultipleBy(-mat.m13);
		vZ.MultipleBy(-mat.m23);


		Point camPt = new Point(0,0,0);
		camPt.Plus(vX);
		camPt.Plus(vY);
		camPt.Plus(vZ);

		//   if (! transWorld) postDraw();

		return camPt;
	}

	Point GetTarget()
	{
		// pokud probihaji mimo transformaci matic, pak si svet docasne transformuje

		if (! transWorld) preDraw();

		//   PMatrix3D mat = new PMatrix3D();
		//    p3d.getMatrix(mat);

		Vector vX = xAxis;
		Vector vY = yAxis;
		Vector vZ = zAxis;

		vX.MultipleBy(-mat.m03);
		vY.MultipleBy(-mat.m13);
		//  vZ.MultipleBy(-mat.m23);

		Point targetPt = new Point(0,0,0);
		targetPt.Plus(vX);
		targetPt.Plus(vY);

		if (! transWorld) postDraw();


		// konec transformace

		return targetPt;
	}

	float DistanceFrom(Point pt)
	{

		/*
		 pushMatrix();
		 
		 if (! transWorld) preDraw();
		 
		 translations();
		 Point camPt = new Point(GetCamera());
		 //     float dis = camPt.DistanceTo(pt);
		 
		 if (! transWorld) postDraw();
		 popMatrix();
		 */
		return 1;//dis;
	}

	void Print()
	{
		Point pos = GetCamera();
		Point targ = GetTarget();
		println( "camera [ " + pos.x+ " ; " + pos.y + " ; " + pos.z + " ]");
		println( "target [ " + targ.x+ " ; " + targ.y + " ; " + targ.z + " ]");  // CHYBA - VYPISUJE STEJNE HODNOTY JAKO CAMERA
	}


	Point Picking()
	{
		// pokud probihaji mimo transformaci matic, pak si svet docasne transformuje
		if (! transWorld) preDraw();

		scrn[0] = mouseX;
		scrn[1] = mouseY;
		scrn[2] = 0;

		model = new float[3];

		applyMatrices();
		Point camPt = GetCamera();

		if (! transWorld) postDraw();

		// konec transformace


		return cPLN. IntersectionLine( new Point( model[0],model[1],model[2] ) , camPt );
	}

	void SaveScreen()
	{
		String path = "D:/Data/processing/ScreenShots/";
		try{
			File dir = new File(path);

			String[] stavajici = dir.list();
			int count = stavajici.length;

			String fileName = "";

			if(count < 10) fileName = "00000"+count;
			else if( count >= 10 && count < 100) fileName = "0000"+count;
			else if( count >= 100 && count < 1000) fileName = "000"+count;
			else if( count >= 1000 && count < 10000) fileName = "00"+count;
			else if( count >= 10000 && count < 100000) fileName = "0"+count;
			else if( count >= 100000 && count < 1000000) fileName = ""+count;

			if(count < 9999999)
			{
				save(path + fileName + ".png");
				println ("Screen " + fileName + " byl uspesne ulozen do adresare " + path);
			}
			else println("pocet ScreenShotu prekrocil predvidanou mez, zapsi se nezdaril");
		}
		catch (NullPointerException e)
		{
			println("neni mozne ulozit ScreenSchot do adreseare " + path);
		}
	}

}








Wall[] W = new Wall[0];

class Wall
{
            Point A, B;
            Line wall;
            Point[] refPt;
            float numRef = 200;

            Wall()
            {
                        wall = new Line(new Point(0,0,0), new Point(1,0,0));

                        refPt = new Point[0];
                        float delka = wall.Delka();
                        for(int i = 0; i < numRef+1; i++)
                        {
                                    refPt = (Point[]) append (refPt, wall.PointAt(i/numRef));     
                        }
            }

            Wall(Point ptA, Point ptB)
            {
                        wall = new Line(ptA, ptB);

                        refPt = new Point[0];
                        float delka = wall.Delka();
                        for(int i = 0; i < numRef+1; i++)
                        {
                                    refPt = (Point[]) append (refPt, wall.PointAt(i/numRef));     
                        }
            }

            void AddWall()
            {
                        W = (Wall[]) append (W, this);
            }

            void Draw()
            {
                        stroke(0);
                        wall.Draw();
            }
}


Point tmpFirst = null;
void PolozWall()
{
            if(tmpFirst == null)
            {
                        tmpFirst = cam.Picking();
            }
            else
            {
                        Point tmpSecond =  cam.Picking();

                        Wall w = new Wall(tmpFirst,tmpSecond);
                        w.AddWall();
                        tmpFirst = null;
                        tmpSecond = null;
            }
}









Ant[] A = new Ant[0];
static int numberOfAnt = 0;

class Ant
{
            int id;
            int maxLife, life, produceTime;
            float lastCorner, fromLastCorner;
            float[] videlID;
            Point origin, moveWay;
            Vector move;
            Spray parentSpray, targetSpray;
            float bodySize, viewSize, rozhlidnuti;
            float bboxX1, bboxX2, bboxY1, bboxY2, bboxZ1, bboxZ2;

            PseudoRandom rnd ;
            Feromon nejlepsiFeromon = null;
            boolean nahodnyPohyb = true;
            boolean isOver, isSelected;
	    float tailX[];
	    float tailY[];
	    	    int tailLen;
	    int cc = 0;

            Ant(Spray parent, Spray target)
            {
                        id = numberOfAnt;
                        numberOfAnt ++;
                        this.parentSpray = parent;
                        this.targetSpray = target;

                         tailLen = maxLife = 2000;
                        life = maxLife;
                        produceTime = floor(random(40,100));
                        lastCorner = 60;
                        bodySize = 10;
                        rozhlidnuti = floor(random(100,150));
                        viewSize = random(300,800);
                        fromLastCorner = lastCorner;

                        moveWay =  new Point(parent.origin);
                        origin = new Point(parent.origin);
                        move = new Vector(parent.dir);
                        rnd = new PseudoRandom(10,27);

                        RefreshBBox();
			
			tailX = new float[tailLen];
			tailY = new float[tailLen];
			
			for(int i =0;i<tailLen;i++){
				tailX[i] = origin.x;
				tailY[i] = origin.y;
			}
			
                        videlID =new float[numberOfSpray];
                        videlID[parentSpray.id] = life;

                        A = (Ant[]) append (A, this);
            }

            float IsInRange(Point test, float range)
            {
                        if(test.x > bboxX1 && test.x < bboxX2)
                        {
                                    if(test.y > bboxY1 && test.y < bboxY2)
                                    {
                                                if(test.z > bboxZ1 && test.z < bboxZ2)
                                                {
                                                            if(! origin.CompareTo(test))
                                                            {
                                                                        float dis = origin.DistanceTo(test);
                                                                        if( dis < range)
                                                                        {
                                                                                    return dis;           
                                                                        }
                                                            }
                                                }
                                    }
                        }
                        return -1;
            }

            void TryFeromon(Feromon f)
            {
                        try
                        {
                                    if(f.parentLife > nejlepsiFeromon.parentLife)
                                    {
                                                nejlepsiFeromon = f;       
                                    }
                        }
                        catch(NullPointerException e)
                        {
                                    nejlepsiFeromon = f;       
                        }      
            }

            boolean IsVisible(Point target)
            {
                        if(W.length < 1) 
                        {
                                    if (IsInRange(target, viewSize) == -1) return false;
                                    else return true;
                        }
                        else
                        {
                                    Line seeLn = new Line(origin, target);         
                                    boolean neniBranen = true;
                                    for(int i = 0; i < W.length; i++)
                                    {
                                                Point crossPt = seeLn.LineLineIntersection(W[i].wall);
                                                if (crossPt != null) 
                                                {
                                                            neniBranen = false;
                                                            break;
                                                }
                                    }  
                                    if(neniBranen)
                                    {
                                                if (IsInRange(target, viewSize) == -1) return false;           
                                                return true;
                                    }
                                    return false;
                        }
            }

            boolean IsToTarget(Feromon f)
            {
                        if (targetSpray.id == f.parentFrom) return true;
                        return false;      
            }

            boolean IsLive()
            {
                        if (life > 0) return true;
                        Kill(); 
                        return false;
            }

            void Calculate()
            {
                        if(IsLive())
                        {
                                    ProduceFeromon();
                                    RefreshBBox();

                                    if (IsInRange(targetSpray.origin, viewSize/10) != -1)  
                                    {
                                                life = 1;   
                                    }
                                    else
                                    {
                                                int[] seeID = new int[0];
                                                if (time % rozhlidnuti == 0)
                                                {
                                                            nejlepsiFeromon = null;

                                                            nahodnyPohyb = true;

                                                            for(int i = 0; i < F.length; i++)
                                                            {
                                                                        if(IsToTarget(F[i]))
                                                                        {
                                                                                    if (IsVisible(F[i].origin))
                                                                                    {
                                                                                                seeID = (int[]) append(seeID,i);   
                                                                                    }
                                                                        }
                                                            }
                                                            for (int i = 0 ; i < seeID.length; i++)
                                                            {
                                                                        TryFeromon(F[seeID[i]]);
                                                            }
                                                }


                                                if(nejlepsiFeromon != null) 
                                                {
                                                            Vector nejVec =  new Vector(origin, nejlepsiFeromon.origin);
                                                            nejVec.Unitize();

                                                            move.Plus(nejVec);
                                                            nahodnyPohyb = false;           
                                                }


                                                // odpudiva sila proti pruchodu skrz jineho mravence
                                                for(int i = 0; i < A.length; i++)
                                                {
                                                            float dis = IsInRange(A[i].origin, bodySize);
                                                            if(dis != -1)
                                                            {
                                                                        if( dis < bodySize && dis != 0)
                                                                        {
                                                                                    Vector odVec = new Vector (A[i].origin,origin);
                                                                                    odVec.Unitize();
                                                                                    odVec.MultipleBy(dis/bodySize);
                                                                                    move.Plus(odVec);
                                                                                    nahodnyPohyb = true;       
                                                                        } 
                                                            }
                                                }

                                              

                                                if(nahodnyPohyb)
                                                {
                                                            Vector ranDir  = new Vector(rnd.Next()*TWO_PI, rnd.Next()*TWO_PI, 0.0);  
                                                            move.Plus(ranDir);
                                                }
                                                  for(int i = 0; i < W.length; i++)
                                                {
                                                            Point temp = W[i].wall.GetClosestPoint(origin);
                                                            float dis = IsInRange(temp, bodySize/2);

                                                            if(dis != -1)
                                                            {                 
                                                                        Vector odVec = new Vector (temp,origin);
                                                                        odVec.Unitize();
                                                                        odVec.MultipleBy(dis/bodySize*100);
                                                                        move.Plus(odVec);
                                                                                                                                         //   nejlepsiFeromon = null;
                                                            }
                                                }
                                    }

                                    move.Unitize();
                                                                      moveWay = origin;
                                    origin.Plus(move);

                                    fromLastCorner--;
                                    life--;          
                        }

            }



            void RefreshBBox()
            {
                        bboxX1 = origin.x - viewSize/2;
                        bboxX2 = origin.x + viewSize/2;
                        bboxY1 = origin.y - viewSize/2;
                        bboxY2 = origin.y + viewSize/2;           
                        bboxZ1 = origin.z - viewSize/2;
                        bboxZ2 = origin.z + viewSize/2;           
            }



            boolean ProduceFeromon()
            {
                        if(time % produceTime == 0)
                        {
                                    new Feromon(this);
                                    return true;           
                        }
                        return false;
            }

            void Kill()
            {                        
                        Ant[] temp = new Ant[0];
                        int noAnt = 0;
                        if(A.length > 0)
                        {
                                    for(int i = 0 ; i < A.length; i++)
                                    {
                                                if(i != id)
                                                {
                                                            A[i].id = noAnt;
                                                            temp = (Ant[]) append(temp,A[i]);
                                                            noAnt ++;
                                                }            
                                    }

                                    numberOfAnt --;
                        }
                        A = temp;
            }

            boolean IsOver()
            {
                        int scx,scy;
                        int tolerance = 10;
                        // mouse hit detection using screnX, screenY
                        scx = int(screenX(origin.x, origin.y, origin.z));
                        scy = int(screenY(origin.x, origin.y, origin.z));

                        if (scx > mouseX-tolerance && scx < mouseX+tolerance && scy > mouseY-tolerance && scy < mouseY+tolerance) return true;
                        else	return false;
            }

            String[] GetInfo()
            {
                        String[] answ = new String[0];
                        answ = append(answ,"Name : Ant " + id);

                        answ = append(answ,"");
                        answ = append(answ, "Life : " + life);
                        answ = append(answ, "FromID : " + parentSpray.id);
                        answ = append(answ, "ToID : " + targetSpray.id);
                        answ = append(answ,"");

                        for(int i = 0; i < videlID.length; i++)
                        {
                                    answ = append(answ, "VidelID " + i + " : " + videlID[i]);
                        }
                        return answ;
            }

            void Draw()
            {
                        isOver = IsOver();

                        if(isSelected) 
                        {
                                    stroke(232,120,20);
                                    new Circle(new Plane(origin),viewSize/2).Draw();

                                    pushMatrix();
                                    translate(origin.x, origin.y, origin.z);
                                    fill(232,120,20);
                                    stroke(255);
                                    ellipse(0,0,bodySize, bodySize);
                                    popMatrix();

                                    stroke(0);  
                                    if(nejlepsiFeromon != null) new Line(origin, nejlepsiFeromon.origin).Draw();

                        }
                        else if(isOver) stroke(26,120,200);
                        else  stroke(232,120,20);


                        new Circle(new Plane(origin),bodySize/2).Draw();
			
			
			tailX[cc] = origin.x;
			tailY[cc] = origin.y;
			cc++;
			
			if(cc>tailLen)
				cc = 0;
			
			pushStyle();
			
			stroke(0,50);
			noFill();
			
			for(int i = 1 ;i<cc;i++){
				if(i!=cc)
				line(tailX[i],tailY[i],tailX[i-1],tailY[i-1]);
			}
			
			popStyle();




            }

            void Graph()
            {
                        if(isSelected)
                        {
                                    float velikostOkna = 20;
                                    float maxRadek = 3;
                                    float maxSloupek = 8;

                                    int poziceRadek, poziceSloupek;
                                    poziceRadek = poziceSloupek = 0;

                                    int poziceX, poziceY;
                                    poziceX = 20;
                                    poziceY = 200;

                                    float[] graphValue = new float[0];
                                    graphValue = (float[]) append(graphValue, lerp(0,255,life/maxLife));

                                    for(int i = 0; i < videlID.length; i++)
                                    {
                                                graphValue = (float[]) append(graphValue, lerp(0,255,videlID[i]/maxLife));
                                    }

                                    noFill();
                                    rect(poziceX+velikostOkna*poziceSloupek, poziceY+velikostOkna*poziceRadek, velikostOkna, velikostOkna); 
                                    fill(255);
                                    text(floor(graphValue[0]),poziceX+velikostOkna*poziceSloupek, poziceY+velikostOkna*poziceRadek+velikostOkna/2); 

                                    poziceRadek = 1;
                                    for(int i = 1 ;  i < graphValue.length; i++)
                                    {                       
                                                // fill(graphValue[i]);
                                                if( poziceRadek < maxRadek && poziceSloupek < maxSloupek) 
                                                {
                                                            noFill();
                                                            rect(poziceX+velikostOkna*poziceSloupek, poziceY+velikostOkna*poziceRadek, velikostOkna, velikostOkna); 
                                                            fill(255);
                                                            text(floor(graphValue[i]),poziceX+velikostOkna*poziceSloupek, poziceY+velikostOkna*poziceRadek+velikostOkna/2); 
                                                }

                                                poziceRadek ++;
                                                if (poziceSloupek % maxSloupek == 0)
                                                {
                                                            poziceRadek = 0;
                                                            poziceSloupek ++;        
                                                }
                                    }
                        }
            }


}






























































































































static int seed;
static int countNext;

class PseudoRandom
{
            int radku, sloupcu;
            float[][] nahodneCislo;

            public PseudoRandom(int radku, int sloupcu)
            {
                        seed++;
                        Random rnd = new Random(seed);
                        this.radku = radku;
                        this.sloupcu = sloupcu;

                        nahodneCislo = new float[0][0];

                        for (int i = 0; i < radku; i++)
                        {
                                    float[] temp = new float[sloupcu + i];
                                    for (int k = 0; k < sloupcu + i; k++)
                                    {
                                                temp[k] = random(-1,1);
                                    }
                                    temp[0] = 0;
                                    nahodneCislo = (float[][]) append(nahodneCislo,temp);
                        }
            }

            public float Next()
            {
                        float answ = 0;

                        for (int i = 0; i < radku; i++)
                        {
                                    int zbytek = (countNext * (i + 1)) % nahodneCislo[i].length;
                                    answ += nahodneCislo[i][zbytek];
                        }
                        answ /= radku;

                        countNext++;
                        return (answ);
            }
}


  PFont font;
static int globalNumControl = 0;
class Toolbar
{
            int x, y, w, h;

            Button[] collButton;

            int ID_Over, ID_Pressed, ID_LastPressed;
            boolean isOverToolbar;

          
            int fontSize = 10;

            Toolbar(int scrX, int scrY, int toolW, int toolH)
            {
                        x = scrX;                        
                        y = scrY;
                        w = toolW;
                        h = toolH;

                        ID_Over = ID_Pressed = ID_LastPressed = -1;

                        //zalozeni nove kolekce tlacitek
                        collButton = new Button[0];


                        // font, velikost, smoothing?
			//println(PFont.list());
                        font = createFont("Arial",fontSize,true);
                        //selekce aktual fontu
                        textFont(font);
                        //lepsi pro P3D

            }

            void Calculate()
            {
                        if(! drag)
                        {
                                    if (IsOverToolbar())
                                    {
                                                if (IsOverControl())
                                                {
                                                            if(leftDown) 
                                                            {
                                                                        if(ID_Pressed > -1)  collButton[ID_Pressed].pressed = false;

                                                                        ID_Pressed = ID_Over;
                                                                        collButton[ID_Over].pressed = true;

                                                                        // okamzita akce pro nezaskrtnutelne buttony
                                                                        if(! collButton[ID_Pressed].permanentAction)
                                                                        {
                                                                                    Draw();
                                                                                    LClick();    
                                                                        }
                                                            }
                                                }
                                    }
                                    else
                                    {
                                                if(leftDown) LClick();
                                    }

                                    if(rightDown) RClick();
                                    ID_Over = -1;
                        }

            }

            void AddControl(Button b)
            {
                        b.ID = globalNumControl;
                        globalNumControl ++;

                        collButton = (Button[]) append(collButton,b);
            }


            boolean IsOverToolbar()
            {
                        if (x<mouseX && mouseX<(x+w))
                        {
                                    if (y<mouseY && mouseY<(y+h))
                                    {
                                                return true;
                                    }
                        }
                        return false;            
            }

            boolean IsOverControl()
            {
                        for(int i = 0; i < collButton.length; i++)
                        {
                                    if (collButton[i].IsOver())
                                    {
                                                ID_Over = i;
                                                return true;
                                    }
                        }
                        return false;
            }

            void LClick()
            {
                        if(ID_Pressed >-1)
                        {
                                    if(collButton[ID_Pressed].action == "makeSpray") PolozSpray();
                                    if(collButton[ID_Pressed].action == "makeWall") PolozWall();
                                    if(collButton[ID_Pressed].action == "testArea") PolozArea();

                                    if(ID_Pressed >-1)
                                    {
                                                if (collButton[ID_Pressed].action == "makeImport")
                                                {
                                                            ref.Import(); 
                                                            collButton[ID_Pressed].pressed = false; 
                                                            ID_LastPressed = ID_Pressed ;          
                                                            ID_Pressed = -1;
                                                }
                                    }
                                    if(ID_Pressed >-1)
                                    {
                                                if (collButton[ID_Pressed].action == "makeExport")
                                                {
                                                            ref.Export(); 
                                                            collButton[ID_Pressed].pressed = false; 
                                                            ID_LastPressed = ID_Pressed ;          
                                                            ID_Pressed = -1;
                                                }
                                    }
                        }

                        else
                        {
                                    boolean someSelect = false;

                                    for( int i = 0; i < area.length; i++)
                                    {
                                                if(area[i].isOver) 
                                                {
                                                            area[i].isSelected = true;
                                                            someSelect = true;
                                                            break;
                                                }
                                    }
                                    for( int i = 0; i < S.length; i++)
                                    {
                                                if(S[i].isOver) 
                                                {
                                                            S[i].isSelected = true;
                                                            someSelect = true;
                                                            break;
                                                }
                                    }
                                    for( int i = 0; i < A.length; i++)
                                    {
                                                if(A[i].isOver) 
                                                {
                                                            A[i].isSelected = true;
                                                            someSelect = true;
                                                            break;
                                                }
                                    }
                                    for( int i = 0; i < F.length; i++)
                                    {
                                                if(F[i].isOver) 
                                                {
                                                            F[i].isSelected = true;
                                                            someSelect = true;
                                                            break;
                                                }
                                    }

                                    if(! someSelect) 
                                    {
                                                for( int i = 0; i < area.length; i++)
                                                {           
                                                            area[i].isSelected = false;
                                                }    
                                                for( int i = 0; i < S.length; i++)
                                                {           
                                                            S[i].isSelected = false;
                                                }    
                                                for( int i = 0; i < A.length; i++)
                                                {           
                                                            A[i].isSelected = false;
                                                }       
                                                for( int i = 0; i < F.length; i++)
                                                {           
                                                            F[i].isSelected = false;
                                                }          
                                    }
                        }

            }

            void RClick()
            {
                        if(ID_Pressed >-1) 
                        {
                                    collButton[ID_Pressed].pressed = false; 
                                    ID_LastPressed = ID_Pressed ;  
                                    ID_Pressed  = -1;
                        }
                        else 
                        {
                                    if(ID_LastPressed != -1)
                                    {
                                                collButton[ID_LastPressed].pressed = true; 
                                                ID_Pressed  = ID_LastPressed;     
                                    }       
                        }
            }

            void Draw()
            {
                        // toolbar cara
                        stroke(120);
                        line(2,20,2,height-20);
                         line(w,20,w,height-20);


                        // vykresli tlacitka
                        for(int i = 0; i < collButton.length; i++)
                        {
                                    collButton[i].Draw();
                        }

fill(200);
                        String[] info;
                        for(int i = 0; i < F.length; i ++)
                        {
                                    if(F[i].isSelected)
                                    {
                                                info = F[i].GetInfo();
                                                for(int m = 0 ; m < info.length; m++)
                                                {
                                                            text(info[m],20,200+fontSize*m);           
                                                }
                                    }
                        }
                        for(int i = 0; i < A.length; i ++)
                        {
                                    if(A[i].isSelected)
                                    {
                                                info = A[i].GetInfo();
                                                for(int m = 0 ; m < info.length; m++)
                                                {
                                                            text(info[m],20,200+fontSize*m);           
                                                }
                                    }
                        }
                         for(int i = 0; i < area.length; i ++)
                        {
                                    if(area[i].isSelected)
                                    {
                                                info = area[i].GetInfo();
                                                for(int m = 0 ; m < info.length; m++)
                                                {
                                                            text(info[m],20,200+fontSize*m);           
                                                }
                                    }
                        }


                        text("FrameRate : " + frameRate, 20, height -50);
                        text("numberOfAnt : " + numberOfAnt, 20, height -35);
                        text("numberOfFeromon : " + numberOfFeromon, 20, height -20);
            }

}

class Button 
{
            PImage ikona[];
            int x, y, w, h, ID;
            boolean permanentAction;
            boolean pressed;
            boolean imageLoaded;
            String action;

            Button(int scrX, int scrY, int toolW, int toolH)
            {
                        x = scrX;
                        y = scrY;
                        w = toolW;
                        h = toolH;
            }

            void LoadImage(String fileName)
            {
                        String path =  ref.path + "/picture/";

                        ikona = new PImage[3];
                        String name[] = new String[3];

                        name[0] = "Button_"+fileName+"_Basic";
                        name[1] = "Button_"+fileName+"_Blue";
                        name[2] = "Button_"+fileName+"_Orange";

                        for(int i = 0; i < name.length; i++)
                        {
                                    ikona[i] = loadImage(path+name[i]+".png");
                        }
                        imageLoaded = true;
            }

            void SetAction(String name)
            {
                        action = name;
            }

            boolean IsOver()
            {
                        if (x<mouseX && mouseX<(x+w))
                        {
                                    if (y<mouseY && mouseY<(y+h))
                                    {
                                                return true;
                                    }
                        }
                        return false;
            }

            void Draw()
            {
                        if (imageLoaded)
                        {
                                    if(pressed)  image(ikona[2],x,y);
                                    else   if(IsOver())  image(ikona[1],x,y);
                                    else image(ikona[0],x,y);
                        }
                        else
                        {
                                    if(pressed)  
                                    {
                                                fill(255); 
                                                rect(x,y,w,h);
                                    }
                                    else   if(IsOver())  
                                    {
                                                fill(150); 
                                                rect(x,y,w,h);
                                    }
                                    else 
                                    {
                                                noFill(); 
                                                rect(x,y,w,h);
                                    }
                        }
            }


}

void ControlSetup()
{
            Button spray = new Button(20,20,50,50);
            spray.permanentAction = true;
            spray.SetAction("makeSpray");
            spray.LoadImage("Spray");
            tool.AddControl(spray);

            Button block = new Button(80,20,50,50);
            block.permanentAction = true;
            block.LoadImage("Wall");
            block.SetAction("makeWall");
            tool.AddControl(block);

            Button im = new Button(20,height-300,50,50);
            im.LoadImage("Import");
            im.SetAction("makeImport");
            tool.AddControl(im);

            Button export = new Button(80,height-300,50,50);
            export.LoadImage("Export");
            export.SetAction("makeExport");
            tool.AddControl(export);

            Button tArea = new Button(20, 80, 50,50);
            tArea.permanentAction = true;
            tArea.SetAction("testArea");
            tool.AddControl(tArea);



}



























































public class Point
{
            float x, y, z;

            public Point(Point point)
            {
                        x = point.x;
                        y = point.y;
                        z = point.z;
            }
            public Point(float x, float y)
            {
                        this.x = x;
                        this.y = y;
                        this.z = 0;
            }
            public Point(float x, float y, float z)
            {
                        this.x = x;
                        this.y = y;
                        this.z = z;
            }
            public Point(Point origin, Vector direction)
            {
                        x = origin.x + direction.x;
                        y = origin.y + direction.y;
                        z = origin.z + direction.z;
            }
            public float DistanceTo(Point targetPoint)
            {
                        float d = 0;
                        d = sqrt((targetPoint.x - x) * (targetPoint.x - x) +
                                    (targetPoint.y - y) * (targetPoint.y - y) +
                                    (targetPoint.z - z) * (targetPoint.z - z));
                        return (d);
            }

            boolean CompareTo(Point targetPoint)
            {
                        float tolerance = 0.01;
                        if(x - tolerance <=  targetPoint.x && x + tolerance >=  targetPoint.x)
                        {
                                    if(y - tolerance <=  targetPoint.y && y + tolerance >=  targetPoint.y)
                                    {
                                                if(z - tolerance <=  targetPoint.z && z + tolerance >=  targetPoint.z)
                                                {
                                                            return true;
                                                }
                                    }
                        }
                        return false;         
            }

            public void Plus(Vector direction)
            {
                        x += direction.x;
                        y += direction.y;
                        z += direction.z;
            }

            String ToString()
            {
                        String answ = round(x*100)/100.0 + ";" + round(y*100)/100.0 + ";" + round(z*100)/100.0;
                        return answ;           
            }

            void Draw()
            {
                        if(this != null)
                        {
                                    pushMatrix();
                                    translate(x,y,z);
                                    noFill();	
                                    box(5);	
                                    popMatrix();
                        }
            }

            void Draw(float crossSize)
            {

                        Point pt = new Point(0,0,0);
                        float distanceKoef = cam.DistanceFrom(pt)/1;

                        Plane viewPln = new Plane(new Point(x,y,z),cam.xAxis,cam.yAxis);

                        Point pt1 = viewPln.PointAt(crossSize*distanceKoef,crossSize*distanceKoef,0);
                        Point pt2 = viewPln.PointAt(-crossSize*distanceKoef,-crossSize*distanceKoef,0);
                        Point pt3 = viewPln.PointAt(crossSize*distanceKoef,-crossSize*distanceKoef,0);
                        Point pt4 = viewPln.PointAt(-crossSize*distanceKoef,crossSize*distanceKoef,0);

                        line(pt1.x,pt1.y,pt1.z,pt2.x,pt2.y,pt2.z);
                        line(pt3.x,pt3.y,pt3.z,pt4.x,pt4.y,pt4.z);

            }
}

public class Vector
{
            public Vector(Vector vec)
            {
                        x = vec.x;
                        y = vec.y;
                        z = vec.z;
            }
            public Vector(float x, float y, float z)
            {
                        this.x = x;
                        this.y = y;
                        this.z = z;
            }
            public Vector(float x1, float y1, float z1, float x2, float y2, float z2)
            {
                        this.x = x2 - x1;
                        this.y = y2 - y2;
                        this.z = z1 - z2;
            }
            public Vector(Point fromPoint, Point toPoint)
            {
                        x = toPoint.x - fromPoint.x;
                        y = toPoint.y - fromPoint.y;
                        z = toPoint.z - fromPoint.z;
            }
            public Vector (Point fromPoint, float degXY, float degXZ)
            {
                        Vector dir = new Vector(cos (degXY) , sin (degXY), 0);
                        Plane pln = new Plane(fromPoint, dir, new Vector(0,0,1));           
                        Point toPoint = pln.PointAt(cos (degXZ) , sin (degXZ), 0);
                        Vector answ = new Vector(fromPoint, toPoint);
                        answ.Unitize();

                        x = answ.x;
                        y = answ.y;
                        z = answ.z;
            }

            public void MultipleBy(float koef)
            {
                        x *= koef;
                        y *= koef;
                        z *= koef;
            }

            public void Plus(Vector addVector)
            {
                        x += addVector.x;
                        y += addVector.y;
                        z += addVector.z;
            }

            Vector Reverse()
            {
                        x *= -1;
                        y *= -1;
                        z *= -1;

                        return new Vector(x,y,z);
            }

            public void CrossProduct(Vector secondVector)
            {
                        float tempX, tempY, tempZ;
                        tempX = x;
                        tempY = y;
                        tempZ = z;

                        x = tempY * secondVector.z - tempZ * secondVector.y;
                        y = tempZ * secondVector.x - tempX * secondVector.z;
                        z = tempX * secondVector.y - tempY * secondVector.x;
            }

            public float DotProduct(Vector vec2)
            {
                        return x*vec2.x+y*vec2.y+z*vec2.z;
            }

            public void Unitize()
            {
                        float d = Delka();
                        if(d == 0)
                        {
                                    x /= 0;
                                    y /= 0;
                                    z /= 0;     
                        }
                        else
                        {
                                    x /=  d;
                                    y /=  d;
                                    z /=  d;
                        }
            }

            public float Delka()
            {
                        float d = 0;
                        //length = sqrt((ax * ax) + (ay * ay) + (az * az))
                        d = sqrt((x * x) + (y * y) + (z * z));
                        return d;
            }

            public boolean IsZero()
            {
                        if ((x == 0) && (y == 0) && (z == 0)) return true;
                        return false;
            }

            float RadToVector(Vector vector)
            {
                        Vector vec1 = new Vector(this);
                        Vector vec2 = new Vector(vector);
                        if (vec1.IsZero() || vec2.IsZero()) return 0;

                        vec1.Unitize();
                        vec2.Unitize();

                        return acos(vec1.DotProduct(vec2));
            }

            float DegToVector(Vector vector)
            {
                        Vector vec1 = new Vector(this);
                        Vector vec2 = new Vector(vector);
                        if (vec1.IsZero() || vec2.IsZero()) return 0;

                        vec1.Unitize();
                        vec2.Unitize();

                        return acos(vec1.DotProduct(vec2))*180/PI;
            }



            float RadXY()
            {
                        //  println(atan2(1,1)*180/PI);        
                        return atan2(y,x);
            }
            float DegXY()
            {
                        //  println(atan2(1,1)*180/PI);        
                        return atan2(y,x)*180/PI;
            } 
            float RadXZ()
            {
                        //  println(atan2(1,1)*180/PI);        
                        return atan2(z,x);
            }
            float DegXZ()
            {
                        //  println(atan2(1,1)*180/PI);        
                        return atan2(z,x)*180/PI;
            }

            String ToString()
            {
                        String answ = x + ";" + y + ";" + z;
                        return answ;           
            }

            void Draw(Point origin)
            {
                        stroke(255,0,0);
                        line(origin.x, origin.y, origin.z, origin.x+x, origin.y+y, origin.z+z);

                        pushMatrix();
                        translate(origin.x+x, origin.y+y, origin.z+z);
                        noFill();
                        box(10);
                        popMatrix();
            }

            void Draw(Point origin, float arrowSize)
            {
                        Vector tmp = new Vector(x,y,z);

                        // tmp.Unitize();
                        //   tmp.MultipleBy(arrowSize);

                        stroke(255,0,0);
                        line(origin.x, origin.y, origin.z, origin.x+tmp.x, origin.y+tmp.y, origin.z+tmp.z);

                        Point pt = new Point(0,0,0);
                        float distanceKoef =  cam.DistanceFrom(pt)/1;

                        Plane viewPln = new Plane(new Point(x+origin.x,y+origin.y,z+origin.z),tmp,cam.yAxis);

                        Point pt1 = viewPln.PointAt(0,0,0);
                        Point pt2 = viewPln.PointAt(-arrowSize*distanceKoef,arrowSize*distanceKoef/3,0);
                        Point pt3 = viewPln.PointAt(-arrowSize*distanceKoef,-arrowSize*distanceKoef/3,0);

                        fill(255,0,0);
                        beginShape();
                        vertex(pt1.x,pt1.y,pt1.z);
                        vertex(pt2.x,pt2.y,pt2.z);
                        vertex(pt3.x,pt3.y,pt3.z);
                        vertex(pt1.x,pt1.y,pt1.z);
                        endShape();
                        noFill();
            }

            void Draw(Point origin,float multiplikator, float arrowSize)
            {
                        Vector tmp = new Vector(x,y,z);

                        tmp.Unitize();
                        tmp.MultipleBy(multiplikator);

                        stroke(255,0,0);
                        line(origin.x, origin.y, origin.z,x*multiplikator+origin.x,y*multiplikator+origin.y,z*multiplikator+origin.z);

                        Point pt = new Point(0,0,0);
                        float distanceKoef =  cam.DistanceFrom(pt)/1;

                        Plane viewPln = new Plane(new Point(x*multiplikator+origin.x,y*multiplikator+origin.y,z*multiplikator+origin.z),tmp,cam.xAxis);

                        Point pt1 = viewPln.PointAt(0,0,0);
                        Point pt2 = viewPln.PointAt(-arrowSize*distanceKoef,arrowSize*distanceKoef/3,0);
                        Point pt3 = viewPln.PointAt(-arrowSize*distanceKoef,-arrowSize*distanceKoef/3,0);

                        fill(255,0,0);
                        beginShape();
                        vertex(pt1.x,pt1.y,pt1.z);
                        vertex(pt2.x,pt2.y,pt2.z);
                        vertex(pt3.x,pt3.y,pt3.z);
                        vertex(pt1.x,pt1.y,pt1.z);
                        endShape();
                        noFill();
            }
            float x, y, z;
}

public class Plane
{
            public Plane(float x, float y, float z)
            {
                        this.origin = new Point(x, y, z);

                        xAxis = new Vector(1, 0, 0);
                        yAxis = new Vector(0, 1, 0);
                        zAxis = new Vector(0, 0, 1);

                        displaySize = 10;
                        numOfGrid = 4;
            }

            public Plane(Point origin)
            {
                        this.origin = origin;

                        xAxis = new Vector(1, 0, 0);
                        yAxis = new Vector(0, 1, 0);
                        zAxis = new Vector(0, 0, 1);

                        displaySize = 10;
                        numOfGrid = 4;
            }

            public Plane(Point origin, Point xVectorPoint, Point yVectorPoint)
            {
                        this.origin = origin;
                        xAxis = new Vector(origin, xVectorPoint);
                        xAxis.Unitize();
                        xAxis.Reverse();

                        yAxis = new Vector(origin, yVectorPoint);

                        yAxis.CrossProduct(xAxis);
                        yAxis.Reverse();
                        zAxis = new Vector(yAxis);
                        zAxis.Unitize();

                        yAxis.CrossProduct(xAxis);
                        yAxis.Unitize();

                        displaySize = 10;
                        numOfGrid = 4;
            }

            public Plane(Point origin, Vector xDirection, Vector yDirection)
            {
                        this.origin = origin;

                        Vector xDir = new Vector(xDirection);
                        Vector yDir = new Vector(yDirection);
                        xDir.Unitize();

                        xAxis = xDir;
                        yAxis = yDir;

                        yAxis.CrossProduct(xDir);
                        yAxis.Reverse();
                        zAxis = new Vector(yAxis);
                        zAxis.Unitize();
                        //  zAxis.Reverse();

                        yAxis.CrossProduct(xDir);
                        yAxis.Unitize();

                        displaySize = 10;
                        numOfGrid = 4;
            }

            public Point PointAt(float u, float v, float w)
            {
                        Vector xVec =new Vector(xAxis);
                        xVec.MultipleBy(u);

                        Vector yVec = new Vector(yAxis);
                        yVec.MultipleBy(v);

                        Vector zVec = new Vector(zAxis);
                        zVec.MultipleBy(w);

                        float pozX, pozY, pozZ;
                        pozX = origin.x + xVec.x + yVec.x + zVec.x;
                        pozY = origin.y + xVec.y + yVec.y + zVec.y;
                        pozZ = origin.z + xVec.z + yVec.z + zVec.z;

                        return new Point(pozX, pozY, pozZ);
            }

            public Point IntersectionLine(Point ptA, Point ptB)
            {
                        Point ptC = PointAt(1,1,0);
                        float koef1, koef2;

                        koef1 =  (ptC.x-ptA.x)*zAxis.x + (ptC.y-ptA.y)*zAxis.y + (ptC.z-ptA.z)*zAxis.z;
                        koef2 =  (ptB.x-ptA.x)*zAxis.x + (ptB.y-ptA.y)*zAxis.y + (ptB.z-ptA.z)*zAxis.z;

                        Vector dir = new Vector(ptA,ptB);
                        dir.MultipleBy(koef1/koef2);
                        //println(koef1/koef2);
                        return new Point(dir.x+ptA.x, dir.y+ptA.y, dir.z+ptA.z);
            }

            public void Draw()
            {
                        stroke (40,40,40,255);

                        for (float i = -displaySize / 2; i <= displaySize / 2; i += displaySize / numOfGrid)
                        {
                                    if (i == 0)
                                    {
                                                Point ptStart = new Point(PointAt(0, -displaySize / 2, 0));
                                                line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);

                                                ptStart = new Point(PointAt(0, displaySize / 2, 0));
                                                stroke (0, 255, 0, 255);
                                                line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);
                                                stroke (40,40,40,255);
                                    }
                                    else
                                    {
                                                Point ptStart = new Point(PointAt(i, displaySize / 2, 0));
                                                Point ptEnd = new Point(PointAt(i, -displaySize / 2, 0));

                                                line(ptStart.x, ptStart.y, ptStart.z,ptEnd.x, ptEnd.y, ptEnd.z);
                                    }
                        }

                        for (float i = -displaySize / 2; i <= displaySize / 2; i += displaySize / numOfGrid)
                        {
                                    if (i == 0)
                                    {
                                                Point ptStart = new Point(PointAt(-displaySize / 2, 0, 0));
                                                line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);

                                                ptStart = new Point(PointAt(displaySize / 2, 0, 0));
                                                stroke(255, 0, 0, 255);
                                                line(ptStart.x, ptStart.y, ptStart.z,origin.x, origin.y, origin.z);
                                                stroke(40, 40, 40, 255);
                                    }
                                    else
                                    {
                                                Point ptStart = new Point(PointAt(displaySize / 2, i, 0));
                                                Point ptEnd = new Point(PointAt(-displaySize / 2, i, 0));

                                                line(ptStart.x, ptStart.y, ptStart.z,ptEnd.x, ptEnd.y, ptEnd.z);
                                    }


                        }

                        Point ptStartZ = new Point(PointAt(0, 0, displaySize / 2));
                        stroke(0, 0, 255, 255);
                        line(ptStartZ.x, ptStartZ.y, ptStartZ.z,origin.x, origin.y, origin.z);
                        stroke(40, 40, 40, 255);
            }

            Point origin;
            Vector xAxis, yAxis, zAxis;
            float displaySize;
            int numOfGrid;
}

class Line
{
            Point from, to;
            Vector dir;

            Line(Point p1, Point p2)
            {
                        from = p1;
                        to = p2;
                        dir = new Vector(p1,p2);
            } 

            Line(Point p, Vector vec, float distance)
            {
                        from = p;
                        dir = new Vector(vec);
                        dir.Unitize();
                        dir.MultipleBy(distance);
                        to = new Point(from);
                        to.Plus(dir);                       
            } 

            Line(float x1, float y1, float z1, float x2, float y2, float z2)
            {
                        from = new Point(x1, y1, z1);
                        to = new Point(x2, y2, z2);
                        dir = new Vector(from,to);
            } 

            float GetCloserT()
            {
                        // mouse hit detection using screnX, screenY
                        float citlivost = ceil(from.DistanceTo(to));
                        int tolerance = 5;
                        float nejmensiVzdalenost = 99999999;
                        float nejblizsiT = -1;
                        int screen_X, screen_Y;

                        for (int i = 0 ; i < citlivost; i++)
                        {
                                    Point temp = PointAt(1/(float)citlivost*i);

                                    screen_X = int(screenX(temp.x, temp.y, temp.z));
                                    screen_Y = int(screenY(temp.x, temp.y, temp.z));

                                    if (screen_X > mouseX-tolerance && screen_X < mouseX+tolerance && screen_Y > mouseY-tolerance && screen_Y < mouseY+tolerance)
                                    {

                                                float dis = sqrt((screen_X-mouseX)*(screen_X-mouseX)+(screen_Y-mouseY)*(screen_Y-mouseY));
                                                if(nejmensiVzdalenost > dis)
                                                {
                                                            nejmensiVzdalenost = dis;
                                                            nejblizsiT = i;
                                                            nejblizsiT /= (float)citlivost;
                                                }
                                    }
                        }
                        return nejblizsiT;
            }

            Point GetCloserPoint()
            {
                        float t = GetCloserT();
                        return PointAt(t);
            }



            public Point GetClosestPoint(Point p) 
            {

                        final float xDelta = to.x - from.x;
                        final float yDelta = to.y - from.y;

                        if ((xDelta == 0) && (yDelta == 0)) {
                                    throw new IllegalArgumentException("p1 and p2 cannot be the same point");
                        }

                        final float u = ((p.x - from.x) * xDelta + (p.y - from.y) * yDelta) / (xDelta * xDelta + yDelta * yDelta);

                        final Point closestPoint;
                        if (u < 0) 
                        {
                                    closestPoint = from;
                        } 
                        else if (u > 1) 
                        {
                                    closestPoint = to;
                        } 
                        else 
                        {
                                    closestPoint = PointAt(u); 
                        }

                        return closestPoint;
            }





            float Delka()
            {
                        return dir.Delka();     
            }

            // t = <0;1>
            Point PointAt(float t)
            {
                        Point temp = new Point(from);
                        Vector tVec = new Vector(dir);
                        tVec.MultipleBy(t);
                        temp.Plus(tVec);    
                        return temp;       
            }

            // pouze 2D
            Point LineLineIntersection(Line otherLine)
            {
                        float x1, x2, x3, x4;       
                        float y1, y2, y3, y4;

                        x1 = from.x;
                        x2 = to.x;
                        x3 = otherLine.from.x;
                        x4 = otherLine.to.x;

                        y1 = from.y;
                        y2 = to.y;
                        y3 = otherLine.from.y;
                        y4 = otherLine.to.y;

                        float u = ((x4-x3)*(y1-y3)-(y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1)-(x4-x3)*(y2-y1));
                        float v = ((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1)-(x4-x3)*(y2-y1));
                        if(u > 1) return null;
                        if(u < 0) return null;
                        if(v > 1) return null;
                        if(v < 0) return null;
                        if(u == 0 && v == 0) return null;

                        return PointAt(u);
            }

            void Draw()
            {
                        line(from.x, from.y, from.z ,to.x,to.y, to.z);
            }

}

class Polyline
{
            Point[] pt;
            boolean closed;

            Polyline()
            {
                        pt = new Point[0];
            }
            Polyline(Point[] pts)
            {
                        pt = new Point[0];
                        for(int i = 0 ; i < pts.length; i++)
                        {
                                    pt = (Point[]) append(pt,pts[i]);
                        }           
            }

            void AddPoint(float x, float y, float z)
            {
                        pt = (Point[]) append(pt,new Point(x,y,z));
            }

            void AddPoint(Point onePt)
            {
                        pt = (Point[]) append(pt,onePt);
            }

            void RemovePoint(int num)
            {

            }

            Point GetPoint(int no)
            {
                        if(pt[no] != null)  return pt[no];
                        return null;
            }

            float[] GetPointT()
            {
                        float delka = GetDelka();
                        float[] tSeg = new float[0];
                        float delta = 0;

                        tSeg = append(tSeg, 0);
                        for (int i = 1; i < pt.length; i++)
                        {
                                    delta += pt[i-1].DistanceTo(pt[i])/delka;
                                    tSeg = append(tSeg, delta);
                        }   

                        return tSeg;
            }

            Point PointAt(float t)
            {
                        if(t >= 0 && t <= 1)
                        {
                                    float[] tSeg = GetPointT();

                                    for(int i = 1; i < tSeg.length; i++)
                                    {
                                                if(t >= tSeg[i-1] && t <= tSeg[i])
                                                {
                                                            float a = tSeg[i]-tSeg[i-1];
                                                            float b = t - tSeg[i-1];
                                                            t = b/a;
                                                            t = constrain(t, 0, 1);

                                                            return new Line (pt[i-1], pt[i]) .PointAt(t);
                                                }    
                                    }
                        }
                        return null;
            }

            float GetCloserT()
            {
                        float delka = GetDelka();
                        float[] tSeg = new float[0];
                        float delta = 0;

                        tSeg = append(tSeg, 0);
                        for (int i = 1; i < pt.length; i++)
                        {
                                    delta += pt[i-1].DistanceTo(pt[i])/delka;
                                    tSeg = append(tSeg, delta);
                        }

                        // mouse hit detection using screnX, screenY
                        float citlivost = ceil(delka);
                        int tolerance = 5;
                        float nejmensiVzdalenost = 99999999;
                        float nejblizsiT = -1;
                        int screen_X, screen_Y;
                        for (int k = 1 ; k < pt.length; k++)
                        {
                                    Line tmpLine = new Line(pt[k-1], pt[k]);
                                    for (float i = 0 ; i < 1; i+=1/citlivost)
                                    {
                                                Point temp = tmpLine.PointAt(i);

                                                screen_X = int(screenX(temp.x, temp.y, temp.z));
                                                screen_Y = int(screenY(temp.x, temp.y, temp.z));

                                                if (screen_X > mouseX-tolerance && screen_X < mouseX+tolerance && screen_Y > mouseY-tolerance && screen_Y < mouseY+tolerance)
                                                {
                                                            float dis = sqrt((screen_X-mouseX)*(screen_X-mouseX)+(screen_Y-mouseY)*(screen_Y-mouseY));
                                                            if(nejmensiVzdalenost > dis)
                                                            {
                                                                        nejmensiVzdalenost = dis;
                                                                        nejblizsiT = (tSeg[k] - tSeg[k-1])* i + tSeg[k-1] ;
                                                            }
                                                }
                                    }
                        }
                        return nejblizsiT;
            }

            Point GetCloserPoint()
            {
                        float t = GetCloserT();
                        return PointAt(t);
            }

            float GetDelka()
            {
                        float answ = 0;
                        for (int i = 1; i < pt.length; i++)
                        {
                                    answ += pt[i-1].DistanceTo(pt[i]);
                        }
                        return answ;
            }

            float GetDelka(int no)
            {
                        try
                        {
                                    return pt[no-1].DistanceTo(pt[no]);
                        }
                        catch (Exception e)
                        {
                                    return -1;     
                        }
            }


            void Draw()
            {
                        for (int i = 1; i < pt.length; i++)
                        {
                                    if (( pt[i-1] != null ) && ( pt[i] != null ))   new Line( pt[i-1] , pt[i] ).Draw();
                        }
            }
            void Draw(float displaySize)
            {
                        for (int i = 1; i < pt.length; i++)
                        {
                                    if (( pt[i-1] != null ) && ( pt[i] != null ))   new Line( pt[i-1] , pt[i] ).Draw();
                                    if(pt.length-1 != i) pt[i].Draw(displaySize);
                        }
            }
}

class Circle
{
            Point origin;
            Plane cPln;
            float r;

            Circle(Point origin, float r)
            {
                        cPln = new Plane(origin, new Vector(1,0,0), new Vector(0,1,0));
                        this.r = r;
            }
            Circle (Plane cPln, float r)
            {
                        this.cPln = cPln;
                        this.r = r;
            }

            Point PointAt(float t)
            {
                        float i = 2*PI * t;
                        return  cPln.PointAt( r * cos (i) , r * sin (i) , 0 );
            }

            // NEFUNGUJE OBECNE !!!!
            Point[] Intersection_CircleCircle(Circle cir2)
            {
                        if(cPln.origin.x == cir2.cPln.origin.x && cPln.origin.y == cir2.cPln.origin.y && cPln.origin.z == cir2.cPln.origin.z) return null;
                        Point[] answ = new Point[0];

                        float a = cir2.r;
                        float b = this.r;
                        Vector centers = new Vector(cPln.origin, cir2.cPln.origin);
                        float c = centers.Delka();
                        centers.Draw(cPln.origin,10);
                        // println("a = " +a + " b = " +b + " c = " +c );

                        if (c > a+b || c < a-b || c < b-a) return null; 

                        float uhel = acos((a*a-c*c-b*b)/(-2*b*c));

                        Point p1 = new Point(r*cos(uhel), r*sin(uhel),0);
                        p1.Plus(new Vector(cPln.origin.x, cPln.origin.y, cPln.origin.z));
                        p1.Draw();

                        Point p2 = new Point(r*cos(-uhel), r*sin(-uhel),0);
                        p2.Plus(new Vector(cPln.origin.x, cPln.origin.y, cPln.origin.z));
                        p2.Draw();




                        return answ;
            }


            void Draw()
            {
                        int seg = 50;
                        for(float i = 0 ; i < 2*PI ; i += PI/seg)
                        {
                                    Line l = new Line(cPln.PointAt(r* cos (i), r*sin (i) , 0), cPln.PointAt(r* cos (i+ PI/seg), r*sin (i+ PI/seg) , 0));
                                    l.Draw();
                        }    
                        //     PointAt(0,this).Draw();
            }

}

























import processing.pdf.*;


Camera cam;
Toolbar tool;
ExternalData ref;

static int time;
int speed = 3;

boolean rec = false;

void setup()
{
	size(1100,700,P3D);
	//     frameRate(25);
	smooth();

	cam = new Camera();
	tool = new Toolbar(0,0,145,height);
	ref = new ExternalData();
	time = 0;
	frameRate = 25;
	ControlSetup();
}

void draw()
{

	if(rec){
		beginRecord(PDF, "/desk/pdf_complex_out.pdf");
		textFont(font);
	}
	background(255);

	


	// pocatek kresleni
	cam.preDraw();
	stroke(0);

	for (int k = 0; k < speed; k++)
	{
		for(int i = 0; i < S.length; i++)
		{
			S[i].Calculate();
		}

		for(int i = 0; i < A.length; i++)
		{
			A[i].Calculate();
		}

		for(int i = 0; i < F.length; i++)
		{
			F[i].Calculate();
		}

		for(int i = 0; i < area.length; i++)
		{
			area[i].Calculate();
		}

		time ++;
		if(time % 3000 == 0) ClearFeromons();
	}

	for(int i = 0; i < area.length; i++)
	{
		area[i].Draw();
	}

	for(int i = 0; i < S.length; i++)
	{
		S[i].Draw();
	}
	/*
	            for(int i = 0; i < F.length; i++)
	            {
	                        F[i].Draw();
	            }
	*/
	for(int i = 0; i < A.length; i++)
	{
		A[i].Draw();
	}

	for(int i = 0; i < W.length; i++)
	{
		W[i].Draw();
	}


	cam.postDraw();
	
	if(!rec)
	tool.Draw();

	if(rec){
		endRecord();
		rec = false;
	}


}



































































import processing.pdf.*;


PGraphicsPDF pdf;
boolean PDFing = false;
PFont font;

float maxx = 10.0;


void setup(){
	size(1048,1048,P2D);

	stroke(0,50);
	strokeWeight(1);
	noFill();
	smooth();
	
	font = createFont("Anivers", 9);
	textFont(font);
}
void draw(){

	background(0);
	
	if (PDFing) {
	pdf = (PGraphicsPDF) createGraphics(width ,height, PDF,  frameCount+".pdf");
	beginRecord(pdf);
	pdf.background(0);
	pdf.textFont(font);
	pdf.textMode(SHAPE);// = SHAPE;
	pdf.noFill();

	}

	float y = mouseY/100.0;
	for(float q = 1.1+y;q<(maxx+y);q+=0.8){

		beginShape();
		//vertex(0,noise(1/30.0)*height);
		stroke(map(q,1,maxx,255,0));
		if (PDFing) pdf.stroke(255,map(q,0,maxx,255,10));
			
		for(int i = 0;i<width;i+=2){
			curveVertex(i,map(noise(frameCount+cos(map(i+mouseX,0,width,-PI/2,PI/2))*q),0,1,0,height));
		}
		//vertex(width,noise(width/30.0)*height/q);
		endShape();
	}
	
	if (PDFing) {
		PDFing = false;
		endRecord();
	}
}

void mousePressed(){
	PDFing = true;

}
import geomerative.*;

RShape C;
RPoint pC[];
RShape polyshp;


PImage metroCbck;
int h,m,s;
boolean ignoringStyles = true;
	

ArrayList soupravy;


void setup(){
	size(1200,800,P2D);
	metroCbck = loadImage("c.png");

	h = m = s = 0;
	//geomerative.RGeomerative.init(this);
	geomerative.RG.init(this);
	geomerative.RG.ignoreStyles(ignoringStyles);

	C = geomerative.RG.loadShape("C.svg");
	polyshp = geomerative.RG.polygonize(C);
	pC = C.getPoints();


	soupravy = new ArrayList();
	soupravy.add(new Souprava(pC,soupravy.size()));
	 

	println(pC[0]);

	textFont(createFont("Sans",20));
	strokeWeight(3);
	rectMode(CENTER);

}

void mousePressed(){
	soupravy.add(new Souprava(pC,soupravy.size()));
}

void draw(){

	background(0);
	
	pushMatrix();
	
	translate(400,100);

	image(metroCbck,0,0);

	noFill();
	stroke(255,0,0,120);

	pushStyle();
	noStroke();
	fill(255);
	
	for(int i = 0;i<soupravy.size();i++){
		Souprava tmp = (Souprava)soupravy.get(i);
		tmp.tick();
	
		tmp.draw();
	}
	
	popStyle();
	
	

	//for(int i = 0;i<pC.length;i++)
	//rect(pC[i].x,pC[i].y,5,5);

	//C.draw();
	//C.centerIn(g, 1, 1, 1);
	//C.scale(0.98); //scales the map
	//C.translate(0, 0); //center the map

	popMatrix();


	fill(255);
	text(h+":"+nf(m,2)+":"+nf(s,2),width - 100,20);


	
	tick(10);



}


void tick(int speed){
	s += speed;
	if(s>=60){
		s = 0;
		m++;
	}

	if(m>=60){
		m = 0;
		h++;
	}

	if(h>=24){
		h = 0;
	}
}

class Souprava{
	float x,y,tx,ty;
	int cntr = 1;
	RPoint[] body;
	float speed = 3.0;
	float delta;
	int id;

	Souprava(RPoint[] _body,int _id){
		id = _id;
		body = _body;
		gotoStart();
	}

	void gotoStart(){
		cntr = 1;
		x = body[0].x;
		y = body[0].y;
		tx = body[1].x;
		ty = body[1].y;

	}

	void tick(){

		x+=(tx-x)/speed;
		y+=(ty-y)/speed;

		delta += (atan2(ty-y,tx-x)-delta)/speed;
		if(abs(delta-atan2(ty-y,tx-x))>1.5){
		delta = atan2(ty-y,tx-x);
		}
		
		if(dist(tx,ty,x,y)<=0.5){

			tx = body[cntr].x;
			ty = body[cntr].y;

			cntr++;

			if(cntr>=body.length-1){
				//gotoStart();
				destroy();
			}

		}
		
		

	}

	void draw(){
		pushMatrix();
		translate(x+3,y);
		
		text(id,5,5);
		rotate(delta);
		rect(0,0,10,5);
		
		popMatrix();


	}
	
	void destroy(){
	soupravy.remove(this);
	
	}

}

int num = 100;
Intel in[];

void setup(){
	size(400,300,P2D);
	background(255);
	
	in = new Intel[num];
	
	stroke(0,50);
	
	for(int i = 0;i<num;i++){
		in[i] = new Intel(20);
	}

}



void draw(){

	fill(255,15);
	rect(0,0,width,height);
	
	for(int i = 0;i<num;i++){
		in[i].draw();
	}
}

class Intel{
	float x,y;
	float speed = 11.0;
	Leg[] legs;
	int num;

	Intel(int _num){
		x = random(width);
		y = random(height);
		num = _num;

		legs = new Leg[num];
		for(int i = 0 ;i<legs.length;i++)
			legs[i] = new Leg(this,x,y,x+random(-20,20),y+random(-20,20));
	}


	void draw(){
		for(int i = 0 ;i<legs.length;i++)
			legs[i].draw();
		move();
	}

	void move(){
		for(int i = 0 ;i<legs.length;i++){
			x+=(legs[i].x2-x)/((legs.length)*speed);
			y+=(legs[i].y2-y)/((legs.length)*speed);
		}

		if(x<0)x=0;
		if(x>width)x=width;

		if(y<0)y=0;
		if(y>height)y=height;

	}

}

class Leg{
	float x1,y1,x2,y2;
	Intel parent;

	Leg(Intel _parent,float _x1,float _y1,float _x2,float _y2){
		parent=_parent;
		x1=_x1;
		x2=_x2;
		y1=_y1;
		y2=_y2;
	}



	void draw(){
		line(x1,y1,x2,y2);
		move();
	}

	void move(){
		x1 = parent.x;
		y1 = parent.y;
		x2 += random(-10,10)/10.0;
		y2 += random(-10,10)/10.0;
		

	}

}
import processing.pdf.*;


PGraphicsPDF pdf;
boolean PDFing = true;
PFont font;

PGraphics guess;
float perimeter = 20;

PImage podklad;

boolean filled = true;
boolean newvals = false;

float w = random(1,perimeter);
float h = random(1,perimeter);

float x,y,rot;

char current;

int choice = 0;

float sw = 1;

void setup(){
	
	podklad = loadImage("A3ver2.png");
	
	

	size(podklad.width,podklad.height);
	x = random(-width/2,height/2);
	y = random(-height/2,height/2);
	rot = random(-PI,PI);

	

	//rectMode(CENTER);
	background(255);
	smooth();
	fill(0);
	noStroke();

	font = createFont("URW Gothic L",perimeter);
	textFont(font);


	image(podklad,0,0);

	if (PDFing) {
		pdf = (PGraphicsPDF) createGraphics(width ,height, PDF,  "txt.pdf");
		beginRecord(pdf);
		//pdf.background(0);
		pdf.textFont(font);
		pdf.textMode(SHAPE);// = SHAPE;
		pdf.fill(0);
		pdf.noStroke();

	}


	generate();



}


void generate(){

	int cnt = 0;


	for(int i = 0;i<100;i++){
	genNew();


	}

}

void printit(){

	//pushMatrix();

	translate(width/2,height/2);
	rotate(rot);

	translate(x,y);

	//rect(0,0,w,h);

	//popMatrix();



	//image(guess,0,0);
}

void keyPressed(){

	if (PDFing&&key=='q') {
		PDFing = false;
		endRecord();
		exit();
	}
}

void genNew(){
	w = random(2,perimeter);
	h = random(2,perimeter);//random(6,perimeter);

	x = random(-width/2,width/2);
	y = random(-height/2,height/2);
	rot = random(-PI,PI);

	current = (char)random(55,120);

	
        choice = 1;//(int)random(1,2);

	//sw = random(1,10);

	guess = createGraphics(width,height,P2D);


	guess.beginDraw();
	//guess.background(-1);
	guess.rectMode(CENTER);
	guess.smooth();

	//perimeter*=0.999999;

	if(filled){
		guess.noStroke();
		guess.fill(0);
	}else{
		guess.stroke(0);
		guess.strokeWeight(sw);
		guess.noFill();
	}






	//guess.pushMatrix();
	guess.translate(width/2,height/2);
	guess.rotate(rot);
	guess.translate(x,y);
	if(choice == 0){
		guess.textFont(font,h*4);
		guess.text(current,0,0);
	}else if(choice == 1){
		guess.rect(0,0,h*4,h*4);
	}else if(choice == 2){
		guess.ellipse(0,0,h*4,h*4);
	}else if(choice == 3){
		guess.triangle(0,0,-w,w,-h,h);
	}
	guess.endDraw();

	if(pass()){
		if(filled){
			noStroke();
			fill(0);
		}else{
			stroke(0);
			strokeWeight(sw);
			noFill();
		}

		//noStroke();
		//fill(0);
		rectMode(CENTER);
		resetMatrix();
		translate(width/2,height/2);
		rotate(rot);
		translate(x,y);
		if(choice == 0){
			textFont(font,h*4);
		}else if(choice == 1){
			rect(0,0,h*4,h*4);
			text(current,0,0);
		}else if(choice == 2){
			ellipse(0,0,h*4,h*4);
		}else if(choice == 3){
			triangle(0,0,-w,w,-h,h);
		}

	}



}

boolean pass(){
	guess.loadPixels();
	loadPixels();

	boolean pass = true;

	int first = 0;
	for(int i = 0;i<width*height;i++){
		if(guess.pixels[i]!=0){
			first = i;
			//println(i);
			break;
		}
	}

	for(int i = first;i<width*height;i++){
		if(guess.pixels[i]!=0){
			if(brightness(pixels[i])<=200){
				pass = false;
				break;
			}
		}
	}

	return pass;

}



void draw(){

	generate();



}

void mousePressed(){
	generate();
}
/**
*  Hardcoded pixels by Krystof Pesek alias Kof, licensed under Creative Commons Attribution-Share Alike 3.0 license.
*  License: http://creativecommons.org/licenses/by-sa/3.0/
*
* visit more @ http://vimeo.com/kof
* if you leave this header, bend, share, spread the code, it is a freedom!
*
*   ,dPYb,                  ,dPYb,
*   IP'`Yb                  IP'`Yb
*   I8  8I                  I8  8I
*   I8  8bgg,               I8  8'
*   I8 dP" "8    ,ggggg,    I8 dP
*   I8d8bggP"   dP"  "Y8ggg I8dP
*   I8P' "Yb,  i8'    ,8I   I8P
*  ,d8    `Yb,,d8,   ,d8'  ,d8b,_
*  88P      Y8P"Y8888P"    PI8"8888
*                           I8 `8,
*                           I8  `8,
*                           I8   8I
*                           I8   8I
*                           I8, ,8'
*                            "Y8P'
*
*/


/*
* [0][1][2]
* [3][x][4]
* [5][6][7]
*/


int[][] px;
int matrix[][][];

int mm[] = {3,3,3,3,6,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,3,3,3,6,7};
int mod[];

int runNum[];

void setup(){

	size(400,300,P2D);
	px = new int[width][height];
	matrix = new int[width][height][mm.length];
	runNum = new int[width*height];
	mod = new int[width*height];
	frameRate(50);

	loadPixels();
	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			runNum[y*width+x] = 0;
			mod[y*width+x] = 0;
			px[x][y] = color(0);

			for(int i = 2;i<mm.length-1;i+=3){
				matrix[x][y][i] = mm[i];
				matrix[x][y][i-1] = mm[i-1];
				matrix[x][y][i-2] = (int)random(8);
			}

			matrix[x][y] = (int[])expand(matrix[x][y],matrix[x][y].length+1);
			matrix[x][y][matrix[x][y].length-1] = (int)random(8);

			pixels[y*width+x] = px[x][y];
		}
	}
}

void draw(){
	
	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			int index = y*width+x;

			if(runNum[index]>=matrix[x][y].length-1){
				runNum[index] = 0;
			}

			if(index%2==0)
				mod[index]++;

			int shx = 0, shy = 0;

			int modded = (matrix[x][y][runNum[index]]+mod[index])%7;
			switch(modded){
			case 0:
				shx = -1;
				shy = -1;
				break;

			case 1:
				shx = 0;
				shy = -1;
				break;

			case 2:
				shx = 1;
				shy = -1;
				break;

			case 3:
				shx = -1;
				shy = 0;
				break;

			case 4:
				shx = 1;
				shy = 0;
				break;

			case 5:
				shx = -1;
				shy = 1;
				break;

			case 6:
				shx = 0;
				shy = 1;
				break;

			case 7:
				shx = 1;
				shy = 1;
				break;
			}
			
			if(x>width/2)
				px[x][y] = pixels[((y+height-shy+mod[index])%height)*width+((x+width+shx+mod[index])%width)];
			else
				px[x][y] = pixels[((y+height+shy+mod[index])%height)*width+((x+width-shx+mod[index])%width)];

			runNum[index]++;
		}
	}
	
	// r = 10 0

	int r = (int)((sin(frameCount/30.0)+1)*20);
	int r2 = (int)((cos(frameCount/33.3333)+1)*20);

	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			int index = y*width+x;
			if(x>width/2-r&&x<width/2+r&&y<height/2+r&&y>height/2-r){
				pixels[index] = color(0);
			}else if(x>width/2-r2&&x<width/2+r2&&y<height/2+r2&&y>height/2-r2){
				pixels[index] = color(255);
			}else{
				pixels[index] = px[x][y];
			}

		}

	}
	//println(frameCount);
}
/**
*  Hardcoded pixels by Krystof Pesek alias Kof, licensed under Creative Commons Attribution-Share Alike 3.0 license.
*  License: http://creativecommons.org/licenses/by-sa/3.0/
*
* visit more @ http://vimeo.com/kof
* if you leave this header, bend, share, spread the code, it is a freedom!
*
*   ,dPYb,                  ,dPYb,
*   IP'`Yb                  IP'`Yb
*   I8  8I                  I8  8I
*   I8  8bgg,               I8  8'
*   I8 dP" "8    ,ggggg,    I8 dP
*   I8d8bggP"   dP"  "Y8ggg I8dP
*   I8P' "Yb,  i8'    ,8I   I8P
*  ,d8    `Yb,,d8,   ,d8'  ,d8b,_
*  88P      Y8P"Y8888P"    PI8"8888
*                           I8 `8,
*                           I8  `8,
*                           I8   8I
*                           I8   8I
*                           I8, ,8'
*                            "Y8P'
*
*/


/*
* [0][1][2]
* [3][x][4]
* [5][6][7]
*/


int[][] px;
int matrix[][][];
int mm[] = {3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,6,7};
int mod[];

int runNum[];

void setup(){
	size(640,360,P2D);
	px = new int[width][height];
	matrix = new int[width][height][mm.length];
	runNum = new int[width*height];
	mod = new int[width*height];
	frameRate(50);

	loadPixels();

	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			runNum[y*width+x] = 0;
			mod[y*width+x] = 0;
			px[x][y] = color(0);

			for(int i = 2;i<mm.length-1;i+=3){
				matrix[x][y][i] = mm[i];
				matrix[x][y][i-1] = mm[i-1];
				matrix[x][y][i-2] = (int)random(8);
			}

			matrix[x][y] = (int[])expand(matrix[x][y],matrix[x][y].length+1);
			matrix[x][y][matrix[x][y].length-1] = (int)random(8);

			pixels[y*width+x] = px[x][y];
		}
	}
}

void draw(){

	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			int index = y*width+x;

			if(runNum[index]>=matrix[x][y].length-1){
				runNum[index] = 0;
			}

			if(index%2==0)
				mod[index]++;

			int shx = 0, shy = 0;

			int modded = (matrix[x][y][runNum[index]]+mod[index])%7;
			switch(modded){
			case 0:
				shx = -1;
				shy = -1;
				break;

			case 1:
				shx = 0;
				shy = -1;
				break;

			case 2:
				shx = 1;
				shy = -1;
				break;

			case 3:
				shx = -1;
				shy = 0;
				break;

			case 4:
				shx = 1;
				shy = 0;
				break;

			case 5:
				shx = -1;
				shy = 1;
				break;

			case 6:
				shx = 0;
				shy = 1;
				break;

			case 7:
				shx = 1;
				shy = 1;
				break;
			}


			if(x>width/2)
				px[x][y] = pixels[((y+height-shy+mod[index])%height)*width+((x+width+shx+mod[index])%width)];
			else
				px[x][y] = pixels[((y+height+shy+mod[index])%height)*width+((x+width-shx+mod[index])%width)];

			runNum[index]++;
		}
	}

	int r = (int)((sin(frameCount/30.0)+1)*20);
	int r2 = (int)((cos(frameCount/33.3333)+1)*20);

	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			int index = y*width+x;
			if(x>width/2-r&&x<width/2+r&&y<height/2+r&&y>height/2-r){
				pixels[index] = color(0);
			}else if(x>width/2-r2&&x<width/2+r2&&y<height/2+r2&&y>height/2-r2){
				pixels[index] = color(255);
			}else{
				pixels[index] = px[x][y];
			}
		}
	}
}
int n = 256;          // The size of the calculation grid
int gridSize = n+2;   // Extra grid space for boundary
int pixelSize = 1;    // The size of each grid square on the screen

// I unravelled the 1D arrays from Jos Stam's paper back to 2D arrays, as we don't have compile time macros in Java...
float[][] u = new float[gridSize][gridSize];
float[][] v = new float[gridSize][gridSize];
float[][] uPrev = new float[gridSize][gridSize];
float[][] vPrev = new float[gridSize][gridSize];
float[][] dens = new float[gridSize][gridSize];
float[][] densPrev = new float[gridSize][gridSize];

float viscosity = 0.0001;  // Viscosity of fluid
float dt = 0.2;            // Rate of change
float diff = 0.0001;       // Degree of diffusion of density over time

int prevMouseX;
int prevMouseY;

// Flags for control of display
boolean showDensity = true;
boolean showVelocity = false;
boolean showNormals = false;
boolean showLighting = true;
boolean showGradient = false;

// Flag for drawing velocity or density - shift (or RMB) = density
boolean shiftPressed = false;

Gradient gradient = new Gradient();
color[] gradientColours;
int numGradientColours = 256;  // Use a larger array for better gradient resolution

int densityBrushSize = n/10;   // Size of the density area applied with the mouse
int velocityBrushSize = n/20;  // Ditto velocity
int lineSpacing = n/10;        // Spacing between velocity and normal lines


void setup() {
	size ( n*pixelSize, n*pixelSize, P2D );
	background ( 0 );
	noStroke();

	gradient.makeDefaultGradient(gradient.DEFAULT_BLACKBODY);
	gradientColours = gradient.makeArrayOfColours(numGradientColours);

	reset();
}

void draw() {
	setForce();
	calculateVelocity(u, v, uPrev, vPrev, viscosity, dt);
	calculateDensity(dens, densPrev, u, v, diff, dt);
	drawField(dens);
}

void reset() {
	initVelocity();
	initDensity();
}

void initField(float[][] f) {
	for ( int i=0; i < gridSize; i++ )
		for ( int j=0; j < gridSize; j++ )
			f[i][j] = 0.0;
}

void initVelocity() {
	initField(u);
	initField(v);
	initField(uPrev);
	initField(vPrev);
}

void initDensity() {
	initField(dens);
	initField(densPrev);
}

int ix(int i, int j) {
	return i + j*(n+2);
}

void addSource ( float[][] x, float[][] s, float dt )
{
	for ( int i=0; i<gridSize; i++ )
		for ( int j=0; j<gridSize; j++ )
			x[i][j] += s[i][j]*dt;
}

void setBnd ( int b, float[][] x )
{

	int i;
	for ( i=1; i <= n; i++ ) {

		if ( b==1 )  x [0  ][i  ] = -x [1  ][i  ];  else  x [0  ][i  ] = x [1  ][i  ];
		if ( b==1 )  x [n+1][i  ] = -x [n  ][i  ];  else  x [n+1][i  ] = x [n  ][i  ];
		if ( b==2 )  x [i  ][0  ] = -x [i  ][1  ];  else  x [i  ][0  ] = x [i  ][1  ];
		if ( b==2 )  x [i  ][n+1] = -x [i  ][n  ];  else  x [i  ][n+1] = x [i  ][n  ];

	}
	x [0  ][0  ] = 0.5 * ( x [1  ][0  ] + x [0  ][1  ] );
	x [0  ][n+1] = 0.5 * ( x [1  ][n+1] + x [0  ][n  ] );
	x [n+1][0  ] = 0.5 * ( x [n  ][0  ] + x [n+1][1  ] );
	x [n+1][n+1] = 0.5 * ( x [n  ][n+1] + x [n+1][n  ] );

}

void diffuse ( int b, float[][] x, float[][] x0, float diff, float dt ) {

	int i, j, k;
	float a = dt * diff * n * n;

	for ( k=0; k<20; k++ ) {
		for ( i=1; i <= n; i++ ) {
			for ( j=1; j <= n; j++ ) {
				x[i][j] = (x0[i][j] + a * ( x[i-1][j] + x[i+1][j] + x[i][j-1] + x[i][j+1] ) ) / (1+4*a);
			}
		}
		setBnd(b, x);
	}

}

void project ( float[][] u, float[][] v, float[][] p, float[][] div ) {

	int i, j, k;
	float h;

	h = 1.0/n;
	for ( i=1; i<=n; i++ ) {
		for ( j=1; j<=n; j++ ) {
			div [i][j] = -0.5 * h * ( u [i+1][j] - u [i-1][j] + v [i][j+1] - v [i][j-1] );
			p [i][j] = 0;
		}
	}
	setBnd ( 0, div );
	setBnd ( 0, p );

	for ( k=0; k<20; k++ ) {
		for ( i=1; i<=n; i++ ) {
			for ( j=1; j<=n; j++ ) {
				p [i][j] = ( div [i][j] + p [i-1][j] + p [i+1][j] + p [i][j-1] + p [i][j+1] ) / 4;
			}
		}
		setBnd ( 0, p );
	}

	for ( i=1; i<=n; i++ ) {
		for ( j=1; j<=n; j++ ) {
			u [i][j] -= 0.5 * ( p [i+1][j] - p [i-1][j] ) / h;
			v [i][j] -= 0.5 * ( p [i][j+1] - p [i][j-1] ) / h;
		}
	}
	setBnd ( 1, u );
	setBnd ( 2, v );

}

void advect ( int b, float[][] d, float[][] d0, float[][] u, float[][] v, float dt ) {

	int i, j, i0, j0, i1, j1;
	float x, y, s0, t0, s1, t1, dt0;

	dt0 = dt*n;
	for ( i=1; i<=n; i++ ) {
		for ( j=1; j<=n; j++ ) {
			x = i - dt0 * u [i][j];
			y = j - dt0 * v [i][j];

			x = max (0.5, x);
			x = min (n+0.5, x);

			//i0 = (int)x;
			i0 = floor(x);
			i1 = i0 + 1;

			y = max (0.5, y);
			y = min (n+0.5, y);

			//j0 = (int)j;
			j0 = floor(y);
			j1 = j0+1;

			s1 = x-i0;
			s0 = 1-s1;
			t1 = y-j0;
			t0 = 1-t1;

			d [i][j] = s0 * ( t0 * d0 [i0][j0] + t1 * d0 [i0][j1] ) +
			           s1 * ( t0 * d0 [i1][j0] + t1 * d0 [i1][j1] );
		}
	}
	setBnd ( b, d );
}

void calculateVelocity(float[][] u, float[][] v, float[][] u0, float[][] v0, float visc, float dt) {

	addSource ( u, u0, dt );
	addSource ( v, v0, dt );

	float[][] tmp;
	tmp = u;  u = u0;  u0 = tmp;
	tmp = v;  v = v0;  v0 = tmp;

	diffuse ( 1, u, u0, visc, dt );
	diffuse ( 2, v, v0, visc, dt );

	project ( u, v, u0, v0 );

	tmp = u;  u = u0;  u0 = tmp;
	tmp = v;  v = v0;  v0 = tmp;

	advect ( 1, u, u0, u0, v0, dt );
	advect ( 2, v, v0, u0, v0, dt );

	project ( u, v, u0, v0 );

}

void calculateDensity(float[][] x, float[][] x0, float[][] u, float[][] v, float diff, float dt) {
	float[][] tmp;

	addSource ( x, x0, dt );
	tmp = x; x = x0; x0 = tmp;
	diffuse ( 0, x, x0, diff, dt );
	tmp = x; x = x0; x0 = tmp;
	advect ( 0, x, x0, u, v, dt );
}

void drawField(float[][] f) {
	int x,y;
	float s;
	color col;

	float ax, ay, az;
	float bx, by, bz;
	float nx=0, ny=0, nz=0;

	float vu, vv;

	float l;

	float lx=0, ly=0, lz=0;
	float vx=0, vy=0, vz=0;
	float hx=0, hy=0, hz=0;

	float ndoth, ndotl;

	float w;
	float d;

	background(0);


	for (y = 1; y <= n; y++ ) {
		for ( x = 1; x <= n; x++ ) {

			d = dens[x][y];

			if ( showNormals || showLighting ) {
				//ax = 1;
				//ay = 0;
				az = d - dens[x+1][y];
				//bx = 0;
				//by = 1;
				bz = d - dens[x][y+1];

				//nx = ay*bz - az*by;
				//ny = az*bx - ax*bz;
				//nz = ax*by - ay*bx;

				nx = -az;
				ny = -bz;
				nz = 1;

				//l = sqrt(nx*nx + ny*ny + nz*nz); if ( l != 0 ) { nx /= l; ny /= l; nz /= l; }
				l = -sqrt(nx*nx + ny*ny + 1); nx /= l; ny /= l; nz /= l;
			}

			if ( showDensity ) {
				s = abs(range(numGradientColours * d,0,numGradientColours-1));
				noStroke();

				col = gradientColours[int(s)];

				if ( showLighting ) {
					/*
					lx = n/2 - x;
					ly = n/2 - y;
					lz = 1000 - 1000*dens[x,y];
					l = sqrt(lx*lx + ly*ly + lz*lz); if ( l != 0 ) { lx /= l; ly /= l; lz /= l; }

					vx = n/2 - x;
					vy = n/2 - y;
					vz = n;
					l = sqrt(vx*vx + vy*vy + vz*vz); if ( l != 0 ) { vx /= l; vy /= l; vz /= l; }

					lx = 0; ly = 0; lz = 1;
					vx = 0; vy = 0; vz = 1;

					hx = (lx + vx)/2;
					hy = (ly + vy)/2;
					hz = (lz + vz)/2;
					l = sqrt(hx*hx + hy*hy + hz*hz); if ( l != 0 ) { hx /= l; hy /= l; hz /= l; }

					// ndoth = nx*hx + ny*hy + nz*hz;
					*/

					ndoth = nz;

					w = ((s*512)/numGradientColours) * pow(ndoth, 100000);

					col = blendColor ( col, color(w), ADD );

				}

				fill ( col );
				rect ( (x-1) * pixelSize, (y-1) * pixelSize, pixelSize, pixelSize );
			}

			if ( showVelocity ) {
				if ( (x % lineSpacing) == 0 && (y % lineSpacing) == 0 ) {
					noFill();
					stroke(255,0,0);
					vu = range(500 * u[x][y], -50,50);
					vv = range(500 * v[x][y], -50,50);
					line( (x-1)*pixelSize, (y-1)*pixelSize, (x-1)*pixelSize + vu, (y-1)*pixelSize + vv);
				}
			}

			if ( showNormals ) {
				if ( (x % lineSpacing) == 0 && (y % lineSpacing) == 0 ) {
					noFill();
					stroke(255);

					vu = range(500 * nx, -50,50);
					vv = range(500 * ny, -50,50);
					line( (x-1)*pixelSize, (y-1)*pixelSize, (x-1)*pixelSize + vu, (y-1)*pixelSize + vv);
				}
			}
		}
	}

	if ( showGradient ) {
		noStroke();
		for ( int i=0; i < numGradientColours; i++ ) {
			fill(gradientColours[i]);
			rect ( i % width, i / width, 1,10 );
		}
	}
}


void setForce() {
	initField(densPrev);
	initField(uPrev);
	initField(vPrev);

	if ( mousePressed ) {
		int x, y;

		x = ( mouseX * n ) / ( width ) + 1;
		y = ( mouseY * n ) / ( height ) + 1;

		if ( !keyPressed )
			shiftPressed = false;

		if ( mouseButton == LEFT && !shiftPressed ) {
			//uPrev [x,y] += (mouseX - prevMouseX);
			//vPrev [x,y] += (mouseY - prevMouseY);

			setForceArea ( uPrev, x, y, mouseX - prevMouseX, velocityBrushSize );
			setForceArea ( vPrev, x, y, mouseY - prevMouseY, velocityBrushSize );
		}
		else {
			//densPrev [x,y] += 5;
			int m = (mouseX - prevMouseX) + (mouseY - prevMouseY);
			setForceArea ( densPrev, x, y, range(abs(m),0,2), densityBrushSize );
		}
	}

	prevMouseX = mouseX;
	prevMouseY = mouseY;

}

float range(float f, float minf, float maxf) {
	return max ( min ( f, maxf ), minf );
}

void setForceArea(float[][] field, int x, int y, float s, float r) {

	int i,j, dx, dy;
	float f;

	for ( i = int(range(x-r,1,n)); i <= int(range(x+r,1,n)); i++ ) {
		dx = x - i;
		for ( j = int(range(y-r,1,n)); j <= int(range(y+r,1,n)); j++ ) {
			dy = y - j;
			f = 1 - ( sqrt(dx*dx + dy*dy) / r );
			field[i][j] += range(f,0,1) * s;
		}
	}

}


void keyPressed() {

	if ( keyCode == 32 ) {
		gradient.makeRandomGradient(4);
		gradientColours = gradient.makeArrayOfColours(numGradientColours);
	}

	if ( key == 'v' )
		showVelocity = !showVelocity;

	if ( key == 'n' )
		showNormals = !showNormals;

	if ( key == 'd' )
		showDensity = !showDensity;

	if ( key == 'l' )
		showLighting = !showLighting;

	if ( key == 'r' )
		reset();

	if ( key == '+' )
		viscosity += 0.0001;
	if ( key == '-' )
		viscosity -= 0.0001;

	viscosity = max(viscosity, 0);

	if ( key >= '0' && key <= '7' ) {
		gradient.makeDefaultGradient(key - '0');
		gradientColours = gradient.makeArrayOfColours(numGradientColours);
	}

	if ( key == 'g' )
		showGradient = ! showGradient;

	if ( key == 's' )
		save("screenshot-" + year() + month() + day() + hour() + minute() + second() + ".png");

	if ( key == CODED )
		if ( keyCode == SHIFT )
			shiftPressed = true;

}

class Gradient {

	/*
	  Class for generating gradients of arbitrary colours.
	  Colours can be positioned to move them closer together or further apart.
	  Default and random gradients can be created.
	  An array of color objects of any size can be created.
	  
	  Inspired by Toxi's code here: http://processing.org/discourse/yabb/YaBB.cgi?board=Contribution_Responsive;action=display;num=1051560846
	*/

	/* Default Gradients - 'borrowed' from http://www.plasmapong.com/ */
	public static final int DEFAULT_BLACK_TO_WHITE = 0;
	public static final int DEFAULT_RANDOM = 1; // makes a new random gradient each time
	public static final int DEFAULT_SPECTRUM = 2;
	public static final int DEFAULT_INFRARED = 3;
	public static final int DEFAULT_BLACKBODY = 4;
	public static final int DEFAULT_NEON = 5;
	public static final int DEFAULT_WINTER = 6;
	public static final int DEFAULT_SUMMER = 7;


	private class GradientNode {
		float  location; // placement of this node within the gradient - 0.0 to 1.0
		color  col; // colour of the node
		GradientNode(float l, color c) {
			location = l;
			col = c;
		}
	}

	private GradientNode[] nodes;

	Gradient() {
		// create a black to white gradient on construction
		makeDefaultGradient(DEFAULT_BLACK_TO_WHITE);
	}

	void addNode(float location, color col) {
		// add a node to the gradient, specifying the location (0.0-1.0) and the colour
		// NOTE HACK colours should be added in ascending order of location - needs to resort the nodes on adding

		if ( nodes.length == 0 ) {
			nodes = new GradientNode[1];
			nodes[0] = new GradientNode(location, col);
		}
		else {
			GradientNode[] newNodes = new GradientNode[nodes.length+1];
			System.arraycopy(nodes,0, newNodes,0, nodes.length);
			newNodes[nodes.length] = new GradientNode(location, col);
			nodes = newNodes;
		}
	}

	void clear() {
		nodes = new GradientNode[0];
	}

	void makeDefaultGradient(int defaultGradient) {

		clear();

		switch ( defaultGradient ) {
		case DEFAULT_BLACK_TO_WHITE:
			addNode ( 0, 0x000000 );
			addNode ( 1, 0xFFFFFF );
			break;
		case DEFAULT_RANDOM:
			makeRandomGradient(4);
			break;
		case DEFAULT_SPECTRUM:
			addNode ( 0,    0xFF0000 );
			addNode ( 0.25, 0xFFFF00 );
			addNode ( 0.5,  0x00FF00 );
			addNode ( 0.75, 0x00FFFF );
			addNode ( 1,    0x0000FF );
			break;
		case DEFAULT_INFRARED:
			addNode ( 0,    0x000000 );
			addNode ( 1.0/6,0x000080 );
			addNode ( 2.0/6,0x800080 );
			addNode ( 3.0/6,0xFF0000 );
			addNode ( 4.0/6,0xFF8000 );
			addNode ( 5.0/6,0xFFFF00 );
			addNode ( 1,    0xFFFFFF );
			break;
		case DEFAULT_BLACKBODY:
			addNode ( 0,    0x000000 );
			addNode ( 1.0/5,0x0040FF );
			addNode ( 2.0/5,0x00C0FF );
			addNode ( 3.0/5,0xFF4000 );
			addNode ( 4.0/5,0xFFC000 );
			addNode ( 1,    0xFFFFFF );
			break;
		case DEFAULT_NEON:
			addNode ( 0,    0x000000 );
			addNode ( 0.25, 0x3333FF );
			addNode ( 0.5,  0x0099FF );
			addNode ( 0.75, 0xE60080 );
			addNode ( 1,    0xFF00FF );
			break;
		case DEFAULT_WINTER:
			addNode ( 0,    0x4C80FF );
			addNode ( 0.5,  0xE6E6E6 );
			addNode ( 1,    0x999999 );
			break;
		case DEFAULT_SUMMER:
			addNode ( 0,    0x334CFF );
			addNode ( 0.25, 0xFF0080 );
			addNode ( 0.5,  0xFF8033 );
			addNode ( 0.75, 0xCC4C00 );
			addNode ( 1,    0xFFCC00 );
			break;
		}

	}

	void makeRandomGradient(int numColours) {
		float location, locationMin, locationMax;
		int r,g,b;

		clear();

		for ( int n=0; n < numColours; n++ ) {
			if ( n == 0 )
				location = 0.0;
			else if ( n == numColours-1 )
				location = 1.0;
			else {
				locationMin = float(n)/numColours;
				locationMax = float(n+1)/numColours;
				location = random ( locationMin, locationMax );
			}

			r = int(random(2.5)) * 128;
			g = int(random(2.5)) * 128;
			b = int(random(2.5)) * 128;

			addNode ( location, color(r,g,b) );
		}
	}

	color getColour(float location) {
		float bandLocation, bandScale, bandDelta;
		float r,g,b;

		for ( int c=0; c < nodes.length-1; c++ ) {
			if ( location >= nodes[c].location && location <= nodes[c+1].location ) {
				bandScale = nodes[c+1].location - nodes[c].location;
				bandLocation = location - nodes[c].location;
				bandDelta = bandLocation / bandScale;

				r = bandDelta * ( red(nodes[c+1].col) - red(nodes[c].col) ) + red(nodes[c].col);
				g = bandDelta * ( green(nodes[c+1].col) - green(nodes[c].col) ) + green(nodes[c].col);
				b = bandDelta * ( blue(nodes[c+1].col) - blue(nodes[c].col) ) + blue(nodes[c].col);
				return color(r,g,b);
			}
		}
		return color(0,0,0);
	}

	color[] makeArrayOfColours(int numColours) {

		float location, bandLocation, bandScale, bandDelta;
		color[] cols = new color[numColours];

		for ( int i=0; i < numColours; i++ ) {
			location = float(i) / (numColours-1);
			cols[i] = getColour(location);
		}

		return cols;
	}

}

/*
float res =8;

class Fluid{

	Cell cell[][];

	Fluid(){
		cell = new Cell[(int)(width/res)][(int)(height/res)];

		for(int i =0;i<cell.length;i++){
			for(int ii =0;ii<cell[i].length;ii++){
				cell[i][ii] = new Cell(i,ii);
			}
		}

	}

	void calc(){
		for(int i =0;i<cell.length;i++){
			for(int ii =0;ii<cell[i].length;ii++){
				cell[i][ii].calc();
			}
		}

	}


	void draw(){
		for(int i =0;i<cell.length;i++){
			for(int ii =0;ii<cell[i].length;ii++){
				cell[i][ii].draw();
			}
		}


	}




}

class Cell{


	float x,y;
	float pressure;
	PVector low,high;
	int id;

	Cell(int _x,int _y){
		//parent = _parent;

		x = _x;
		y = _y;

		id = (int)(y*height+x);

		pressure = random(0.9,1.1);
		low = new PVector(0,0);
		high = new PVector(0,0);
		//println("cell no. "+id+" created");
	}



	void calc(){

		int counter = 0;
		int index1[] = new int[0];
		int index2[] = new int[0];
		for(int i =0;i<fl.cell.length;i++){
			for(int ii =0;ii<fl.cell[i].length;ii++){
				if(dist(fl.cell[i][ii].x,fl.cell[i][ii].y,x,y)<rad){
					index1 = (int[])append(index1,i);
					index2 = (int[])append(index2,ii);
					counter++;
				}
			}

		}


		float prss = 0.0;
		high = new PVector(0,0);
		low = new PVector(0,0);
		for(int i =0;i<index1.length;i++){

			Cell tmp = fl.cell[index1[i]][index2[i]];
			prss += tmp.pressure;

			if(tmp.pressure>pressure){
				high.add((tmp.x-x),(tmp.y-y),0);
			}else{
				low.add((tmp.x-x),(tmp.y-y),0);
			}

		}

		low.normalize();
		high.normalize();
		pressure += (prss-pressure)/30.0;

		x += (low.x-x)/20.0;
		y += (low.y-y)/20.0;

		x -= (high.x-x)/20.0;
		y -= (high.y-y)/20.0;

	}

	void draw(){

		stroke(0,150);
		line(x*res,y*res,x*res+1,y*res);

	}

}*/
/**
*  CatastropheTwo by Krystof Pesek, licensed under Creative Commons Attribution-Share Alike 3.0 license.
*  Work: http://openprocessing.org/visuals/?visualID=8802
*  License: http://creativecommons.org/licenses/by-sa/3.0/
*
* visit more @ http://vimeo.com/kof
* if you leave this header, bend, share, spread the code, it is a freedom!
*
*   ,dPYb,                  ,dPYb,
*   IP'`Yb                  IP'`Yb
*   I8  8I                  I8  8I
*   I8  8bgg,               I8  8'
*   I8 dP" "8    ,ggggg,    I8 dP
*   I8d8bggP"   dP"  "Y8ggg I8dP
*   I8P' "Yb,  i8'    ,8I   I8P
*  ,d8    `Yb,,d8,   ,d8'  ,d8b,_
*  88P      Y8P"Y8888P"    PI8"8888
*                           I8 `8,
*                           I8  `8,
*                           I8   8I
*                           I8   8I
*                           I8, ,8'
*                            "Y8P'
*
*/

float tras = 2.0;
PGraphics frame;
float valx = 0.0,valy = 45.23;

void setup(){
	size(320,240,P3D);
	fill(0);
	frameRate(20);
	noStroke();
	loadPixels();

	frame = createGraphics(width+20,height+20,P2D);
	frame.beginDraw();

	frame.stroke(0,120);
	frame.noFill();
	frame.strokeWeight(20);

	frame.stroke(0,40);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,10);

	frame.stroke(0,120);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,2);

	frame.endDraw();

	noSmooth();
}

void draw(){
	
	background(255);
	pre();
	prod();
	post();

}

void prod(){

	stroke(0,50);
	fill(0,10);

	pushMatrix();
	translate(width/2,height/2,100);
	for(int i  =0 ;i<30;i++){
		pushMatrix();
		rotateY(noise(frameCount/(cos(frameCount/100.0)+10)/100.0+i)*10.0);
		rotateX(noise(frameCount/(sin(frameCount/130.78)+10)/50.3+i)*10.0);
		rotateZ(noise(frameCount/(sin(frameCount/330.0)+10)/103.3+i)*10.0);
		//pushMatrix();
		//translate(noise(frameCount*i/200.0)*50,0);
		box(i*2);

		//popMatrix();
		popMatrix();
	}

	popMatrix();

}

void pre(){

	beginShape(QUADS);
	fill(80+noise(frameCount/4.0)*50);
	vertex(0,0);
	vertex(width,0);
	fill(255);
	vertex(width,height);
	vertex(0,height);
	endShape(CLOSE);

	float modx = noise(valx++)*tras-tras/2.0;
	float mody = noise(valy++)*tras-tras/2.0;
	pushMatrix();
	translate(modx,mody);
	translate(-random(2),-random(2));

}

void post(){

	translate(random(2),random(2));
	for(int i =0;i<3;i++){
		stroke(0,25);
		line(width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,0,width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,height);
	}
	
	popMatrix();

	//resetMatrix();
	image(frame,-random(2),-random(2));
	for(int i =0;i<pixels.length;i++)
		pixels[i] = color(brightness(pixels[i])+random(-25,3));
	filter(BLUR,0.76);

}
/**
*  CatastropheTwo by Krystof Pesek, licensed under Creative Commons Attribution-Share Alike 3.0 license.
*  Work: http://openprocessing.org/visuals/?visualID=8802
*  License: http://creativecommons.org/licenses/by-sa/3.0/
*
* visit more @ http://vimeo.com/kof
* if you leave this header, bend, share, spread the code, it is a freedom!
*
*   ,dPYb,                  ,dPYb,
*   IP'`Yb                  IP'`Yb
*   I8  8I                  I8  8I
*   I8  8bgg,               I8  8'
*   I8 dP" "8    ,ggggg,    I8 dP
*   I8d8bggP"   dP"  "Y8ggg I8dP
*   I8P' "Yb,  i8'    ,8I   I8P
*  ,d8    `Yb,,d8,   ,d8'  ,d8b,_
*  88P      Y8P"Y8888P"    PI8"8888
*                           I8 `8,
*                           I8  `8,
*                           I8   8I
*                           I8   8I
*                           I8, ,8'
*                            "Y8P'
*
*/

float tras = 2.0;
PGraphics frame;
float valx = 0.0,valy = 45.23;

void setup(){
	size(320,240,P3D);
	fill(0);
	frameRate(20);
	noStroke();
	loadPixels();

	frame = createGraphics(width+20,height+20,P2D);
	frame.beginDraw();

	frame.stroke(0,120);
	frame.noFill();
	frame.strokeWeight(20);

	frame.stroke(0,40);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,10);

	frame.stroke(0,120);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,2);

	frame.endDraw();

	noSmooth();
}

void draw(){
	background(255);
	pre();
	prod();
	post();
}

void prod(){
	stroke(0,50);
	fill(0,10);

	pushMatrix();
	translate(width/2,height/2,100);
	for(int i  =0 ;i<30;i++){
		pushMatrix();
		rotateY(noise(frameCount/(cos(frameCount/100.0)+10)/100.0+i)*10.0);
		rotateX(noise(frameCount/(sin(frameCount/130.78)+10)/50.3+i)*10.0);
		rotateZ(noise(frameCount/(sin(frameCount/330.0)+10)/103.3+i)*10.0);
		//pushMatrix();
		//translate(noise(frameCount*i/200.0)*50,0);
		box(2*i);

		//popMatrix();
		popMatrix();
	}
	popMatrix();

}

void pre(){

	beginShape(QUADS);
	fill(80+noise(frameCount/4.0)*50);
	vertex(0,0);
	vertex(width,0);
	fill(255);
	vertex(width,height);
	vertex(0,height);
	endShape(CLOSE);

	float modx = noise(valx++)*tras-tras/2.0;
	float mody = noise(valy++)*tras-tras/2.0;
	pushMatrix();
	translate(modx,mody);
	translate(-random(2),-random(2));

}

void post(){

	translate(random(2),random(2));
	for(int i =0;i<3;i++){
		stroke(0,25);
		line(width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,0,width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,height);
	}
	
	popMatrix();

	//resetMatrix();
	image(frame,-random(2),-random(2));
	for(int i =0;i<pixels.length;i++)
		pixels[i] = color(brightness(pixels[i])+random(-25,3));
	filter(BLUR,0.76);
}
// Sktript Dva
// Obraz a kod 2010

// vice v lexikonu _02_ funkce programu

void setup(){

	size(640,480);
	noFill();
	stroke(255);
	rectMode(CENTER);

}



void draw(){

	background(0);	
	// mouseX a mouseY jsou promenne ktere zjisti aktualni
	// pozici mysi na plose
	rect( mouseX, mouseY, 90, 60);

}
float tras = 2.0;
PGraphics frame;
PImage tup,trees;
float valx = 0.0,valy = 45.23;

boolean rec = false;

void setup(){
	size(320,240,P2D);
	fill(0);
	frameRate(20);
	noStroke();

	tup = loadImage("tu.png");	
	trees = loadImage("trees.png");
	

	loadPixels();

	frame = createGraphics(width+20,height+20,P2D);
	frame.beginDraw();

	frame.stroke(0,120);
	frame.noFill();
	frame.strokeWeight(20);

	frame.stroke(0,40);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,10);

	frame.stroke(0,120);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,2);

	frame.endDraw();

	noSmooth();
	
}

void draw(){
	background(255);
	pre();
	prod();
	post();
}

void prod(){
	stroke(0,50);
	fill(0,10);

	tint(#fdee9d);
	image(tup,random(-10,10)/10.0+noise(frameCount/100.0)*80,noise(frameCount/1000.0)*180+noise(frameCount/100.0)*12.0,tup.width/2,tup.height/2);
	noTint();
	
	image(trees,((frameCount*40)%(trees.width*2))-trees.width,height/2-50);
	image(trees,((frameCount*40)%(trees.width*3))-trees.width*2,height/2-50);
	image(trees,((frameCount*40)%(trees.width))-trees.width*2,height/2-50);
	image(trees,((frameCount*40)%(trees.width*3))-trees.width,height/2-50);
	
}

void pre(){

	beginShape(QUADS);
	fill(20+noise(frameCount/4.0)*50);
	vertex(0,0);
	vertex(width,0);
	fill(#a8d8ff);
	vertex(width,height);
	vertex(0,height);
	endShape(CLOSE);

	float modx = noise(valx++)*tras-tras/2.0;
	float mody = noise(valy++)*tras-tras/2.0;
	pushMatrix();
	translate(modx,mody);
	translate(-random(2),-random(2));
}

void post(){

	translate(random(2),random(2));
	for(int i =0;i<3;i++){
		stroke(0,25);
		line(width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,0,width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,height);
	}
	
	popMatrix();

	image(frame,-random(2),-random(2));
	for(int i =0;i<pixels.length;i++){
		float glitch = random(-85,3);
		pixels[i] = color(red(pixels[i])+glitch,green(pixels[i])+glitch,blue(pixels[i])+glitch);
	}
		filter(ERODE);
	filter(BLUR,random(1,2));
	
	
}
// Sktript Jedna
// Obraz a kod 2010

// velikost okna s parametry (x,  y) v poctu pixelu
size(320,240);

// promenna ''barva" definovana prikazem "color(cervena,zelena,modra);" min 0 .. 255 max
color barvaPozadi = color(255,0,0);

// pozadi background(color) vyplni plochu jednou barvou
background(barvaPozadi);

// nastaveni vyplne fill s parametry (cervena,zelena,modra,[pruhlednost])
// pro zadnou vypln prikaz noFill();
fill(0,0,0);

// stejne tak prikaz stroke(cervena,zelena,modra,[pruhlednost]);
// zadna kontura noStroke();
noStroke();

// rect mode znaci mod kresleni obdelniku CENTER znamena ze
// prvni dve promenne x a y budou na stredu obelniku
rectMode(CENTER);

// obdelnik rect(pozice x,pozice y, sirka, vyska);
// width je promenna ktera zjisti sirku okna, height je promenna ktera zjisti vysku
rect(width/2, height/2, 90, 60);

// zde program konci


// Sktript Ctyri
// Obraz a kod 2010

// vice v lexikonu _07_ smycky

int X,Y;

void setup(){

	size(320,240);
	
	rectMode(CENTER);
	
	fill(0);

}

void draw(){
	
	background(127);

	X = mouseX;
	Y = mouseY;

	for(int x = 0; x < width ; x+=5 ){
		for(int y = 0; y < height ; y+=5 ){
			// pseudonahodne cislo od 0 .. 255
			// map skaluje parametry (puvodni min, puvodni max, vysledny min, vysledny max)
			// vzdalenost se meri funkci dist(x1, y1, x2, y2);
			fill( map( dist(X,Y,x,y), 0, 100, 0, 255) ); 
			
			 // na kazde pozici udelej bod
			rect( x, y , 5, 5);
		}
	}

}

// Sktript Pet
// Obraz a kod 2010

// komplikovanejsi program
// doporucuji male zmeny systemem "pokus omyl"

/*
* [0][1][2]
* [3][x][4]
* [5][6][7]
*/


int[][] px;
int matrix[][][];
int mm[] = {3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,6,7};
int mod[];

int runNum[];


void setup(){
	size(640,480,P2D);
	px = new int[width][height];
	matrix = new int[width][height][mm.length];
	runNum = new int[width*height];
	mod = new int[width*height];
	frameRate(50);

	loadPixels();
	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			runNum[y*width+x] = 0;
			mod[y*width+x] = 0;
			px[x][y] = color(0);

			for(int i = 2;i<mm.length-1;i+=3){
				matrix[x][y][i] = mm[i];
				matrix[x][y][i-1] = mm[i-1];
				matrix[x][y][i-2] = (int)random(8);
			}

			matrix[x][y] = (int[])expand(matrix[x][y],matrix[x][y].length+1);
			matrix[x][y][matrix[x][y].length-1] = (int)random(8);

			pixels[y*width+x] = px[x][y];
		}
	}
}

void draw(){

	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			int index = y*width+x;

			if(runNum[index]>=matrix[x][y].length-1){
				runNum[index] = 0;
			}

			if(index%2==0)
				mod[index]++;

			int shx = 0, shy = 0;

			int modded = (matrix[x][y][runNum[index]]+mod[index])%7;
			switch(modded){
			case 0:
				shx = -1;
				shy = -1;
				break;

			case 1:
				shx = 0;
				shy = -1;
				break;

			case 2:
				shx = 1;
				shy = -1;
				break;

			case 3:
				shx = -1;
				shy = 0;
				break;

			case 4:
				shx = 1;
				shy = 0;
				break;

			case 5:
				shx = -1;
				shy = 1;
				break;

			case 6:
				shx = 0;
				shy = 1;
				break;

			case 7:
				shx = 1;
				shy = 1;
				break;
			}


			if(x>width/2)
				px[x][y] = pixels[((y+height-shy+mod[index])%height)*width+((x+width+shx+mod[index])%width)];
			else
				px[x][y] = pixels[((y+height+shy+mod[index])%height)*width+((x+width-shx+mod[index])%width)];

			runNum[index]++;
		}
	}

	int r = (int)((sin(frameCount/30.0)+1)*20);
	int r2 = (int)((cos(frameCount/33.3333)+1)*20);

	for(int x = 0;x<width;x++){
		for(int y = 0;y<height;y++){
			int index = y*width+x;
			if(x>width/2-r&&x<width/2+r&&y<height/2+r&&y>height/2-r){
				pixels[index] = color(0);
			}else if(x>width/2-r2&&x<width/2+r2&&y<height/2+r2&&y>height/2-r2){
				pixels[index] = color(255);
			}else{
				pixels[index] = px[x][y];
			}

		}

	}
	//println(frameCount);
}
// processing 2 - NOD / Roxy 6.5. 2008 Praha
// :: krystof pesek

// 11 objekt, koncepce, zaklady

// objekt je ucelena sada funkci, promennych, operaci ktere
// se chovaji jako jednotne teleso
// objekty se pouzivaji pro organizaci kodu do srozumitelnejsiho tvaru
// pod objektem je mozno predstavit si cokoli, v tomto prikladu
// budeme pracovat s jadnoduchym objektem ktery bude reagovat na uzivateluv
// vstup a kreslit jednoduchy obrazec

// telo objektu vypada nasledovne:
// v processingu se definice omezuje na slovo "class" - tedy hrube prelozeno jako trida
// k zalozeni vlastni class piseme takto:

// class MujObjekt{
//  
// }

// timto se vytvorila class nazvana "MujObjekt"
// ta v sobe muze drzet neomezeny pocet funkci a promennych
// tak napriklad:

class MujObjekt{
  float x;
  float y;
  float rychlost;
  float w,h;

  // tzv. konstruktor je volan jen pri vytvoreni obejktu
  // konstruktor muze obsahovat i vstup promennych z vnejsku
  // napr.
  //  MujObjekt(float _x){
  // //prebrani promenne z vnesku do lokalni objektove
  //   x=_x;
  // }
  // konstruktoru muze byt i vice v jednom objektu
  // tedy objekt muze mit vice verzi zrodu
  // to se da napsat rozdilnymi argumenty v kulatych zavorkach konstruktoru
  //
  // MujObjekt(){ ... }
  // MujObjekt(float x, float y,int id){ ... }


  MujObjekt(){
    y = height/2.0;
    x = width/2.0;
    rychlost = 3.0;
    w = h = 5;
  }

  // funkce ktera pricte k "x" promennou "rychlost", pohyb doprava;
  void pohniSeDoprava(){
    x+=rychlost;
  }

  // funkce ktera odecte od "x" promennou "rychlost", pohyb doleva;
  void pohniSeDoleva(){
    x-=rychlost;
  }

  //funkce ktera vykresli objekt
  void vykresli(){

    // volani vnitrni promenne, i bez teckove syntaxe je srozumitelne
    // rovna se this.zustanNaPlose();
    zustanNaPlose();

    noStroke();
    fill(0);
    rect(x,y,w,h);
  }

  void zustanNaPlose(){
    x = constrain(x,0,width-w); 
    y = constrain(y,0,width-h);    
  }
}


//////////////////////////////////////////////////////////////
// voila
// nyni mame svuj jednoduchy objekt definovan, ten nemusi byt nezbytne na
// zacatku programu, muze byt kdekoli
// nize priklad jak se da pouzit..
//////////////////////////////////////////////////////////////


// vytvoreni objektu zde;
MujObjekt instanceObjektu;

void setup(){
  // tzv. cast objektu, zde se objekt vytvari - vola se konstruktor
  instanceObjektu = new MujObjekt(); 
  size(400,200); 
}

void draw(){
  background(255);
  
  //delici cara na polovine
  stroke(0,155);
  line(width/2.0,0,width/2.0,height);

  if(mouseX>width/2.0){
    // teckovou syntaxi se da takto zavolat funkce objetku
    instanceObjektu.pohniSeDoprava();    
  }
  else if(mouseX<width/2.0){
    instanceObjektu.pohniSeDoleva();    
  }

  //volani kreslici funkce do drawu
  instanceObjektu.vykresli();

  // na vnitrni funkce promenne cokoli se muzeme zvnejsi dostat teckovou syntaxi..
  println("X: "+instanceObjektu.x+"   Y: "+instanceObjektu.x);
}

// objekty maji dalsi zajimave vlastnosti, moho mezi sebou komunikovat
// navzajem se vytvaret, dedit svoje vlastnosti, modifikovat je atd..
// cela koncepce je prevzata z javy, temer cokoli co lze napsat jave
// lze i v processingu, vyjma nejakych poslednich specialit, processing
// defaultne bezi pod javou 1.4.2, tedy vse co je kompatibilni s touto javou
// jinak se da pouzit tzv processing expert pro custom nastaveni
//
// vice o objektech v java referencich:
// http://java.sun.com/docs/books/tutorial/java/concepts/index.html


// objekty mohou tvorit i pole
// v nasledujici sketchi bude popsan koncept poli objektu

// processing 1 - NOD 28.4. 2008 Praha
// :: krystof pesek

// Prace s promnennymi
// prirazeni hodnoty: =
//
// zakladnio operace: +,-,*,/
// prirustky: ++,--
// porovnavani: ==,!=,<,>
//
// dalsi operace: +=7,-=3,*=4,/=2
// zvlastni operace: % (modulo)
// (bitwise operace pro milovniky hexu &,|, a bit shifty - posuny: >> <<)
//
// dale matematicke operace:
// sq,sqrt,pow,dist,map,norm,constrain,round,ceil,roof,random..
// sin,cos,tan,atan,atan2 .. acos,asin
//
// zmeny datatypu.. "int nejakyInteger = (int)nejakyFloat";

// Vytvoreni promenne, zde se jedna o cele cislo - "int" - integer
int pocitadlo;
// lze vytvorit i s prirazenim hodnoty, napriklad: int pocitadlo = 0;
// promennou si muzeme nazvat jakkoli, zde "pocitadlo", doporuciji kratsi a vzdy vystizne :)

void setup(){
  size(200,200);
  stroke(255);
  // "stroke" barva kontury, v dalsim prikladu (_04_Kresba)

  pocitadlo = 0;
  // prirazeni hodnoty se provadi pomoci "=" 
  // promenna je vzdy vlevo, nova hodnota vpravo
}

void draw(){
  pocitadlo ++;
  // "++" toto je tzv increment - prirustek, promenna bude vzdy navysena o 1;
  // jedna se o zkreceny zapis "pocitadlo += 1;", nebo "pocitadlo = pocitadlo + 1;"
  // take mozne "--", decrement - ubytek

  background(pocitadlo); 
  // se zmenou v promenne se bude v case menit pozadi 0..255, cerna az bila
  // "background(color);"

  if(pocitadlo > 255) {
    pocitadlo = 0;
  }
  // jednoducha podminka, jestlize pocitadlo presahne 255 vrat zpet na nulu
  // vice nize..
}


/* .. k podminkam,
 podminky jsou velmi zakladnim nastrojem pro stavbu programu, utvari dej a odklonuji program do ruznych cest
 
 podminka se pise slovem "if", pak nasleduji kulate zavorky "( )" do nich patri dotaz,
 mohou nasledovat curly zavorky "{ }" v nich se pise to co ma byt spusteno jestlize je
 splnena predchozi podminka, tedy:
 if(neco > necoMensiho){ udelej toto }; 
 if(neco == 2){ udelej toto }; 
 
 nebo nejkratsi s booleanem:
 boolean b = true;
 if(b){ udelej toto }; 
 
 lze take napsat co se stane pokazde kdy neni splnena podminka, pomoci "else"
 
 if( 1 > 0 -coz neni) { udelal bych toto } else { jinak udelam toto };
 
 pracovat lze i s vicenasobnymi podminkami, "&&" znamena logicke A, "||" znamena logicke NEBO:
 if((neco > necoMensiho)&&(neco2 > necoMensiho)){ pri splneni obou podminek udelej toto };    
 if((neco > necoMensiho)||(neco2 > necoMensiho)){ pri splneni jedne ze dvou podminek udelej toto };
 
 pro dalsi pominkovani je jeste uzitecne:
 switch(neco){
 case 1: v pripade ze neco == 1, udelej toto; break;
 case 2: v pripade ze neco == 2, udelej neco jineho; break;
 case 3:....atd.
 } 
 
 a take:
 while(true){ delej dokud je pravda (nebo break;)} - dokud splnuje nejakou podminku opakuje prikazy v curly zavorece
 (while je blizsi smyckam "for"- tzv. iterace, vice v _07_Smycky)
 */
// processing 1 - NOD 28.4. 2008 Praha
// :: krystof pesek

// Kresba a dalsi prace s promennymi

int pocitadlo;

void setup(){
  size(200,200);

  stroke( 255 , 128 , 0 );
  // "stroke" udava barvu kontur objektu, pro zadnou barvu "noStroke()"
  // (255,128,0) RGB - "takova oranzova" - viz. TOOLS > COLORSELECTOR
  
  fill(255);
  // "fill" nastavuje barvu vyplne
  noFill();
  // pro zadnou vypln prikaz "noFill()"  

  // v pripade ze jsme zavolali stroke,fill,noStroke,noFill jen jednou,
  // prikazy budou fungovat globalne k celemu programu
  // jestlize v prubehu nize zavolame jednu z funkci znovu
  // prepise se dokud nebude volana znovu ...
  
  pocitadlo = 0; 
  // nase promenna - "pocitadlo" na nulu
}

void draw(){
  background(0); 
  pocitadlo ++; 
  
  line(0,pocitadlo,width,pocitadlo);  
  // "line" je linka,usecka jeji pozice se urcuje (x1,y1,x2,y2)
  // x1 - pocatecni bod x, y1 - pocatecni bod y
  // x2 - konecny bod x, y2 - konecny bod y
  // "width" je globalni promenna programu ktera drzi informaci o sirce okna
  // pro vysku je tu "height"
  
  rect(width/2,pocitadlo,20,20);
  // "rect" - rectangle - obdelnik (x,y,sirka,vyska)
  // x,y je v defaultu nastaven jako levy horni roh obdelniku (je mozne zmenit za pomoci "rectMode")
  // do kolonky x je zde zapsan vypocet "width/2" tzn. polovina sirky okenka  
  
  ellipse(width/2+30,pocitadlo,20,20);
  // "ellipse" (x,y,prumerX,prumerY)
  // x,y jsou nasaveny jako stred elipsy (je mozne zmenit za pomoci "ellipseMode")


  if(pocitadlo > height) {
    pocitadlo = 0;
  }
}
// processing 1 - NOD 28.4. 2008 Praha
// :: krystof pesek



//- Toto je KOMENTAR
// cokoli napisete po "//" bude programem ignorovano! (seda barva)

// nejlepsi pomoc v zacatcich psani kodu:
//     http://processing.org/reference/index.html
//     http://processing.org/learning/basics/index.html
//
// a take vrele doporucuji: FILE > EXAMPLES > *

// klavesove zkratky:
//
// oznaceny prikaz a ctrl+shif+f - otevre prohlizec s helpem k prikazu
// ctrl+r - spusti program (ctrl+shift+r - present mode)
// ctrl+t - autoformat, beautyfier, zarovnava text
// ctrl+k - otevre adresar sketche
// ctlr+f - klasicky find, replace nastroj
// ctrl+s - save, se shiftem pak -save as
// ctrl+e - export jako applet, se shiftem - jako aplikace

/* viceradkovy komentar se pise takto:
toto je viceradkovy KOMENTAR
toto je viceradkovy KOMENTAR
toto je viceradkovy KOMENTAR
toto je viceradkovy KOMENTAR
*/

/*zacatek .............. konec*/

// Prikaz je vzdy ukoncen strednikem ";"
// text je interpretovan "CaSe SeNsITive" ..neni jako.. "case sensitive" 

// Zakladni typy promennych
boolean a = true; // boolean je pravda nebo lez, "TRUE" nebo "FALSE"
int b = 1; // int - integers - cela cisla, 1,5,8,1207,-12144
float c = 1.67; // cisla s desetinnou carkou, 1.314, -5.87, 144.37687
byte d = -24; //cisla jen s rozsahem 255, byte -127 az 127 
char e = 'A'; //chars - znaky reprezentuji znakovou sadu, a,b,z,?,@,$ 
String f = "hello world!"; // tzv. Strings - retezce drzi v sobe pole znaku, text "Ema mele maso.."

color g = color(18,255,0); // color je promenna drzici barvu, 
//!pozor nezamenovat s javackou "Color", je to processingova specialita a lze prirazovat ve tvarech:
/* color(0..255) -skala sede
   color(0..255,0..255) - skala sede + alpha kanal
   color(0..255,0..255,0..255) red green blue
   color(0..255,0..255,0..255,0..255) red green blue + alpha
   
   .. nebo take: color(#FFCC00).. v html stylu =(hex)(0xFFFFCC00)
   vice o barevnych modech pod "colorMode()" - HSB,RGB,RGBA...
*/


// Tisk do konzole
// velmi prakticka vec pro kontrolu kodu,
// prikazy "print(neco)", "println(cokoli)"
// umi zobrazovat jakekoli hodnoty v konzoli (cerne okno dole pod kodem)

// tisk, vse do jednoho radku prikazem "print( moje promenna )"
print("tisk do stejne radky: ");
print(a+", "); // mezi textem a promennymi se pise "+" (mezera je take text)
print(b+", ");
print(c+", ");
print(d+", ");
print(e+", ");
print(f);
print("\n \n"); //nova radka pro win,unix se tusim znaci "\n" - newline

//nebo pokazde na novy radek, prikazem "println( neco )"
println("tisk na novou radku: ");
println(a+" ");
println(b+" ");
println(c+" ");
println(d+" ");
println(e+" ");
println(f+" ");

// !!! pozn. !!! 
// veskere ukazkove kody jsou spustitelne
// tlacitko nahore vlevo "Run" nebo klavesova zkratka - win,linux "Ctrl+R", mac "apple+R"
// processing 2 - NOD / Roxy 6.5. 2008 Praha
// :: krystof pesek

// 12 pole objektu a jejich vzajemna interakce//

// promenna drzici pocet castic
int pocetCastic = 500;

// zde se vytvari pole objektu "[]"
// zatim je abstraktne velke
Castice castice[];

void setup(){
  size(400,400,P3D);
  background(0);
  
  // zde si urcime velikost pole
  castice = new Castice[pocetCastic];
  
  // a naplnime ho vicenasobnym castem naseho objektu..
  for(int i = 0;i< pocetCastic;i++){
    // posleme do kazdeho objektu "[i]" - "i" promennou, ktera se promeni
    // v objektu v "id".. viz nize
    castice[i] = new Castice(i); 
  }
}



void draw(){  
  // syckou kazdy obekt zavolame k behu
  // tedy vypocte a vykresli se zde 500 objektu kazde okno
  for(int i = 0;i< pocetCastic;i++){
    castice[i].spust(); 
  }
}


// definice class "Castice"
class Castice{
  // jeji lokalni promenne
  float x,y;
  float speed = 10000.0;
  int id;
  float vzdalenost;
  float okruh = 100.0;
  boolean visible = true;

  // jeji konstruktor
  Castice(int _id){
    // prevzeti promenne ktera bude posleze pouzita pro identifikaci objektu
    id=_id;

    //width a height jsou globlani promenne ktere objekt zna, jako kterekoli jine globalni promenne
    x=random(width); 
    y=random(height);    
  }

  // funkce ktera pouze spousti lokalni funkce, navenek bude srozumitelnejsi
  void spust(){
    pocitej();
    
    if(visible){
      kresli();    
    }
  }
  
  
  // funkce zajistujici vypocet pohybu
  void pocitej(){
    for(int i = 0;i< castice.length;i++){
      if(id!=i){
        vzdalenost = dist(x,y,castice[i].x,castice[i].y);          
        if(vzdalenost < okruh/3.0){
          x -= (castice[i].x-x) / (speed*0.2);
          y -= (castice[i].y-y) / (speed*0.2);
        }else if(vzdalenost < okruh){
          x += (castice[i].x-x) / speed;
          y += (castice[i].y-y) / speed;
        }
      }
    }
    hranice();        
  }

  void hranice(){
    x=constrain (x,0,width);
    y=constrain (y,0,height);

  }

  void kresli(){
    noStroke();
    fill(255,5);
    rect(x,y,3,3);
  }
}


// timto zpusobem se daji programy vrstvit a rozdelovat,
// pro prehlednejsi usporadani a lepsi orientaci v kodu

// processing 1 - NOD 28.4. 2008 Praha
// :: krystof pesek

// 07 Smycky

void setup(){
 size(100,100); 
}

int X,Y;

void draw(){  
  X = mouseX;
  Y = mouseY;
  
  for(int x = 0; x < width ; x+=5 ){
    for(int y = 0; y < height ; y+=5 ){
      stroke( map(dist(X,Y,x,y),0,100,0,255) ); //pseudonahodne cislo od 0..255 - pro kazdy pixel jina barevna (cernobila) hodnota
      point(x,y); // na kazde pozici udelej bod
    } 
  }
  
}




// processing 1 - NOD 28.4. 2008 Praha
// :: krystof pesek

// 08 Knihovny

/* Obrovskou silou processingu je moznost jeho rozsireni
  v soucasne dobe existuje nespocet moznych knihoven ke stazeni (primo na processing.org)
  
  Processing potrebuje mit vsechny knihovny nakopirovane ve slozce "libraries"
  pod rootem hlavniho programu
  
  V tomto prikladu je vyuzivana knihovna VIDEO, ktera je soucasti zakladniho baliku processingu
  stejne jako dalsi knihovny:
  DXF - pro praci s vektorovym vystupem autocad, 3d programy atd.
  XML - pro praci s tabulkami
  CANDY - pro nacitani vektorove grafikou ve formatu svg - Adobe Illustrator
  JAVASCRIPT - komunikace s prohlizeci servery skrze javascript
  PDF - specialni renderer pro tisk do PDF
  OPENGL - pristup processingu ke graficke akceleraci, velmi uzitecne pro narocnejsi kresleni
  SERIAL - seriova datova komunikace, od Arduina pres bluetooth az po buhvico 
  
  a konecne VIDEO - balik pro praci s videem, tato knihovna vyzaduje pro zakladni funkcnost nainstalovany quicktime
  take na nekterych Win pocitacich vhodny win-Vdig (quicktimovy hack pro javu)
  knihovna umi jak zobrazovat video, komunikovat s externimi zarizenimi (webkamerami), tak nahravat do souboru
     
 */

// prvni vec kterou jakakoli knihovna potrebuje, je prikaz "import"
// to se da napsat takto:
import processing.video.*;
// nebo jednoduseji vyberte ze zalozky SKETCH > IMPORT LIBRARY > VIDEO 

Movie mojeVideo;
// "Movie" je objekt z knihovny
// objekt je soubor funkci, promennych a sad nastroju(interfacu) pro jeho ovladani
// .. o objektech pozdeji


void setup() {
  size(640, 480, P3D);
  // pro rychlejsi render je zde pouzita zakladni akcelerace P3D..
  // je to dalsi moznost funkce "size(x,y,render)"
  // processing zatim nabizi tyto renderery:
  // "JAVA2D" - prednastaveny, klasicky, cisty a trochu pomalejsi
  // "P2D" - zatim nedopracovana 2D gradicka akcelerace - nepouzitelna 
  // "P3D" - velmi vykony pro carovou grafiku, obraz, mnoho objektu na scene, podporuje z dimenzi
  // "OPENGL" - vykony ale mene kompatibilni 3D renderer, obcas mi prijde cistsi nez P3D, vyzaduje importovani knihovny "OPENGL"
  
  // "PDF" - jen pro tisk do souboru *.pdf, vyzaduje import knihovny PDF
  
  background(0);
  // pozadi jedenkrat.. jsme v "setupu"
  
  // instanci knihovniho objektu "Movie" nazvanemu "mojeVideo" vytvorime takto:
  mojeVideo = new Movie(this, "station.mov");
  // zakladani objektu je vzdy velmi podobne
  // funnguje podobne jako promenna
  // klicove slovo "new" znaci vytvoreni objektu
  // nasleduje jmeno objektu s argumenty "this" a "nazvemSouboru.mov"
  // "this" - vetsinou potrebuji knihovny vedet pro svoji implementaci do naseho kodu
  // (odkazuje k tomuto kodu, ktery je vlastne take objektem, ..to nic, pozdeji)
    
  //instanci muzeme dat prikaz skrze "."+"knihovniFunkci()" asi takto: 
  mojeVideo.loop();
  // ".play()" spusti prehravani souboru, ".loop()" neustale prehravani, ".stop()" zastavi
  // ".jump(3.10)" - jde na pozici ve vterinach atd.. vice v referencich na processing.org  
}


void movieEvent(Movie mojeVideo) {
  mojeVideo.read();
}
// specialni funkce pro nacitani okenek, slouzi ke komunikaci s nasim kodem,
// "movieEvent()" je volan pokazde, kdyz je k dispozici dalsi okenko,
// pak tato funkce zavola ".read()" na nas objekt a nacita dalsi
// proces je zautomatizovan knihovnou, tuto funkci tudiz nemusime nikdy volat


void draw() {
  tint(255, 20);
  // nastavi pruhlednost obrazku
  // "tint(color)" - slouzi pro jednoduche barevne a pruhlednostni upravy obrazku
 
  image(mojeVideo, mouseX-mojeVideo.width/2, mouseY-mojeVideo.height/2);
  // konecne zde se zobrazuji okenka ze souboru
  // knihovna vraci klasicky obrazek (PImage) tedy, da se zobrazit prikazem
  // image( PImage , x , y );
  // pro nacentrovani na kurzor je zde pouzit jeste odecet poloviny sirky obrazku z x a y
  // chcete-li roztahnout obraz na celou plochu
  // da se pouzit image takto:
  // image( PImage , x , y , sirka , vyska )
  // tedy image(mojeVideo,0,0,width,height); ..u nekterych stroju to ovsem muze delat problemy
}
// processing 1 - NOD 28.4. 2008 Praha
// :: krystof pesek

// Prace s obrazem

PImage obrazek;
// Obrazky processing drzi pod objektem "PImage"
// nejdrive si musime vytvorit jednu instanci objektu - "obrazek"

void setup(){
 obrazek = loadImage("obrazek.jpg");
 // nacteni obrazku z disku pomoci "loadImage(String cesta)"
 // prikaz prednasavene saha do adresare "./data" v vasi sketchi

  size(400,400); 
  background(0);
  
}

void draw(){  
  image(obrazek,mouseX,mouseY);
  // funkce "image" zobrazi obraz v okne, dalsi parametry
  // udavaji osu x a y, zde pouzivam "mouseX" a "mouseY"
// to jsou promenne ktere umeji vratit aktualni hodnotu kurzoru
}

// kazdy obraz je nacitan do pameti javy z disku
// trva to vcelku dost casu, nedoporucuje se nacitat obrazy
// pri chodu "draw()" smycky, lepsi je, pokudmozno, vse nacist
// najednou v setupu

// muze se stat, ze se priliz velke obrazy nevejdou do ram pameti
// v tom pripade program hlasi neco jako: "problem with java heap space"
// to se da vyresit nastavenim processingu, nebo mozna lepe, zmensenim zdrojovych
// souboru


// pristup k jednotlivym pixelum skrze "obrazek.pixels"(int[]), vetsinou musi predchazet "loadPixels()"
// jinak program hlasi neco jako: "array out of length", 
//
//("[]"- hranate zavorky jsou tzv. arrays, pole - skladuji v sobe [x] promennych,objektu..)
// ..ale k arrays pozdeji
// processing 2 - NOD / Roxy 6.5. 2008 Praha
// :: krystof pesek

// 09 Jednoducha kresba - mouse input //

float x,y; //zalozeni globalnich promennych x a y
float speed; // promenna speed bude urcovat rychlost castic
boolean kliknuto = false;

int cnt = 0;

void setup(){
  size(400,400);
  background(25); 

  // "rectMode" pro zpusob zakladani obdelniku.. moznosti CORNER, CORNERS, CENTER, nebo RADIUS
  // defaultne je nastaven CORNER
  rectMode(CENTER);

  //vypln bila s pruhlednosti
  fill(255,15); 
  // bez kontury
  noStroke();

  speed = 0.15;
}

void draw(){  
  //rovnice pro vypocet "x" a "y" promenne, je updatovan kazde okenko
  //"x" a "y" k sobe vzdy pricita zlomek rozdilu mezi svoji pozici a pozici kurzoru
  x += speed*(mouseX-x); 
  y += speed*(mouseY-y); 

  //podminka se naplni kdyz je zmacknuto leve tlacitko viz. nize
  if(kliknuto){   
    // ctverec
    rect(x,y,5,5);
  }
}

// moznosti vstupu jsou pestre
// 3 funkce vypsane nize reaguji na podnet mysi 

// 1 tato funkce se spusti (jednou) vzdy na stisknuti jakehokoli tlacitka mysi
// dotazem na nativni promennou "mouseButton" se pak dozvime ktere ze tlacitko
// bylo stisknuto
void mousePressed(){
  // jestlize leve tlacitko?
  if(mouseButton==LEFT){
    println("leve tlacitko zmacknuto"); 
    // cnt pocitadlo okenek pri tahu, zde jen ilustrativne
    cnt = 0;
    // kliknuto true pro splneni podminky v drawu
    kliknuto = true;
  }
  // jestlize prave tlacitko?
  else if(mouseButton==RIGHT){
    println("prave tlacitko zmacknuto"); 
    // smaz cmaranici pozadim
    background(25);
  }
  else{
    // volanim mouseButon se muzeme dozvedet i dalsi tlacika
    // jestlize tedy bude jine nez leve nebo prave zde se dozvime jak se jmenuje
    // a muzeme ho pak namapovat na akci
    println("jine tlacitko zmacknuto, kod: "+mouseButton);
  }
}

// funkce opakovana cyklicky pri tazeni nakliknute mysi
void mouseDragged(){
  // pocitej
  cnt++;
  // a tiskni
  println(cnt+" okenek tahu");
}

// funkce zavolana processingem kdyz zdetekuje odkliknuti mysi, reaguje i na odlkiknuti
// mimo ram programu
void mouseReleased(){
  if(mouseButton==LEFT){
    println("leve tlacitko uvolneno"); 
    // zde se vrati promenna zpet na false
    kliknuto = false;
    // a "x" a "y" se vynuluji na pozici kurzoru, detail
    x=mouseX;
    y=mouseY;
  }
  else if(mouseButton==RIGHT){
    println("prave tlacitko uvolneno"); 
  }
  else{
    println("jine tlacitko uvolneno");
  }
}


// processing 2 - NOD / Roxy 6.5. 2008 Praha
// :: krystof pesek

// 10 pole, neb arrays  - skladovani promennych //

// pole jsou vhodne pro uchovavani vetsich poctu promennych
// pod kontrolou, hodi se temer vsude
// pole se pozna tak, ze je vzdy znaceno hranatymi zavorkami "[]"
// jestlize budeme premyslet textualne, promenna je jako pismeno
// ve slove a slovo je sada techto promennych, veta pak muze byt sada
// sad promennych, atd..
// pole mohou obsahovat jakekoli promenne od booleanu, pres floaty az po kompletni objekty

// v praxi to znamena, mame-li 3 promenne
int prvni = 1;
int druhy = 3;
int treti = 5;
// muzeme si z nich udelat jednu
int cisla[] = {prvni, druhy, treti};

// dalsi, temer obvyklejsi zpusoby vytvareni:
// int cisla[] = new int[20]; //vytvori prazdne pole o dvaceti integrech
// int[] cisla = new int[20]; //da se napsat i takto bez rozdilu v ucinku
// int cisla[]; //vytvori prazdne pole s nespecifikovanou delkou*
//             
/*
  void setup(){
   cisla = new int[10]; //*specifikovat nelze mimo  beh programu.. draw nebo loop, tzn. 
  }
*/


// tisk je pripraven na pole tak ze vytiskne vsechny hodnoty v nem obsazene
println(cisla);
println();

// chceme-li se dostat ke konkretni promenne, jak pro zapis tak cteni,
// vpiseme do zavorek
// na jakem miste se nachazi (!pozor na "[0]" znaci prvni promennou v poli)
// tj. 
println("1. promenna: "+cisla[0]);
println("2. promenna: "+cisla[1]);
println("3. promenna: "+cisla[2]);
println();

// pri praci s polemi je neocenitelna smycka ktera nas usetri hodne psani
// ".length" vraci velikost pole
for(int i = 0;i<cisla.length;i++){
 println("loop cislo "+i+"..."+(i+1)+". promenna: "+cisla[i]); 
}


//...
// pole moho byt jedo/dvou/vicedimenzonalni
// tak napr.
int dvouRozmernePole[][] = new int[3][3];
// vytvori prazdne pole o 9 promennych
// na kazdou jednotlivou se muzeme odkazat nasledovne:
dvouRozmernePole[0][2] = 9;

//se dvou rozmernymi polemi se da pak pracovat takto:
println("\n'dvouRozmernePole': ");
for(int x = 0;x<dvouRozmernePole.length;x++){
  for(int y = 0;y<dvouRozmernePole[x].length;y++){
    dvouRozmernePole[x][y] = (int)random(100);
    println("x:"+x+", y:"+y+" ... "+dvouRozmernePole[x][y]);
  }
}

//dalsi zajimave operace pro prace s poli..
//expand(),sort(),reverse(),splice(),arraycopy(),append(),subset(),concat(), a kdo vi co jeste..

// pozn, pri vytvareni vicerozmernych poli se nasobi velikosti kazdeho z nich:
// pole[5][5] .. 25 
// pole[5][5][5] .. 125
// pole[50][50][5][5] .. 62500
// ! pozor na skladovani, nesetrne operovani s priliz velkymi poli muze znacne zpomalit program

  



// processing 1 - NOD 28.4. 2008 Praha
// :: krystof pesek

// Prace s funkcemi

// Funkce,
// pro usporadani kodu je sikovne pouzit funkce
// uvadeji se prikazem "void" a dale nazvem funkce
// do zavorek se da priradi jakakoli vstupni hodnota
// promenne uvnitr funkce nejsou dostupne zvenci
// funkce ovsem muze pracovat i s vnejsimi hodnotami

PImage obrazek;

void setup(){
  obrazek = loadImage("obrazek.jpg");
  size(obrazek.width*10,obrazek.height*10); 
  background(0);

  int sirka = width;
  // jelikoz "setup" je take vlasne funkci, promenna "sirka" bude 
  // na konci setupu znicena
  tiskniDoKonzoleCislo( sirka );
  // takto vypada spusteni funkce .. tato "tiskniDoKonzoleCislo(int hodnota)" je definovana nize
  // funkce se poznaji tak, ze konci "()" -kulatymi zavorkami
  // do zavorek je mozne vepsat i promennou kterou prijmou jako vstupni hodnotu
  //  
}

void tiskniDoKonzoleCislo(int _docasnaPromenna){
  int abc = _docasnaPromenna; 
  println(abc); 
}
// jednoducha funkce spoustena ze setupu

void draw(){  
  kresliObraz(mouseX,mouseY,55.0);  
}
// "draw()" - tedy hlavni processingova kreslici smycka je take funkci


// definice vlastnich funkci mohou byt temer kdekoli v kodu,
// to ze jsou zde na konci nevadi, processing o nich bude vedet jelikoz
// budou nacitany prioritne

void kresliObraz(float _x,float _y,float _alpha){
  tint(255,_alpha);
  image(obrazek,_x,_y);  
}

void uplnePrimitivniFunkce(){
 println("..."); 
}

void funkceVeFunkci(){ 
 uplnePrimitivniFunkce(); //spusteni 1. funkce
 kresliObraz(10,10,50); //spusteni 2. funkce
  // atd...
}
// usporadani se muze i vetvit,
// vsechny funkce mohou uvnitr spoustet neomezeny pocet dalsich dalsi
// to se hodi k prehlednosti a organizaci kodu

// processing 1 - NOD 28.4. 2008 Praha
// :: krystof pesek

// Zakladni funkce programu
// pro pochopeni processingu je dobre zacit s dvemi zakladnimi funkcemi:
// (o funkcich obecne, vice v prikladu _06_Funkce) 

// 1. "setup()" - funkce, ktera je spustena na zacatku programu, pouze jednou
// slouzi k vychozimu nastaveni programu
void setup(){ // "{" znamenko znacici pocatek funkce
  // hned prvni udaj by mel rikat jak je ramecek velky, prikaz "size"
  size(200,200); //velikost ramecku v "size(int x,int y)" - x a y v pixelech
  
  frameRate(15); //"frameRate(int kolik)" - snimku za vterinu, bez tohoto prikazu prednastaveno 60fps 
  
  println("tisk ze setup-u! " + frameCount); // tisk do konzole, tento bude spusten jednou
  // zajimava promenna "frameCount" uchovava pocet vykreslenych okenek
  // ze "setupu" to bude vzdy = 0
  
}// "}" znamenko znacici konec funkce


// 2. "draw()" - funkce, ktera je spoustana cyklicky, nekolikrat do vteriny - podle "frameRate" - nyni 15x za vterinu
void draw(){
  // v teto smycce se vetsinou provadi kresba, animace, zivy vypocet, prvni co je dobre vykreslit je pozadi
  background(0); //"background" vyplni celou plochu barvou, s jednim udajem od 0..255 - color
  println("tisk z draw-u! " + frameCount);  // tisk do konzole je cyklicky opakovan, "frameCount" vraci udaj o poctu prekresleni
}// "}" znamenko znacici konec funkce
// Sktript Tri
// Obraz a kod 2010


void setup(){

	size(640,480,P2D);
	noFill();
	
	// stroke s dvame parametry (bila,pruhlednost) 0 .. 255
	stroke(255,15);
	rectMode(CENTER);
	background(0);

}



void draw(){

	//bez pozdaji se pozadi nemaze
	
	// mouseX a mouseY jsou promenne ktere zjisti aktualni
	// pozici mysi na plose
	
	//random pro pseudo-nahodne cislo bud random(5) 0 .. 5 nebo random(0,6)
	rect( mouseX, mouseY, random(60,90), random(30,60));

}
void setup(){
	size(400,300,P2D);
	background(0);
	stroke(255);


}



void draw(){


	background(0);
	float h = random(height);
	line(0,h,width,h);

}
Seeker s;

void setup(){

	size(320,240,P2D);
	background(0);

	loadPixels();
	stroke(255);
	s = new Seeker();
}


void draw(){

	s.seek();
	s.step();
	s.draw();


}

class Seeker{

	int x,y,nx,ny;
	boolean[] ng;

	Seeker(){
		x = (int)(random(width));
		y= (int)(random(height));
		point(x,(y+1+height)%height);
		ng = new boolean[16];
		seek();


	}

	void seek(){
		int cnt = 0;
		for(int Y = -2;Y<3;Y++){
			for(int X = -2;X<3;X++){

				if(X!=0&&Y!=0){
					if(brightness(pixels[((y+Y+height)%height)*width+((x+X+width)%width)])<127){
						ng[cnt] = true;
						cnt++;
					}else{
						ng[cnt] = false;
						cnt++;
					}
				}
			}
		}
	}

	int next(){

		int tmp[] = new int[0];

		for(int i = 0;i<ng.length;i++){
			if(ng[i])
				tmp = (int[])append(tmp,i);
		}



		int choice = (int)random(tmp.length);
		//print(tmp[choice]);

		try{
			return tmp[choice];
		}catch(java.lang.NullPointerException e){
			reborn();
		}

		return -1;


	}

	void reborn(){

		int count = 0;
		while(brightness(pixels[y*width+x])>127||count>1000){
			x = (int)random(width);
			y = (int)random(height);
			seek();
			count++;
		}

	}

	void step(){
		int q = next();

		int cnt = 0;
		for(int Y = -2;Y<3;Y++){
			for(int X = -2;X<3;X++){

				if(X!=0&&Y!=0){

					if(cnt==q){
						x+=X;
						y+=Y;
					}
					cnt++;
				}
			}
		}


	}

	void draw(){

		point(x,y);

	}

}
/*

SimpleSpreadsheetManager Class
blprnt@blprnt.com
July, 2009

This is a quick & dirty class for accessing data from the Google Spreadsheet API.


*/

import com.google.gdata.client.spreadsheet.*;
import com.google.gdata.data.*;
import com.google.gdata.data.spreadsheet.*;
import com.google.gdata.util.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.URL;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


public class SimpleSpreadsheetManager {

  SpreadsheetService myService;
  SpreadsheetEntry spreadsheetEntry;
  SpreadsheetFeed sheetFeed;
  WorksheetEntry worksheetEntry;

  List spreadsheets;

  String user;
  String pass;
  
  ListFeed currentListFeed;
  CellFeed currentCellFeed;
  List currentCells;
  List currentListEntries;
  
  int currentTotalRows;
  int currentTotalCols;
  
  String currentTitle;


  SimpleSpreadsheetManager() {
    
  };
  
  /*
  
  INIT FUNCTION
  Opens session, uses username & password for authentication
  
  */

  void init(String sessionName, String u, String p) {
    user = u;
    pass = p;
    myService = new SpreadsheetService(sessionName);
    try {
      myService.setUserCredentials(user, pass);
    } 
    catch (Exception e) {
      println("ERROR IN AUTHENTICATION");
    };

  };
  
  /*
  
  FETCH SHEET BY KEY
  Gets a spreadsheet listfeed using the unique key - this is in the URL of the spreadsheet
  The retrieved sheet is both returned and set as the currentListFeed
  
  */
  
  ListFeed fetchSheetByKey(String k, int wi) {
    
    ListFeed f = new ListFeed();
    CellFeed cf = new CellFeed();
    WorksheetFeed w = new WorksheetFeed();
    
    //GET WORKSHEETS FEED
    try {
      URL worksheetFeedUrl = new URL("http://spreadsheets.google.com/feeds/worksheets/" + k + "/private/full");
      WorksheetFeed wf2 = new WorksheetFeed();
      w = myService.getFeed(worksheetFeedUrl, wf2.getClass());
    }
    catch(Exception e) {
      println("ERROR RETRIEVING WORKSHEET FEED");
    };
    
    List worksheets = w.getEntries();
    WorksheetEntry we = (WorksheetEntry) worksheets.get(wi);   
    println("RETRIEVED WORKSHEET " + we.getTitle().getPlainText()); 
    
    //GET LIST FEED URL
    try {
      URL listFeedUrl = we.getListFeedUrl();//new URL("http://spreadsheets.google.com/feeds/list/" + k + "/od6/private/full");
      ListFeed lf2 = new ListFeed();
      f = myService.getFeed(listFeedUrl, lf2.getClass());
    }
    catch(Exception e) {
      println("ERROR RETRIEVING LIST FEED");
    };
    
    //GET CELL FEED
    try {
      URL cellFeedUrl = we.getCellFeedUrl();//new URL("http://spreadsheets.google.com/feeds/cells/" + k + "/od6/private/full");
      CellFeed lf2 = new CellFeed();
      cf = myService.getFeed(cellFeedUrl, lf2.getClass());

    }
    catch(Exception e) {
      println("ERROR RETRIEVING LIST FEED");
    };
    
    currentListFeed = f;
    currentCellFeed = cf;
    currentCells = cf.getEntries();
    currentListEntries = f.getEntries();
    
    currentTitle = we.getTitle().getPlainText();
    currentTotalRows = currentListEntries.size();
    ListEntry le = (ListEntry) currentListEntries.get(0);  
    currentTotalCols = le.getCustomElements().getTags().size();
    return(f);
  };
  
  /*
  
  GET CELL VALUE
  Returns the value held in an individual sheet cell.
  
  */
  
  String getCellValue(int c, int r) {

    ListEntry le = (ListEntry) currentListEntries.get(r);    
    Set<String> tags = le.getCustomElements().getTags();
    String[] tagArray = new String[tags.size()];
    tagArray = tags.toArray(tagArray);
  
    return(le.getCustomElements().getValue(tagArray[c]));
   
  };
  
  String getCellValue(String tag, int r) {
 
    ListEntry le = (ListEntry) currentListEntries.get(r);    
    return(le.getCustomElements().getValue(tag));
   
  };
  


};




/*

Processing & Google Spreasheet API Example
blprnt@blprnt.com
July, 2009

*/

SimpleSpreadsheetManager sm;

void setup() {
  size(500,500);
  background(255);
  
  SimpleSpreadsheetManager sm = new SimpleSpreadsheetManager();
	sm.init("test","krystof.pesek@gmail.com", "cigareta");
		sm.fetchSheetByKey("tZJr_DDPd33YdTrCLpnxSpw", 0);

}

void draw() {

	background(0);
}




import processing.opengl.*;


Bot bot[];
PImage art;

//Recorder r;
boolean rec  = false;


int num = 50;
int pass[];
color c[];
int intv[];

void setup(){

	size(1024,480,OPENGL);
	art = loadImage("psi.png");


	bot = new Bot[num];
	for(int i = 0;i<bot.length;i++){
		bot[i] = new Bot(i);
	}


	pass =new int[num];
	intv =new int[num];
	c = new color[num];
	for(int i = 0;i<num;i++){
		c[i] = color(random(255),random(123),random(100));
		intv[i] = (int)random(3,300);
		pass[i] = 0;

	}

  noSmooth();

//	if(rec)
//		r = new Recorder("out","smrst.mp4");

}


void draw(){

	background(0);


	for(int i = 0;i<num;i++){
		if(frameCount%intv[i]==0)
			pass[i]+=1;

		if(pass[i]>bot.length)
			pass[i]=0;

	}



	pushMatrix();
	translate(width/2-art.width/2,height/2-art.height/2);
	for(int i = 0;i<bot.length;i++){
		for(int q = 0;q<num;q++){
			noTint();
			if(i==pass[q]){
				tint(c[q]);
				break;
			}

		}

		bot[i].draw();

	}

	popMatrix();

	pushStyle();
	noStroke();
	fill(0);
	rect(0,0,width,10);

	rect(0,0,10,height);

	rect(width,height,-width,-10);

	rect(width,height,-10,-height);

	popStyle();


//	if(rec)
//		r.add();


}

void keyPressed(){
	if(key=='q'){
//		if(rec)
//			r.finish();
		exit();

	}

}

class Bot{

	float x,y;
	float sca,speed;
	float al,shiftX,shiftY;
	float Z;

	Bot(float _scl){
		Z = _scl;
		x = width/2.0;
		y = height/2.0;
		sca = map(_scl,0,bot.length,0.001,1);// random(0.001,1);
		speed = random(500,2550)*((random(50)>25)?-1:1);
		al = 255;// random(60,240);
		shiftX = random(-512,512);
		shiftY = random(-512,512);

	}


	void draw(){
		//tint(255,al);
		pushMatrix();
		//translate(x,y);
		pushMatrix();
		translate(art.width/2+shiftX,art.height/2);
		rotate(frameCount/speed);
		scale(sca);
		//background(123);
		image(art,-art.width/2+shiftX,-art.height/2+shiftY);
		popMatrix();

		popMatrix();


	}
}


Agent a;

void setup(){

	size(1280,720,P2D);


	hint(DISABLE_OPENGL_2X_SMOOTH);
	hint(DISABLE_DEPTH_TEST);
	hint(ENABLE_DEPTH_SORT);

	background(255);
	stroke(0,15);

	a = new Agent();
}



int h = 0;
float val = 0;

void draw(){

	//background(255);
	a.draw();

}

class Agent{

	float x,y,x2,y2;


	Agent(){
		x = 0;
		y = 0;
		update();



	}

	void update(){

		if(frameCount%5==0){
			x2 = x;
			y2 = y;
		}
		x = mouseX;
		y = mouseY;


	}


	void draw(){

		update();

		float dd = dist(mouseX,mouseY,width/2,height/2);


		if(abs(x-x2)>0.1&&abs(y-y2)>0.1)
			val = atan2(y-y2,x-x2);// ((atan2(y-y2,x-x2)+TWO_PI)-val)/30.0;

		pushMatrix();
		translate(x,y);


		//pushMatrix();

		rotate(val-TWO_PI);


		//line(0,dd,0,);
		line(0,-50,0,50);

		//line(-width,0,width,0);

		//popMatrix();

		popMatrix();

	}



}
/**
*
* Peresent mode
*
*
*/

import processing.opengl.*;

PImage sim;
float x,y,tx,ty;
float speed = 50.0;
float theta;

boolean down = false;

void setup(){
	size(1024,768,P2D);
	background(0);

//	hint(DISABLE_OPENGL_2X_SMOOTH);
	//hint(DISABLE_DEPTH_TEST);
	//hint(ENABLE_DEPTH_SORT);


	sim=loadImage("test.png");
		smooth();
}

void draw(){/*
				  //background(0);
				  fill(0,5);
				  rect(0,0,width,height);

				*/

	if(frameCount<10)
		background(0);


	if(!down){
		tx = mouseX;
		ty = mouseY;
	}else{

		tx+=(mouseX-tx)/speed;
		ty+=(mouseY-ty)/speed;
		x+=(tx-x)/speed;
		y+=(ty-y)/speed;
		theta=atan2(ty-y,tx-x);

		tint(255,5);
		pushMatrix();
		translate(x+(sim.width/2),y+(sim.height/2));
		rotate(theta);
		//image(sim,0,0);
		
		for(int i = (-50);i<50;i+=5){
			stroke(#FFCC00,map(i,-50,50,0,20));
			line(0,i,15,i);
		}
		popMatrix();

	}
}

void mousePressed(){
	down = true;
	tx = mouseX;
	ty = mouseY;

	x = pmouseX;
	y = pmouseY;
}

void mouseReleased(){
	down = false;

}

void keyPressed(){
	if(key == ' '){
		save("screen"+frameCount+".png");
	}else if(keyCode == DELETE){
		background(0);
	}
	keyPressed=false;
}
import org.xvolks.test.bug.*;
import org.xvolks.jnative.util.ole.*;
import org.xvolks.jnative.util.windows.hooks.*;
import org.xvolks.jnative.pointers.*;
import org.xvolks.jnative.logging.*;
import org.xvolks.jnative.com.interfaces.*;
import org.xvolks.test.windows.trayicon.*;
import org.xvolks.jnative.util.mapi.*;
import org.xvolks.jnative.com.typebrowser.business.export.*;
import org.xvolks.jnative.misc.*;
import org.xvolks.jnative.util.mapi.structs.*;
import org.xvolks.jnative.misc.basicStructures.*;
import org.xvolks.test.com.*;
import org.xvolks.jnative.util.windows.hotkey.*;
import org.xvolks.jnative.pointers.memory.*;
import org.xvolks.jnative.misc.registry.*;
import org.xvolks.test.windows.*;
import org.xvolks.jnative.exceptions.*;
import org.xvolks.jnative.com.typebrowser.gui.*;
import org.xvolks.jnative.com.utils.*;
import org.xvolks.jnative.util.windows.*;
import org.xvolks.jnative.util.constants.winuser.*;
import org.xvolks.test.callbacks.*;
import org.xvolks.jnative.com.typebrowser.gui.panels.*;
import org.xvolks.jnative.*;
import org.xvolks.jnative.util.win32session.*;
import org.xvolks.test.callbacks.linux.*;
import org.xvolks.jnative.util.constants.*;
import org.xvolks.jnative.com.typebrowser.business.*;
import org.xvolks.test.*;
import org.xvolks.jnative.misc.machine.*;
import org.xvolks.jnative.util.*;
import org.xvolks.jnative.util.windows.structures.*;
import org.xvolks.jnative.com.*;


void setup(){
	JNative.setLoggingEnabled(true); // show what JNative is doing!
	try{
		int blah=org.xvolks.jnative.util.libeopenNURBS.ANT_Init((byte)0,(short)57600); // Call the first native function. This initializes the USB radio via the manufacturer's DLL.
		print(blah); // should return '1' upon success. This was easy so far!
	}catch (NativeException e) // traps in case anything naughty happens
	{
		e.printStackTrace();
	}
	catch (IllegalAccessException e)
	{
		e.printStackTrace();
	}



}


import processing.serial.*;
import cc.arduino.*;

boolean listen = true;


Arduino arduino;
float vals[] = new float[8];

float smoothv[] = new float[8];
int  bin [] = {000, 1, 10, 11, 100, 101, 110, 111};
color c[] = {color(255,200,0),color(255,180,0),color(255,160,0),color(255,140,0),
             color(255,120,0),color(255,100,0),color(255,80,0),color(255,60,0)};
int row = 0;
int r0,r1,r2;

void setup() {


	size(1920,300,P2D);

	println(Arduino.list());
	arduino = new Arduino(this, Arduino.list()[0], 57600);

	frameRate(30);


	for (int i = 0; i <= 13; i++)
		arduino.pinMode(i, Arduino.OUTPUT);
	//arduino.pinMode(0,Arduino.INPUT);
	background(0);
}

int cnt=0;
int a = 0;

void draw(){

	//background(0);

	stroke(255);

	for(int i = 0;i<vals.length;i++){
		row = bin[i];
		r0 = row & 0x01;
		r1 = (row>>1) & 0x01;
		r2 = (row>>2) & 0x01;

		if(r0==1){
			arduino.digitalWrite(5,Arduino.HIGH);
		}else{
			arduino.digitalWrite(5,Arduino.LOW);
		}

		if(r1==1){
			arduino.digitalWrite(6,Arduino.HIGH);
		}else{
			arduino.digitalWrite(6,Arduino.LOW);
		}

		if(r2==1){
			arduino.digitalWrite(7,Arduino.HIGH);
		}else{
			arduino.digitalWrite(7,Arduino.LOW);
		}

		delay(5);
		a = arduino.analogRead(1);
		smoothv[i] += (a-smoothv[i])/3.0;

	}

	//arduino.digitalWrite(13,Arduino.HIGH);


	for(int i = 0;i<vals.length;i++){
		stroke(c[i]);
		line(cnt,map(smoothv[i],0,1024,height,0),cnt+1,map(smoothv[i],0,1024,height,0));
	}

	cnt += 1;
	if(cnt>width){
		background(0);
		cnt=0;
	}

	//println(a);


}


import timeline.*; 
Timeline timeline; 


void setup() {
  size(320,240,P2D);

  timeline = new Timeline(this);


 // timeline.setTime("br", 0.0);

}


void draw() {

  float value = timeline.getValue("br");

  background(value*255);

}




float rate = 1000;

void setup(){
	size(400,300);
	
	frameRate(rate);
	
	println(PFont.list());

	textFont(createFont("Rachana",11));
//	textMode(SCREEN);

}



void draw(){

	background(0);
	fill(255);
	stroke(255);
	
	
	float rr = map(frameRate,0,rate,0,width);
	text(frameRate,rr,20);
	line(rr,0,rr,height);
	



}
class Recorder{
  String dir,name;
  int cntr = 0;

	
  Recorder(String _dir,String _name){
    dir = _dir;
    name= _name;
    //btrt = _btrt;
  }

  void add(){
    save(dir+"/screen"+nf(cntr,4)+".png");
    cntr++;
  }

  void finish(){
    String Path = sketchPath+"/"+dir;
    try{     
      String bitrate="8000k";//+(((int)(50*25*width*height)/256)*2);
      Runtime.getRuntime().exec("xterm -e png2vid "+Path+" "+name+" "+width+"x"+height+" "+bitrate);
      println("finishing");
    }
    catch(java.io.IOException e){
      println(e); 
    }  
  }
}
PGraphics tmp,frame;

float valx = 0.0,valy = 45.23;
float tras = 2.0;

Recorder r;
boolean rec = true;

void setup(){

	size(640,240,P2D);

	tmp = createGraphics(width,height,P2D);
	tmp.loadPixels();
	tmp.beginDraw();
	
	for(int y = 0;y<height;y++){
		for(int x = 0;x<width;x++){
			tmp.pixels[y*width+x] = color(random(255));
		}
	}

	tmp.endDraw();

	frame = createGraphics(width+20,height+20,P2D);
	frame.beginDraw();

	frame.stroke(0,120);
	frame.noFill();
	frame.strokeWeight(20);

	frame.stroke(0,40);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,10);

	frame.stroke(0,120);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,2);

	frame.endDraw();

	background(tmp);
	loadPixels();

	if(rec)
		r = new Recorder("out","turning.mp4");

}



void draw(){

	pre();

	//tint(255,50);
	image(tmp,random(-2,3),random(-2,3));
	noTint();

	float approx = 0.5;
	for(int y = 0;y<height;y++){
		for(int x = 0;x<width;x++){
			tmp.pixels[y*width+x] = color(pixels[y*width+x]);
			approx += map(brightness(pixels[y*width+x]),0,255,0,1);
		}
	}


	if(frameCount%50==0){
		tmp.beginDraw();
		for(int y = 0;y<height;y++){
			for(int x = 0;x<width;x++){
				tmp.pixels[y*width+x] = color(random(255));
			}

		}
		tmp.endDraw();
	}

	approx /= (width*height);

	//if(frameCount%10==0)
	tmp.filter(BLUR,2);

	//if(frameCount%20==0)
	tmp.filter(THRESHOLD,approx);

	if(frameCount%2==0)
		filter(INVERT);
	
	post();

	if(rec)
		r.add();


}

void pre(){

	float modx = noise(valx++)*tras-tras/2.0;
	float mody = noise(valy++)*tras-tras/2.0;
	
	pushMatrix();
	
	translate(modx,mody);
	translate(-random(2),-random(2));

}

void post(){

	translate(random(2),random(2));
	
	for(int i =0;i<3;i++){
	
		stroke(0,25);
		line(width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,0,width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,height);
	
	}

	popMatrix();
	filter(BLUR,3);
	
	//resetMatrix();
	image(frame,-random(2),-random(2));
	
	for(int i =0;i<pixels.length;i++)
		pixels[i] = color(brightness(pixels[i])+random(-30,3));

}

void keyPressed(){

	if(key == 'q'){
		if(rec)
			r.finish();

		exit();
	}

}
float tras = 2.0;
PGraphics frame;
PImage tup,trees;
float valx = 0.0,valy = 45.23;

boolean rec = false;

void setup(){
	size(320,240,P2D);
	fill(0);
	frameRate(20);
	noStroke();

	tup = loadImage("tu.png");	
	trees = loadImage("trees.png");
	

	loadPixels();

	frame = createGraphics(width+20,height+20,P2D);
	frame.beginDraw();

	frame.stroke(0,120);
	frame.noFill();
	frame.strokeWeight(20);

	frame.stroke(0,40);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,10);

	frame.stroke(0,120);
	frame.rect(0,0,width,height);
	frame.filter(BLUR,2);

	frame.endDraw();

	noSmooth();
	
}

void draw(){
	background(255);
	pre();
	prod();
	post();
}

void prod(){
	stroke(0,50);
	fill(0,10);

	tint(#fdee9d);
	image(tup,random(-10,10)/10.0+noise(frameCount/100.0)*80,noise(frameCount/1000.0)*180+noise(frameCount/100.0)*12.0,tup.width/2,tup.height/2);
	noTint();
	
	image(trees,((frameCount*40)%(trees.width*2))-trees.width,height/2-50);
	image(trees,((frameCount*40)%(trees.width*3))-trees.width*2,height/2-50);
	image(trees,((frameCount*40)%(trees.width))-trees.width*2,height/2-50);
	image(trees,((frameCount*40)%(trees.width*3))-trees.width,height/2-50);
	
}

void pre(){

	beginShape(QUADS);
	fill(20+noise(frameCount/4.0)*50);
	vertex(0,0);
	vertex(width,0);
	fill(#a8d8ff);
	vertex(width,height);
	vertex(0,height);
	endShape(CLOSE);

	float modx = noise(valx++)*tras-tras/2.0;
	float mody = noise(valy++)*tras-tras/2.0;
	pushMatrix();
	translate(modx,mody);
	translate(-random(2),-random(2));
}

void post(){

	translate(random(2),random(2));
	for(int i =0;i<3;i++){
		stroke(0,25);
		line(width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,0,width/2+noise(frameCount/200.0+i)*160+noise(frameCount/10.0+i)*6,height);
	}
	
	popMatrix();

	image(frame,-random(2),-random(2));
	for(int i =0;i<pixels.length;i++){
		float glitch = random(-85,3);
		pixels[i] = color(red(pixels[i])+glitch,green(pixels[i])+glitch,blue(pixels[i])+glitch);
	}
		filter(ERODE);
	filter(BLUR,random(1,2));
	
	if(rec)
		r.add();
}
